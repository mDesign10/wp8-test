/**
 * nya-bootstrap-select v2.1.0
 * Copyright 2014 Nyasoft
 * Licensed under MIT license
 */
serviceFunc.$inject = ["$q", "$log", "StoreFactory", "toastr", "SchemaHelper", "$injector", "Plugin", "TranslationService", "Platform"];
(function(){
  'use strict';

  var uid = 0;

  function nextUid() {
    return ++uid;
  }

  /**
   * Checks if `obj` is a window object.
   *
   * @private
   * @param {*} obj Object to check
   * @returns {boolean} True if `obj` is a window obj.
   */
  function isWindow(obj) {
    return obj && obj.window === obj;
  }

  /**
   * @ngdoc function
   * @name angular.isString
   * @module ng
   * @kind function
   *
   * @description
   * Determines if a reference is a `String`.
   *
   * @param {*} value Reference to check.
   * @returns {boolean} True if `value` is a `String`.
   */
  function isString(value){return typeof value === 'string';}

  /**
   * @param {*} obj
   * @return {boolean} Returns true if `obj` is an array or array-like object (NodeList, Arguments,
   *                   String ...)
   */
  function isArrayLike(obj) {
    if (obj == null || isWindow(obj)) {
      return false;
    }

    var length = obj.length;

    if (obj.nodeType === 1 && length) {
      return true;
    }

    return isString(obj) || Array.isArray(obj) || length === 0 ||
      typeof length === 'number' && length > 0 && (length - 1) in obj;
  }

  /**
   * Creates a new object without a prototype. This object is useful for lookup without having to
   * guard against prototypically inherited properties via hasOwnProperty.
   *
   * Related micro-benchmarks:
   * - http://jsperf.com/object-create2
   * - http://jsperf.com/proto-map-lookup/2
   * - http://jsperf.com/for-in-vs-object-keys2
   *
   * @returns {Object}
   */
  function createMap() {
    return Object.create(null);
  }

  /**
   * Computes a hash of an 'obj'.
   * Hash of a:
   *  string is string
   *  number is number as string
   *  object is either result of calling $$hashKey function on the object or uniquely generated id,
   *         that is also assigned to the $$hashKey property of the object.
   *
   * @param obj
   * @returns {string} hash string such that the same input will have the same hash string.
   *         The resulting string key is in 'type:hashKey' format.
   */
  function hashKey(obj, nextUidFn) {
    var objType = typeof obj,
      key;

    if (objType == 'function' || (objType == 'object' && obj !== null)) {
      if (typeof (key = obj.$$hashKey) == 'function') {
        // must invoke on object to keep the right this
        key = obj.$$hashKey();
      } else if (key === undefined) {
        key = obj.$$hashKey = (nextUidFn || nextUid)();
      }
    } else {
      key = obj;
    }

    return objType + ':' + key;
  }

  //TODO: use with caution. if an property of element in array doesn't exist in group, the resultArray may lose some element.
  function sortByGroup(array ,group, property) {
    var unknownGroup = [],
      i, j,
      resultArray = [];
    for(i = 0; i < group.length; i++) {
      for(j = 0; j < array.length;j ++) {
        if(!array[j][property]) {
          unknownGroup.push(array[j]);
        } else if(array[j][property] === group[i]) {
          resultArray.push(array[j]);
        }
      }
    }

    resultArray = resultArray.concat(unknownGroup);

    return resultArray;
  }

  /**
   * Return the DOM siblings between the first and last node in the given array.
   * @param {Array} array like object
   * @returns {jqLite} jqLite collection containing the nodes
   */
  function getBlockNodes(nodes) {
    // TODO(perf): just check if all items in `nodes` are siblings and if they are return the original
    //             collection, otherwise update the original collection.
    var node = nodes[0];
    var endNode = nodes[nodes.length - 1];
    var blockNodes = [node];

    do {
      node = node.nextSibling;
      if (!node) break;
      blockNodes.push(node);
    } while (node !== endNode);

    return angular.element(blockNodes);
  }

  var getBlockStart = function(block) {
    return block.clone[0];
  };

  var getBlockEnd = function(block) {
    return block.clone[block.clone.length - 1];
  };

  var updateScope = function(scope, index, valueIdentifier, value, keyIdentifier, key, arrayLength, group) {
    // TODO(perf): generate setters to shave off ~40ms or 1-1.5%
    scope[valueIdentifier] = value;
    if (keyIdentifier) scope[keyIdentifier] = key;
    scope.$index = index;
    scope.$first = (index === 0);
    scope.$last = (index === (arrayLength - 1));
    scope.$middle = !(scope.$first || scope.$last);
    // jshint bitwise: false
    scope.$odd = !(scope.$even = (index&1) === 0);
    // jshint bitwise: true

    if(group) {
      scope.$group = group;
    }
  };

  var setElementIsolateScope = function(element, scope) {
    element.data('isolateScope', scope);
  };

  var contains = function(array, element) {
    var length = array.length,
      i;
    if(length === 0) {
      return false;
    }
    for(i = 0;i < length; i++) {
      if(deepEquals(element, array[i])) {
        return true;
      }
    }
    return false;
  };

  var indexOf = function(array, element) {
    var length = array.length,
      i;
    if(length === 0) {
      return -1;
    }
    for(i = 0; i < length; i++) {
      if(deepEquals(element, array[i])) {
        return i;
      }
    }
    return -1;
  };

  /**
   * filter the event target for the nya-bs-option element.
   * Use this method with event delegate. (attach a event handler on an parent element and listen the special children elements)
   * @param target event.target node
   * @param parent {object} the parent, where the event handler attached.
   * @param selector {string}|{object} a class or DOM element
   * @return the filtered target or null if no element satisfied the selector.
   */
  var filterTarget = function(target, parent, selector) {
    var elem = target,
      className, type = typeof selector;

    if(target == parent) {
      return null;
    } else {
      do {
        if(type === 'string') {
          className = ' ' + elem.className + ' ';
          if(elem.nodeType === 1 && className.replace(/[\t\r\n\f]/g, ' ').indexOf(selector) >= 0) {
            return elem;
          }
        } else {
          if(elem == selector) {
            return elem;
          }
        }

      } while((elem = elem.parentNode) && elem != parent && elem.nodeType !== 9);

      return null;
    }

  };

  var getClassList = function(element) {
    var classList,
      className = element.className.replace(/[\t\r\n\f]/g, ' ').trim();
    classList = className.split(' ');
    for(var i = 0; i < classList.length; i++) {
      if(/\s+/.test(classList[i])) {
        classList.splice(i, 1);
        i--;
      }
    }
    return classList;

  };

  // work with node element
  var hasClass = function(element, className) {
    var classList = getClassList(element);
    return classList.indexOf(className) !== -1;
  };

  // query children by class(one or more)
  var queryChildren = function(element, classList) {
    var children = element.children(),
      length = children.length,
      child,
      valid,
      classes;
    if(length > 0) {
      for(var i = 0; i < length; i++) {
        child = children.eq(i);
        valid = true;
        classes = getClassList(child[0]);
        if(classes.length > 0) {
          for(var j = 0; j < classList.length; j++) {
            if(classes.indexOf(classList[j]) === -1) {
              valid = false;
              break;
            }
          }
        }
        if(valid) {
          return child;
        }
      }
    }
    return [];
  };

  /**
   * Current support only drill down one level.
   * case insensitive
   * @param element
   * @param keyword
   */
  var hasKeyword = function(element, keyword) {
    var childElements,
      index, length;
    if(element.text().toLowerCase().indexOf(keyword.toLowerCase()) !== -1) {
      return true;
    } else {
      childElements = element.children();
      length = childElements.length;
      for(index = 0; index < length; index++) {
        if(childElements.eq(index).text().toLowerCase().indexOf(keyword.toLowerCase()) !== -1) {
          return true;
        }
      }
      return false;
    }
  };

  function sibling( cur, dir ) {
    while ( (cur = cur[dir]) && cur.nodeType !== 1) {}
    return cur;
  }


  // map global property to local variable.
  var jqLite = angular.element;

  var deepEquals = angular.equals;

  var deepCopy = angular.copy;

  var extend = angular.extend;

  var nyaBsSelect = angular.module('nya.bootstrap.select', []);

  /**
   * A service for configuration. the configuration is shared globally.
   */
  nyaBsSelect.provider('nyaBsConfig', function() {

    var locale = null;

    // default localized text. cannot be modified.
    var defaultText = {
      'en-us': {
        defaultNoneSelection: 'Nothing selected',
        noSearchResult: 'NO SEARCH RESULT',
        numberItemSelected: '%d item selected',
        selectAll: 'Select All',
        deselectAll: 'Deselect All'
      }
    };

    // localized text which actually being used.
    var interfaceText = deepCopy(defaultText);

    /**
     * Merge with default localized text.
     * @param localeId a string formatted as languageId-countryId
     * @param obj localized text object.
     */
    this.setLocalizedText = function(localeId, obj) {
      if(!localeId) {
        throw new Error('localeId must be a string formatted as languageId-countryId');
      }
      if(!interfaceText[localeId]) {
        interfaceText[localeId] = {};
      }
      interfaceText[localeId] = extend(interfaceText[localeId], obj);
    };

    /**
     * Force to use a special locale id. if localeId is null. reset to user-agent locale.
     * @param localeId a string formatted as languageId-countryId
     */
    this.useLocale = function(localeId) {
      locale = localeId;
    };

    /**
     * get the localized text according current locale or forced locale
     * @returns localizedText
     */
    this.$get = ['$locale', function($locale){
      var localizedText;
      if(locale) {
        localizedText = interfaceText[locale];
      } else {
        localizedText = interfaceText[$locale.id];
      }
      if(!localizedText) {
        localizedText = defaultText['en-us'];
      }
      return localizedText;
    }];

  });


  nyaBsSelect.controller('nyaBsSelectCtrl', function(){

    var self = this;

    // keyIdentifier and valueIdentifier are set by nyaBsOption directive
    // used by nyaBsSelect directive to retrieve key and value from each nyaBsOption's child scope.
    self.keyIdentifier = null;
    self.valueIdentifier = null;

    self.isMultiple = false;

    // Should be override by nyaBsSelect directive and called by nyaBsOption directive when collection is changed.
    self.onCollectionChange = function(){};

    // for debug
    self.setId = function(id) {
      self.id = id || 'id#' + Math.floor(Math.random() * 10000);
    };

  });
  nyaBsSelect.directive('nyaBsSelect', ['$parse', '$document', '$timeout', 'nyaBsConfig', function ($parse, $document, $timeout, nyaBsConfig) {

    var DEFAULT_NONE_SELECTION = 'Nothing selected';

    var DROPDOWN_TOGGLE = '<button class="btn btn-default dropdown-toggle" type="button">' +
      '<span class="pull-left filter-option"></span>' +
      '&nbsp;' +
      '<span class="caret"></span>' +
      '</button>';

    var DROPDOWN_CONTAINER = '<div class="dropdown-menu open"></div>';

    var SEARCH_BOX = '<div class="bs-searchbox">' +
      '<input type="text" class="form-control">' +
      '</div>';

    var DROPDOWN_MENU = '<ul class="dropdown-menu inner"></ul>';

    var NO_SEARCH_RESULT = '<li class="no-search-result"><span>NO SEARCH RESULT</span></li>';

    var ACTIONS_BOX = '<div class="bs-actionsbox">' +
      '<div class="btn-group btn-group-sm btn-block">' +
      '<button class="actions-btn bs-select-all btn btn-default">SELECT ALL</button>' +
      '<button class="actions-btn bs-deselect-all btn btn-default">DESELECT ALL</button>' +
      '</div>' +
      '</div>';

    return {
      restrict: 'ECA',
      require: ['ngModel', 'nyaBsSelect'],
      controller: 'nyaBsSelectCtrl',
      compile: function nyaBsSelectCompile (tElement, tAttrs){


        tElement.addClass('btn-group');

        var getDefaultNoneSelectionContent = function() {
          // text node or jqLite element.
          var content;

          if(tAttrs.titleTpl) {
            // use title-tpl attribute value.
            content = jqLite(tAttrs.titleTpl);
          } else if(tAttrs.title) {
            // use title attribute value.
            content = document.createTextNode(tAttrs.title);
          } else if(localizedText.defaultNoneSelectionTpl){
            // use localized text template.
            content = jqLite(localizedText.defaultNoneSelectionTpl);
          } else if(localizedText.defaultNoneSelection) {
            // use localized text.
            content = document.createTextNode(localizedText.defaultNoneSelection);
          } else {
            // use default.
            content = document.createTextNode(DEFAULT_NONE_SELECTION);
          }
          return content;
        };

        var options = tElement.children(),
          dropdownToggle = jqLite(DROPDOWN_TOGGLE),
          dropdownContainer = jqLite(DROPDOWN_CONTAINER),
          dropdownMenu = jqLite(DROPDOWN_MENU),
          searchBox,
          noSearchResult,
          actionsBox,
          classList,
          length,
          index,
          liElement,
          localizedText = nyaBsConfig,
          isMultiple = typeof tAttrs.multiple !== 'undefined',
          nyaBsOptionValue;

        classList = getClassList(tElement[0]);
        classList.forEach(function(className) {
          if(/btn-(?:primary|info|success|warning|danger|inverse)/.test(className)) {
            tElement.removeClass(className);
            dropdownToggle.removeClass('btn-default');
            dropdownToggle.addClass(className);
          }

          if(/btn-(?:lg|sm|xs)/.test(className)) {
            tElement.removeClass(className);
            dropdownToggle.addClass(className);
          }

          if(className === 'form-control') {
            dropdownToggle.addClass(className);
          }
        });

        dropdownMenu.append(options);

        // add tabindex to children anchor elements if not present.
        // tabindex attribute will give an anchor element ability to be get focused.
        length = options.length;
        for(index = 0; index < length; index++) {
          liElement = options.eq(index);
          if(liElement.hasClass('nya-bs-option') || liElement.attr('nya-bs-option')) {
            liElement.find('a').attr('tabindex', '0');
            // In order to be compatible with old version, we should copy value of value attribute into data-value attribute.
            // For the reason we use data-value instead, see http://nya.io/AngularJS/Beware-Of-Using-value-Attribute-On-list-element/
            nyaBsOptionValue = liElement.attr('value');
            if(angular.isString(nyaBsOptionValue) && nyaBsOptionValue !== '') {
              liElement.attr('data-value', nyaBsOptionValue);
              liElement.removeAttr('value');
            }
          }
        }

        if(tAttrs.liveSearch === 'true') {
          searchBox = jqLite(SEARCH_BOX);

          // set localized text
          if(localizedText.noSearchResultTpl) {
            NO_SEARCH_RESULT = NO_SEARCH_RESULT.replace('NO SEARCH RESULT', localizedText.noSearchResultTpl);
          } else if(localizedText.noSearchResult) {
            NO_SEARCH_RESULT = NO_SEARCH_RESULT.replace('NO SEARCH RESULT', localizedText.noSearchResult);
          }

          noSearchResult = jqLite(NO_SEARCH_RESULT);
          dropdownContainer.append(searchBox);
          dropdownMenu.append(noSearchResult);
        }

        if (tAttrs.actionsBox === 'true' && isMultiple) {
          // set localizedText
          if (localizedText.selectAllTpl) {
            ACTIONS_BOX = ACTIONS_BOX.replace('SELECT ALL', localizedText.selectAllTpl);
          } else if (localizedText.selectAll) {
            ACTIONS_BOX = ACTIONS_BOX.replace('SELECT ALL', localizedText.selectAll);
          }

          if (localizedText.deselectAllTpl) {
            ACTIONS_BOX = ACTIONS_BOX.replace('DESELECT ALL', localizedText.deselectAllTpl);
          } else if (localizedText.selectAll) {
            ACTIONS_BOX = ACTIONS_BOX.replace('DESELECT ALL', localizedText.deselectAll);
          }

          actionsBox = jqLite(ACTIONS_BOX);
          dropdownContainer.append(actionsBox);
        }

        // set default none selection text
        dropdownToggle.children().eq(0).append(getDefaultNoneSelectionContent());

        dropdownContainer.append(dropdownMenu);

        tElement.append(dropdownToggle);
        tElement.append(dropdownContainer);

        return function nyaBsSelectLink ($scope, $element, $attrs, ctrls) {

          var ngCtrl = ctrls[0],
            nyaBsSelectCtrl = ctrls[1],
            liHeight,
            isDisabled = false,
            previousTabIndex,
            valueExpFn,
            valueExpGetter = $parse(nyaBsSelectCtrl.valueExp),
            isMultiple = typeof $attrs.multiple !== 'undefined';

          // find element from current $element root. because the compiled element may be detached from DOM tree by ng-if or ng-switch.
          var dropdownToggle = queryChildren($element, ['dropdown-toggle']),
            dropdownContainer = dropdownToggle.next(),
            dropdownMenu = queryChildren(dropdownContainer, ['dropdown-menu', 'inner']),
            searchBox = queryChildren(dropdownContainer, ['bs-searchbox']),
            noSearchResult = queryChildren(dropdownMenu, ['no-search-result']),
            actionsBox = queryChildren(dropdownContainer, ['bs-actionsbox']);

          if(nyaBsSelectCtrl.valueExp) {
            valueExpFn = function(scope, locals) {
              return valueExpGetter(scope, locals);
            };
          }

          // for debug
          nyaBsSelectCtrl.setId($element.attr('id'));

          if (isMultiple) {
            nyaBsSelectCtrl.isMultiple = true;

            // required validator
            ngCtrl.$isEmpty = function(value) {
              return !value || value.length === 0;
            };
          }

          dropdownToggle.on('focus', function () {
            if (!isDisabled) {
              $element.triggerHandler('focus');
            }
          });

          if(typeof $attrs.disabled !== 'undefined') {
            $scope.$watch($attrs.disabled, function(disabled){
              if(!!disabled) {
                dropdownToggle.addClass('disabled');
                previousTabIndex = dropdownToggle.attr('tabindex');
                dropdownToggle.attr('tabindex', '-1');
                isDisabled = true;
              } else {
                dropdownToggle.removeClass('disabled');
                if(previousTabIndex) {
                  dropdownToggle.attr('tabindex', previousTabIndex);
                } else {
                  dropdownToggle.removeAttr('tabindex');
                }
                isDisabled = false;
              }
            });
          }

          /**
           * Do some check on modelValue. remove no existing value
           * @param values
           */
          nyaBsSelectCtrl.onCollectionChange = function (values) {
            var valuesForSelect = [],
              index,
              length,
              modelValue = ngCtrl.$modelValue;

            if(!modelValue) {
              return;
            }

            /**
             * Behavior change, since 2.1.0, we don't want to reset model to null or empty array when options' collection is not prepared.
             */
            if(Array.isArray(values) && values.length > 0) {
              if(valueExpFn) {
                for(index = 0; index < values.length; index++) {
                  valuesForSelect.push(valueExpFn($scope, values[index]));
                }
              } else {
                for(index = 0; index < values.length; index++) {
                  if(nyaBsSelectCtrl.valueIdentifier) {
                    valuesForSelect.push(values[index][nyaBsSelectCtrl.valueIdentifier]);
                  } else if(nyaBsSelectCtrl.keyIdentifier) {
                    valuesForSelect.push(values[index][nyaBsSelectCtrl.keyIdentifier]);
                  }
                }

              }

              if(isMultiple) {
                length = modelValue.length;
                for(index = 0; index < modelValue.length; index++) {
                  if(!contains(valuesForSelect, modelValue[index])) {
                    modelValue.splice(index, 1);
                    index--;
                  }
                }

                if(length !== modelValue.length) {
                  // modelValue changed.
                  // Due to ngModelController compare reference with the old modelValue, we must set an new array instead of modifying the old one.
                  // See: https://github.com/angular/angular.js/issues/1751
                  modelValue = deepCopy(modelValue);
                }

              } else {
                if(!contains(valuesForSelect, modelValue)) {
                  modelValue = valuesForSelect[0];
                }
              }

            }

            ngCtrl.$setViewValue(modelValue);

            updateButtonContent();

          };

          // view --> model

          dropdownMenu.on('click', function menuEventHandler (event) {

            event.stopPropagation();
            if(isDisabled) {
              return;
            }

            if(jqLite(event.target).hasClass('dropdown-header')) {
              return;
            }
            var nyaBsOptionNode = filterTarget(event.target, dropdownMenu[0], 'nya-bs-option'),
              nyaBsOption;

            if(nyaBsOptionNode !== null) {
              nyaBsOption = jqLite(nyaBsOptionNode);
              if(nyaBsOption.hasClass('disabled')) {
                return;
              }
              selectOption(nyaBsOption);
            }
          });

          // if click the outside of dropdown menu, close the dropdown menu
          var outClick = function(event) {
            if(filterTarget(event.target, $element.parent()[0], $element[0]) === null) {
              if($element.hasClass('open')) {
                $element.triggerHandler('blur');
              }
              $element.removeClass('open');
            }
          };
          $document.on('click', outClick);



          dropdownToggle.on('blur', function() {
            if(!$element.hasClass('open')) {
              $element.triggerHandler('blur');
            }
          });
          dropdownToggle.on('click', function() {
            var nyaBsOptionNode;
            $element.toggleClass('open');
            if($element.hasClass('open') && typeof liHeight === 'undefined') {
              calcMenuSize();
            }
            if($attrs.liveSearch === 'true' && $element.hasClass('open')) {
              //searchBox.children().eq(0)[0].focus();
              nyaBsOptionNode = findFocus(true);
              if(nyaBsOptionNode) {
                dropdownMenu.children().removeClass('active');
                jqLite(nyaBsOptionNode).addClass('active');
              }
            } else if($element.hasClass('open')) {
              nyaBsOptionNode = findFocus(true);
              if(nyaBsOptionNode) {
                setFocus(nyaBsOptionNode);
              }
            }
          });

          // actions box
          if ($attrs.actionsBox === 'true' && isMultiple) {
            actionsBox.find('button').eq(0).on('click', function () {
              setAllOptions(true);
            });
            actionsBox.find('button').eq(1).on('click', function () {
              setAllOptions(false);
            });
          }


          // live search
          if($attrs.liveSearch === 'true') {
            searchBox.children().on('input', function(){

              var searchKeyword = searchBox.children().val(),
                found = 0,
                options = dropdownMenu.children(),
                length = options.length,
                index,
                option,
                nyaBsOptionNode;

              if(searchKeyword) {
                for(index = 0; index < length; index++) {
                  option = options.eq(index);
                  if(option.hasClass('nya-bs-option')) {
                    if(!hasKeyword(option.find('a'), searchKeyword)) {
                      option.addClass('not-match');
                    } else {
                      option.removeClass('not-match');
                      found++;
                    }
                  }
                }

                if(found === 0) {
                  noSearchResult.addClass('show');
                } else {
                  noSearchResult.removeClass('show');
                }
              } else {
                for(index = 0; index < length; index++) {
                  option = options.eq(index);
                  if(option.hasClass('nya-bs-option')) {
                    option.removeClass('not-match');
                  }
                }
                noSearchResult.removeClass('show');
              }

              nyaBsOptionNode = findFocus(true);

              if(nyaBsOptionNode) {
                options.removeClass('active');
                jqLite(nyaBsOptionNode).addClass('active');
              }

            });
          }


          // model --> view

          ngCtrl.$render = function() {
            var modelValue = ngCtrl.$modelValue,
              index,
              bsOptionElements = dropdownMenu.children(),
              length = bsOptionElements.length,
              value;
            if(typeof modelValue === 'undefined') {
              // if modelValue is undefined. uncheck all option
              for(index = 0; index < length; index++) {
                if(bsOptionElements.eq(index).hasClass('nya-bs-option')) {
                  bsOptionElements.eq(index).removeClass('selected');
                }
              }
            } else {
              for(index = 0; index < length; index++) {
                if(bsOptionElements.eq(index).hasClass('nya-bs-option')) {

                  value = getOptionValue(bsOptionElements.eq(index));
                  if(isMultiple) {
                    if(contains(modelValue, value)) {
                      bsOptionElements.eq(index).addClass('selected');
                    } else {
                      bsOptionElements.eq(index).removeClass('selected');
                    }
                  } else {
                    if(deepEquals(modelValue, value)) {
                      bsOptionElements.eq(index).addClass('selected');
                    } else {
                      bsOptionElements.eq(index).removeClass('selected');
                    }
                  }

                }
              }
            }
            //console.log(nyaBsSelectCtrl.id + ' render end');
            updateButtonContent();
          };

          // simple keyboard support
          $element.on('keydown', function(event){
            var keyCode = event.keyCode;

            if(keyCode !== 27 && keyCode !== 13 && keyCode !== 38 && keyCode !== 40) {
              // we only handle special keys. don't waste time to traverse the dom tree.
              return;
            }

            // prevent a click event to be fired.
            event.preventDefault();
            if(isDisabled) {
              event.stopPropagation();
              return;
            }
            var toggleButton = filterTarget(event.target, $element[0], dropdownToggle[0]),
              menuContainer,
              searchBoxContainer,
              liElement,
              nyaBsOptionNode;

            if($attrs.liveSearch === 'true') {
              searchBoxContainer = filterTarget(event.target, $element[0], searchBox[0]);
            } else {
              menuContainer = filterTarget(event.target, $element[0], dropdownContainer[0])
            }

            if(toggleButton) {


              // press enter to active dropdown
              if((keyCode === 13 || keyCode === 38 || keyCode === 40) && !$element.hasClass('open')) {

                event.stopPropagation();

                $element.addClass('open');

                // calculate menu size
                if(typeof liHeight === 'undefined') {
                  calcMenuSize();
                }

                // if live search enabled. give focus to search box.
                if($attrs.liveSearch === 'true') {
                  searchBox.children().eq(0)[0].focus();
                  // find the focusable node but we will use active
                  nyaBsOptionNode = findFocus(true);
                  if(nyaBsOptionNode) {
                    // remove previous active state
                    dropdownMenu.children().removeClass('active');
                    // set active to first focusable element
                    jqLite(nyaBsOptionNode).addClass('active');
                  }
                } else {
                  // otherwise, give focus to first menu item.
                  nyaBsOptionNode = findFocus(true);
                  if(nyaBsOptionNode) {
                    setFocus(nyaBsOptionNode);
                  }
                }
              }

              // press enter or escape to de-active dropdown
              //if((keyCode === 13 || keyCode === 27) && $element.hasClass('open')) {
              //  $element.removeClass('open');
              //  event.stopPropagation();
              //}
            } else if(menuContainer) {

              if(keyCode === 27) {
                // escape pressed
                dropdownToggle[0].focus();
                if($element.hasClass('open')) {
                  $element.triggerHandler('blur');
                }
                $element.removeClass('open');
                event.stopPropagation();

              } else if(keyCode === 38) {
                event.stopPropagation();
                // up arrow key
                nyaBsOptionNode = findNextFocus(event.target.parentNode, 'previousSibling');
                if(nyaBsOptionNode) {
                  setFocus(nyaBsOptionNode);
                } else {
                  nyaBsOptionNode = findFocus(false);
                  if(nyaBsOptionNode) {
                    setFocus(nyaBsOptionNode);
                  }
                }
              } else if(keyCode === 40) {
                event.stopPropagation();
                // down arrow key
                nyaBsOptionNode = findNextFocus(event.target.parentNode, 'nextSibling');
                if(nyaBsOptionNode) {
                  setFocus(nyaBsOptionNode);
                } else {
                  nyaBsOptionNode = findFocus(true);
                  if(nyaBsOptionNode) {
                    setFocus(nyaBsOptionNode);
                  }
                }
              } else if(keyCode === 13) {
                event.stopPropagation();
                // enter pressed
                liElement = jqLite(event.target.parentNode);
                if(liElement.hasClass('nya-bs-option')) {
                  selectOption(liElement);
                  if(!isMultiple) {
                    dropdownToggle[0].focus();
                  }
                }
              }
            } else if(searchBoxContainer) {
              if(keyCode === 27) {
                dropdownToggle[0].focus();
                $element.removeClass('open');
                event.stopPropagation();
              } else if(keyCode === 38) {
                // up
                event.stopPropagation();

                liElement = findActive();
                if(liElement) {
                  nyaBsOptionNode = findNextFocus(liElement[0], 'previousSibling');
                  if(nyaBsOptionNode) {
                    liElement.removeClass('active');
                    jqLite(nyaBsOptionNode).addClass('active');
                  } else {
                    nyaBsOptionNode = findFocus(false);
                    if(nyaBsOptionNode) {
                      liElement.removeClass('active');
                      jqLite(nyaBsOptionNode).addClass('active');
                    }
                  }
                }

              } else if(keyCode === 40) {
                // down
                event.stopPropagation();

                liElement = findActive();
                if(liElement) {
                  nyaBsOptionNode = findNextFocus(liElement[0], 'nextSibling');
                  if(nyaBsOptionNode) {
                    liElement.removeClass('active');
                    jqLite(nyaBsOptionNode).addClass('active');
                  } else {
                    nyaBsOptionNode = findFocus(true);
                    if(nyaBsOptionNode) {
                      liElement.removeClass('active');
                      jqLite(nyaBsOptionNode).addClass('active');
                    }
                  }
                }
              } else if(keyCode === 13) {
                // select an option.
                liElement = findActive();
                if(liElement) {
                  selectOption(liElement);
                  if(!isMultiple) {
                    dropdownToggle[0].focus();
                  }
                }
              }
            }
          });

          function findActive() {
            var list = dropdownMenu.children(),
              i, liElement,
              length = list.length;
            for(i = 0; i < length; i++) {
              liElement = list.eq(i);
              if(liElement.hasClass('active') && liElement.hasClass('nya-bs-option') && !liElement.hasClass('not-match')) {
                return liElement;
              }
            }
            return null;
          }

          /**
           * setFocus on a nya-bs-option element. it actually set focus on its child anchor element.
           * @param elem a nya-bs-option element.
           */
          function setFocus(elem) {
            var childList = elem.childNodes,
              length = childList.length,
              child;
            for(var i = 0; i < length; i++) {
              child = childList[i];
              if(child.nodeType === 1 && child.tagName.toLowerCase() === 'a') {
                child.focus();
                break;
              }
            }
          }

          function findFocus(fromFirst) {
            var firstLiElement;
            if(fromFirst) {
              firstLiElement = dropdownMenu.children().eq(0);
            } else {
              firstLiElement = dropdownMenu.children().eq(dropdownMenu.children().length - 1);
            }

            // focus on selected element
            for(var i = 0; i < dropdownMenu.children().length; i++) {
              var childElement = dropdownMenu.children().eq(i);
              if (!childElement.hasClass('not-match') && childElement.hasClass('selected')) {
                return dropdownMenu.children().eq(i)[0];
              }
            }

            if(firstLiElement.hasClass('nya-bs-option') && !firstLiElement.hasClass('disabled') && !firstLiElement.hasClass('not-match')) {
              return firstLiElement[0];
            } else {
              if(fromFirst) {
                return findNextFocus(firstLiElement[0], 'nextSibling');
              } else {
                return findNextFocus(firstLiElement[0], 'previousSibling');
              }
            }
          }

          /**
           * find next focusable element on direction
           * @param from the element traversed from
           * @param direction can be 'nextSibling' or 'previousSibling'
           * @returns the element if found, otherwise return null.
           */
          function findNextFocus(from, direction) {
            if(from && !hasClass(from, 'nya-bs-option')) {
              return;
            }
            var next = from;
            while ((next = sibling(next, direction)) && next.nodeType) {
              if(hasClass(next,'nya-bs-option') && !hasClass(next, 'disabled') && !hasClass(next, 'not-match')) {
                return next
              }
            }
            return null;
          }

          /**
           *
           */
          function setAllOptions(selectAll) {
            if (!isMultiple || isDisabled)
              return;

            var liElements,
              modelValue,
              viewValue;

            liElements = dropdownMenu.find('li');
            if (liElements.length > 0) {
              modelValue = ngCtrl.$modelValue;

              // make a deep copy enforce ngModelController to call its $render method.
              // See: https://github.com/angular/angular.js/issues/1751
              viewValue = Array.isArray(modelValue) ? deepCopy(modelValue) : [];

              for (var i = 0; i < liElements.length; i++) {
                var nyaBsOption = jqLite(liElements[i]);
                if (nyaBsOption.hasClass('disabled'))
                  continue;

                var value, index;

                // if user specify the value attribute. we should use the value attribute
                // otherwise, use the valueIdentifier specified field in target scope
                value = getOptionValue(nyaBsOption);

                if (typeof value !== 'undefined') {
                  index = indexOf(viewValue, value);
                  if (selectAll && index == -1) {
                    // check element
                    viewValue.push(value);
                    nyaBsOption.addClass('selected');
                  } else if (!selectAll && index != -1) {
                    // uncheck element
                    viewValue.splice(index, 1);
                    nyaBsOption.removeClass('selected');
                  }
                }
              }

              // update view value regardless
              ngCtrl.$setViewValue(viewValue);
              $scope.$digest();

              updateButtonContent();
            }
          }

          /**
           * select an option represented by nyaBsOption argument. Get the option's value and update model.
           * if isMultiple = true, doesn't close dropdown menu. otherwise close the menu.
           * @param nyaBsOption the jqLite wrapped `nya-bs-option` element.
           */
          function selectOption(nyaBsOption) {
            var value,
              viewValue,
              modelValue = ngCtrl.$modelValue,
              index;
            // if user specify the value attribute. we should use the value attribute
            // otherwise, use the valueIdentifier specified field in target scope

            value = getOptionValue(nyaBsOption);

            if(typeof value !== 'undefined') {
              if(isMultiple) {
                // make a deep copy enforce ngModelController to call its $render method.
                // See: https://github.com/angular/angular.js/issues/1751
                viewValue = Array.isArray(modelValue) ? deepCopy(modelValue) : [];
                index = indexOf(viewValue, value);
                if(index === -1) {
                  // check element
                  viewValue.push(value);
                  nyaBsOption.addClass('selected');

                } else {
                  // uncheck element
                  viewValue.splice(index, 1);
                  nyaBsOption.removeClass('selected');

                }

              } else {
                dropdownMenu.children().removeClass('selected');
                viewValue = value;
                nyaBsOption.addClass('selected');

              }
            }

            if (!deepEquals(viewValue, modelValue)) {
              $element.triggerHandler('change');
            }

            // update view value regardless
            ngCtrl.$setViewValue(viewValue);
            $scope.$digest();

            if(!isMultiple) {
              // in single selection mode. close the dropdown menu
              if($element.hasClass('open')) {
                $element.triggerHandler('blur');
              }
              $element.removeClass('open');
            }
            updateButtonContent();
          }

          /**
           * get a value of current nyaBsOption. according to different setting.
           * - if `nya-bs-option` directive is used to populate options and a `value` attribute is specified. use expression of the attribute value.
           * - if `nya-bs-option` directive is used to populate options and no other settings, use the valueIdentifier or keyIdentifier to retrieve value from scope of current nyaBsOption.
           * - if `nya-bs-option` class is used on static options. use literal value of the `value` attribute.
           * @param nyaBsOption a jqLite wrapped `nya-bs-option` element
           */
          function getOptionValue(nyaBsOption) {
            var scopeOfOption;
            if(valueExpFn) {
              // here we use the scope bound by ourselves in the nya-bs-option.
              scopeOfOption = nyaBsOption.data('isolateScope');
              return valueExpFn(scopeOfOption);
            } else {
              if(nyaBsSelectCtrl.valueIdentifier || nyaBsSelectCtrl.keyIdentifier) {
                scopeOfOption = nyaBsOption.data('isolateScope');
                return scopeOfOption[nyaBsSelectCtrl.valueIdentifier] || scopeOfOption[nyaBsSelectCtrl.keyIdentifier];
              } else {
                return nyaBsOption.attr('data-value');
              }
            }

          }

          function getOptionText(nyaBsOption) {
            var item = nyaBsOption.find('a');
            if(item.children().length === 0 || item.children().eq(0).hasClass('check-mark')) {
              // if the first child is check-mark or has no children, means the option text is text node
              return item[0].firstChild.cloneNode(false);
            } else {
              // otherwise we clone the first element of the item
              return item.children().eq(0)[0].cloneNode(true);
            }
          }

          function updateButtonContent() {
            var modelValue = ngCtrl.$modelValue;

            var filterOption = dropdownToggle.children().eq(0);
            if(typeof modelValue === 'undefined') {
              /**
               * Select empty option when model is undefined.
               */
              filterOption.empty();
              filterOption.append(getDefaultNoneSelectionContent());
              return;
            }
            if(isMultiple && modelValue.length === 0) {
              filterOption.empty();
              filterOption.append(getDefaultNoneSelectionContent());
            } else {
              $timeout(function() {

                var bsOptionElements = dropdownMenu.children(),
                  value,
                  nyaBsOption,
                  index,
                  length = bsOptionElements.length,
                  optionTitle,
                  selection = [],
                  match,
                  count;

                if(isMultiple && $attrs.selectedTextFormat === 'count') {
                  count = 1;
                } else if(isMultiple && $attrs.selectedTextFormat && (match = $attrs.selectedTextFormat.match(/\s*count\s*>\s*(\d+)\s*/))) {
                  count = parseInt(match[1], 10);
                }

                // data-selected-text-format="count" or data-selected-text-format="count>x"
                if((typeof count !== 'undefined') && modelValue.length > count) {
                  filterOption.empty();
                  if(localizedText.numberItemSelectedTpl) {
                    filterOption.append(jqLite(localizedText.numberItemSelectedTpl.replace('%d', modelValue.length)));
                  } else if(localizedText.numberItemSelected) {
                    filterOption.append(document.createTextNode(localizedText.numberItemSelected.replace('%d', modelValue.length)));
                  } else {
                    filterOption.append(document.createTextNode(modelValue.length + ' items selected'));
                  }
                  return;
                }

                // data-selected-text-format="values" or the number of selected items is less than count
                for(index = 0; index < length; index++) {
                  nyaBsOption = bsOptionElements.eq(index);
                  if(nyaBsOption.hasClass('nya-bs-option')) {

                    value = getOptionValue(nyaBsOption);

                    if(isMultiple) {
                      if(Array.isArray(modelValue) && contains(modelValue, value)) {
                        // if option has an title attribute. use the title value as content show in button.
                        // otherwise get very first child element.
                        optionTitle = nyaBsOption.attr('title');
                        if(optionTitle) {
                          selection.push(document.createTextNode(optionTitle));
                        } else {
                          selection.push(getOptionText(nyaBsOption));
                        }

                      }
                    } else {
                      if(deepEquals(modelValue, value)) {
                        optionTitle = nyaBsOption.attr('title');
                        if(optionTitle) {
                          selection.push(document.createTextNode(optionTitle));
                        } else {
                          selection.push(getOptionText(nyaBsOption));
                        }
                      }
                    }

                  }
                }

                if(selection.length === 0) {
                  filterOption.empty();
                  filterOption.append(getDefaultNoneSelectionContent());
                } else if(selection.length === 1) {
                  // either single or multiple selection will show the only selected content.
                  filterOption.empty();
                  filterOption.append(selection[0]);
                } else {
                  filterOption.empty();
                  for(index = 0; index < selection.length; index++) {
                    filterOption.append(selection[index]);
                    if(index < selection.length -1) {
                      filterOption.append(document.createTextNode(', '));
                    }
                  }
                }

              });
            }

          }

          // will called only once.
          function calcMenuSize(){

            var liElements = dropdownMenu.find('li'),
              length = liElements.length,
              liElement,
              i;
            for(i = 0; i < length; i++) {
              liElement = liElements.eq(i);
              if(liElement.hasClass('nya-bs-option') || liElement.attr('nya-bs-option')) {
                liHeight = liElement[0].clientHeight;
                break;
              }
            }

            if(/\d+/.test($attrs.size)) {
              var dropdownSize = parseInt($attrs.size, 10);
              dropdownMenu.css('max-height', (dropdownSize * liHeight) + 'px');
              dropdownMenu.css('overflow-y', 'auto');
            }

          }

          $scope.$on('$destroy', function() {
            dropdownMenu.off();
            dropdownToggle.off();
            searchBox.off();
            $document.off('click', outClick);

          });

        };
      }
    };
  }]);

  nyaBsSelect.directive('nyaBsOption', ['$parse', function($parse){

                          //00000011111111111111100000000022222222222222200000003333333333333330000000000000004444444444000000000000000000055555555550000000000000000000006666666666000000
    var BS_OPTION_REGEX = /^\s*(?:([\$\w][\$\w]*)|(?:\(\s*([\$\w][\$\w]*)\s*,\s*([\$\w][\$\w]*)\s*\)))\s+in\s+([\s\S]+?)(?:\s+group\s+by\s+([\s\S]+?))?(?:\s+track\s+by\s+([\s\S]+?))?\s*$/;

    return {
      restrict: 'A',
      transclude: 'element',
      priority: 1000,
      terminal: true,
      require: ['^nyaBsSelect', '^ngModel'],
      compile: function nyaBsOptionCompile (tElement, tAttrs) {

        var expression = tAttrs.nyaBsOption;
        var nyaBsOptionEndComment = document.createComment(' end nyaBsOption: ' + expression + ' ');
        var match = expression.match(BS_OPTION_REGEX);

        if(!match) {
          throw new Error('invalid expression');
        }

        // we want to keep our expression comprehensible so we don't use 'select as label for value in collection' expression.
        var valueExp = tAttrs.value,
          valueExpGetter = valueExp ? $parse(valueExp) : null;

        var valueIdentifier = match[3] || match[1],
          keyIdentifier = match[2],
          collectionExp = match[4],
          groupByExpGetter = match[5] ? $parse(match[5]) : null,
          trackByExp = match[6];

        var trackByIdArrayFn,
          trackByIdObjFn,
          trackByIdExpFn,
          trackByExpGetter;
        var hashFnLocals = {$id: hashKey};
        var groupByFn, locals = {};

        if(trackByExp) {
          trackByExpGetter = $parse(trackByExp);
        } else {
          trackByIdArrayFn = function(key, value) {
            return hashKey(value);
          };
          trackByIdObjFn = function(key) {
            return key;
          };
        }
        return function nyaBsOptionLink($scope, $element, $attr, ctrls, $transclude) {

          var nyaBsSelectCtrl = ctrls[0],
            ngCtrl = ctrls[1],
            valueExpFn,
            valueExpLocals = {};

          if(trackByExpGetter) {
            trackByIdExpFn = function(key, value, index) {
              // assign key, value, and $index to the locals so that they can be used in hash functions
              if (keyIdentifier) {
                hashFnLocals[keyIdentifier] = key;
              }
              hashFnLocals[valueIdentifier] = value;
              hashFnLocals.$index = index;
              return trackByExpGetter($scope, hashFnLocals);
            };
          }

          if(groupByExpGetter) {
            groupByFn = function(key, value) {
              if(keyIdentifier) {
                locals[keyIdentifier] = key;
              }
              locals[valueIdentifier] = value;
              return groupByExpGetter($scope, locals);
            }
          }

          // set keyIdentifier and valueIdentifier property of nyaBsSelectCtrl
          if(keyIdentifier) {
            nyaBsSelectCtrl.keyIdentifier = keyIdentifier;
          }
          if(valueIdentifier) {
            nyaBsSelectCtrl.valueIdentifier = valueIdentifier;
          }

          if(valueExpGetter) {
            nyaBsSelectCtrl.valueExp = valueExp;
            valueExpFn = function(key, value) {
              if(keyIdentifier) {
                valueExpLocals[keyIdentifier] = key;
              }
              valueExpLocals[valueIdentifier] = value;
              return valueExpGetter($scope, valueExpLocals);
            }

          }


          // Store a list of elements from previous run. This is a hash where key is the item from the
          // iterator, and the value is objects with following properties.
          //   - scope: bound scope
          //   - element: previous element.
          //   - index: position
          //
          // We are using no-proto object so that we don't need to guard against inherited props via
          // hasOwnProperty.
          var lastBlockMap = createMap();

          // deepWatch will impact performance. use with caution.
          if($attr.deepWatch === 'true') {
            $scope.$watch(collectionExp, nyaBsOptionAction, true);
          } else {
            $scope.$watchCollection(collectionExp, nyaBsOptionAction);
          }

          function nyaBsOptionAction(collection) {
            var index,

              previousNode = $element[0],     // node that cloned nodes should be inserted after
            // initialized to the comment node anchor

              key, value,
              trackById,
              trackByIdFn,
              collectionKeys,
              collectionLength,
            // Same as lastBlockMap but it has the current state. It will become the
            // lastBlockMap on the next iteration.
              nextBlockMap = createMap(),
              nextBlockOrder,
              block,
              groupName,
              nextNode,
              group,
              lastGroup,

              removedClone, // removed clone node, should also remove isolateScope data as well

              values = [],
              valueObj; // the collection value

            if(groupByFn) {
              group = [];
            }

            if(isArrayLike(collection)) {
              collectionKeys = collection;
              trackByIdFn = trackByIdExpFn || trackByIdArrayFn;
            } else {
              trackByIdFn = trackByIdExpFn || trackByIdObjFn;
              // if object, extract keys, sort them and use to determine order of iteration over obj props
              collectionKeys = [];
              for (var itemKey in collection) {
                if (collection.hasOwnProperty(itemKey) && itemKey.charAt(0) != '$') {
                  collectionKeys.push(itemKey);
                }
              }
              collectionKeys.sort();
            }
            collectionLength = collectionKeys.length;
            nextBlockOrder = new Array(collectionLength);

            for(index = 0; index < collectionLength; index++) {
              key = (collection === collectionKeys) ? index : collectionKeys[index];
              value = collection[key];
              trackById = trackByIdFn(key, value, index);

              // copy the value with scope like structure to notify the select directive.
              valueObj = {};
              if(keyIdentifier) {
                valueObj[keyIdentifier] = key;
              }

              valueObj[valueIdentifier] = value;
              values.push(valueObj);

              if(groupByFn) {
                groupName = groupByFn(key, value);
                if(group.indexOf(groupName) === -1 && groupName) {
                  group.push(groupName);
                }
              }

              if(lastBlockMap[trackById]) {
                // found previously seen block
                block = lastBlockMap[trackById];
                delete lastBlockMap[trackById];

                // must update block here because some data we stored may change.
                if(groupByFn) {
                  block.group = groupName;
                }
                block.key = key;
                block.value = value;

                nextBlockMap[trackById] = block;
                nextBlockOrder[index] = block;
              } else if(nextBlockMap[trackById]) {
                //if collision detected. restore lastBlockMap and throw an error
                nextBlockOrder.forEach(function(block) {
                  if(block && block.scope) {
                    lastBlockMap[block.id] = block;
                  }
                });
                throw new Error("Duplicates in a select are not allowed. Use 'track by' expression to specify unique keys.");
              } else {
                // new never before seen block
                nextBlockOrder[index] = {id: trackById, scope: undefined, clone: undefined, key: key, value: value};
                nextBlockMap[trackById] = true;
                if(groupName) {
                  nextBlockOrder[index].group = groupName;
                }
              }
            }

            // only resort nextBlockOrder when group found
            if(group && group.length > 0) {

              nextBlockOrder = sortByGroup(nextBlockOrder, group, 'group');
            }

            // remove DOM nodes
            for( var blockKey in lastBlockMap) {
              block = lastBlockMap[blockKey];
              removedClone = getBlockNodes(block.clone);
              // remove the isolateScope data to detach scope from this clone
              removedClone.removeData('isolateScope');
              removedClone.remove();
              block.scope.$destroy();
            }

            for(index = 0; index < collectionLength; index++) {
              block = nextBlockOrder[index];
              if(block.scope) {
                // if we have already seen this object, then we need to reuse the
                // associated scope/element

                nextNode = previousNode;
                if(getBlockStart(block) != nextNode) {
                  jqLite(previousNode).after(block.clone);
                }
                previousNode = getBlockEnd(block);

                updateScope(block.scope, index, valueIdentifier, block.value, keyIdentifier, block.key, collectionLength, block.group);
              } else {
                $transclude(function nyaBsOptionTransclude(clone, scope) {
                  // in case of the debugInfoEnable is set to false, we have to bind the scope to the clone node.
                  setElementIsolateScope(clone, scope);

                  block.scope = scope;

                  var endNode = nyaBsOptionEndComment.cloneNode(false);
                  clone[clone.length++] = endNode;

                  jqLite(previousNode).after(clone);

                  // add nya-bs-option class
                  clone.addClass('nya-bs-option');

                  // for newly created item we need to ensure its selected status from the model value.
                  if(valueExpFn) {
                    value = valueExpFn(block.key, block.value);
                  } else {
                    value = block.value || block.key;
                  }

                  if(nyaBsSelectCtrl.isMultiple) {
                    if(Array.isArray(ngCtrl.$modelValue) && contains(ngCtrl.$modelValue, value)) {
                      clone.addClass('selected');
                    }
                  } else {
                    if(deepEquals(value, ngCtrl.$modelValue)) {
                      clone.addClass('selected');
                    }
                  }

                  previousNode = endNode;
                  // Note: We only need the first/last node of the cloned nodes.
                  // However, we need to keep the reference to the jqlite wrapper as it might be changed later
                  // by a directive with templateUrl when its template arrives.
                  block.clone = clone;
                  nextBlockMap[block.id] = block;
                  updateScope(block.scope, index, valueIdentifier, block.value, keyIdentifier, block.key, collectionLength, block.group);
                });

              }

              // we need to mark the first item of a group
              if(group && (group != undefined && group.length > 0)) {
                if(!lastGroup || lastGroup !== block.group) {
                  block.clone.addClass('first-in-group');
                } else {
                  block.clone.removeClass('first-in-group');
                }

                lastGroup = block.group;

                // add special class for indent
                block.clone.addClass('group-item');
              }
            }

            lastBlockMap = nextBlockMap;

            nyaBsSelectCtrl.onCollectionChange(values);
          }
        };
      }
    }
  }]);
})();



// mostly taken from http://www.codinginsight.com/angularjs-and-pickadate/

angular.module('angular-datepicker', [])
    .directive('pickADate', ["$timeout", function ($timeout) {
        return {
            restrict: 'A',
            scope: {
                pickADate: '=',
                pickADateOptions: '='
            },
            link: function (scope, element) {

                var options = scope.pickADateOptions || {};

                var userOnSet = options.onSet;
                function onSet(e) {

                    if (typeof userOnSet === 'function') {
                        userOnSet.apply(this, arguments);
                    }

                    if (scope.$$phase || scope.$root.$$phase) {
                        // we are coming from $watch or link setup
                        return;
                    }

                    $timeout(function () {
                        if (e.hasOwnProperty('clear')) {
                            scope.pickADate = null;
                        } else if (e.hasOwnProperty('select')) {
                            scope.pickADate = toDateString(new Date(e.select));
                        }
                    }, 0);
                }

                var userOnOpen = options.onOpen;
                function onOpen(e) {

                    if (typeof userOnOpen === 'function') {
                        userOnOpen.apply(this, arguments);
                    }
                }

                var userOnClose = options.onClose;
                function onClose(e) {

                    if (typeof userOnClose === 'function') {
                        userOnClose.apply(this, arguments);
                    }

                    if (!window.cordova || !window.cordova.plugins || !window.cordova.plugins.Keyboard) {
                        return;
                    }

                    var keyboardShowCallback = function () {
                        window.cordova.plugins.Keyboard.close();
                        window.removeEventListener('native.keyboardshow', this);
                    };

                    window.addEventListener('native.keyboardshow', keyboardShowCallback);

                    setTimeout(function () {
                        window.removeEventListener('native.keyboardshow', keyboardShowCallback);
                    }, 500);
                }

                if (options.min && typeof (options.min) === 'string') {
                    if (options.min !== 'current') {
                        options.min = toDateObject(options.min);
                    }
                } else {
                    options.min = '';
                }

                if (options.max && typeof (options.max) === 'string') {
                    if (options.max !== 'current') {
                        options.max = toDateObject(options.max);
                    }
                } else {
                    options.max = '';
                }

                if (options.default && typeof (options.default) === 'string' && !scope.pickADate) {
                    if (options.default === 'current') {
                        scope.pickADate = toDateString(new Date());
                        scope.$parent.updateStore(scope.pickADate);
                    } else {
                        scope.pickADate = toDateString(toDateObject(options.default));
                        scope.$parent.updateStore(scope.pickADate);
                    }
                }

                if (options.selectYears === true) {
                    options.selectYears = 200;
                }

                element.pickadate(angular.extend(options, {
                    onOpen: onOpen,
                    onSet: onSet,
                    onClose: onClose,
                    container: document.body
                }));

                if (scope.pickADate) {
                    processSelectedDate(scope.pickADate);
                }

                scope.$watch('pickADate', function (newValue, oldValue) {
                    if (newValue !== oldValue) {
                        processSelectedDate(newValue);
                        scope.$parent.updateStore(newValue);
                    }
                });

                function padTwo(number) {
                    if (number.toString().length === 1) return '0' + number;
                    return number.toString();
                }

                function toUTCDate(dateObj) {
                    if (!dateObj || !dateObj.getUTCDate) {
                        return null;
                    }
                    return new Date(dateObj.getUTCFullYear(), dateObj.getUTCMonth(), dateObj.getUTCDate(), 0, 0, 0, 0);
                }

                function toDateString(dateObj) {
                    return dateObj.getFullYear() + '-' + padTwo(dateObj.getMonth() + 1) + '-' + padTwo(dateObj.getDate())
                }

                function toDateObject(dateObj) {
                    var dateString = null;
                    var dateRegex = /\d{4}-\d{2}-\d{2}/;
                    if (typeof (dateObj) === 'string' && dateRegex.test(dateObj)) {
                        dateString = dateRegex.exec(dateObj)[0];
                    } else if (dateObj instanceof Date) {
                        dateString = dateObj.getFullYear() + '-' + padTwo(dateObj.getMonth() + 1) + '-' + padTwo(dateObj.getDate());
                    }
                    if (dateString) {
                        return toUTCDate(new Date(dateString));
                    }
                    return null;
                }

                function processSelectedDate(dateObj) {
                    var date = toDateObject(dateObj);
                    if (date) {
                        element.pickadate('picker').set('select', date);
                    } else {
                        // Adding this because if a user tried to clear the date it wouldn't update the UI because undefined or null isn't a valid date
                        scope.pickADate = null;
                        element.pickadate('picker').set('clear');
                    }
                }
            }
        };
    }])
    .directive('pickATime', ["$timeout", function ($timeout) {
        return {
            restrict: 'A',
            scope: {
                pickATime: '=',
                pickATimeOptions: '='
            },
            link: function (scope, element) {

                var options = scope.pickATimeOptions || {};

                var userOnSet = options.onSet;
                function onSet(e) {

                    if (typeof userOnSet === 'function') {
                        userOnSet.apply(this, arguments);
                    }

                    if (scope.$$phase || scope.$root.$$phase) {
                        // we are coming from $watch or link setup
                        return;
                    }

                    $timeout(function () {
                        if (e.hasOwnProperty('clear')) {
                            scope.pickATime = null;
                        } else if (e.hasOwnProperty('select')) {
                            var totalMinutes = e.select;
                            var hours = Math.floor(totalMinutes / 60);
                            var minutes = totalMinutes % 60;
                            scope.pickATime = padTwo(hours) + ':' + padTwo(minutes);
                        }
                    }, 0);
                }

                var userOnOpen = options.onOpen;
                function onOpen(e) {

                    if (typeof userOnOpen === 'function') {
                        userOnOpen.apply(this, arguments);
                    }
                }

                var userOnClose = options.onClose;
                function onClose(e) {

                    if (typeof userOnClose === 'function') {
                        userOnClose.apply(this, arguments);
                    }

                    if (!window.cordova || !window.cordova.plugins || !window.cordova.plugins.Keyboard) {
                        return;
                    }

                    var keyboardShowCallback = function () {
                        window.cordova.plugins.Keyboard.close();
                        window.removeEventListener('native.keyboardshow', this);
                    };

                    window.addEventListener('native.keyboardshow', keyboardShowCallback);

                    setTimeout(function () {
                        window.removeEventListener('native.keyboardshow', keyboardShowCallback);
                    }, 500);
                }

                if (options.min && typeof (options.min) === 'string') {
                    if (options.min !== 'current') {
                        options.min = toTimeObject(options.min);
                    }
                } else {
                    options.min = '';
                }

                if (options.max && typeof (options.max) === 'string') {
                    if (options.max !== 'current') {
                        options.max = toTimeObject(options.max);
                    }
                } else {
                    options.max = '';
                }

                if (options.default && typeof (options.default) === 'string' && !scope.pickATime) {
                    if (options.default === 'current') {
                        scope.pickATime = toTimeString(new Date());
                        scope.$parent.updateStore(scope.pickATime);
                    } else {
                        scope.pickATime = toTimeString(toTimeObject(options.default));
                        scope.$parent.updateStore(scope.pickATime);
                    }
                }

                element.pickatime(angular.extend(options, {
                    onSet: onSet,
                    onOpen: onOpen,
                    onClose: onClose,
                    container: document.body
                }));

                if (scope.pickATime) {
                    processSelectedTime(scope.pickATime);
                }

                scope.$watch('pickATime', function (newValue, oldValue) {
                    if (newValue !== oldValue) {
                        processSelectedTime(newValue);
                        scope.$parent.updateStore(newValue);
                    }
                });

                function padTwo(number) {
                    if (number.toString().length === 1) return '0' + number;
                    return number.toString();
                }

                function toUTCDate(dateObj) {
                    if (!dateObj || !dateObj.getUTCDate) {
                        return null;
                    }
                    return new Date(dateObj.getUTCFullYear(), dateObj.getUTCMonth(), dateObj.getUTCDate(), dateObj.getUTCHours(), dateObj.getUTCMinutes(), 0, 0);
                }

                function toTimeString(dateObj) {
                    return padTwo(dateObj.getHours()) + ':' + padTwo(dateObj.getMinutes());
                }

                function toTimeObject(timeObj) {
                    var timeString = null;
                    var timeRegex = /\d{2}:\d{2}/;
                    if (typeof (timeObj) === 'string' && timeRegex.test(timeObj)) {
                        timeString = timeRegex.exec(timeObj)[0];
                    } else if (timeObj instanceof Date) {
                        timeString = padTwo(timeObj.getHours()) + ':' + padTwo(timeObj.getMinutes());
                    }
                    if (timeString) {
                        return toUTCDate(new Date('1970-01-01T' + timeString + ':00Z'));
                    }
                    return null;
                }

                function processSelectedTime(timeObj) {
                    var time = toTimeObject(timeObj);
                    if (time) {
                        element.pickatime('picker').set('select', time);
                    } else {
                        // Adding this because if a user tried to clear the date it wouldn't update the UI because undefined or null isn't a valid date
                        scope.pickATime = null;
                        element.pickatime('picker').set('clear');
                    }
                }
            }
        };
    }]);

/*!
 Taken and modified from: bower install angular-gettext
 Copyright (C) 2013-2015 by Ruben Vermeersch <ruben@rocketeer.be>
 MIT Licence
 */
/*
 Modifications by CommonTime:
 - Attempted translations of null, undefined or empty strings returns empty strings rather than undefined value
 - Supports a single language key "*" to allow translations to read without having to know the exact language code to access it (only suitable with one translation per file)
 */

angular.module('gettext', []);

angular.module('gettext').constant('gettext', function (str) {
    /*
     * Does nothing, simply returns the input string.
     *
     * This function serves as a marker for `grunt-angular-gettext` to know that
     * this string should be extracted for translations.
     */
    return str;
});

angular.module('gettext').factory('gettextCatalog', ["gettextPlurals", "$http", "$cacheFactory", "$interpolate", "$rootScope", function (gettextPlurals, $http, $cacheFactory, $interpolate, $rootScope) {
    var catalog;
    var noContext = '$$noContext';

    // IE8 returns UPPER CASE tags, even though the source is lower case.
    // This can causes the (key) string in the DOM to have a different case to
    // the string in the `po` files.
    // IE9, IE10 and IE11 reorders the attributes of tags.
    var test = '<span id="test" title="test" class="tested">test</span>';
    var isHTMLModified = (angular.element('<span>' + test + '</span>').html() !== test);

    var prefixDebug = function (string) {
        if (catalog.debug && catalog.currentLanguage !== catalog.baseLanguage) {
            return catalog.debugPrefix + string + catalog.debugSuffix;
        } else {
            return string;
        }
    };

    var addTranslatedMarkers = function (string) {
        if (catalog.showTranslatedMarkers) {
            return catalog.translatedMarkerPrefix + string + catalog.translatedMarkerSuffix;
        } else {
            return string;
        }
    };

    function isEmpty(string) {
        return (string === undefined)
            || (string === null)
            || (typeof (string) !== 'string')
            || (string.trim().length == 0);
    }

    function broadcastUpdated() {
        $rootScope.$broadcast('gettextLanguageChanged');
    }

    catalog = {
        debug: false,
        debugPrefix: '[MISSING]: ',
        debugSuffix: '',
        showTranslatedMarkers: false,
        translatedMarkerPrefix: '[',
        translatedMarkerSuffix: ']',
        strings: {},
        baseLanguage: 'en',
        currentLanguage: 'en',
        cache: $cacheFactory('strings'),

        setCurrentLanguage: function (lang) {
            this.currentLanguage = lang;
            broadcastUpdated();
        },

        getCurrentLanguage: function () {
            return this.currentLanguage;
        },

        setStrings: function (language, strings) {
            if (!this.strings[language]) {
                this.strings[language] = {};
            }

            for (var key in strings) {
                var val = strings[key];

                if (isHTMLModified) {
                    // Use the DOM engine to render any HTML in the key (#131).
                    key = angular.element('<span>' + key + '</span>').html();
                }

                if (angular.isString(val) || angular.isArray(val)) {
                    // No context, wrap it in $$noContext.
                    var obj = {};
                    obj[noContext] = val;
                    val = obj;
                }

                // Expand single strings for each context.
                for (var context in val) {
                    var str = val[context];
                    val[context] = angular.isArray(str) ? str : [str];
                }
                this.strings[language][key] = val;
            }

            broadcastUpdated();
        },

        getStringForm: function (string, n, context) {
            if (isEmpty(string)) return '';
            var stringTable = this.strings[this.currentLanguage] || this.strings['*'] || {};
            var contexts = stringTable[string] || {};
            var plurals = contexts[context || noContext] || [];
            return plurals[n];
        },

        getString: function (string, scope, context) {
            if (isEmpty(string)) return '';
            string = this.getStringForm(string, 0, context) || prefixDebug(string);
            string = scope ? $interpolate(string)(scope) : string;
            return addTranslatedMarkers(string);
        },

        getPlural: function (n, string, stringPlural, scope, context) {
            if (isEmpty(string)) return '';
            var form = gettextPlurals(this.currentLanguage, n);
            string = this.getStringForm(string, form, context) || prefixDebug(n === 1 ? string : stringPlural);
            if (scope) {
                scope.$count = n;
                string = $interpolate(string)(scope);
            }
            return addTranslatedMarkers(string);
        },

        loadRemote: function (url) {
            return $http({
                method: 'GET',
                url: url,
                cache: catalog.cache
            }).success(function (data) {
                for (var lang in data) {
                    catalog.setStrings(lang, data[lang]);
                }
            });
        }
    };

    return catalog;
}]);

angular.module('gettext').directive('translate', ["gettextCatalog", "$parse", "$animate", "$compile", "$window", function (gettextCatalog, $parse, $animate, $compile, $window) {
    // Trim polyfill for old browsers (instead of jQuery)
    // Based on AngularJS-v1.2.2 (angular.js#620)
    var trim = (function () {
        if (!String.prototype.trim) {
            return function (value) {
                return (typeof value === 'string') ? value.replace(/^\s*/, '').replace(/\s*$/, '') : value;
            };
        }
        return function (value) {
            return (typeof value === 'string') ? value.trim() : value;
        };
    })();

    function assert(condition, missing, found) {
        if (!condition) {
            throw new Error('You should add a ' + missing + ' attribute whenever you add a ' + found + ' attribute.');
        }
    }

    var msie = parseInt((/msie (\d+)/.exec(angular.lowercase($window.navigator.userAgent)) || [])[1], 10);

    return {
        restrict: 'AE',
        terminal: true,
        compile: function compile(element, attrs) {
            // Validate attributes
            assert(!attrs.translatePlural || attrs.translateN, 'translate-n', 'translate-plural');
            assert(!attrs.translateN || attrs.translatePlural, 'translate-plural', 'translate-n');

            var msgid = trim(element.html());
            var translatePlural = attrs.translatePlural;
            var translateContext = attrs.translateContext;

            if (msie <= 8) {
                // Workaround fix relating to angular adding a comment node to
                // anchors. angular/angular.js/#1949 / angular/angular.js/#2013
                if (msgid.slice(-13) === '<!--IE fix-->') {
                    msgid = msgid.slice(0, -13);
                }
            }

            return {
                post: function (scope, element, attrs) {
                    var countFn = $parse(attrs.translateN);
                    var pluralScope = null;

                    function update() {
                        // Fetch correct translated string.
                        var translated;
                        if (translatePlural) {
                            scope = pluralScope || (pluralScope = scope.$new());
                            scope.$count = countFn(scope);
                            translated = gettextCatalog.getPlural(scope.$count, msgid, translatePlural, null, translateContext);
                        } else {
                            translated = gettextCatalog.getString(msgid, null, translateContext);
                        }

                        // Swap in the translation
                        var newWrapper = angular.element('<span>' + translated + '</span>');
                        $compile(newWrapper.contents())(scope);
                        var oldContents = element.contents();
                        var newContents = newWrapper.contents();
                        $animate.enter(newContents, element);
                        $animate.leave(oldContents);
                    }

                    if (attrs.translateN) {
                        scope.$watch(attrs.translateN, update);
                    }

                    scope.$on('gettextLanguageChanged', update);

                    update();
                }
            };
        }
    };
}]);

angular.module('gettext').filter('translate', ["gettextCatalog", function (gettextCatalog) {
    function filter(input, context) {
        return gettextCatalog.getString(input, null, context);
    }

    filter.$stateful = true;
    return filter;
}]);

// Do not edit this file, it is autogenerated using genplurals.py!
angular.module("gettext").factory("gettextPlurals", function () {
    return function (langCode, n) {
        switch (langCode) {
            case "ay":  // Aymar
            case "bo":  // Tibetan
            case "cgg": // Chiga
            case "dz":  // Dzongkha
            case "fa":  // Persian
            case "id":  // Indonesian
            case "ja":  // Japanese
            case "jbo": // Lojban
            case "ka":  // Georgian
            case "kk":  // Kazakh
            case "km":  // Khmer
            case "ko":  // Korean
            case "ky":  // Kyrgyz
            case "lo":  // Lao
            case "ms":  // Malay
            case "my":  // Burmese
            case "sah": // Yakut
            case "su":  // Sundanese
            case "th":  // Thai
            case "tt":  // Tatar
            case "ug":  // Uyghur
            case "vi":  // Vietnamese
            case "wo":  // Wolof
            case "zh":  // Chinese
                // 1 form
                return 0;
            case "is":  // Icelandic
                // 2 forms
                return (n % 10 != 1 || n % 100 == 11) ? 1 : 0;
            case "jv":  // Javanese
                // 2 forms
                return n != 0 ? 1 : 0;
            case "mk":  // Macedonian
                // 2 forms
                return n == 1 || n % 10 == 1 ? 0 : 1;
            case "ach": // Acholi
            case "ak":  // Akan
            case "am":  // Amharic
            case "arn": // Mapudungun
            case "br":  // Breton
            case "fil": // Filipino
            case "fr":  // French
            case "gun": // Gun
            case "ln":  // Lingala
            case "mfe": // Mauritian Creole
            case "mg":  // Malagasy
            case "mi":  // Maori
            case "oc":  // Occitan
            case "pt_BR":  // Brazilian Portuguese
            case "tg":  // Tajik
            case "ti":  // Tigrinya
            case "tr":  // Turkish
            case "uz":  // Uzbek
            case "wa":  // Walloon
            case "zh":  // Chinese
                // 2 forms
                return n > 1 ? 1 : 0;
            case "lv":  // Latvian
                // 3 forms
                return (n % 10 == 1 && n % 100 != 11 ? 0 : n != 0 ? 1 : 2);
            case "lt":  // Lithuanian
                // 3 forms
                return (n % 10 == 1 && n % 100 != 11 ? 0 : n % 10 >= 2 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);
            case "be":  // Belarusian
            case "bs":  // Bosnian
            case "hr":  // Croatian
            case "ru":  // Russian
            case "sr":  // Serbian
            case "uk":  // Ukrainian
                // 3 forms
                return (n % 10 == 1 && n % 100 != 11 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);
            case "mnk": // Mandinka
                // 3 forms
                return (n == 0 ? 0 : n == 1 ? 1 : 2);
            case "ro":  // Romanian
                // 3 forms
                return (n == 1 ? 0 : (n == 0 || (n % 100 > 0 && n % 100 < 20)) ? 1 : 2);
            case "pl":  // Polish
                // 3 forms
                return (n == 1 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);
            case "cs":  // Czech
            case "sk":  // Slovak
                // 3 forms
                return (n == 1) ? 0 : (n >= 2 && n <= 4) ? 1 : 2;
            case "sl":  // Slovenian
                // 4 forms
                return (n % 100 == 1 ? 1 : n % 100 == 2 ? 2 : n % 100 == 3 || n % 100 == 4 ? 3 : 0);
            case "mt":  // Maltese
                // 4 forms
                return (n == 1 ? 0 : n == 0 || ( n % 100 > 1 && n % 100 < 11) ? 1 : (n % 100 > 10 && n % 100 < 20 ) ? 2 : 3);
            case "gd":  // Scottish Gaelic
                // 4 forms
                return (n == 1 || n == 11) ? 0 : (n == 2 || n == 12) ? 1 : (n > 2 && n < 20) ? 2 : 3;
            case "cy":  // Welsh
                // 4 forms
                return (n == 1) ? 0 : (n == 2) ? 1 : (n != 8 && n != 11) ? 2 : 3;
            case "kw":  // Cornish
                // 4 forms
                return (n == 1) ? 0 : (n == 2) ? 1 : (n == 3) ? 2 : 3;
            case "ga":  // Irish
                // 5 forms
                return n == 1 ? 0 : n == 2 ? 1 : n < 7 ? 2 : n < 11 ? 3 : 4;
            case "ar":  // Arabic
                // 6 forms
                return (n == 0 ? 0 : n == 1 ? 1 : n == 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5);
            default: // Everything else
                return n != 1 ? 1 : 0;
        }
    }
});

window.cti = {};
angular.module("app", ["app.core","app.templates"]);

angular.module("cti-directives", []);

angular
    .module("app.core", [
        "cti-directives",
        "ngSanitize",
        "ngAnimate",
        "ngRoute",
        "ngTouch",
        "LocalStorageModule",
        "vr.directives.slider",
        "tmh.dynamicLocale",
        "angularLoad",
        "angles",
        "toastr",
        "base64",
        "ngMessages",
        "angular-datepicker",
        "nya.bootstrap.select",
        "mobile-router",
        "ngElectron",
        "gettext"
    ])
    .config(["localStorageServiceProvider", "$compileProvider", "$logProvider", "$sceDelegateProvider", "$provide", function (localStorageServiceProvider, $compileProvider, $logProvider, $sceDelegateProvider, $provide) {

        // mad - need to put the defiantJS JSON object functions back into the window.JSON object \_()_/
        angular.extend(window.JSON, window.JSON2);
        delete window.JSON2;

        $logProvider.debugEnabled(false);
        localStorageServiceProvider.setPrefix("");
        $compileProvider.debugInfoEnabled(true);
        $compileProvider.aHrefSanitizationWhitelist(/^\s*(https?|ftp|mailto|tel|content|file|ms-appx|cdvfile):/);
        $compileProvider.imgSrcSanitizationWhitelist(/^\s*(https?|ftp|mailto|tel|content|file|ms-appx|cdvfile|data):/);
        angular.module("cti-directives").directive = $compileProvider.directive;
        $provide.decorator("$log", ["$delegate", "LoggingFactory", function ($delegate, LoggingFactory) {
            return LoggingFactory.process$log($delegate);
        }]);
        $sceDelegateProvider.resourceUrlWhitelist([
            "self",
            "cdvfile://**"
        ]);
    }])
    .run(["Router", "RouterConfig", "SchemaHelper", "SchemaService", "StoreFactory", "StoreProvider", "Auth", "$rootScope", "ActionFactory", "Platform", function (Router, RouterConfig, SchemaHelper, SchemaService, StoreFactory, StoreProvider, Auth, $rootScope, ActionFactory, Platform) {

        if (window.cti.api === undefined) {
            window.cti.api = {};
        }

        window.handleOpenUrlWhenReady = function (url) {
            setTimeout(function () {
                if (isOauthUrl(url)) {
                    var params = getParams(url);
                    if (params == null) {
                        return;
                    }
                    StoreFactory.set("oauth", params);
                    var oauthItem = SchemaHelper.getSchemaConfigItemsByItemType("onoauthdata");
                    if (oauthItem && oauthItem.length > 0) {
                        ActionFactory.triggerEvent("onoauthdata", oauthItem[0].actions, params);
                    }
                } else {
                    var initialData = getURLParameter(url, "initial_data");
                    var pageName = getURLParameter(url, "page");
                    var xcallbackData = getURLParameter(url, "xcallback");
                    if (initialData != null) {
                        initialData = decodeURIComponent(initialData);
                    }
                    var initialDataJsonObj = null;
                    if (initialData != null) {
                        initialDataJsonObj = createInitialDataJsonObj(initialData);
                    }
                    if (xcallbackData != null) {
                        xcallbackData = decodeURIComponent(xcallbackData);
                    }
                    var xCallbackJsonObj = null;
                    if (xcallbackData != null) {
                        xCallbackJsonObj = createXCallbackJsonObj(xcallbackData);
                    }
                    if (xCallbackJsonObj != null) {
                        if (initialDataJsonObj != null) {
                            mergeJsonObjects(initialDataJsonObj, xCallbackJsonObj);
                        } else {
                            initialDataJsonObj = xCallbackJsonObj;
                        }
                    }
                    if (pageName != null) {
                        pageName = decodeURIComponent(pageName);
                        var curr = Router.getCurrent();
                        if (curr !== undefined) {
                            if (initialDataJsonObj != null) {
                                StoreFactory.mergeInitialData(initialDataJsonObj);
                            }
                            Router.go("/" + pageName);
                        } else {
                            if (initialDataJsonObj != null) {
                                StoreProvider.set("initialData", initialDataJsonObj);
                            }
                            RouterConfig.set("startPage", "/" + pageName);
                        }
                    } else {
                        if (initialDataJsonObj != null) {
                            StoreProvider.set("initialData", initialDataJsonObj);
                        }
                    }
                    var remainingParams = getParams(url, ["initial_data", "page", "xcallback"]);
                    if (remainingParams) {
                        StoreFactory.set("query", remainingParams);
                        var queryparamsItem = SchemaHelper.getSchemaConfigItemsByItemType("onqueryparamsdata");
                        if (queryparamsItem && queryparamsItem.length > 0) {
                            ActionFactory.triggerEvent("onqueryparamsdata", queryparamsItem[0].actions, remainingParams);
                        }
                    }
                }
            }, 0);
        };

        function getURLParameter(url, paramName) {
            try {
                url = decodeURIComponent(url);
                var params = url.split(/\?(.+)?/)[1].split("&");
                for (var i = 0; i < params.length; i++) {
                    var param = params[i];
                    if (param.indexOf(paramName + "=") > -1) {
                        var data = param.split(/=(.+)?/);
                        return data[1];
                    }
                }
                return null;
            } catch (err) {
                return null;
            }
        }

        function getParams(url, exclusions) {
            try {
                var jsonObj;
                url = decodeURIComponent(url);
                var params = url.split(/\?(.+)?/)[1].split("&");
                for (var i = 0; i < params.length; i++) {
                    var paramsItem = params[i];
                    var key = paramsItem.split(/=(.+)?/)[0];
                    var value = paramsItem.split(/=(.+)?/)[1];
                    if (exclusions === undefined || !exclusions.includes(key)) {
                        if (jsonObj === undefined) {
                            jsonObj = {};
                        }
                        jsonObj[key] = value;
                    }
                }
                return jsonObj;
            } catch (err) {
                return null;
            }
        }

        function createInitialDataJsonObj(initialData) {
            // Create initial JSON Object
            var initialDataJsonObj = {};
            // Split on , to get a list of model location and value
            var modelDataListSplit = initialData.split(",");
            // Loop through list
            for (var i = 0; i < modelDataListSplit.length; i++) {
                // Get the current location value set
                var modelData = modelDataListSplit[i];
                // Seperate the location and value from set
                var parts = modelData.split(/=(.+)?/);
                // Seperate out the location to be able to get the levels
                var locationSplit = parts[0].split(".");
                // Get the value
                var value = parts[1];
                // Convert the value as required tro ensure it is the right type before adding it to the initialDataJsonObj
                value = convertValueAsRequired(value);
                // Add the current location and value set to the JSON Object to be returned
                addLocationToJsonObj(initialDataJsonObj, locationSplit, 0, value);
            }
            return initialDataJsonObj;
        }

        function createXCallbackJsonObj(xcallbackData) {
            // Create initial JSON Object
            var xcallbackJsonObj = {};
            var data = xcallbackJsonObj;
            data["xcallback"] = {};
            var xcallback = data.xcallback;
            // Split on , to get a list of model location and value
            var xcallbackDataSplit = xcallbackData.split(",");
            // Loop through list
            for (var i = 0; i < xcallbackDataSplit.length; i++) {
                // Get the current location value set
                var xcallbackDataSplitPart = xcallbackDataSplit[i];
                // Seperate the location and value from set
                var parts = xcallbackDataSplitPart.split(/=(.+)?/);
                xcallback[parts[0]] = parts[1];
            }
            return xcallbackJsonObj;
        }

        function mergeJsonObjects(obj1, obj2) {
            for (var p in obj2) {
                if (obj2.hasOwnProperty(p) && typeof obj1[p] !== "undefined") {
                    mergeJsonObjects(obj1[p], obj2[p]);
                } else {
                    obj1[p] = obj2[p];
                }
            }
        }

        function convertValueAsRequired(value) {
            if (isNumeric(value)) {
                value = parseInt(value);
            }
            return value;
        }

        function isNumeric(n) {
            return !isNaN(parseFloat(n)) && isFinite(n);
        }

        function addLocationToJsonObj(obj, subLevelNames, index, val) {
            // If we are not at the highest level of location, add the current level to the JSON Objects heirachy
            if (index < subLevelNames.length - 1) {
                // If this level has not been created in the JSON Object heirachy then create it and set the current JSON Object to the newly created level
                if (obj[subLevelNames[index]] == null) {
                    obj = obj[subLevelNames[index]] = {};
                } else { // It has been set allready so just set the new JSON Object to the current level
                    obj = obj[subLevelNames[index]];
                }
                // Use recursion to add the next location level to the JSON Object heirachy. This process will stop once we hit the top level location.
                addLocationToJsonObj(obj, subLevelNames, index + 1, val);
            } else { // Otherwise we are at the top so now just need to add the top level to the JSON Object along with setting it"s value
                // Set the value
                obj[subLevelNames[index]] = val;
            }
        }

        function isOauthUrl(url) {
            url = decodeURIComponent(url);
            var devicePatt = new RegExp("[a-z]\\:\\/\\/oauth\\?");
            var isDeviceOauth = devicePatt.test(url);
            var webPatt = new RegExp("\\/oauth\\?");
            var isWebOauth = webPatt.test(url);
            if (isDeviceOauth || isWebOauth) {
                return true;
            } else {
                return false;
            }
        }

        document.addEventListener("resume", function () {
            $rootScope.$broadcast("device-resume");
            var currentRoute = Router.getCurrent();
            if ((SchemaHelper.schema.settings !== undefined && SchemaHelper.schema.settings.auth === true) || (currentRoute !== undefined && currentRoute.auth === true)) {
                Auth.authenticate("Please re-authenticate").then(function () {
                    // Authentication was successful
                }).catch(function () {
                    Router.go("/error");
                });
            }
            var item = SchemaHelper.getSchemaConfigItemsByItemType("onappresume");
            if (item && item.length > 0) {
                ActionFactory.triggerEvent("onappresume", item[0].actions);
            }
        }, false);

        window.addEventListener("orientationchange", function () {
            var initialData = {
                "orientation": getOrientationAsString()
            };
            StoreFactory.set("env.orientation", initialData.orientation);
            var item = SchemaHelper.getSchemaConfigItemsByItemType("onorientationchange");
            if (item && item.length > 0) {
                ActionFactory.triggerEvent("onorientationchange", item[0].actions, initialData);
            }
        }, false);

        function getOrientationAsString() {
            if (window.orientation === undefined) {
                return "portrait";
            }
            switch (window.orientation) {
                case -90:
                case 90:
                    return "landscape";
                default:
                    return "portrait";
            }
        }

        StoreFactory.set("env.orientation", getOrientationAsString());

        if (window.mayflower !== undefined) {
            document.addEventListener("backbutton", function () {
                window.mayflower.moveTaskToBack();
            }, false);
        }

        // Device
        if (Platform.getType() === "device") {
            window.addEventListener("batterystatus", function (status) {
                fireBatteryEvent("onbatterychange", status);
            }, false);
            window.addEventListener("batterylow", function (status) {
                fireBatteryEvent("onbatterylow", status);
            }, false);
            window.addEventListener("batterycritical", function (status) {
                fireBatteryEvent("onbatterycritical", status);
            }, false);
        }
        // Device
        // Desktop
        if (Platform.getType() === "desktop") {
            navigator.getBattery().then(function (battery) {
                battery.addEventListener("chargingchange", function () {
                    fireBatteryEvent("onbatterychange", battery);
                });
                battery.addEventListener("levelchange", function () {
                    fireBatteryEvent("onbatterychange", battery);
                });
            });
        }
        // Desktop

        function fireBatteryEvent(event, batteryStatus) {
            var initialData = {};
            if (Platform.getType() === "device") {
                initialData = {
                    "batteryLevel": batteryStatus.level,
                    "isPluggedIn": batteryStatus.isPlugged
                };
            } else if (Platform.getType() === "desktop") {
                initialData = {
                    "batteryLevel": batteryStatus.level * 100,
                    "isPluggedIn": batteryStatus.charging
                };
            }
            var item = SchemaHelper.getSchemaConfigItemsByItemType(event);
            if (item && item.length > 0) {
                ActionFactory.triggerEvent(event, item[0].actions, initialData);
            }
        }

        // Device
        if (Platform.getType() === "device") {
            document.addEventListener("online", onOnline, false);
            document.addEventListener("offline", onOffline, false);
        }
        // Device
        // Desktop
        if (Platform.getType() === "desktop") {
            window.addEventListener("online", onOnline);
            window.addEventListener("offline", onOffline);
        }
        // Desktop

        function onOnline() {
            var initialData = {};
            initialData["connectionState"] = "online";
            if (Platform.getType() === "device") {
                initialData["connectionType"] = navigator.connection.type;
            } else {
                initialData["connectionType"] = null;
            }
            var item = SchemaHelper.getSchemaConfigItemsByItemType("onnetworkchange");
            if (item && item.length > 0) {
                ActionFactory.triggerEvent("onnetworkchange", item[0].actions, initialData);
            }
        }

        function onOffline() {
            var initialData = {
                "connectionState": "offline",
                "connectionType": null
            };
            var item = SchemaHelper.getSchemaConfigItemsByItemType("onnetworkchange");
            if (item && item.length > 0) {
                ActionFactory.triggerEvent("onnetworkchange", item[0].actions, initialData);
            }
        }

        window.cti.appReady = true;

        var event = new CustomEvent("app-core-loaded");
        document.dispatchEvent(event);
    }]);

window.cti = window.cti || {};
window.cti.appReady = false;
window.cti.calls = [];
window.cti.debug = {
    ngStats: function (opts) {
        if (!window.hasOwnProperty("showAngularStats")) {
            var s = document.createElement("script");
            s.src = "./assets/js/ng-stats.min.js";
            s.onload = function () {
                window.showAngularStats(opts);
            };
            document.head.appendChild(s);
        } else {
            window.showAngularStats(opts);
        }
    }
};

window.handleOpenURL = function (url) {
    if (window.cti.appReady) {
        window.handleOpenUrlWhenReady(url);
    } else {
        window.cti.calls.push({
            fn: "handleOpenUrlWhenReady",
            args: arguments
        });
    }
};
document.addEventListener("app-core-loaded", function () {

    if (!window.cti || !window.cti.calls) return;

    for (var i = 0; i < window.cti.calls.length; i++) {

        (function (call) {
            if (typeof (window[call.fn]) === "function") {
                window[call.fn].apply(window, call.args);
            }
        })(window.cti.calls[i]);
    }

    delete window.cti.calls;
});

// Listen to message from a child window
var eventMethod = window.addEventListener ? "addEventListener" : "attachEvent";
var eventer = window[eventMethod];
var messageEvent = eventMethod == "attachEvent" ? "onmessage" : "message";
eventer(messageEvent, function (e) {
    // Check if origin is proper
    if (e.origin !== window.location.origin) {
        return;
    }
    if (e.data && e.data !== "") {
        if (window.cti.appReady) {
            window.handleOpenUrlWhenReady(e.data);
        } else {
            window.cti.calls.push({
                fn: "handleOpenUrlWhenReady",
                args: arguments
            });
        }
    }
}, false);

angular.module("app.routes", [])
    .config(["$routeProvider", function ($routeProvider) {
        $routeProvider.when("/error", {
            templateUrl: "components/error/error.tpl.html"
        })
        .otherwise({
            redirectTo: "/"
        });
    }]);

angular
    .module("app.core")
    .directive("mdApp", ["$rootScope", "$compile", "$q", "$timeout", "$log", "SchemaService", "localStorageService", "StudioStorage", "SchemaHelper", "ActionFactory", "Router", "Plugin", "TranslationService", "$filter", "ForegroundBackground", function ($rootScope, $compile, $q, $timeout, $log, SchemaService, localStorageService, StudioStorage, SchemaHelper, ActionFactory, Router, Plugin, TranslationService, $filter, ForegroundBackground) {

        return {

            scope: {
                mdApp: "@",
                debug: "@",
                json: "="
            },
            restrict: "A",
            compile: function () {

                return {

                    pre: function ($scope, element) {

                        var executed = false;
                        var isDevice = (window.cordova !== false);
                        var initApp = function () {

                            SchemaService
                                // stop is the initApp method - changed to something misleading to make hacking the licensing mechanism harder
                                .stop($scope.mdApp)
                                .then(function () {
                                    return TranslationService.init();
                                })
                                .then(function () {

                                    Router.init();
                                    element.html("<div mobile-view></div>");
                                    $compile(element.contents())($scope);

                                    if ($rootScope.currentLanguage) {
                                        window.document.body.setAttribute("class", "language-" + $rootScope.currentLanguage);
                                    }

                                    document.getElementById("splash-screen").style.display = "none";
                                    window.document.querySelectorAll("body div.view-frame")[0].style.display = "block";

                                    $timeout(function () {
                                        if ($rootScope.grace) {
                                            $timeout(function () {
                                                // eslint-disable-next-line no-alert
                                                alert("This app will expire on " + $filter("date")($rootScope.grace, "short"));
                                            }, 500);
                                        }
                                    }, 1000);

                                    ForegroundBackground.init();

                                }).catch(function (error) {
                                    $log.error(error);
                                });

                        };

                        // Load a JSON schema file
                        if (isDevice === true) {

                            document.addEventListener("deviceready", function () {
                                initApp();
                                executed = true;
                            });

                            // Executed after 5 seconds anyway. Useful for when in browser device mode.
                            $timeout(function () {
                                if (executed === false) {
                                    initApp();
                                }
                            }, 5000);

                        } else {
                            initApp();
                        }

                    }
                };

            }
        };
    }]);

angular
    .module("app.core")
    .directive("mdContextProvider", function () {
       
        return {
            restrict: "A",
            scope: {
                item: "=mdContextProvider",
                items: "=mdContextItemCollection"
            },
            controller: ["$scope", function ($scope) {
                
                var ctrl = this;
                
                if (!$scope.contextState) {
                    
                    $scope.contextState = {};
                }
                
                ctrl.getContextItemData = function (keyName) {
        
                    var itemData = {
                        $item: $scope.item,
                        $state: $scope.contextState
                    };
                    
                    if ($scope.items) {
                        
                        var idx = $scope.items.indexOf($scope.item);
                        if (idx !== -1) {
                            
                            itemData.$index = idx;
                            itemData.$totalItems = $scope.items.length;
                        }
                    }
        
                    if (keyName) {
            
                        var returnValue = {};
                        returnValue[keyName] = itemData;
                        return returnValue;
            
                    } else {
            
                        return itemData;
                    }
                };
    
                ctrl.applyContextItemData = function (obj, keyName) {
        
                    angular.extend(obj, this.getContextItemData(keyName));
                };
                
                ctrl.isRepeaterContextProvider = function () {
                  
                    var data = ctrl.getContextItemData();
                    return data.hasOwnProperty("$index");
                };
            }]
        };
    });
angular
    .module("app.core")
    .controller("PageController", ["$scope", function ($scope) {
        
        var vm = this;
        vm.name = $scope.$parent.route.id;
        vm.meta = {
            valid: false
        };
    }]);

angular
    .module("app.core")
    .directive("pageInfo", function () {
        
        return {
            restrict: "A",
            scope: false,
            controller: ["$scope", function ($scope) {
                return {
                    name: $scope.$parent.route.id
                };
            }]
        };
    });

angular.module("app.core").directive("mdForm", function () {
    return {
        restrict: "A",
        require: "^form",
        link: function (scope, element, attrs, ctrl) {
            scope.$watch(function () {
                return ctrl.$valid;
            }, function (status) {
                scope.$parent.page.meta.valid = status;
            });
        }
    };
});

angular.module("app.core").directive("isolateForm", [function () {
    return {
        restrict: "A",
        require: "?form",
        link: function (scope, elm, attrs, ctrl) {
            if (!ctrl) {
                return;
            }

            // Do a copy of the controller
            var ctrlCopy = {};
            angular.copy(ctrl, ctrlCopy);

            // Get the parent of the form
            var parent = elm.parent().controller("form");
            // Remove parent link to the controller
            parent.$removeControl(ctrl);

            // Replace form controller with a "isolated form"
            var isolatedFormCtrl = {
                $setValidity: function (validationToken, isValid, control) {
                    ctrlCopy.$setValidity(validationToken, isValid, control);
                    parent.$setValidity(validationToken, true, ctrl);
                },
                $setDirty: function () {
                    elm.removeClass("ng-pristine").addClass("ng-dirty");
                    ctrl.$dirty = true;
                    ctrl.$pristine = false;
                }
            };
            angular.extend(ctrl, isolatedFormCtrl);
        }
    };
}]);

angular
    .module("app.core")
    .directive("mdContent", ["TranslationService", "AssetFactory", function (TranslationService, AssetFactory) {
        
        return {
            restrict: "E",
            compile: function ($element, $attrs) {
                
                var content = null;
                
                if ($attrs.itemType === "markdown") {
                    
                    var markdown = $element.text();
                    markdown = TranslationService.translate(markdown);
    
                    var markdownConverter = new window.Showdown.converter({});
                    content = markdownConverter.makeHtml(markdown) || "";
                    
                } else {
                    
                    var markup = $element.html();
                    markup = TranslationService.translate(markup);
                    content = markup || "";
                }
                
                content = AssetFactory.rewriteAssetPaths(content);
                
                var cssClasses = ("content-block " + ($attrs.classes || "")).trim();
                var html = "<div class=\"" + cssClasses + "\">" + content + "</div>";
                
                $element.html(html);
            }
        };
    }]);
angular
    .module("app.core")
    .directive("starRating", function () {

        return {
            restrict: "A",
            scope: {
                ratingValue: "=",
                max: "=",
                disabled: "=",
                actions: "=",
                onRatingSelected: "&"
            },
            template: [
                "<ul class=\"rating\">",
                "   <li ng-repeat=\"star in stars track by $index\" " +
                "       ng-class=\"star\" " +
                "       ng-click=\"toggle($index)\" ",
                "       md-actions=\"{{actions}}\">",
                "       <i class=\"fa fa-star\" ng-class=\"{'star-disabled': (disabled) }\"></i>",
                "   </li>",
                "</ul>"
            ].join(""),
            link: function ($scope) {

                function updateStars() {

                    $scope.stars = [];
                    for (var i = 0; i < $scope.max; i++) {
                        $scope.stars.push({
                            filled: i < $scope.ratingValue
                        });
                    }
                }

                $scope.toggle = function (index) {

                    if (!$scope.disabled) {

                        $scope.ratingValue = index + 1;
                        $scope.onRatingSelected({
                            rating: index + 1
                        });
                    }
                };

                $scope.$watch("ratingValue", function () {

                    updateStars();
                });
            }
        };
    });

angular.module("app.core").directive("takePhoto", ["$log", "StoreFactory", "Camera", function ($log, StoreFactory, Camera) {
    return {
        restrict: "E",
        require: "ngModel",
        scope: {
            "imageUrl": "=",
            "source": "@",
            "quality": "=",
            "disabled:": "="
        },
        template: [
            "<div class=\"photo-control-container\">",
            "   <button class=\"btn btn-primary btn-lg\">",
            "       <span ng-if=\"sourceIndex == 1\">",
            "           <span class=\"fa fa-camera\"></span> {{ 'Take Photo' | translate }}",
            "       </span>",
            "       <span ng-if=\"sourceIndex == 2\">",
            "           <span class=\"fa fa-picture-o\"></span> {{ 'Choose Photo' | translate }}}",
            "       </span>",
            "   </button>",
            "</div>"
        ].join(""),
        link: function (scope, element) {

            scope.imageData = null;
            scope.quality = (scope.quality === undefined) ? 75 : scope.quality;

            switch (scope.source) {
                case "gallery":
                    scope.sourceIndex = 2;
                    break;
                case "camera":
                default:
                    scope.sourceIndex = 1;
            }

            scope.destination = 1;
            scope.encodingType = 1;

            element.find("button").on("click", function () {
                if (scope.source === 2) {
                    Camera.selectPhoto().then(function (imageURI) {
                        scope.loadThumbnail(imageURI);
                    });
                } else {
                    Camera.takePhoto(scope.quality).then(function (imageURI) {
                        scope.loadThumbnail(imageURI);
                    });
                }
            });
            scope.loadThumbnail = function (imageURI) {
                scope.$parent.$parent.updateStore(imageURI);
                scope.imageData = imageURI;
            };
            scope.removePhoto = function () {
                scope.imageData = null;
                scope.$parent.$parent.updateStore(undefined);
            };
            var deviceReady = function () {
                if (typeof scope.imageUrl != "undefined") {
                    scope.loadThumbnail(scope.imageUrl);
                }
            };
            document.addEventListener("deviceready", deviceReady);
            window.parent.document.addEventListener("deviceready", deviceReady);
        }
    };
}]);

angular.module("app.core").directive("takeBarcode", ["$log", "Plugin", function ($log, Plugin) {
    return {
        restrict: "E",
        require: "ngModel",
        replace: true,
        templateUrl: "components/mdDynamicForm/fields/md-barcode.tpl.html",
        link: function (scope, element, attrs, ctrl) {
            scope.codeType = attrs.codeType;
            element.on("click", function () {
                var barcodeScanner = Plugin.getSource("barcodeScanner");
                if (barcodeScanner !== false) {
                    barcodeScanner.scan(function (result) {
                        var res = (typeof result == "object") ? result.text : result;
                        scope.$parent.$parent.updateStore(res);
                        ctrl.$setViewValue(res);
                    }, function (error) {
                        ctrl.$setValidity("error", false);
                        $log.error(error);
                    });
                }
            });
            scope.clear = function () {
                scope.$parent.$parent.updateStore("");
                ctrl.$setViewValue("");
            };
        }
    };
}]);

angular.module("app.core").directive("mdSignature", function () {
    return {
        restrict: "A",
        disabled: "=",
        require: "ngModel",
        link: function ($scope, $element, $attrs, $ctrl) {
            var $canvas = $element[0];
            var signaturePad = new window.SignaturePad($canvas);
            signaturePad.onEnd = function () {
                var value = signaturePad.toDataURL();
                $ctrl.$setViewValue(value);
            };
            var hidefContext = $canvas.getContext("2d");
            if (window.devicePixelRatio) {
                var hidefCanvasWidth = $canvas.width;
                var hidefCanvasHeight = $canvas.height;
                var hidefCanvasCssWidth = hidefCanvasWidth;
                var hidefCanvasCssHeight = hidefCanvasHeight;
                $canvas.setAttribute("width", (hidefCanvasWidth * window.devicePixelRatio));
                $canvas.setAttribute("height", (hidefCanvasHeight * window.devicePixelRatio));
                $element.css("width", (hidefCanvasCssWidth) + "px");
                $element.css("height", (hidefCanvasCssHeight) + "px");
                hidefContext.scale(window.devicePixelRatio, window.devicePixelRatio);
            }
            if ($scope.inputModel != undefined && $scope.inputModel != "") {
                signaturePad.fromDataURL($scope.inputModel);
            }
            $scope.$watch("inputModel", function (newValue, oldValue) {
                if (newValue == undefined) {
                    signaturePad.clear();
                } else if (newValue != oldValue) {
                    signaturePad.fromDataURL(newValue);
                }
            });
            $scope.$watch("disabled", function () {
                if ($scope.disabled) {
                    signaturePad.off();
                } else {
                    signaturePad.on();
                }
            });
        }
    };
});

angular.module("app.core").directive("mdSelect", ["$rootScope", "StoreFactory", "$parse", "$filter", "$timeout", "OptionFactory", "TranslationService", function ($rootScope, StoreFactory, $parse, $filter, $timeout, OptionFactory, TranslationService) {
    return {
        restrict: "A",
        require: "ngModel",
        link: function ($scope, element, attrs, ctrl) {
            var $select = null;
            // It is possible to populate from localStorage
            var store = OptionFactory.get($scope.pageName + "." + $scope.name);
            $scope.options = (store === undefined) ? $scope.$parent.options : store;

            angular.forEach($scope.options, function (option) {
                option.label = TranslationService.translate(option.label);
                if (option.hasOwnProperty("group")) {
                    option.group = TranslationService.translate(option.group);
                }
            });

            if ($scope.$parent.searchable === true) {
                $select = $(element);
                $timeout(function () {
                    $select.selectpicker();
                    $select.change(function () {
                        ctrl.$setViewValue($select.val());
                    });
                });
            }

            if (typeof $scope.$parent.optionsfilter != "undefined") {
                // Used to validate the selection in case the options have changed and a currently selection isn"t available
                $scope.selectionValid = function () {
                    var value = $scope.$parent.inputModel;
                    var filter = false;
                    angular.forEach($scope.$parent.optionsfilter, function (value, key) {
                        var val = StoreFactory.evaluate(value);
                        if (typeof val != "undefined") {
                            if (filter === false) {
                                filter = {};
                            }
                            filter[key] = val;
                        }
                    });
                    var valid = false;
                    if (filter !== false) {
                        var options = $filter("filter")($scope.$parent.options, filter);
                        angular.forEach(options, function (option) {
                            if (option.value == value) {
                                valid = true;
                            }
                        });
                    }
                    if (valid === false) {
                        ctrl.$setViewValue("");
                        if ($select !== null) {
                            $timeout(function () {
                                $select.selectpicker("deselectAll").selectpicker("refresh");
                            });
                        }
                    }
                };
                // Work out an filters that need to be applied to options
                $scope.calcFilter = function () {
                    if (typeof $scope.optionsfilter != "undefined") {
                        $scope.filterString = {};
                        angular.forEach($scope.optionsfilter, function (value, key) {
                            var val = StoreFactory.evaluate(value);
                            if (typeof val != "undefined") {
                                $scope.filterString[key] = val;
                            }
                        });
                        if ($select !== null) {
                            $timeout(function () {
                                $select.selectpicker("refresh");
                            });
                        }
                    }
                };
                $rootScope.$on("StoreChanged", function () {
                    $scope.calcFilter();
                    $scope.selectionValid();
                });
                $scope.calcFilter();
                $scope.selectionValid();
            }
        }
    };
}]);

angular.module("app.core").directive("mdCheckbox", ["OptionFactory", function (OptionFactory) {
    return {
        restrict: "E",
        replace: true,
        scope: {
            "required": "=",
            "options": "=",
            "disabled": "=",
            "name": "=",
            "model": "=",
            "iconSelected": "@",
            "iconUnselected": "@",
            "actions": "@",
            "validators": "@"
        },
        templateUrl: "components/mdDynamicForm/fields/md-checkbox.tpl.html",
        require: "^form",
        link: function ($scope, $element, $attrs, FormController) {
            // It is possible to populate from localStorage
            var store = OptionFactory.get($scope.$parent.$parent.pageName + "." + $scope.$parent.name);
            $scope.options = (store === undefined) ? $scope.$parent.options : store;
            var isValid = function () {
                var valid = true;
                if ($scope.required === true || $scope.required == "true") {
                    valid = false;
                    angular.forEach($scope.model, function (option) {
                        if (option === true) {
                            valid = true;
                        }
                    });
                }
                FormController[$scope.name].$setValidity("validationValid", valid);
            };
            isValid();
            $scope.makeSelection = function (id) {
                if (!$scope.disabled) {
                    if ($scope.model == undefined) {
                        $scope.model = {};
                    }
                    $scope.model[id] = !$scope.model[id];
                    isValid();
                }
            };
            $scope.getClasses = function (option) {
                var classes = {};
                if (option["icon-selected"] !== undefined) {
                    classes[option["icon-selected"]] = ($scope.model != undefined && $scope.model[option.id] == true);
                } else {
                    classes[$scope.iconSelected] = ($scope.model != undefined && $scope.model[option.id] == true);
                }
                if (option["icon-unselected"] !== undefined) {
                    classes[option["icon-unselected"]] = ($scope.model === undefined || $scope.model[option.id] != true);
                } else {
                    classes[$scope.iconUnselected] = ($scope.model == undefined || $scope.model[option.id] != true);
                }
                // If we have the same icons for selected and unselected, always set it to true
                if (Object.keys(classes).length === 1) {
                    var key = (classes[$scope.iconUnselected] !== undefined) ? $scope.iconUnselected : option["icon-unselected"];
                    classes[key] = true;
                }
                return classes;
            };
        }
    };
}]);

angular.module("app.core").directive("mdRadio", ["OptionFactory", function (OptionFactory) {
    return {
        restrict: "E",
        replace: true,
        scope: {
            "required": "=",
            "options": "=",
            "disabled": "=",
            "name": "=",
            "model": "=",
            "iconSelected": "@",
            "iconUnselected": "@",
            "validators": "@",
            "actions": "@"
        },
        templateUrl: "components/mdDynamicForm/fields/md-radio.tpl.html",
        require: "^form",
        link: function ($scope, $element, $attrs, FormController) {
            // It is possible to populate from localStorage
            var store = OptionFactory.get($scope.$parent.$parent.pageName + "." + $scope.$parent.name);
            $scope.options = (store === undefined) ? $scope.$parent.options : store;
            var isValid = function () {
                var valid = true;
                if ($scope.required === true || $scope.required == "true") {
                    valid = (typeof $scope.model != "undefined");
                }
                FormController[$scope.name].$setValidity("validationValid", valid);
            };
            isValid();
            $scope.makeSelection = function (value) {
                if (!$scope.disabled) {
                    $scope.model = value;
                    isValid();
                }
            };
            $scope.getClasses = function (option) {
                var classes = {};

                if (option["icon-selected"] !== undefined) {
                    classes[option["icon-selected"]] = ($scope.model != undefined && $scope.model == option.value);
                } else {
                    classes[$scope.iconSelected] = ($scope.model != undefined && $scope.model == option.value);
                }
                if (option["icon-unselected"] !== undefined) {
                    classes[option["icon-unselected"]] = ($scope.model == undefined || $scope.model != option.value);
                } else {
                    classes[$scope.iconUnselected] = ($scope.model == undefined || $scope.model != option.value);
                }

                // If we have the same icons for selected and unselected, always set it to true
                if (Object.keys(classes).length === 1) {
                    var key = (classes[$scope.iconUnselected] !== undefined) ? $scope.iconUnselected : option["icon-unselected"];
                    classes[key] = true;
                }
                return classes;
            };
        }
    };
}]);

angular.module("app.core").directive("validation", ["ValidationFactory", "$log", function (ValidationFactory, $log) {
    return {
        restrict: "A",
        require: "ngModel",
        link: function ($scope, elem, attrs, ctrl) {
            // Check to see if validation has been requested for this field
            var validationObject = false;
            if (typeof attrs.validation != "undefined" && attrs.validation != "") {
                validationObject = angular.fromJson(attrs.validation);
            }
            if (validationObject !== false) {
                angular.forEach(validationObject, function (validation) {
                    if (validation.name != undefined && validation.type != undefined) {
                        var validationFunction = null;
                        if (validation.type != "custom") {
                            validationFunction = function (modelValue, viewValue) {
                                return ValidationFactory.isValid(viewValue, validation, $scope.pageName, attrs.name);
                            };
                        } else {
                            try {
                                var code = "validationFunction = " + validation.content;
                                eval(code);
                            } catch (e) {
                                $log.error("Could not eval validation function code.");
                            }
                        }
                        if (validationFunction !== null) {
                            ctrl.$validators[validation.name] = validationFunction;
                        }
                    }
                });
            }
            // If customExpression has been specified then we need to re-validate when the formStore changes
            // This is because the validation state of this field might depend on the value of another
            $scope.$on("StoreChanged", function () {
                angular.forEach(validationObject, function (validation) {
                    if (validation.name != undefined && validation.type != "regex") {
                        ctrl.$setValidity(validation.name, ctrl.$validators[validation.name](null, ctrl.$viewValue));
                    }
                });
            });
        }
    };
}]);

angular.module("app.core").directive("validEmail", function () {
    return {
        restrict: "A",
        require: "ngModel",
        link: function (scope, elem, attrs, ctrl) {

            var valid = function (value) {
                ctrl.$setValidity("email", /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/.test(value));
                return value;
            };

            ctrl.$formatters.push(valid);
            ctrl.$parsers.push(valid);
        }
    };
});

angular
    .module("app.core")
    .directive("mdGroup", ["$parse", "StoreFactory", function ($parse, StoreFactory) {
        
        return {
            scope: {
                name: "@",
                repeat: "=",
                classes: "@"
            },
            restrict: "E",
            replace: false,
            transclude: true,
            template: [
                "<div id=\"{{name}}\" class=\"{{ classes }}\">",
                "   <ng-transclude class=\"group-contents\"></ng-transclude>",
                "   <div ng-if=\"repeat\" class=\"group-controls\">",
                "       <button class=\"btn btn-success\" ng-disabled=\"form.$invalid\" ng-click=\"addItem()\">",
                "           <span class=\"icon icon-plus-circle2\"></span> {{ 'Add' | translate }}",
                "       </button>",
                "   </div>",
                "</div>"
            ].join(""),
            require: ["^pageInfo", "?form", "?^mdContextProvider"],
            link: function ($scope, $element, $attrs, $ctrls) {
                
                var pageInfoCtrl = $ctrls[0];
                var formCtrl = $ctrls[1];
                var mdContextProviderCtrl = $ctrls[2];
                
                var contextDataItem = null;
                var storeLocation = null;
                var pageName = pageInfoCtrl.name;
                
                if (mdContextProviderCtrl) {
                    contextDataItem = mdContextProviderCtrl.getContextItemData("$data");
                }
                
                if ($scope.repeat && formCtrl) {
                    
                    $scope.form = formCtrl;
                    storeLocation = "repeater." + pageName + "." + $scope.name;
                }
                
                $scope.addItem = function () {
                    
                    if (!$scope.repeat) return;
                    
                    var groupData = {};
                    
                    // Find all questions inside this group
                    var questions = $element.find("md-question");
                    
                    angular.forEach(questions, function (question) {
                        
                        // obtain the data model location of the question
                        var name = angular.element(question).attr("name");
                        var originalName = angular.element(question).attr("originalname");
                        var modelLocationOverride = angular.element(question).attr("modellocationoverride");
                        var storeKey = modelLocationOverride || originalName || name;
                        
                        var modelLocation = (contextDataItem !== null)
                            ? "$data.$item." + storeKey
                            : "$store.pages." + pageName + "." + storeKey;
                        
                        var modelValue = StoreFactory.getForElement(modelLocation, $element);
                    
                        // set the value in the new object
                        var getter = $parse(storeKey);
                        getter.assign(groupData, modelValue);
                        
                        // clear the value for the question
                        StoreFactory.setForElement(modelLocation, undefined, $element);
                    });
                    
                    if (storeLocation !== null) {
                        
                        // add the new data to the store
                        StoreFactory.push(storeLocation, groupData);
                    }
                };
            }
        };
    }]);

angular
    .module("app.core")
    .directive("mdList", ["$rootScope", "$interpolate", "$parse", "$filter", "$routeParams", "StoreFactory", "ActionFactory", "ListFactory", function ($rootScope, $interpolate, $parse, $filter, $routeParams, StoreFactory, ActionFactory, ListFactory) {
        
        return {
            scope: {
                name: "@",
                actions: "="
            },
            restrict: "E",
            replace: false,
            transclude: true,
            templateUrl: "components/area/mdList/mdList.tpl.html",
            require: ["?^mdContextProvider", "?^scrollableItem", "^pageInfo"],
            link: function ($scope, $element, $attrs, $ctrls) {
                
                var mdContextProviderCtrl = $ctrls[0];
                var scrollableItemCtrl = $ctrls[1];
                var pageInfoCtrl = $ctrls[2];
    
                var pageName = pageInfoCtrl.name;
                var listName = $scope.name;
                
                var listDataInitialized = false;
                var listDataFiltered = false;
                var storeUpdateDebounce;
                
                // data
                var staticData = attrEquals("datasource", "static");
                var dynamicData = attrEquals("datasource", "dynamic");
                var autoScroll = attrEquals("autoscroll", "true");
                var data = JSON.parse($attrs.data || "[]");
                var model = $attrs.model;
                
                // searching / filtering
                var search = !attrEquals("search", "");
                var internalSearch = search && attrEquals("search", "internal");
                var allowExternalSearch = search && attrEquals("search", "external");
                var searchOnType = internalSearch && attrEquals("searchmode", "type");
                var searchDebounce = (searchOnType && parseInt($attrs.searchdebounce)) || 0;
                var searchOnButton = internalSearch && attrEquals("searchmode", "button");
                var customSearch = internalSearch && attrEquals("searchwithin", "custom");
                var searchFunctionJs = (customSearch && $attrs.searchfunction) || "";
                var searchFunctionExternalJs = (allowExternalSearch && $attrs.searchfunctionexternal) || "";
                var customSearchFunction = null;
                var criticalSearchError = false;
                
                // ordering
                var order = attrEquals("order", "true");
                var orderProperty = order ? ($attrs.orderproperty || "") : undefined;
                var orderReverse = order && attrEquals("orderdirection", "desc");
                
                // pagination
                var pagination = attrEquals("pagination", "true");
                var paginationItemsPerPage = (pagination && parseInt($attrs.paginationitemsperpage)) || undefined;
                var paginationShowAbove = pagination && attrEquals("paginationabove", "true");
                var paginationShowBelow = pagination && attrEquals("paginationbelow", "true");
                var paginationShowOnePage = pagination && attrEquals("paginationshowonepage", "true");
                var paginationPagesToDisplay = (pagination && parseInt($attrs.paginationpagestodisplay)) || undefined;
                var showFirstLast = pagination && attrEquals("paginationfirstlast", "true");
                var showPrevNext = pagination && attrEquals("paginationprevnext", "true");
                
                // actions
                var actions = angular.copy($scope.actions);
    
                // get the important stuff onto the scope
                $scope.search = {
                    enabled: search,
                    internal: internalSearch,
                    allowExternal: allowExternalSearch,
                    debounce: searchDebounce,
                    showButton: searchOnButton,
                    buttonIcon: $attrs.searchbuttonicon,
                    buttonLabel: $attrs.searchbuttonlabel,
                    inputValue: "",
                    term: "",
                    external: null
                };
    
                $scope.order = {
                    property: orderProperty,
                    reverse: orderReverse
                };
    
                $scope.pagination = {
                    enabled: pagination,
                    showAbove: paginationShowAbove,
                    showBelow: paginationShowBelow,
                    showFirstLast: showFirstLast,
                    showPrevNext: showPrevNext,
                    firstPageIcon: $attrs.paginationfirsticon,
                    prevPageIcon: $attrs.paginationprevicon,
                    nextPageIcon: $attrs.paginationnexticon,
                    lastPageIcon: $attrs.paginationlasticon,
                    firstPageLabel: $attrs.paginationfirstlabel,
                    prevPageLabel: $attrs.paginationprevlabel,
                    nextPageLabel: $attrs.paginationnextlabel,
                    lastPageLabel: $attrs.paginationlastlabel,
                    limit: paginationItemsPerPage,
                    currentPage: 1,
                    start: 0
                };
                
                prepareListState();
                
                $scope.classes = $attrs.classes;
                $scope.listItemClasses = $attrs.listItemClasses;
                
                if ($attrs.theme === "bootstrap") {
                    
                    $scope.classes = (($scope.classes || "") + " list-group").trim();
                    $scope.listItemClasses = (($scope.listItemClasses || "") + " list-group-item").trim();
                }
                
                $scope.itemTrackFn = function (item, index) {
                    
                    return JSON.stringify(item) + "_" + index + "_" + $scope.listData.length;
                };
                
                $scope.listOrder = function (item) {
                    
                    if ($scope.order.property === undefined) {
                        return "";
                    }
                    
                    if ($scope.order.property === "") {
                        
                        return item;
                        
                    } else {
    
                        return $parse($scope.order.property)(item);
                    }
                };
                
                $scope.filter = function (item) {
                    
                    if (criticalSearchError) return false;
                    
                    if (!search) return true;
                    
                    if (internalSearch) {
                        
                        if (!$scope.search.term) return true;
                        
                        if (customSearch) {
                            
                            if (customSearchFunction === null) {
                                
                                if (searchFunctionJs) {
                                    eval("customSearchFunction = " + searchFunctionJs);
                                } else {
                                    criticalSearchError = true;
                                    throw "List \"" + $scope.name + "\" on page \"" + pageInfoCtrl.name + "\" does not have a custom search function defined for built-in search.";
                                }
                            }
                            
                            if (typeof (customSearchFunction) === "function") {
                                return customSearchFunction($scope.search.term || "", item);
                            }
                            
                        } else {
                            
                            return $filter("filter")([item], $scope.search.term).length > 0;
                        }
                        
                    } else if (allowExternalSearch && $scope.search.external) {
                        
                        if ($scope.search.external.simple) {
                            
                            return $filter("filter")([item], $scope.search.external.criteria).length > 0;
                            
                        } else {
                            
                            if (customSearchFunction === null) {
                                
                                if (searchFunctionExternalJs) {
                                    eval("customSearchFunction = " + searchFunctionExternalJs);
                                } else {
                                    criticalSearchError = true;
                                    throw "List \"" + $scope.name + "\" on page \"" + pageInfoCtrl.name + "\" does not have a custom search function defined for search actions.";
                                }
                            }
                            
                            if (typeof (customSearchFunction) === "function") {
                                return customSearchFunction($scope.search.external.criteria || {}, item);
                            }
                        }
                    }
                    
                    return true;
                };
                
                $scope.performSearch = function (force) {
                    
                    if (!internalSearch) return;
                    
                    if (!searchOnButton && force !== true) return;
                    
                    ListFactory.setListSearchState(pageName, listName, "internal", $scope.search.inputValue, true);
                };
                
                $scope.goToPage = function (page) {
                    
                    if (!pagination) return;
    
                    ListFactory.setListPaginationState(pageName, listName, page);
                };
                
                $scope.itemCssClass = function (item, index) {
                    
                    if (!$scope.listItemClasses) return "";
                    
                    if ($scope.listItemClasses.indexOf("\\{") === -1) return $scope.listItemClasses;
                    
                    var value = $scope.listItemClasses.replace(/\\{/g, "{");
                    
                    var context = {
                        $data: {
                            $item: item,
                            $index: index,
                            $items: $scope.listData
                        }
                    };
                    return $interpolate(value)(context);
                };
                
                $scope.$watch("filteredListData.length", function (newValue, oldValue) {
                    
                    if (!listDataFiltered || newValue !== oldValue) {
                        
                        $scope.pagination.totalPages = ListFactory.calculateNumberOfPages(newValue, $scope.pagination.limit);
                        var newCurrentPage = Math.min($scope.pagination.currentPage, $scope.pagination.totalPages);
                        recalculatePagination(newCurrentPage, true);
    
                        listDataFiltered = true;
                    }
                });
                
                if (searchOnType) {
                    
                    $scope.$watch("search.inputValue", function () {
                        
                        $scope.performSearch(true);
                    });
                }
                
                if (autoScroll) {
    
                    scrollToBottom();
                }
                
                if (staticData === true && data) {
                    
                    bindData(data);
                    
                } else if (dynamicData === true && model) {
                    
                    var actionTimeout = null;
                    var scrollTimeout = null;
                    
                    var oldListData = null;
                    
                    function bindFromModel() {
                        
                        var listData = StoreFactory.getForElement(model, $element);
                        if (listData === undefined) return;
                        
                        if (!listDataInitialized || !angular.equals(listData, oldListData)) {
                            
                            clearTimeout(actionTimeout);
                            clearTimeout(scrollTimeout);
                            
                            if (listDataInitialized) {
                                
                                actionTimeout = setTimeout(function () {
                                    ActionFactory.triggerEvent("data-changed", actions, {
                                        oldItems: oldListData,
                                        newItems: listData
                                    });
                                }, 500);
                            }
                            
                            if (autoScroll) {
    
                                scrollToBottom();
                            }
                            
                            bindData(listData);
                            
                            oldListData = angular.copy(listData);
                        }
                    }
                    
                    bindFromModel();
                    $scope.$on("StoreChanged", bindFromModel);
                }
                
                function scrollToBottom() {
    
                    if (scrollableItemCtrl) {
                        
                        scrollTimeout = setTimeout(function () {
                            scrollableItemCtrl.scrollToBottom();
                        }, 0);
                        
                    } else {
    
                        scrollTimeout = setTimeout(function () {
                            var innerScrollable = $element[0].querySelector(".main.scrollable");
                            innerScrollable.scrollTop = innerScrollable.scrollHeight;
                        }, 0);
                    }
                }
                
                function attrEquals(attrName, value) {
                    
                    return ($attrs[attrName] || "").toLowerCase() === value;
                }
                
                function prepareListState() {
    
                    var inputValue = "";
                    var searchTerm = "";
                    var externalSearchCriteria = null;
                    var currentOrderProperty = orderProperty;
                    var currentOrderReverse = orderReverse;
                    var currentPage = 1;
                    
                    var storedState = getStateFromStore();
                    if (storedState) {
        
                        if (search && storedState.search) {
            
                            if (internalSearch && storedState.search.mode === "internal") {
                
                                inputValue = storedState.search.criteria;
                                searchTerm = storedState.search.criteria;
                
                            } else if (allowExternalSearch && storedState.search.mode) {
                
                                externalSearchCriteria = {
                                    simple: storedState.search.mode === "simple",
                                    criteria: storedState.search.criteria
                                };
                            }
                        }
        
                        if (storedState.order && storedState.order.property) {
    
                            currentOrderProperty = storedState.order.property;
                            currentOrderReverse = storedState.order.direction === "desc";
                        }
        
                        if (pagination && storedState.pagination) {
            
                            currentPage = (storedState && pagination && storedState.pagination.currentPage);
                        }
                        
                        angular.extend($scope.search, {
                            inputValue: inputValue,
                            term: searchTerm,
                            external: externalSearchCriteria
                        });
    
                        angular.extend($scope.order, {
                            property: currentOrderProperty,
                            reverse: currentOrderReverse
                        });
                    }
    
                    recalculatePagination(currentPage, true);
                }
                
                function bindData(listData) {
                    
                    if (!angular.isArray(listData)) listData = [];
                    
                    $scope.listData = listData;
                    
                    if (pagination) {
                        
                        $scope.pagination.totalPages = ListFactory.calculateNumberOfPages(listData.length, $scope.pagination.limit);
                        recalculatePagination($scope.pagination.currentPage || 1, true);
                    }
                    
                    listDataInitialized = true;
                    
                    setStateInStore();
                }
                
                function recalculatePagination(newPageNumber, force) {
                    
                    if (!pagination) {
    
                        $scope.pagination.currentPage = 1;
                        $scope.pagination.start = 0;
                        $scope.pagination.limit = undefined;
                        
                    } else {
    
                        if (newPageNumber < 1) newPageNumber = 1;
                        if (newPageNumber > $scope.pagination.totalPages) newPageNumber = $scope.pagination.totalPages;
    
                        if (!force && newPageNumber === $scope.pagination.currentPage) return;
    
                        $scope.pagination.currentPage = newPageNumber;
                        $scope.pagination.start = (newPageNumber - 1) * $scope.pagination.limit;
                        $scope.pagination.visible = pagination && $scope.pagination.totalPages > (paginationShowOnePage ? 0 : 1);
                        $scope.pagination.visiblePages = ListFactory.calculateVisiblePages(newPageNumber, $scope.pagination.totalPages, paginationPagesToDisplay);
                    }
                    
                    setStateInStore();
                }
                
                function getStateFromStore() {
                    
                    return ListFactory.getListState(pageName, listName);
                }
                
                function setStateInStore() {
                    
                    if (!listDataInitialized) return;
                    
                    // if this list is within a context provider that repeats, then do not write anything to the store
                    if (mdContextProviderCtrl && mdContextProviderCtrl.isRepeaterContextProvider()) return;
                    
                    clearTimeout(storeUpdateDebounce);
                    
                    storeUpdateDebounce = setTimeout(function () {
                        
                        ListFactory.setListStateFromListScope(pageName, listName, $scope);
                    }, 250);
                }
                
                var unsubscribe = $rootScope.$on("UpdateList_" + pageInfoCtrl.name + "_" + $scope.name, prepareListState);
                $scope.$on("$destory", function () {
                    unsubscribe();
                });
            },
            controller: ["$scope", function ($scope) {
                
                var ctrl = this;
                
                ctrl.getListScope = function () {
                    
                    return $scope;
                };
            }]
        };
    }]);

angular
    .module("app.core")
    .directive("mdListItem", ["ActionFactory", function (ActionFactory) {
        
        return {
            restrict: "A",
            require: ["^mdList", "mdContextProvider"],
            translude: true,
            link: function ($scope, $element, $attrs, $ctrls, $transclude) {
                               
                var mdListCtrl = $ctrls[0];
                var mdContextProviderCtrl = $ctrls[1];
                
                $transclude(function ($clone, $transcludedScope) {
                    
                    mdContextProviderCtrl.applyContextItemData($transcludedScope, "$data");
                    
                    var $listScope = mdListCtrl.getListScope();
                    var actions = $listScope.actions;
                    
                    $element.on("click", function (e) {
                        
                        if (e.srcElement && ["A", "INPUT", "BUTTON", "TEXTAREA", "SELECT"].indexOf(e.srcElement.tagName) !== -1) return;
                        
                        if (actions && actions.length) {
                            
                            var contextualData = mdContextProviderCtrl.getContextItemData();
                            ActionFactory.triggerEvent("click", actions, contextualData);
                        }
                    });
                    
                    $element.on("$destroy", function () {
                        $transcludedScope.$destroy();
                    });
    
                    $element.append($clone);
                });
            }
        };
    }]);
angular.module("app.core").directive("mdTitle", ["TranslationService", "AssetFactory", function (TranslationService, AssetFactory) {
    return {
        restrict: "E",
        compile: function ($element, $attrs) {
        
            var content = $element.html();
    
            content = TranslationService.translate(content);
            content = AssetFactory.rewriteAssetPaths(content);
    
            var cssClasses = ($attrs.classes || "").trim();
            var html = "<div class=\"" + cssClasses + "\">" + content + "</div>";
        
            $element.html(html);
        }
    };
}]);

angular.module("app.core").directive("mdQuestion", ["$http", "$rootScope", "$parse", "$filter", "$timeout", "SchemaService", "$templateCache", "$log", "StoreFactory", "ActionFactory", "TranslationService", function ($http, $rootScope, $parse, $filter, $timeout, SchemaService, $templateCache, $log, StoreFactory, ActionFactory, TranslationService) {

    return {
        scope: {
            // All
            name: "@",
            itemType: "@",
            id: "@",
            label: "@",
            placeholder: "@",
            message: "@",
            default: "@",
            validators: "=",
            show: "@",
            disabled: "@",
            required: "@",
            model: "@",
            description: "@",
            extends: "=",
            leftIcon: "@",
            rightIcon: "@",
            classes: "@",
            // select
            options: "=",
            optionsfilter: "=",
            searchable: "=",
            // text
            maxlength: "@",
            multiline: "=",
            debounce: "=",
            // static
            content: "@",
            // rating, date
            max: "@",
            // date
            min: "@",
            // slider
            dual: "=",
            step: "@",
            // Actions
            actions: "=",
            optionSource: "@",
            labelProperty: "@",
            valueProperty: "@",
            groupProperty: "@",
            // Switch
            onText: "@",
            offText: "@",
            // checkbox/radio
            vertical: "=",
            iconSelected: "@",
            iconUnselected: "@",
            // QR/Barcode
            displayValue: "=",
            // number
            decimals: "@"
        },
        restrict: "E",
        template: [
            "<div id=\"{{ name }}\" ng-if=\"show\" class=\"form-group item-{{itemType}} {{classes}}\" ng-class=\"{'has-error': (form[name].$invalid === true && showValidations()), 'has-success': (form[name].$invalid === false && showValidations()), 'no-error': (type == 'static')}\">",
            "   <label class=\"control-label\">",
            "       {{label | translate}} <span class=\"required-asterix fa fa-star\" ng-if=\"required == 'true' && form[name].$invalid === true\"></span>",
            "   </label>",
            "   <p class=\"description\" ng-if=\"description\">{{description | translate}}</p>",
            "   <div ng-include=\"templateUrl\"></div>",
            "   <div ng-show=\"form[name].$invalid === true && showValidations()\" ng-messages=\"form[name].$error\">",
            "       <div class=\"form-input-error\" ng-message=\"required\">",
            "           <span class=\"fa fa-times\"></span> {{message | translate}}",
            "       </div>",
            "       <div class=\"form-input-error\" ng-message=\"email\">",
            "           <span class=\"fa fa-times\"></span> {{defaultMessage | translate}}",
            "       </div>",
            "       <div class=\"form-input-error\" ng-repeat=\"validation in validators\" ng-message-exp=\"validation.name\">",
            "           <span class=\"fa fa-times\"></span> {{validation.message | translate}}",
            "       </div>",
            "   </div>",
            "</div>"
        ].join(""),
        require: ["^pageInfo", "^form", "?^mdContextProvider"],
        link: function ($scope, $element, $attrs, $ctrls) {
    
            var pageInfoCtrl = $ctrls[0];
            var formCtrl = $ctrls[1];
            var mdContextProviderCtrl = $ctrls[2];
            
            $scope.setTemplate = function () {
                switch ($scope.itemType) {
                    case "select":
                        $scope.templateUrl = "components/mdDynamicForm/fields/templates/select.tpl.html";
                        $scope.defaultMessage = "Please make a selection";
                        break;
                    case "radio":
                        $scope.templateUrl = "components/mdDynamicForm/fields/templates/radio.tpl.html";
                        $scope.defaultMessage = "Please make a selection";
                        break;
                    case "checkbox":
                        $scope.templateUrl = "components/mdDynamicForm/fields/templates/checkbox.tpl.html";
                        $scope.defaultMessage = "Please make a selection";
                        break;
                    case "date":
                        $scope.templateUrl = "components/mdDynamicForm/fields/templates/date.tpl.html";
                        $scope.defaultMessage = "Please provide a valid date";
                        break;
                    case "time":
                        $scope.templateUrl = "components/mdDynamicForm/fields/templates/time.tpl.html";
                        $scope.defaultMessage = "Please provide a valid time";
                        break;
                    case "datetime":
                        $scope.templateUrl = "components/mdDynamicForm/fields/templates/datetime.tpl.html";
                        $scope.defaultMessage = "Please provide a valid date & time";
                        break;
                    case "number":
                        $scope.templateUrl = "components/mdDynamicForm/fields/templates/number.tpl.html";
                        $scope.defaultMessage = "Please provide a number";
                        break;
                    case "email":
                        $scope.templateUrl = "components/mdDynamicForm/fields/templates/email.tpl.html";
                        $scope.defaultMessage = "Please provide a valid email address";
                        break;
                    case "slider":
                        if ($scope.dual) {
                            $scope.templateUrl = "components/mdDynamicForm/fields/templates/range-slider.tpl.html";
                        } else {
                            $scope.templateUrl = "components/mdDynamicForm/fields/templates/slider.tpl.html";
                        }
                        $scope.defaultMessage = "Please choose a value";
                        break;
                    case "rating":
                        $scope.templateUrl = "components/mdDynamicForm/fields/templates/rating.tpl.html";
                        $scope.defaultMessage = "Please provide a rating";
                        break;
                    case "barcode":
                        $scope.templateUrl = "components/mdDynamicForm/fields/templates/barcode.tpl.html";
                        $scope.defaultMessage = "Please capture the barcode";
                        break;
                    case "qrcode":
                        $scope.templateUrl = "components/mdDynamicForm/fields/templates/qrcode.tpl.html";
                        $scope.defaultMessage = "Please capture the QR code";
                        break;
                    case "signature":
                        $scope.templateUrl = "components/mdDynamicForm/fields/templates/signature.tpl.html";
                        $scope.defaultMessage = "Please provide your signature";
                        break;
                    case "switch":
                        $scope.templateUrl = "components/mdDynamicForm/fields/templates/switch.tpl.html";
                        $scope.defaultMessage = "Please make a selection";
                        break;
                    case "password":
                        $scope.templateUrl = "components/mdDynamicForm/fields/templates/password.tpl.html";
                        $scope.defaultMessage = "This is a required field";
                        break;
                    case "text":
                        $scope.multi = ($scope.multiline != undefined) ? $scope.multiline : false;
                        $scope.templateUrl = "components/mdDynamicForm/fields/templates/text.tpl.html";
                        $scope.defaultMessage = "This is a required field";
                        break;
                    default:
                        if ($scope.extends !== undefined) {
                            $scope.type = $scope.extends.type;
                            $scope.itemType = $scope.extends["item-type"];
                            $scope.setTemplate();
                        }
                }
            };

            $scope.message = (typeof $scope.message != "undefined") ? $scope.message : $scope.defaultMessage;

            $scope.form = formCtrl;
            
            $scope.pageName = (pageInfoCtrl)
                ? pageInfoCtrl.name
                : "";
            
            var modelKeyPrefix = mdContextProviderCtrl
                ? "$data.$item."
                : "$store.pages." + $scope.pageName + ".";
            
            var modelKeySuffix = $attrs.modellocationoverride || $attrs.originalname || $scope.name;
            
            $scope.key = modelKeyPrefix + modelKeySuffix;
    
            $scope.setTemplate();

            $scope.inputModel = StoreFactory.getForElement($scope.key, $element);
            $scope.updateStore = function (value) {
                StoreFactory.setForElement($scope.key, value, $element);
            };

            $scope.$watch("inputModel", function (newValue, oldValue) {

                if (newValue !== oldValue) {

                    $scope.updateStore(newValue);

                    // always trigger "change" event(s) if the model value changes
                    var itemsToFireChangeEvent = ["checkbox", "radio", "rating", "smiley", "thumbs", "signature", "barcode", "record-audio"];
                    if (itemsToFireChangeEvent.indexOf($scope.itemType) !== -1) {

                        ActionFactory.triggerEvent("change", $scope.actions);
                    }
                }

            }, true);

            if ($scope.inputModel === undefined && $scope.default !== undefined && !hasExpression("default")) {

                var translatedDefault = TranslationService.translate($scope.default);
                $scope.updateStore(translatedDefault);
                $scope.inputModel = translatedDefault;
            }

            // Set defaults
            $scope.disabled = ($scope.disabled == undefined) ? false : $scope.disabled;
            $scope.required = ($scope.required == undefined) ? false : $scope.required;
            $scope.show = ($scope.show == undefined) ? true : $scope.show;
            $scope.search = ($scope.search == undefined) ? false : $scope.search;

            $scope.evalModel = function () {
                if ($scope.model != undefined) {
                    $scope.inputModel = StoreFactory.evaluateForElement($scope.model, $element);
                }
            };
            $scope.userInput = function () {
                if (formCtrl[$scope.name] !== undefined) {
                    formCtrl[$scope.name].$setTouched(true);
                }
            };

            $scope.evalModel();

            // When a form is updated we need to re-run parsing
            $scope.$on("StoreChanged", function () {
                $scope.evalModel();
            });

            $scope.$watch(function () {
                return StoreFactory.getForElement($scope.key, $element);
            }, function (value) {
                $scope.inputModel = value;
                if ($scope.form[$scope.name] !== undefined) {
                    $scope.form[$scope.name].$pristine = false;
                }
            }, true);

            if ($scope.itemType == "select" && $scope.optionSource != undefined) {
                $scope.$watchCollection(function () {
                    return StoreFactory.getForElement($scope.optionSource, $element);
                }, function (value) {
                    var options = [];
                    if ($scope.labelProperty != undefined || $scope.valueProperty != undefined || $scope.groupValue != undefined) {
                        angular.forEach(value, function (option) {
                            var newOption = {
                                "value": ($scope.valueProperty != undefined) ? option[$scope.valueProperty] : option.value,
                                "label": ($scope.labelProperty != undefined) ? option[$scope.labelProperty] : option.label,
                                "group": ($scope.groupProperty != undefined) ? option[$scope.groupProperty] : option.group
                            };
                            options.push(newOption);
                        });
                    } else {
                        options = value;
                    }
                    $scope.options = options;
                });
            }

            function empty(data) {
                if (typeof(data) == "number" || typeof(data) == "boolean") {
                    return false;
                }

                if (typeof(data) == "undefined" || data === null) {
                    return true;
                }

                if (typeof(data.length) != "undefined") {
                    return data.length == 0;
                }

                var count = 0;
                for (var i in data) {
                    if (data.hasOwnProperty(i)) {
                        count++;
                    }
                }
                return count == 0;
            }

            function hasExpression(expressionType) {

                if (!$attrs) return false;
                if (!$attrs.mdExpressions) return false;

                var expressions = JSON.parse($attrs.mdExpressions);
                return expressions.hasOwnProperty(expressionType);
            }

            $scope.showValidations = function () {
                return (!empty($scope.inputModel) || $scope.form[$scope.name].$pristine === false);
            };

        }
    };
}]);

angular.module("app.core").directive("numberFormat", ["$filter", function ($filter) {
    return {
        "restrict": "A",
        "require": "ngModel",
        "link": function ($scope, $element, $attrs, $ctrl) {
            var decimalPlaces = parseInt($attrs.decimalPlaces);
            if (isNaN(decimalPlaces) === false) {
                $ctrl.$formatters.push(function (value) {
                    var res = parseFloat(value);
                    if (isNaN(res) === true) {
                        return undefined;
                    }
                    if (value !== undefined) {
                        value = $filter("number")(value, decimalPlaces);
                        value = parseFloat(value.replace(",", ""));
                    }
                    $ctrl.$setViewValue(value);
                    return value;
                });
                $ctrl.$parsers.push(function (value) {
                    if (value !== undefined && value !== null) {
                        var string = value.toString();
                        var parts = string.split(".");
                        if (parts[1] !== undefined && parts[1].length > decimalPlaces) {
                            $ctrl.$setViewValue($ctrl.$modelValue);
                            $ctrl.$render();
                            return $ctrl.$modelValue;
                        }
                    }
                    return value;
                });
            }
        }
    };
}]);

angular
    .module("app.core")
    .directive("mdComponent", ["$rootScope", "$timeout", "ComponentFactory", function ($rootScope, $timeout, ComponentFactory) {
        
        return {
            restrict: "E",
            scope: {
                "instanceId": "@"
            },
            require: ["?^mdContextProvider"],
            link: function ($scope, $element, $attrs, $ctrls) {
                
                var mdContextProviderCtrl = $ctrls[0];
                var contextualData = null;
                var isClone = false;
    
                var componentRegistration = ComponentFactory.getComponentById($scope.instanceId);
                if (componentRegistration === null) return;
                
                var componentElement = componentRegistration.element;
                if (mdContextProviderCtrl) {
    
                    var itemData = mdContextProviderCtrl.getContextItemData();
                    contextualData = {
                        "$data": itemData
                    };
                    
                    if (itemData.$index !== undefined) {
                        
                        // this is in a repeating item
                        componentElement = componentRegistration.element.cloneNode(true);
                        
                        var id = componentElement.getAttribute("id");
                        componentElement.setAttribute("id", id + "_" + itemData.$index);
                        
                        isClone = true;
                    }
                }
    
                var hasChildren = ($element.children().length > 0);
                if (hasChildren) {
    
                    var childElements = Array.prototype.slice.call(componentElement.childNodes);
                    if (componentRegistration.processed !== true) {
            
                        // determine start index for dynamic addition of children based on the initial number of child nodes in the component markup
                        componentRegistration.dynamicChildrenStartIndex = childElements.length;
                    }
    
                    // remove all children after dynamic child start index (tear down)
                    for (var i = componentRegistration.dynamicChildrenStartIndex; i < childElements.length; i++) {
    
                        componentElement.removeChild(childElements[i]);
                    }
        
                    // re-add all children to the component element (rebuild)
                    angular.forEach($element.children(), function ($child) {
            
                        var $removedChild = $element[0].removeChild($child); // remove from DOM
                        componentElement.appendChild($removedChild); // put back in as child of component element
                    });
                }
    
                ComponentFactory.setUpComponentAttributes(componentRegistration, componentElement, contextualData, true);
                
                $element.replaceWith(componentElement);
    
                $rootScope.$on("StoreChanged", function () {
                    
                    ComponentFactory.setUpComponentAttributes(componentRegistration, componentElement, contextualData, false);
                });
                
                if (isClone || componentRegistration.processed !== true) {
                    
                    setTimeout(function () {
                        
                        ComponentFactory.setUpComponentBindings(componentRegistration, $scope);
                    }, 0);
                    
                    componentRegistration.processed = true;
                }
            }
        };
    }]);

angular.module("app.core").directive("mdChart", ["$compile", "StoreFactory", function ($compile, StoreFactory) {
    return {
        restrict: "E",
        scope: {
            "title": "@",
            "default": "=",
            "model": "@",
            "classes": "@"
        },
        link: function ($scope, $element, $attrs) {
            
            var chartTypes = {
                "line-chart": "Line",
                "bar-chart": "Bar",
                "doughnut-chart": "Doughnut",
                "pie-chart": "Pie",
                "polar-area-chart": "PolarArea",
                "radar-chart": "Radar"
            };
            $scope.chartType = chartTypes[$attrs.itemType];
            
            if ($scope.model) {
    
                var modelValue = StoreFactory.getForElement($scope.model, $element);
                if (modelValue) {
                    $scope.data = modelValue;
                }
                
                $scope.$watch(function () {
                    
                    return StoreFactory.getForElement($scope.model, $element);
                    
                }, function (newData, oldData) {
                    
                    if (newData !== oldData) {
                        $scope.data = newData;
                    }
                });
                
            } else {
                
                $scope.data = $scope.default;
            }
    
            var chartHtml = [
                "<div class=\"chart-block {{ classes }}\">",
                "   <h4 ng-if=\"title\">{{ title | translate }}</h4>",
                "   <div class=\"md-chart-container\">",
                "       <canvas chart=\"{{ chartType }}\" data=\"data\" responsive=\"true\"></canvas>",
                "   </div>",
                "</div>"
            ].join("");
            var compiledElement = $compile(chartHtml)($scope);
            $element.replaceWith(compiledElement);
        }
    };
}]);
angular.module("app.core").directive("mdGoogleMap", ["GoogleMapService", "StoreFactory", "ActionFactory", "DirectiveBridge", "$log", function (GoogleMapService, StoreFactory, ActionFactory, DirectiveBridge, $log) {
    return {
        restrict: "E",
        replace: true,
        scope: {
            actions: "=",
            lat: "@",
            lng: "@",
            zoom: "@",
            maptype: "@",
            zoomcontrol: "@",
            streetviewcontrol: "@",
            maptypecontrol: "@",
            fullscreencontrol: "@",
            rotatecontrol: "@",
            scalecontrol: "@",
            traffic: "=",
            transit: "=",
            bicycling: "=",
            classes: "@",
            name: "@",
            static: "@",
            data: "@",
            model: "@",
            styles: "@",
            expose: "@",
            exposedproperty: "@",
            draggable: "@",
            scrollwheel: "@",
            doubleclick: "@"
        },
        template: "<div class=\"google-map {{classes}} \" id=\"{{name}}\" style=\"position: relative;\" ></div>",
        controller: ["$scope", "$element", "SchemaHelper", function ($scope, $element, SchemaHelper) {
            var vm = this;
            vm.overlays = [];
            vm.trafficLayer = null;
            vm.bicyclingLayer = null;
            vm.trafficLayer = null;
            vm.transitLayer = null;
            function init() {
                var apiKey = SchemaHelper.schema.settings.mapping ? SchemaHelper.schema.settings.mapping.googleMapsAPIKey : undefined;
                GoogleMapService
                    .requestGoogleMapsScript(apiKey)
                    .then(function (e) {
                        var googleMapsLoaded = false;
                        if (!e && google && google.maps) {
                            var map = new google.maps.Map($element[0], {
                                zoom: parseInt($scope.zoom),
                                center: {lat: parseFloat($scope.lat), lng: parseFloat($scope.lng)},
                                mapTypeId: $scope.maptype,
                                zoomControl: $scope.zoomcontrol == "true",
                                streetViewControl: $scope.streetviewcontrol == "true",
                                mapTypeControl: $scope.maptypecontrol == "true",
                                fullscreenControl: $scope.fullscreencontrol == "true",
                                rotateControl: $scope.rotatecontrol == "true",
                                scaleControl: $scope.scalecontrol == "true",
                                draggable: $scope.draggable == "true",
                                scrollwheel: $scope.scrollwheel == "true",
                                disableDoubleClickZoom: $scope.doubleclick != "true",
                                styles: JSON.parse($scope.styles || "[]")
                            });
                            vm.map = map;

                            registerApi(vm);
                            registerEvents(vm.map, $scope.actions);

                            GoogleMapService.registerResize(map);
                            $element.on("$destroy", function () {
                                GoogleMapService.unregisterResize(map);
                            });

                            google.maps.event.addListener(map, "tilesloaded", function () {
                                googleMapsLoaded = true;
                                google.maps.event.clearListeners(map, "tilesloaded");
                                clearFailedOverlay($element[0]);
                                google.maps.event.trigger(map, "resize");
                            });

                            setTimeout(function () {
                                if (!googleMapsLoaded) {
                                    failedOverlay($element[0]);
                                }
                            }, 5000);

                            if ($scope.traffic) {
                                vm.trafficLayer = vm.trafficLayer || new google.maps.TrafficLayer();
                                vm.trafficLayer.setMap(vm.map);
                            }

                            if ($scope.transit) {
                                vm.transitLayer = vm.transitLayer || new google.maps.TransitLayer();
                                vm.transitLayer.setMap(vm.map);
                            }

                            if ($scope.bicycling) {
                                vm.bicyclingLayer = vm.bicyclingLayer || new google.maps.BicyclingLayer();
                                vm.bicyclingLayer.setMap(vm.map);
                            }

                            if ($scope.static == "true") {
                                addDataToMap(JSON.parse($scope.data || "[]"));
                            } else {
                                if ($scope.model) {
                                    addWatches();
                                }
                            }

                            if ($scope.expose == "true") {
                                if (!window.cti.maps) {
                                    window.cti.maps = {};
                                }
                                window.cti.maps[$scope.exposedproperty] = vm.map;
                            }
                        } else {
                            failedOverlay($element[0]);
                        }
                    });
            }

            init();

            function registerApi(map) {
                var pageName = $element.controller("pageInfo").name;
                DirectiveBridge.registerItemApi(pageName, $scope.name, {
                    setMapLayers: function (layer, show) {
                        var mapLayer;
                        switch (layer) {
                            case "traffic":
                                mapLayer = map.trafficLayer || new google.maps.TrafficLayer();
                                map.trafficLayer = mapLayer;
                                break;
                            case "transit":
                                mapLayer = map.transitLayer || new google.maps.TransitLayer();
                                map.transitLayer = mapLayer;
                                break;
                            case "bicycling":
                                mapLayer = map.bicyclingLayer || new google.maps.BicyclingLayer();
                                map.bicyclingLayer = mapLayer;
                                break;
                            default:
                                return false;

                        }
                        if (show) {
                            mapLayer.setMap(map.map);
                        } else {
                            mapLayer.setMap(null);
                        }
                        return true;
                    },
                    setMapTypeId: function (mapType) {
                        map.map.setMapTypeId(mapType);
                    },
                    setLocation: function (lat, lng, zoom, pan) {
                        if (pan) {
                            map.map.panTo({lat: lat, lng: lng});
                        } else {
                            map.map.setCenter({lat: lat, lng: lng});
                        }

                        if (zoom) {
                            map.map.setZoom(zoom);
                        }
                    },
                    setControls: function (control, show) {
                        switch (control) {
                            case "zoom":
                                map.map.setOptions({"zoomControl": show});
                                break;
                            case "maptype":
                                map.map.setOptions({"mapTypeControl": show});
                                break;
                            case "scale":
                                map.map.setOptions({"scaleControl": show});
                                break;
                            case "streetview":
                                map.map.setOptions({"streetViewControl": show});
                                break;
                            case "rotate":
                                map.map.setOptions({"rotateControl": show});
                                break;
                            case "fullscreen":
                                map.map.setOptions({"fullscreenControl": show});
                                break;
                            default:
                                return false;
                        }

                        return true;
                    }

                });
            }

            function clearFailedOverlay(element) {
                var overlay = element.querySelector("div.google-map-failed");
                if (overlay) {
                    overlay.parentNode.removeChild(overlay);
                }
            }

            function failedOverlay(element) {
                var overlay = document.createElement("div");
                overlay.classList.add("google-map-failed");
                overlay.innerHTML = "<p>Map has failed to load, click to reload</p>";
                overlay.addEventListener("click", function () {
                    init();
                });
                element.appendChild(overlay);
            }

            function addDataToMap(mapData) {

                // Clear
                while (vm.overlays[0]) {
                    vm.overlays.pop().setMap(null);
                }

                if (mapData && Object.prototype.toString.call(mapData) === "[object Array]") {
                    $.each(mapData, function (index, item) {
                        switch (item.type) {
                            case undefined:
                                break;
                            case "marker":
                                addMarker(item);
                                break;
                            case "polygon":
                                addPolygon(item);
                                break;
                            case "polyline":
                                addPolyline(item);
                                break;
                            case "heatmap":
                                addHeatmap(item);
                                break;
                            case "directions":
                                addDirections(item);
                                break;
                        }
                    });
                }
            }

            function addWatches() {

                $scope.$watchCollection(function () {
                    return StoreFactory.get($scope.model);
                }, function (mapData) {
                    addDataToMap(mapData);
                });
            }

            function addDirections(item) {

                var schema = {
                    "$schema": "http://json-schema.org/draft-04/schema#",
                    "type": "object",
                    "properties": {
                        "data": {
                            "type": "object",
                            "properties": {
                                "origin": {
                                    "type": "string"
                                },
                                "destination": {
                                    "type": "string"
                                },
                                "travelMode": {
                                    "type": "string"
                                },
                                "renderer": {
                                    "type": "object",
                                    "properties": {
                                        "preserveViewport": {
                                            "type": "boolean"
                                        },
                                        "draggable": {
                                            "type": "boolean"
                                        }
                                    },
                                    "required": [],
                                    "additionalProperties": false
                                },
                                "drivingOptions": {
                                    "type": "object",
                                    "properties": {
                                        "departureTime": {
                                            "type": "string",
                                            "format": "date-time"
                                        }
                                    },
                                    "required": []
                                }
                            },
                            "required": [
                                "origin",
                                "destination"
                            ]
                        },
                        "type": {
                            "type": "string",
                            "pattern": "^directions$"
                        }
                    },
                    "required": [
                        "data",
                        "type"
                    ]
                };

                if (!validateItem(item, schema)) {
                    return;
                }

                var request = angular.copy(item.data);
                delete request.renderer;
                var renderer = angular.copy(item.data.renderer || {});
                renderer.map = vm.map;

                if (request.drivingOptions && angular.isString(request.drivingOptions.departureTime)) {
                    request.drivingOptions.departureTime = new Date(request.drivingOptions.departureTime);
                }
                if (request.drivingOptions && angular.isString(request.drivingOptions.arrivalTime)) {
                    request.drivingOptions.arrivalTime = new Date(request.drivingOptions.arrivalTime);
                }
                if (request.transitOptions && angular.isString(request.transitOptions.departureTime)) {
                    request.transitOptions.departureTime = new Date(request.transitOptions.departureTime);
                }
                if (request.transitOptions && angular.isString(request.transitOptions.arrivalTime)) {
                    request.transitOptions.arrivalTime = new Date(request.transitOptions.arrivalTime);
                }

                var directionsDisplay = new google.maps.DirectionsRenderer(renderer);
                vm.overlays.push(directionsDisplay);

                var directionsService = new google.maps.DirectionsService();
                directionsService.route(request, function (response, status) {
                    if (status == "OK") {
                        // Display the route on the map.
                        directionsDisplay.setDirections(response);
                    }
                });
            }

            function parseMarker(item) {

                var schema = {
                    "$schema": "http://json-schema.org/draft-04/schema#",
                    "type": "object",
                    "properties": {
                        "type": {
                            "type": "string",
                            "pattern": "^marker$"
                        },
                        "data": {
                            "type": "object",
                            "properties": {
                                "position": {
                                    "type": "object",
                                    "properties": {
                                        "lat": {
                                            "type": "number",
                                            "minimum": -90,
                                            "maximum": 90
                                        },
                                        "lng": {
                                            "type": "number",
                                            "minimum": -180,
                                            "maximum": 180
                                        }
                                    },
                                    "required": [
                                        "lat",
                                        "lng"
                                    ],
                                    "additionalProperties": false
                                },
                                "icon": {
                                    "type": "string"
                                },
                                "infoWindow": {
                                    "type": "object",
                                    "properties": {
                                        "showOn": {
                                            "type": "string"
                                        },
                                        "content": {
                                            "type": "string"
                                        }
                                    },
                                    "required": [
                                        "showOn",
                                        "content"
                                    ],
                                    "additionalProperties": false
                                },
                                "clickable": {
                                    "type": "boolean"
                                },
                                "crossOnDrag": {
                                    "type": "boolean"
                                },
                                "cursor": {
                                    "type": "string"
                                },
                                "draggable": {
                                    "type": "boolean"
                                },
                                "label": {
                                    "type": "string"
                                },
                                "opacity": {
                                    "type": "number",
                                    "minimum": 0,
                                    "maximum": 1
                                },
                                "optimized": {
                                    "type": "boolean"
                                },
                                "place": {
                                    "type": "object",
                                    "properties": {
                                        "location": {
                                            "type": "object",
                                            "properties": {
                                                "lat": {
                                                    "type": "number",
                                                    "minimum": -90,
                                                    "maximum": 90
                                                },
                                                "lng": {
                                                    "type": "number",
                                                    "minimum": -180,
                                                    "maximum": 180
                                                }
                                            }
                                        },
                                        "placeId": {
                                            "type": "string"
                                        },
                                        "query": {
                                            "type": "string"
                                        }
                                    },
                                    "required": [
                                        "location"
                                    ],
                                    "additionalProperties": false
                                },
                                "title": {
                                    "type": "string"
                                },
                                "visible": {
                                    "type": "boolean"
                                },
                                "zIndex": {
                                    "type": "number"
                                }
                            },
                            "required": [
                                "position"
                            ]
                        }
                    },
                    "required": [
                        "type",
                        "data"
                    ]
                };

                if (!validateItem(item, schema)) {
                    return null;
                }

                var obj = angular.copy(item.data);
                delete obj.infoWindow;

                var marker = new google.maps.Marker(obj);

                if (item.data.infoWindow) {
                    var iw = new google.maps.InfoWindow({
                        content: item.data.infoWindow.content
                    });
                    if (item.data.infoWindow.showOn === "click") {
                        marker.addListener("click", function () {
                            iw.open(vm.map, marker);
                        });
                    }
                    if (item.data.infoWindow.showOn === "load") {
                        iw.open(vm.map, marker);
                    }
                }
                return marker;
            }

            function addMarker(item) {
                var marker = parseMarker(item);
                if (marker != null) {
                    marker.setMap(vm.map);
                    vm.overlays.push(marker);
                }
            }

            function addHeatmap(item) {

                var schema = {
                    "$schema": "http://json-schema.org/draft-04/schema#",
                    "type": "object",
                    "properties": {
                        "type": {
                            "type": "string",
                            "pattern": "^heatmap$"
                        },
                        "data": {
                            "type": "array",
                            "items": {
                                "type": "object",
                                "properties": {
                                    "lat": {
                                        "type": "number",
                                        "minimum": -90,
                                        "maximum": 90
                                    },
                                    "lng": {
                                        "type": "number",
                                        "minimum": -180,
                                        "maximum": 180
                                    },
                                    "weight": {
                                        "type": "number",
                                        "minimum": 0
                                    }
                                },
                                "required": ["lat", "lng"],
                                "additionalProperties": false
                            }
                        },
                        "dissipating": {
                            "type": "boolean"
                        },
                        "gradient": {
                            "type": "array",
                            "items": {
                                "type": "string"
                            }
                        },
                        "maxIntensity": {
                            "type": "number"
                        },
                        "opacity": {
                            "type": "number"
                        },
                        "radius": {
                            "type": "number"
                        }
                    },
                    "required": ["type", "data"],
                    "additionalProperties": false
                };
                if (!validateItem(item, schema)) {
                    return;
                }

                var obj = angular.copy(item.data);

                var heatmap = [];
                for (var i in obj) {
                    heatmap.push({
                        location: new google.maps.LatLng(obj[i].lat, obj[i].lng),
                        weight: obj[i].weight || 1
                    });
                }

                var heat = new google.maps.visualization.HeatmapLayer({data: heatmap});
                heat.setMap(vm.map);
                vm.overlays.push(heat);
            }

            function addPolygon(item) {

                var schema = {
                    "$schema": "http://json-schema.org/draft-04/schema#",
                    "type": "object",
                    "properties": {
                        "type": {
                            "type": "string",
                            "pattern": "^polygon$"
                        },
                        "data": {
                            "type": "object",
                            "properties": {
                                "paths": {
                                    "type": "array",
                                    "items": {
                                        "type": "object",
                                        "properties": {
                                            "lat": {
                                                "type": "number",
                                                "minimum": -90,
                                                "maximum": 90
                                            },
                                            "lng": {
                                                "type": "number",
                                                "minimum": -180,
                                                "maximum": 180
                                            }
                                        },
                                        "required": [
                                            "lat",
                                            "lng"
                                        ],
                                        "additionalProperties": false
                                    }
                                },
                                "strokeColor": {
                                    "type": "string"
                                },
                                "strokeOpacity": {
                                    "type": "number"
                                },
                                "strokeWeight": {
                                    "type": "number"
                                },
                                "fillColor": {
                                    "type": "string"
                                },
                                "fillOpacity": {
                                    "type": "number"
                                },
                                "clickable": {
                                    "type": "boolean"
                                },
                                "draggable": {
                                    "type": "boolean"
                                },
                                "editable": {
                                    "type": "boolean"
                                },
                                "geodesic": {
                                    "type": "boolean"
                                },
                                "visible": {
                                    "type": "boolean"
                                },
                                "zIndex": {
                                    "type": "number"
                                }
                            },
                            "required": [
                                "paths"
                            ]
                        }
                    },
                    "required": [
                        "type",
                        "data"
                    ]
                };

                if (!validateItem(item, schema)) {
                    return;
                }

                var poly = new google.maps.Polygon(item.data);
                poly.setMap(vm.map);
                vm.overlays.push(poly);
            }

            function addPolyline(item) {

                var schema = {
                    "$schema": "http://json-schema.org/draft-04/schema#",
                    "type": "object",
                    "properties": {
                        "type": {
                            "type": "string",
                            "pattern": "^polyline$"
                        },
                        "data": {
                            "type": "object",
                            "properties": {
                                "path": {
                                    "type": "array",
                                    "items": {
                                        "type": "object",
                                        "properties": {
                                            "lat": {
                                                "type": "number",
                                                "minimum": -90,
                                                "maximum": 90
                                            },
                                            "lng": {
                                                "type": "number",
                                                "minimum": -180,
                                                "maximum": 180
                                            }
                                        },
                                        "required": [
                                            "lat",
                                            "lng"
                                        ],
                                        "additionalProperties": false
                                    }
                                },
                                "strokeColor": {
                                    "type": "string"
                                },
                                "geodesic": {
                                    "type": "boolean"
                                },
                                "strokeOpacity": {
                                    "type": "number"
                                },
                                "clickable": {
                                    "type:": "boolean"
                                },
                                "draggable": {
                                    "type:": "boolean"
                                },
                                "editable": {
                                    "type:": "boolean"
                                },
                                "strokeWeight": {
                                    "type:": "number"
                                },
                                "visible": {
                                    "type:": "boolean"
                                },
                                "zIndex": {
                                    "type:": "number"
                                }
                            },
                            "required": [
                                "paths"
                            ]
                        }
                    },
                    "required": [
                        "type",
                        "data"
                    ],
                    "additionalProperties": false
                };

                if (!validateItem(item, schema)) {
                    return;
                }

                var poly = new google.maps.Polyline(item.data);
                poly.setMap(vm.map);
                vm.overlays.push(poly);
            }

            function validateItem(item, schema) {
                var valid = window.tv4.validate(item, schema);
                if (!valid) {
                    $log.error("Google maps item validation failed: " + window.tv4.error.message + " " + window.tv4.error.dataPath);
                }
                return valid;
            }

            function registerEvents(map, actions) {
                map.addListener("center_changed", function () {
                    ActionFactory.triggerEvent("map-moved", actions, {
                        lat: map.getCenter().lat(),
                        lng: map.getCenter().lng()
                    });
                });
                map.addListener("click", function (e) {
                    ActionFactory.triggerEvent("map-clicked", actions, {
                        lat: e.latLng.lat(),
                        lng: e.latLng.lng()
                    });
                });
                map.addListener("mousemove", function (e) {
                    ActionFactory.triggerEvent("map-mouse-move", actions, {
                        lat: e.latLng.lat(),
                        lng: e.latLng.lng()
                    });
                });
                map.addListener("rightclick", function (e) {
                    ActionFactory.triggerEvent("map-right-clicked", actions, {
                        lat: e.latLng.lat(),
                        lng: e.latLng.lng()
                    });
                });
                map.addListener("zoom_changed", function () {
                    ActionFactory.triggerEvent("map-zoom-changed", actions, {
                        zoom: map.getZoom()
                    });
                });
                map.addListener("tilesloaded", function () {
                    ActionFactory.triggerEvent("map-tiles-loaded", actions, {});
                });
                map.addListener("idle", function () {
                    ActionFactory.triggerEvent("map-idle", actions, {});
                });
            }
        }]
    };
}]);
angular.module("app.core").directive("mdCustom", ["$http", "$templateCache", "$log", function ($http, $templateCache, $log) {
    return {
        scope: {
            name: "@",
            url: "@",
            data: "="
        },
        restrict: "E",
        template: "<div id=\"{{name}}\" ng-if=\"show\" class=\"form-group\"><div ng-include=\"templateUrl\"></div></div>",
        link: function (scope, element, attrs) {
            // Do we have a location to get the control template from?
            scope.show = true;
            if (typeof attrs.url != "undefined") {
                // Has the template already been cached?
                if ($templateCache.get(attrs.url) === undefined) {
                    // Not currently in cache so lets try and load it
                    $http.get(attrs.url).then(function (response) {
                        $templateCache.put(attrs.url, response.data);
                    }, function () {
                        $log.error("Could not load specified template URL \"" + attrs.url + "\": ");
                        // Couldn"t load the template so don"t show the base.tpl.html section
                        attrs.show = scope.show = false;
                    });
                }
                scope.templateUrl = attrs.url;
            }
        }
    };
}]);
angular
    .module("app.core")
    .directive("mdSlider", ["$timeout", function ($timeout) {
        return {
            restrict: "E",
            scope: {
                required: "=",
                name: "=",
                model: "=",
                min: "@",
                max: "@",
                step: "@",
                validators: "@",
                disabled: "=",
                actions: "="
            },
            template: [
                "<slider ng-model=\"modelValue\" ",
                "        ng-disabled=\"disabled\" ",
                "        validation=\"{{validators}}\" ",
                "        md-actions=\"{{actions}}\" ",
                "        ng-swipe-left=\"cancelSwipe($event)\" ",
                "        ng-swipe-right=\"cancelSwipe($event)\" ",
                "        floor=\"{{min}}\" ",
                "        ceiling=\"{{max}}\" ",
                "        step=\"{{step}}\">",
                "</slider>",
                "<input type=\"hidden\" ng-model=\"model\" md-actions=\"{{actions}}\" name=\"{{name}}\" ng-required=\"required\" />"
            ].join(""),
            require: "^form",
            link: function ($scope, $element, $attrs, FormController) {

                if (angular.isObject($scope.model)) {

                    $scope.modelValue = $scope.model.lower || 0;
                }

                var onModelChange = function (newValue, oldValue) {

                    var valid = true;

                    if ($scope.required === true || $scope.required.toLowerCase() === "true") {
                        valid = ($scope.model > 0);
                    }

                    FormController[$scope.name].$setValidity("validationValid", valid);

                    if (newValue !== oldValue) {
                        $element.find("input").triggerHandler("change");
                    }
                };

                $scope.cancelSwipe = function () {

                    return $scope.disabled;
                };

                $scope.$watch("model", onModelChange);

                $timeout(function () {

                    $scope.modelValue = $scope.model;

                    $scope.$watch("modelValue", function () {

                        $scope.model = $scope.modelValue;
                    });
                }, 0);
            }
        };
    }])
    .directive("mdRangeSlider", ["$timeout", "TranslationService", function ($timeout, TranslationService) {
        return {
            restrict: "E",
            scope: {
                required: "=",
                name: "=",
                model: "=",
                min: "@",
                max: "@",
                step: "@",
                validators: "@",
                disabled: "=",
                actions: "="
            },
            template: [
                "<slider ng-model=\"modelLower\" ",
                "        ng-model-range=\"modelUpper\" ",
                "        ng-disabled=\"disabled\" ",
                "        validation=\"{{validators}}\" ",
                "        md-actions=\"{{actions}}\" ",
                "        ng-swipe-left=\"cancelSwipe($event)\" ",
                "        ng-swipe-right=\"cancelSwipe($event)\" ",
                "        translate-range-fn=\"translateRange(low, high)\" ",
                "        floor=\"{{min}}\" ",
                "        ceiling=\"{{max}}\" ",
                "        step=\"{{step}}\">",
                "</slider>",
                "<input type=\"hidden\" ng-model=\"model\" md-actions=\"{{actions}}\" name=\"{{name}}\" ng-required=\"required\" />"
            ].join(""),
            require: "^form",
            link: function ($scope, $element, $attrs, FormController) {

                if (typeof ($scope.model) === "string") {

                    if (isNaN($scope.model)) {

                        $scope.model = JSON.parse($scope.model);

                    } else {

                        $scope.model = {
                            lower: 0,
                            upper: parseInt($scope.model, 10)
                        };
                    }
                }

                $scope.translateRange = function (low, high) {

                    return TranslationService.translate("Range") + ": " + (high - low);
                };

                $scope.cancelSwipe = function () {

                    return $scope.disabled;
                };

                function onModelChange(newValue, oldValue) {

                    var valid = true;

                    if ($scope.required === true || $scope.required.toLowerCase() === "true") {
                        valid = ($scope.model && ($scope.model.lower > 0 || $scope.model.upper > 0));
                    }

                    FormController[$scope.name].$setValidity("validationValid", valid);

                    if (!angular.equals(newValue, oldValue)) {
                        $element.find("input").triggerHandler("change");
                    }
                }

                $scope.$watch("model", onModelChange, true);

                $timeout(function () {

                    if ($scope.model) {

                        $scope.modelLower = $scope.model.lower || 0;
                        $scope.modelUpper = $scope.model.upper || 0;
                    }

                    $scope.$watchGroup(["modelLower", "modelUpper"], function () {

                        $scope.model = {
                            lower: $scope.modelLower,
                            upper: $scope.modelUpper
                        };
                    });
                }, 0);
            }
        };
    }]);

angular
    .module("app.core")
    .directive("mdButton", ["$compile", "TranslationService", function ($compile, TranslationService) {
        
        return {
            restrict: "E",
            replace: true,
            transclude: true,
            scope: {
                id: "@",
                theme: "@",
                actions: "=",
                classes: "@",
                leftIcon: "@",
                rightIcon: "@"
            },
            template: [
                "<div class=\"md-button-container\">",
                "  <a id=\"{{id}}\" class=\"btn {{ class }} {{ classes }}\" md-actions=\"{{:: actions }}\" ng-disabled=\"disabled\"></a>",
                "</div>"
            ].join(""),
            link: function ($scope, $element, $attrs, $ctrls, $transclude) {
    
                $scope.class = ($scope.theme === undefined || $scope.theme === "default")
                    ? "btn-default"
                    : $scope.theme;
                
                var $a = $element.find("a");
                
                $transclude(function ($clone, $transcludedScope) {
                    
                    var content = $clone.html() || "";
                    
                    content = TranslationService.translate(content);
    
                    if ($scope.leftIcon) {
                        content = "<span class=\"fa " + $scope.leftIcon + "\"></span> " + content;
                    }
                    if ($scope.rightIcon) {
                        content = content + " <span class=\"fa " + $scope.rightIcon + "\"></span>";
                    }
    
                    var $temp = angular.element("<div/>").html(content);
                    var $compiledContent = $compile($temp)($transcludedScope).contents();
                    
                    $a.empty();
                    $a.append($compiledContent);
                    
                    $element.on("$destroy", function () {
                        $transcludedScope.$destroy();
                    });
                });
            }
        };
    }]);

angular
    .module("app.core")
    .directive("mdActions", ["$timeout", "$injector", "ActionFactory", function ($timeout, $injector, ActionFactory) {
        
        return {
            restrict: "A",
            require: "?^mdContextProvider",
            link: function ($scope, $element, $attrs, mdContextProviderCtrl) {
    
                var debouncers = {};
                var eventDetailOnly = $attrs.mdActionsEventDetailOnly === "true";
    
                var actions = [];
    
                if ($attrs.mdActions === "from-callback" && $attrs.mdActionsCallbackFactory) {
        
                    var factory = $attrs.mdActionsCallbackFactory.split("#")[0];
                    var callback = $attrs.mdActionsCallbackFactory.split("#")[1];
                    if (factory && callback) {
    
                        $injector.get(factory)[callback]($element, $scope._schema.actions);
                    }
                    
                } else {
        
                    if ($attrs.mdActions === "from-schema") {
            
                        if ($scope._schema && $scope._schema.actions) {
                
                            actions = $scope._schema.actions;
                        }
            
                    } else {
            
                        actions = JSON.parse($attrs.mdActions || "[]");
                    }
        
                    if (actions.length) {
            
                        var boundActions = [];
            
                        actions.forEach(function (action) {
                
                            if (action.event && boundActions.indexOf(action.event) === -1) {
                    
                                switch (action.event) {
                        
                                    case "enter":
                                        $element.bind("keydown", function ($event) {
                                
                                            var key = $event.keyCode || $event.which;
                                            if (key === 13) {
                                    
                                                triggerEventActions($event, "enter", actions);
                                            }
                                        });
                                        break;
                        
                                    default:
                                        $element.bind(action.event, function ($event) {
                                
                                            triggerEventActions($event, action.event, actions);
                                        });
                                }
                                boundActions.push(action.event);
                            }
                        });
                    }
        
                    function getPertinentEventData($event) {
            
                        var data = {};
            
                        if (eventDetailOnly) {
                
                            data = $event.detail || {};
                
                        } else {
                
                            data = {
                                type: $event.type,
                                target: $event.target,
                                detail: $event.detail,
                                keyCode: $event.keyCode,
                                ctrlKey: $event.ctrlKey,
                                shiftKey: $event.shiftKey
                            };
                
                            if ($event.target && $event.target.hasOwnProperty("value")) {
                                data.value = $event.target.value;
                            }
                
                            if (mdContextProviderCtrl) {
                    
                                mdContextProviderCtrl.applyContextItemData(data);
                            }
                        }
            
                        return data;
                    }
        
                    function triggerEventActions($event, eventName, actions) {
            
                        var eventData = getPertinentEventData($event);
                        $timeout.cancel(debouncers[$event.type]);
                        debouncers[$event.type] = $timeout(function () {
                
                            ActionFactory.triggerEvent(eventName, actions, eventData, $event);
                        }, 100);
                    }
                }
            }
        };
    }]);
angular
    .module("app.core")
    .factory("InlineCSS", ["$rootScope", "$injector", "AssetFactory", function ($rootScope, $injector, AssetFactory) {

        var _allStyles = "";

        function add(styleData) {

            if (styleData) {

                var SchemaService = $injector.get("SchemaService"); // inject here to prevent circular dependencies with factory injection
                if (SchemaService.isPreview() || SchemaService.isLivePreview()) {

                    styleData = AssetFactory.rewriteAssetPaths(styleData);
                }

                _allStyles += styleData;
            }
        }

        function get() {

            return _allStyles;
        }

        return {
            add: add,
            get: get
        };
    }]);
angular
    .module("app.core")
    .directive("themes", ["InlineCSS", "$rootScope", function (InlineCSS, $rootScope) {

        return {

            restrict: "A",
            link: function () {

                $rootScope.$on("ConfigComplete", function () {

                    var data = InlineCSS.get();
                    if (data) {

                        var style = document.createElement("style");
                        style.textContent = data;
                        document.head.appendChild(style);
                    }
                });
            }
        };
    }]);

angular.module("app.core").directive("mdAttributes", ["StoreFactory", "$timeout", function (StoreFactory, $timeout) {
    return {
        "restrict": "A",
        "scope": {
            "mdAttributes": "="
        },
        "link": function ($scope, $element, $attrs) {
            var watches = {};
            var expressions = {};
            if ($attrs.mdExpressions) {
                expressions = angular.fromJson($attrs.mdExpressions);
            }
            if ($scope.mdAttributes != undefined) {
                angular.forEach($scope.mdAttributes, function (value, key) {
                    if (typeof value == "string" && value.indexOf("{{") > -1) {
                        watches[key] = value;
                    }
                });
            }
            $scope.setAttributes = function () {
                angular.forEach(watches, function (value, key) {
                    $attrs.$set(key, StoreFactory.parse(value));
                });
            };

            $scope.evalExpressions = function () {
                if (Object.keys(expressions).length > 0) {
                    angular.forEach(expressions, function (expression, key) {
                        switch (key) {
                            case "show":
                                var res = StoreFactory.evaluate(expression);
                                if (res === true) {
                                    $element.removeClass("ng-hide");
                                } else {
                                    $element.addClass("ng-hide");
                                }
                                break;
                        }
                    });
                }
            };

            $scope.$on("StoreChanged", function () {
                $scope.setAttributes();
                $scope.evalExpressions();
            });
            $timeout(function () {
                $scope.setAttributes();
                $scope.evalExpressions();
            });

        }
    };
}]);

angular
    .module("app.core")
    .directive("mdExpressions", ["$timeout", "StoreFactory", "TranslationService", function ($timeout, StoreFactory, TranslationService) {

        return {
            restrict: "A",
            require: "^form",
            link: function ($scope, $element, $attrs, FormController) {

                if ($attrs.mdExpressions) {

                    var expressionStates = {};
                    var expressions = JSON.parse($attrs.mdExpressions);
                    if (expressions && Object.keys(expressions).length) {

                        var thisScope = null;
                        var elementId = $attrs.id;

                        for (var cs = $scope.$$childHead; cs; cs = cs.$$nextSibling) {

                            if (cs.id === elementId) {
                                thisScope = cs;
                                break;
                            }
                        }

                        function evalExpressions(specificKeys) {

                            angular.forEach(expressions, function (expression, key) {

                                if (angular.isArray(specificKeys) && specificKeys.indexOf(key) === -1) return;
                                
                                if (expression.indexOf("$form.invalid") !== -1) {

                                    expression = expression.replace(/\$form\.invalid/g, FormController.$invalid);
                                }

                                var expressionResult = StoreFactory.evaluate(expression.toString(), $scope);

                                var hasLastResult = expressionStates.hasOwnProperty(key);
                                var lastResult = expressionStates[key];
                                if (!hasLastResult || !angular.equals(expressionResult, lastResult)) {

                                    expressionStates[key] = expressionResult;
                                    invokeExpression(key, expressionResult, $element, thisScope);
                                }
                            });
                        }
    
                        evalExpressions(["show", "disabled"]); // these expression can be acted on immediately to eliminate FOUC
                        $timeout(function () {
    
                            evalExpressions(["disabled", "label", "default"]); // these expressions have to be acted on after an immediate $timeout so that the digest cycle can correctly apply them
                            $scope.$watch(function () {
                                return FormController.$invalid;
                            }, function () {
                                evalExpressions();
                            });
                            $scope.$on("StoreChanged", function () {
                                evalExpressions();
                            });
                        });
                    }
                }

                function invokeExpression(key, expressionResult, element, elementScope) {

                    switch (key) {

                        case "show":
                            if (expressionResult === true) {
                                element.removeClass("ng-hide");
                            } else {
                                element.addClass("ng-hide");
                            }
                            break;

                        case "disabled":
                            if (elementScope) {

                                elementScope.disabled = expressionResult;
                            }
                            break;

                        case "label":
                            if (elementScope) {
                                
                                if (!elementScope.originalLabel) {
                                    elementScope.originalLabel = elementScope.label;
                                }
                                if (expressionResult) {
                                    elementScope.label = expressionResult;
                                } else if (elementScope.originalLabel) {
                                    elementScope.label = elementScope.originalLabel;
                                }
                            }
                            break;

                        case "default":
                            if (elementScope && elementScope.inputModel === undefined) {

                                if (elementScope.itemType === "select") {

                                    for (var i = 0; i < elementScope.options.length; i++) {
                                        if (elementScope.options[i].value === expressionResult) {
                                            elementScope.inputModel = elementScope.options[i];
                                            break;
                                        }
                                    }

                                } else {

                                    elementScope.inputModel = TranslationService.translate(expressionResult);
                                }
                            }
                            break;
                    }
                }
            }
        };
    }]);

/*
 * The whenReady directive allows you to execute the content of a when-ready
 * attribute after the element is ready (i.e. when it"s done loading all sub directives and DOM
 * content). See: http://stackoverflow.com/questions/14968690/sending-event-when-angular-js-finished-loading
 *
 * Execute multiple expressions in the when-ready attribute by delimiting them
 * with a semi-colon. when-ready="doThis(); doThat()"
 *
 * Optional: If the value of a wait-for-interpolation attribute on the
 * element evaluates to true, then the expressions in when-ready will be
 * evaluated after all text nodes in the element have been interpolated (i.e.
 * {{placeholders}} have been replaced with actual values).
 *
 * Optional: Use a ready-check attribute to write an expression that
 * specifies what condition is true at any given moment in time when the
 * element is ready. The expression will be evaluated repeatedly until the
 * condition is finally true. The expression is executed with
 * requestAnimationFrame so that it fires at a moment when it is least likely
 * to block rendering of the page.
 *
 * If wait-for-interpolation and ready-check are both supplied, then the
 * when-ready expressions will fire after interpolation is done *and* after
 * the ready-check condition evaluates to true.
 *
 * Caveats: if other directives exists on the same element as this directive
 * and destroy the element thus preventing other directives from loading, using
 * this directive won"t work. The optimal way to use this is to put this
 * directive on an outer element.
 */
angular.module("app.core").directive("mdDomReady", ["$interpolate", function ($interpolate) {

    return {
        restrict: "A",
        priority: Number.MIN_SAFE_INTEGER, // execute last, after all other directives if any.
        link: function ($scope, $element, $attributes) {

            var expressions = $attributes.mdDomReady.split(";");
            var waitForInterpolation = false;
            var hasReadyCheckExpression = false;

            function evalExpressions(expressions) {

                expressions.forEach(function (expression) {

                    $scope.$eval(expression);
                });
            }

            if ($attributes.mdDomReady.trim().length === 0) {

                return;
            }

            if ($attributes.waitForInterpolation && $scope.$eval($attributes.waitForInterpolation)) {

                waitForInterpolation = true;
            }

            if ($attributes.readyCheck) {

                hasReadyCheckExpression = true;
            }

            if (waitForInterpolation || hasReadyCheckExpression) {

                requestAnimationFrame(function checkIfReady() {

                    var isInterpolated = false;
                    var isReadyCheckTrue = false;

                    if (waitForInterpolation && $element.text().indexOf($interpolate.startSymbol()) >= 0) { // if the text still has {{placeholders}}

                        isInterpolated = false;

                    } else {

                        isInterpolated = true;
                    }

                    if (hasReadyCheckExpression && !$scope.$eval($attributes.readyCheck)) { // if the ready check expression returns false

                        isReadyCheckTrue = false;

                    } else {

                        isReadyCheckTrue = true;
                    }

                    if (isInterpolated && isReadyCheckTrue) {

                        evalExpressions(expressions);

                    } else {

                        requestAnimationFrame(checkIfReady);
                    }

                });
            } else {

                evalExpressions(expressions);
            }
        }
    };
}]);

angular.module("app.core").directive("openDocument", ["electron", "Plugin", "StoreFactory", function (electron, Plugin, StoreFactory) {
    return {
        restrict: "E",
        scope: {
            "classes": "@"},
        template: [
            "<button class=\"btn btn-primary {{classes}}\" ng-disabled=\"!document\" ng-click=\"open()\">",
            "   <span class=\"icon\" ng-class=\"{'icon-file-pdf': (type == 'pdf'), 'icon-file-word': (type == 'worddocument')}\"></span> Open Document",
            "</button>"
        ].join(""),
        link: function ($scope, $element, $attrs) {
            
            $scope.type = $attrs.itemType;
            $scope.document = undefined;

            if ($attrs.static === undefined || $attrs.static === "true") {
                $scope.document = $attrs.path;
            } else {
                $scope.document = StoreFactory.getForElement($attrs.model, $element);
                $scope.$watch(function () {
                    return StoreFactory.getForElement($attrs.model, $element);
                }, function (newValue) {
                    $scope.document = newValue;
                }, true);
            }

            $scope.open = function () {
                var fileopener = Plugin.getSource("fileopener");
                if (fileopener !== false) {
                    fileopener.openFile(function () {
                    }, function () {
                    }, $scope.document);
                } else if (electron.shell) {
                    var uri = $scope.document;
                    if (uri.indexOf("user-assets") != -1) {
                        uri = electron.app.getAppPath() + electron.path.sep + "www" + electron.path.sep + uri;
                    }
                    electron.shell.openItem(uri);
                } else {
                    window.open($scope.document, "_blank");
                }
            };

            document.addEventListener("media-deleted", function (ev) {
                if (ev.detail.location === $scope.document) {
                    $scope.document = undefined;
                }
            });
        }
    };
}]);

angular.module("app.core").directive("imageViewer", ["StoreFactory", "ActionFactory", "Plugin", "electron", function (StoreFactory, ActionFactory, Plugin, electron) {
    return {
        restrict: "E",
        templateUrl: "components/mdDynamicForm/imageViewer/imageViewer.tpl.html",
        scope: {
            "src": "@",
            "model": "@",
            "actions": "=",
            "classes": "@",
            "scaleImage": "=",
            "openExternallyOnClick": "=",
            "maxWidth": "@",
            "maxHeight": "@"
        },
        link: function ($scope, $element) {

            $scope.multiple = false;
            $scope.image = undefined;

            function assignValueFromStore(newValue) {

                if (angular.isArray(newValue)) {

                    $scope.image = newValue[newValue.length - 1];

                } else {

                    $scope.image = newValue;
                }
            }

            if ($scope.model !== undefined) {

                var initialValue = StoreFactory.getForElement($scope.model, $element);

                assignValueFromStore(initialValue);

                $scope.$watch(function () {

                    return StoreFactory.getForElement($scope.model, $element);

                }, function (newValue) {

                    assignValueFromStore(newValue);
                }, true);

            } else if ($scope.src !== undefined && $scope.src != "") {

                $scope.image = $scope.src;
            }

            $scope.close = function () {
                var $element = document.querySelector("#mediaViewerDisplayUi");
                document.body.removeChild($element);
            };

            $scope.open = function () {

                if ($scope.openExternallyOnClick) {
                    var fileOpener = Plugin.getSource("fileopener");
                    if (fileOpener !== false) {
                        fileOpener.openFile(function () {
                        }, function () {
                        }, $scope.src);
                    } else if (electron.shell) {
                        var uri = $scope.src;
                        if (uri.indexOf("user-assets") != -1) {
                            uri = electron.app.getAppPath() + electron.path.sep + "www" + electron.path.sep + uri;
                        }
                        electron.shell.openItem(uri);
                    } else {
                        window.open($scope.src, "_blank");
                    }
                }

                ActionFactory.triggerEvent("click", $scope.actions);
            };

            document.addEventListener("media-deleted", function (ev) {

                if (ev.detail.location === $scope.image) {

                    $scope.image = undefined;
                }

            });
        }
    };
}]);
angular.module("app.core").directive("mediaPlayer", ["StoreFactory", function (StoreFactory) {
    return {
        restrict: "E",
        templateUrl: "components/mdDynamicForm/mediaPlayer/mediaPlayer.tpl.html",
        scope: {
            "src": "@",
            "model": "@",
            "multiple": "@",
            "actions": "=",
            "classes": "@",
            "itemType": "@",
            "name": "@"
        },
        link: function ($scope, $element) {

            function assignModelValue(value) {

                if (angular.isArray(value)) {
                    $scope.src = (value.length > 0) ? value[value.length - 1] : "";
                } else {
                    $scope.src = (value !== undefined) ? value : "";
                }
            }

            if ($scope.src === undefined && $scope.model !== undefined) {

                $scope.$watch(function () {
                    return StoreFactory.getForElement($scope.model, $element);

                }, function (newValue) {

                    assignModelValue(newValue);

                }, true);

                var modelVal = StoreFactory.getForElement($scope.model, $element);
                assignModelValue(modelVal);

                $scope.fileType = $scope.itemType == "video" ? "video/mp4" : "";
            }
        }
    };
}]).filter("trusted", ["$sce", function ($sce) {

    return function (url) {

        if (url !== undefined && typeof url == "string") {

            return $sce.trustAsResourceUrl(url);
        }

        return undefined;
    };
}]);


angular.module("app.core").directive("audioPlayer", ["$log", "AudioPlayer", "ActionFactory", "$rootScope", function ($log, AudioPlayer, ActionFactory, $rootScope) {
    return {
        restrict: "E",
        templateUrl: "components/mdDynamicForm/mediaPlayer/audioPlayer.tpl.html",
        scope: {
            "src": "@",
            "actions": "="
        },
        controllerAs: "ap",
        controller: ["$scope", "$element", function ($scope, $element) {

            var vm = this;

            var defaultInfo = {
                "state": null,
                "totalTime": "0:00",
                "duration": 0,
                "currentTime": "0:00",
                "position": 0
            };

            vm.info = angular.copy(defaultInfo);

            var $filler = $element[0].getElementsByClassName("filler")[0];

            vm.getInfo = function (src) {
                
                AudioPlayer.getDuration(src, function (duration, totalTime) {
                    vm.info.duration = duration;
                    vm.info.totalTime = totalTime;
                    vm.info.state = "stopped";
                });
            };
            vm.getInfo($scope.src);

            vm.button = function () {
                
                if (vm.info.state === null) {
                    return;
                }
                
                switch (vm.info.state) {
                    
                    case "running":
                        pauseAudio();
                        break;
                        
                    case "paused":
                        unpauseAudio();
                        break;
                        
                    case "stopped":
                    case "released":
                        playAudio();
                        break;
                }
            };

            function playAudio() {
                
                AudioPlayer.play($scope.src, {}, function (info) {
                       
                    // Windows Phone needs a $apply :(
                    if (!$rootScope.$$phase) {
                        $rootScope.$apply(function () {
                            updateUi(info);
                        });
                    } else {
                        updateUi(info);
                    }
                });
            }
            
            function pauseAudio() {
                
                AudioPlayer.pause();
            }
            
            function unpauseAudio() {
                
                AudioPlayer.unpause();
            }
            
            function stopAudio() {
                
                AudioPlayer.stop();
            }
    
            function updateUi(info) {
                
                if (info.state !== vm.info.state) {
                    
                    handleStateChange(info.state);
                }
                
                vm.info.currentTime = info.currentTime;
                vm.info.position = info.position;
                vm.info.state = info.state;
        
                var percent = parseInt(Math.ceil((vm.info.position / vm.info.duration) * 100).toFixed(0));
                if (percent <= 100) {
                    $filler.style.width = percent + "%";
                }
                if (percent === 100) {
                    stopAudio();
                }
            }
    
            function resetUi() {
        
                vm.info = angular.copy(defaultInfo);
                $filler.style.width = "0%";
            }
    
            function handleStateChange(state) {
        
                switch (state) {
            
                    case "playing":
                        triggerActions("play-audio");
                        break;
            
                    case "paused":
                        triggerActions("pause-audio");
                        break;
            
                    case "stopped":
                        triggerActions("stop-audio");
                        break;
                }
            }
            
            function triggerActions(actionType) {
                
                ActionFactory.triggerEvent(actionType, $scope.actions);
            }

            $scope.$watch("src", function (newSrc, oldSrc) {
                if (newSrc !== oldSrc) {
                    if (newSrc != "") {
                        vm.getInfo(newSrc);
                    } else {
                        resetUi();
                    }
                }

            });

            document.addEventListener("media-deleted", function (ev) {

                if (ev.detail.location === $scope.src) {

                    stopAudio();
                    resetUi();
                }
            });
        }]
    };
}]);

angular.module("app.core").directive("recordAudio", ["StoreFactory", "$interval", "$log", "ActionFactory", "$timeout", "Plugin", "$q", "FileSystem", function (StoreFactory, $interval, $log, ActionFactory, $timeout, Plugin, $q, FileSystem) {
    return {
        restrict: "E",
        templateUrl: "components/mdDynamicForm/fields/record-audio.tpl.html",
        scope: {
            "name": "@",
            "mediaid": "@",
            "label": "@",
            "actions": "=",
            "classes": "@",
            "smallrecorder": "=",
            "multiple": "="
        },
        link: function ($scope, $element) {

            $scope.media = null;

            var Media = Plugin.getSource("Media"),
                _recordTimer = null;

            var page = $scope.$parent.$parent.page || $scope.$parent.$parent.$parent.page;
            $scope.pageName = page.name;
            
            var modelLocation = "$store.media." + $scope.mediaid + ".audio";

            var initialValue = StoreFactory.getForElement(modelLocation, $element);
            if (initialValue !== null && initialValue !== undefined && angular.isArray(initialValue) && initialValue.length > 0) {
                $scope.isPopulated = true;
            }

            $scope.currentTime = formatTime(0);
            $scope.uiState = false;

            function getFileName() {
                var deferred = $q.defer();

                var d = new Date();
                var n = d.getTime();

                var fileName = n + ".m4a";

                FileSystem.getStorageLocation().then(function (location) {
                    if (location.indexOf("file://") === 0) {
                        location = location.replace("file://", "");
                    }
                    var recordPath = location + fileName;
                    deferred.resolve(recordPath);
                }).catch(function (error) {
                    $log.error(error);
                });

                return deferred.promise;
            }

            function formatTime(time) {
                var mins = Math.floor(time / 60),
                    seconds = Math.floor(time % 60);

                return "" + mins + ":" + (seconds < 10 ? "0" : "") + seconds;
            }

            function startRecording() {
                $log.debug("Start recording...");
                initNewMedia().then(function () {
                    var options = {
                        SampleRate: 44100,
                        NumberOfChannels: 1
                    };

                    $scope.media.startRecordWithCompression(null, options);

                    ActionFactory.triggerEvent("recording-started", $scope.actions);

                    if (_recordTimer !== null) {
                        $interval.cancel(_recordTimer);
                    }

                    var recordTimeStart = null;

                    _recordTimer = $interval(function () {
                        if ($scope.state === Media.MEDIA_RUNNING) {
                            if (recordTimeStart === null) {
                                recordTimeStart = Date.now();
                            }
                            var currentTime = Date.now();
                            var dif = recordTimeStart - currentTime;

                            var secondsDiff = dif / 1000;
                            var absSecondsDiff = Math.abs(secondsDiff);

                            $scope.currentTime = formatTime(absSecondsDiff);
                        }
                    });

                });

            }

            function stopRecording() {
                if ($scope.media !== null) {
                    $scope.media.stopRecord();
                    $interval.cancel(_recordTimer);
                }
            }

            function updateModel() {

                $log.debug("Finished recording.");

                var modelVal = StoreFactory.getForElement(modelLocation, $element);
                if (modelVal === null || modelVal === undefined || !angular.isArray(modelVal)) {
                    modelVal = [];
                }
                if ($scope.multiple) {
                    modelVal.push($scope.media.src);
                } else {
                    modelVal[0] = $scope.media.src;
                }

                $log.debug("Saving filename:", $scope.media.src);

                StoreFactory.set(modelLocation, modelVal);
                $scope.isPopulated = true;

                ActionFactory.triggerEvent("recording-finished", $scope.actions);

            }

            function init(filePath) {
                $log.debug("Initialise new media object...");
                $scope.media = new Media(filePath, function () {
                }, function (error) {
                    $log.error(error);
                }, function (mediaStatus) {
                    $log.debug("State changing", $scope.state, mediaStatus);
                    $scope.$apply(function () {
                        $scope.state = mediaStatus;
                        switch ($scope.state) {
                            case Media.MEDIA_STOPPED:
                                updateModel();
                                $scope.media.release();
                                break;
                        }
                    });
                });
            }

            function initNewMedia() {
                var deferred = $q.defer();
                $log.debug("Get file name...");
                getFileName().then(function (filePath) {
                    $log.debug("Created filename:", filePath);
                    init(filePath);
                    deferred.resolve();
                });

                return deferred.promise;
            }

            $scope.recordButton = function () {
                switch ($scope.state) {
                    case Media.MEDIA_RUNNING:
                        stopRecording();
                        break;
                    case Media.MEDIA_PAUSED:
                    case Media.MEDIA_STOPPED:
                    case Media.MEDIA_NONE:
                    default:
                        startRecording();
                        break;
                }
            };

            var _resetUi = function () {
                $scope.isPopulated = false;
                $scope.currentTime = formatTime(0);
            };

            $scope.$watch(function () {
                return StoreFactory.getForElement(modelLocation, $element);
            }, function (newValue, oldValue) {
                if (newValue !== oldValue) {
                    if (newValue === undefined || (angular.isArray(newValue) && newValue.length === 0)) {
                        _resetUi();
                    }
                }
            });

            document.addEventListener("media-deleted", function (ev) {
                if ($scope.multiple !== true) {
                    var modelVal = StoreFactory.getForElement(modelLocation, $element)[0];
                    if ((ev.detail !== undefined && ev.detail.location === modelVal) || modelVal === undefined) {
                        _resetUi();
                    }
                }
            });

            document.addEventListener("stop-all-recording", function () {
                stopRecording();
            });
        }
    };
}]);

angular.module("app.core").directive("mediaGallery", ["StoreFactory", "MediaViewerDisplay", "ActionFactory", "$rootScope", function (StoreFactory, MediaViewerDisplay, ActionFactory, $rootScope) {
    return {
        restrict: "E",
        templateUrl: "components/mdDynamicForm/imageViewer/imageViewer.tpl.html",
        scope: {
            "sources": "=",
            "actions": "=",
            "classes": "@"
        },
        link: function ($scope, $element) {
            $scope.multiple = true;
            $scope.files = [];
            $scope.models = [];
            $scope.staticFiles = [];

            // Iterate through all sources and find which are dynamic
            for (var si = 0; si < $scope.sources.length; si++) {
                var source = $scope.sources[si];
                if (source.indexOf("{") > -1) {
                    // strip the curly braces out
                    var modelSrc = source.replace(/\{|}/g, "");
                    $scope.models.push(modelSrc);
                } else {
                    $scope.staticFiles.push($rootScope.assetDir + source);
                }
            }

            if ($scope.models !== undefined && $scope.models.length > 0) {
                $scope.models.forEach(function (modelString) {
                    $scope.$watch(function () {
                        return StoreFactory.getForElement(modelString, $element);
                    }, function () {
                        repopulateFileArray();
                    }, true);
                });

            }

            repopulateFileArray();

            function repopulateFileArray() {
                $scope.files = [];
                var dynamicFiles = [];
                $scope.staticFiles.forEach(function (staticFile) {
                    $scope.files.push(staticFile);
                });
                $scope.models.forEach(function (modelString) {
                    var modelValue = StoreFactory.getForElement(modelString, $element);
                    if (angular.isArray(modelValue)) {
                        modelValue.forEach(function (arrayItem) {
                            if (arrayItem !== undefined) {
                                dynamicFiles.push(arrayItem);
                            }
                        });
                    } else {
                        if (modelValue !== undefined) {
                            dynamicFiles.push(modelValue);
                        }
                    }
                });

                dynamicFiles.sort(function (a, b) {
                    var aParts = a.split("/");
                    var bParts = b.split("/");

                    // parse the times as ints, specifying base10 (because MDN tells us to!)
                    var aTime = parseInt(aParts[aParts.length - 1].split(".")[0], 10);
                    var bTime = parseInt(bParts[bParts.length - 1].split(".")[0], 10);

                    if (aTime > bTime) {
                        return 1;
                    }

                    if (aTime < bTime) {
                        return -1;
                    }

                    return 0;
                });

                dynamicFiles.forEach(function (dynamicFile) {
                    $scope.files.push(dynamicFile);
                });
            }

            $scope.getFileType = function (src) {
                if (src === undefined) {
                    return "none";
                }
                var fileParts = src.split(".");
                var extension = fileParts[fileParts.length - 1].toLowerCase();
                // check audio types, if none, assume image.
                return (extension === "aac" || extension === "m4a" || extension === "mp3" || extension === "wav") ? "audio" : "image";
            };

            $scope.getViewableFilePath = function (src) {
                if (src === undefined) {
                    return "";
                }

                var fileParts = src.split("/");
                return fileParts[fileParts.length - 1];
            };

            $scope.close = function () {
                var $element = document.querySelector("#mediaViewerDisplayUi");
                document.body.removeChild($element);
            };
            $scope.open = function ($index) {
                var imageURI = $scope.files[$index];
                if (imageURI !== undefined) {
                    MediaViewerDisplay.open(imageURI, $scope.actions).then(function (actionIdx) {
                        var action = $scope.actions[actionIdx];
                        if (action !== undefined) {
                            action.data.index = $index;
                            action.data.model = $scope.model;
                            ActionFactory.triggerEvent(null, [action]).then(function () {
                                $scope.close();
                            }).catch(function () {
                                $scope.close();
                            });
                        }
                    }).catch(function () {
                        $scope.close();
                    });
                }
            };

            document.addEventListener("media-deleted", function (ev) {

                var fileIndex = $scope.files.indexOf(ev.detail.location);

                if (fileIndex !== -1) {
                    // remove the item from the array
                    $scope.files = $scope.files.some(function (value) {
                        return value !== ev.detail.location;
                    });
                }

            });

        }
    };
}]);

angular.module("app.core").factory("MediaViewerDisplay", ["$q", "$compile", "$rootScope", function ($q, $compile, $rootScope) {
    var service = {
        "open": open
    };

    function open(src, actions) {
        var deferred = $q.defer();
        var $template = [
            "<div id=\"mediaViewerDisplayUi\" class=\"image-viewer-display-container\">",
            "   <div class=\"image-frame\">",
            "       <img ng-if=\"fileType === 'image'\" ng-src=\"{{src}}\" />",
            "       <audio-player ng-if=\"fileType === 'audio'\" class=\"col-md-4 col-xs-12\" item-type=\"{{fileType}}\" src=\"{{src | trusted}}\"></audio-player>",
            "   </div>",
            "   <div class=\"image-footer\">",
            "       <a ng-repeat=\"action in actions track by $index\" href=\"javascript:void(0)\" class=\"{{action.data.theme || ''}}\" ng-click=\"callAction($index)\">",
            "           <span ng-if=\"action.data['left-icon']\" class=\"fa {{action.data['left-icon']}}\"></span> {{action.data.label}} ",
            "           <span ng-if=\"action.data['right-icon']\" class=\"fa {{action.data['right-icon']}}\"></span>",
            "       </a>",
            "       <a href=\"javascript:void(0)\" ng-click=\"close()\" class=\"primary\">",
            "           <span class=\"fa fa-close\"></span> Close",
            "       </a>",
            "   </div>",
            "</div>"
        ].join("");
        var $scope = $rootScope.$new(true);
        $scope.src = src;
        $scope.actions = actions;
        var fileParts = $scope.src.split(".");
        var extension = fileParts[fileParts.length - 1];
        // check audio types, if none, assume image.
        $scope.fileType = (extension === "aac" || extension === "m4a" || extension === "mp3") ? "audio" : "image";
        $scope.close = function () {
            deferred.reject();
        };
        $scope.callAction = function (actionIdx) {
            deferred.resolve(actionIdx);
        };
        var $element = angular.element($compile($template)($scope))[0];
        document.body.appendChild($element);

        return deferred.promise;
    }

    return service;
}]);

angular.module("app.core").directive("mdThumbnail", ["$log", "Plugin", "Platform", function ($log, Plugin, Platform) {
    return {
        "restrict": "A",
        "scope": {
            "mdThumbnail": "@"
        },
        "link": function ($scope, $element, $attrs) {

            $scope.genThumb = function () {

                var maxWidth, maxHeight;

                try {

                    maxWidth = parseInt($attrs.mdThumbnailMaxwidth);
                    maxHeight = parseInt($attrs.mdThumbnailMaxheight);

                } catch (e) {
                    $log.debug("Failed to parse width and height from thumbnail");
                }

                if (maxWidth === undefined) {
                    maxWidth = 200;
                }

                if (maxHeight === undefined) {
                    maxHeight = 200;
                }

                var isSvg = $scope.mdThumbnail.toLowerCase().indexOf(".svg") > -1;

                if ($scope.mdThumbnail !== undefined && $scope.mdThumbnail != "" && !isSvg) {

                    var thumbnail = Plugin.getSource("thumbnail");
                    var isWinPhone = Platform.getName() === "winphone";

                    if (thumbnail !== false) {

                        thumbnail.makeThumbnail(function (data) {

                            $element.attr("src", data);

                        }, function (error) {

                            $log.error(error);

                        }, $scope.mdThumbnail, maxWidth, maxHeight, 100);
                    } else {

                        if (isWinPhone && $scope.mdThumbnail[0] !== "/" && $scope.mdThumbnail.length > 0) {

                            $scope.mdThumbnail = "/" + $scope.mdThumbnail;
                        }
                        $element.attr("src", $scope.mdThumbnail);
                    }
                } else if (isSvg) {
                    $element.attr("width", maxWidth);
                    $element.attr("height", maxHeight);
                    $element.attr("src", $scope.mdThumbnail);
                }
            };
            $scope.genThumb();
            $scope.$watch("mdThumbnail", function (newValue, oldValue) {

                if (newValue != oldValue) {
                    $scope.genThumb();
                }
            });
        }
    };
}]);

angular.module("app.core").directive("scrollableItem", function () {
    return {
        "restrict": "A",
        "scope": false,
        "controller": ["$scope", "$element", function ($scope, $element) {
            return {
                "scrollToBottom": function () {
                    $element[0].scrollTop = $element[0].scrollHeight;
                }
            };
        }]
    };
});

angular.module("app.core").directive("schemaSource", ["SchemaHelper", function (SchemaHelper) {
    return {
        "restrict": "A",
        "link": function ($scope, $element, $attrs) {
            var id = $attrs.schemaSource;
            if (id) {
                var schema = SchemaHelper.getSchemaByAutoId(id)[0];
                if (schema !== undefined) {
                    $scope._schema = schema;
                }
            }
        }
    };
}]);

angular
    .module("app.core")
    .directive("mdOnEnter", function () {
        return function (scope, element, attrs) {
            element.bind("keydown keypress", function (event) {
                if (event.which === 13) {
                    scope.$apply(function () {
                        scope.$eval(attrs.mdOnEnter);
                    });
                    event.preventDefault();
                }
            });
        };
    });
angular
    .module("app.core")
    .factory("DirectiveBridge", function () {
       
        var _registrations = [];
        
        function registerItemApi(pageName, itemName, api) {
            
            var existing = getItemRegistration(pageName, itemName);
            if (existing) {
                
                var idx = _registrations.indexOf(existing);
                _registrations[idx].api = api;
                
            } else {
                
                var id = generateItemId(pageName, itemName);
                _registrations.push({
                    id: id,
                    api: api
                });
            }
        }
        
        function getItemApi(pageName, itemName) {
            
            var registration = getItemRegistration(pageName, itemName);
            return registration && registration.api || null;
        }
        
        function getItemRegistration(pageName, itemName) {
            
            var id = generateItemId(pageName, itemName);
            return getRegistration(id);
        }
        
        function generateItemId(pageName, itemName) {
            
            return "page_" + pageName + "_item_" + itemName;
        }
        
        function getRegistration(id) {
            
            for (var i = 0; i < _registrations.length; i++) {
                
                if (_registrations[i].id === id) return _registrations[i];
            }
            return null;
        }
        
        return {
            "registerItemApi": registerItemApi,
            "getItemApi": getItemApi
        };
    });
angular
    .module("app.core")
    .factory("Utilities", function () {
        
        return {
            
            uuid: function () {
                
                var d = Date.now();
                if (window.performance && typeof window.performance.now === "function") {
                    d += performance.now(); // use high-precision timer if available
                }
                return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
                    var r = (d + Math.random() * 16) % 16 | 0;
                    d = Math.floor(d / 16);
                    return (c == "x" ? r : (r & 0x3 | 0x8)).toString(16);
                });
            },
            
            escapeForRegExp: function (string) {
                
                return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"); // $& means the whole matched string
            }
        };
        
    });

angular
    .module("app.core")
    .factory("MimeTypes", function () {

        var MEDIA_TYPES = {
            IMAGE: "image",
            AUDIO: "audio",
            VIDEO: "video"
        };

        var mappings = {
            "a": { mimeType: "application/octet-stream", mediaType: null },
            "ai": { mimeType: "application/postscript", mediaType: null },
            "aif": { mimeType: "audio/x-aiff", mediaType: MEDIA_TYPES.AUDIO },
            "aifc": { mimeType: "audio/x-aiff", mediaType: MEDIA_TYPES.AUDIO },
            "aiff": { mimeType: "audio/x-aiff", mediaType: MEDIA_TYPES.AUDIO },
            "au": { mimeType: "audio/basic", mediaType: MEDIA_TYPES.AUDIO },
            "avi": { mimeType: "video/x-msvideo", mediaType: null },
            "bat": { mimeType: "text/plain", mediaType: null },
            "bin": { mimeType: "application/octet-stream", mediaType: null },
            "bmp": { mimeType: "image/x-ms-bmp", mediaType: MEDIA_TYPES.IMAGE },
            "c": { mimeType: "text/plain", mediaType: null },
            "cdf": { mimeType: "application/x-cdf", mediaType: null },
            "csh": { mimeType: "application/x-csh", mediaType: null },
            "css": { mimeType: "text/css", mediaType: null },
            "dll": { mimeType: "application/octet-stream", mediaType: null },
            "doc": { mimeType: "application/msword", mediaType: null },
            "docm": { mimeType: "application/vnd.ms-word.document.macroEnabled.12", mediaType: null },
            "docx": { mimeType: "application/vnd.openxmlformats-officedocument.wordprocessingml.document", mediaType: null },
            "dot": { mimeType: "application/msword", mediaType: null },
            "dotx": { mimeType: "application/vnd.openxmlformats-officedocument.wordprocessingml.template", mediaType: null },
            "dvi": { mimeType: "application/x-dvi", mediaType: null },
            "eml": { mimeType: "message/rfc822", mediaType: null },
            "eps": { mimeType: "application/postscript", mediaType: null },
            "etx": { mimeType: "text/x-setext", mediaType: null },
            "exe": { mimeType: "application/octet-stream", mediaType: null },
            "gif": { mimeType: "image/gif", mediaType: MEDIA_TYPES.IMAGE },
            "gtar": { mimeType: "application/x-gtar", mediaType: null },
            "h": { mimeType: "text/plain", mediaType: null },
            "hdf": { mimeType: "application/x-hdf", mediaType: null },
            "htm": { mimeType: "text/html", mediaType: null },
            "html": { mimeType: "text/html", mediaType: null },
            "jpe": { mimeType: "image/jpe", mediaType: MEDIA_TYPES.IMAGE },
            "jpeg": { mimeType: "image/jpeg", mediaType: MEDIA_TYPES.IMAGE },
            "jpg": { mimeType: "image/jpeg", mediaType: MEDIA_TYPES.IMAGE, preferred: true },
            "js": { mimeType: "application/javascript", mediaType: null },
            "json": { mimeType: "application/json", mediaType: null },
            "ksh": { mimeType: "text/plain", mediaType: null },
            "latex": { mimeType: "application/x-latex", mediaType: null },
            "m1v": { mimeType: "video/mpeg", mediaType: MEDIA_TYPES.VIDEO },
            "m4a": { mimeType: "audio/mpeg", mediaType: MEDIA_TYPES.AUDIO, preferred: true },
            "man": { mimeType: "application/x-troff-man", mediaType: null },
            "me": { mimeType: "application/x-troff-me", mediaType: null },
            "mht": { mimeType: "message/rfc822", mediaType: null },
            "mhtml": { mimeType: "message/rfc822", mediaType: null },
            "mif": { mimeType: "application/x-mif", mediaType: null },
            "mov": { mimeType: "video/quicktime", mediaType: MEDIA_TYPES.VIDEO },
            "movie": { mimeType: "video/x-sgi-movie", mediaType: MEDIA_TYPES.VIDEO },
            "mp2": { mimeType: "audio/mpeg", mediaType: MEDIA_TYPES.AUDIO },
            "mp3": { mimeType: "audio/mp3", mediaType: MEDIA_TYPES.AUDIO },
            "mp4": { mimeType: "video/mp4", mediaType: MEDIA_TYPES.VIDEO },
            "mpa": { mimeType: "video/mpeg", mediaType: MEDIA_TYPES.VIDEO },
            "mpe": { mimeType: "video/mpeg", mediaType: MEDIA_TYPES.VIDEO },
            "mpeg": { mimeType: "video/mpeg", mediaType: MEDIA_TYPES.VIDEO },
            "mpg": { mimeType: "video/mpeg", mediaType: MEDIA_TYPES.VIDEO, preferred: true },
            "ms": { mimeType: "application/x-troff-ms", mediaType: null },
            "nc": { mimeType: "application/x-netcdf", mediaType: null },
            "nws": { mimeType: "message/rfc822", mediaType: null },
            "o": { mimeType: "application/octet-stream", mediaType: null },
            "obj": { mimeType: "application/octet-stream", mediaType: null },
            "oda": { mimeType: "application/oda", mediaType: null },
            "otf": { mimeType: "application/x-font-opentype", mediaType: null },
            "pbm": { mimeType: "image/x-portable-bitmap", mediaType: MEDIA_TYPES.IMAGE },
            "pdf": { mimeType: "application/pdf", mediaType: null },
            "pfx": { mimeType: "application/x-pkcs12", mediaType: null },
            "pgm": { mimeType: "image/x-portable-graymap", mediaType: MEDIA_TYPES.IMAGE },
            "png": { mimeType: "image/png", mediaType: MEDIA_TYPES.IMAGE },
            "pnm": { mimeType: "image/x-portable-anymap", mediaType: MEDIA_TYPES.IMAGE },
            "po": { mimeType: "text/x-gettext-translation", mediaType: null },
            "pot": { mimeType: "application/vnd.ms-powerpoint", mediaType: null },
            "ppa": { mimeType: "application/vnd.ms-powerpoint", mediaType: null },
            "ppm": { mimeType: "image/x-portable-pixmap", mediaType: MEDIA_TYPES.IMAGE },
            "pps": { mimeType: "application/vnd.ms-powerpoint", mediaType: null },
            "ppt": { mimeType: "application/vnd.ms-powerpoint", mediaType: null },
            "pptm": { mimeType: "application/vnd.ms-powerpoint.presentation.macroEnabled.12", mediaType: null },
            "pptx": { mimeType: "application/vnd.openxmlformats-officedocument.presentationml.presentation", mediaType: null },
            "ps": { mimeType: "application/postscript", mediaType: null },
            "pwz": { mimeType: "application/vnd.ms-powerpoint", mediaType: null },
            "py": { mimeType: "text/x-python", mediaType: null },
            "pyc": { mimeType: "application/x-python-code", mediaType: null },
            "pyo": { mimeType: "application/x-python-code", mediaType: null },
            "qt": { mimeType: "video/quicktime", mediaType: MEDIA_TYPES.VIDEO },
            "ra": { mimeType: "audio/x-pn-realaudio", mediaType: MEDIA_TYPES.AUDIO },
            "ram": { mimeType: "application/x-pn-realaudio", mediaType: MEDIA_TYPES.AUDIO },
            "ras": { mimeType: "image/x-cmu-raster", mediaType: MEDIA_TYPES.IMAGE },
            "rdf": { mimeType: "application/xml", mediaType: null },
            "rgb": { mimeType: "image/x-rgb", mediaType: MEDIA_TYPES.IMAGE },
            "roff": { mimeType: "application/x-troff", mediaType: null },
            "rtx": { mimeType: "text/richtext", mediaType: null },
            "sgm": { mimeType: "text/x-sgml", mediaType: null },
            "sgml": { mimeType: "text/x-sgml", mediaType: null },
            "sh": { mimeType: "application/x-sh", mediaType: null },
            "shar": { mimeType: "application/x-shar", mediaType: null },
            "snd": { mimeType: "audio/basic", mediaType: MEDIA_TYPES.AUDIO },
            "so": { mimeType: "application/octet-stream", mediaType: null },
            "src": { mimeType: "application/x-wais-source", mediaType: null },
            "svg": { mimeType: "image/svg+xml", mediaType: MEDIA_TYPES.IMAGE },
            "swf": { mimeType: "application/x-shockwave-flash", mediaType: null },
            "t": { mimeType: "application/x-troff", mediaType: null },
            "tar": { mimeType: "application/x-tar", mediaType: null },
            "tcl": { mimeType: "application/x-tcl", mediaType: null },
            "tex": { mimeType: "application/x-tex", mediaType: null },
            "texi": { mimeType: "application/x-texinfo", mediaType: null },
            "texinfo": { mimeType: "application/x-texinfo", mediaType: null },
            "tif": { mimeType: "image/tiff", mediaType: MEDIA_TYPES.IMAGE },
            "tiff": { mimeType: "image/tiff", mediaType: MEDIA_TYPES.IMAGE },
            "tr": { mimeType: "application/x-troff", mediaType: null },
            "tsv": { mimeType: "text/tab-separated-values", mediaType: null },
            "ttf": { mimeType: "application/x-font-truetype", mediaType: null },
            "txt": { mimeType: "text/plain", mediaType: null, preferred: true },
            "ustar": { mimeType: "application/x-ustar", mediaType: null },
            "vcf": { mimeType: "text/x-vcard", mediaType: null },
            "wav": { mimeType: "audio/x-wav", mediaType: MEDIA_TYPES.AUDIO },
            "woff": { mimeType: "application/font-woff", mediaType: null, preferred: true },
            "woff2": { mimeType: "application/font-woff", mediaType: null },
            "wsdl": { mimeType: "application/xml", mediaType: null },
            "xbm": { mimeType: "image/x-xbitmap", mediaType: MEDIA_TYPES.IMAGE },
            "xlb": { mimeType: "application/vnd.ms-excel", mediaType: null },
            "xls": { mimeType: "application/vnd.ms-excel", mediaType: null },
            "xlsm": { mimeType: "application/vnd.ms-excel.sheet.macroEnabled.12", mediaType: null },
            "xlsx": { mimeType: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet", mediaType: null },
            "xml": { mimeType: "text/xml", mediaType: null },
            "xpdl": { mimeType: "application/xml", mediaType: null },
            "xpm": { mimeType: "image/x-xpixmap", mediaType: MEDIA_TYPES.IMAGE },
            "xsl": { mimeType: "application/xml", mediaType: null },
            "xwd": { mimeType: "image/x-xwindowdump", mediaType: MEDIA_TYPES.IMAGE },
            "zip": { mimeType: "application/zip", mediaType: null }
        };

        /**
         * Obtains an appropriate mime type given a file extension
         * @param {string} extensionOrPath - The file name or file path of the file including the file extension
         * @returns {string|null} - An appropriate mime type for the file extension, or null if one not found
         */
        function mimeTypeFromExtension(extensionOrPath) {

            if (extensionOrPath.indexOf(".") != -1) {
                extensionOrPath = extensionOrPath.split(".").pop().toLowerCase();
            }

            if (mappings.hasOwnProperty(extensionOrPath)) {

                return mappings[extensionOrPath].mimeType;
            }

            return null;
        }

        /**
         * the media type of the file given a file extension
         * @param {string} extensionOrPath - The file name or file path of the file including the file extension
         * @returns {string|null} - The media type of the file, or null if not applicable
         */
        function mediaTypeFromExtension(extensionOrPath) {

            if (extensionOrPath.indexOf(".") != -1) {
                extensionOrPath = extensionOrPath.split(".").pop().toLowerCase();
            }

            if (mappings.hasOwnProperty(extensionOrPath)) {

                return mappings[extensionOrPath].mediaType;
            }

            return null;
        }

        /**
         * Obtains file extensions for a given mime type
         * @param {string} mimeType - The mime type
         * @returns {Array<string>} - A collection of file extensions for the mime type
         */
        function extensionsFromMimeType(mimeType) {

            var extensions = [];

            for (var extension in mappings) {
                if (mappings.hasOwnProperty(extension)) {
                    if (mappings[extension].mimeType.toLowerCase() === (mimeType || "").toLowerCase()) {
                        extensions.push(extension);
                    }
                }
            }

            return extensions;
        }

        /**
         * Obtains a suitable file extension for a given mime type
         * @param {string} mimeType - The mime type of the file
         * @returns {string|null} - A appropriate file extension for the mime type, or null if one not found
         */
        function extensionFromMimeType(mimeType) {

            var extensions = [];

            for (var extension in mappings) {
                if (mappings.hasOwnProperty(extension)) {
                    if (mappings[extension].mimeType.toLowerCase() === (mimeType || "").toLowerCase()) {
                        extensions.push({ extension: extension, preferred: mappings[extension].preferred || false });
                    }
                }
            }

            if (extensions.length == 1) { // if only one file extension matches the mime type
                return extensions[0].extension;
            }

            if (extensions.length > 1) { // if multiple file extensions match the mime type
                for (var i = 0; i < extensions.length; i++) {
                    if (extensions[i].preferred === true) { // return preferred extension if one is set
                        return extensions[i].extension;
                    }
                }
                return extensions[0].extension; // otherwise return first match
            }

            return null; // no file extensions match the mime type
        }

        /**
         * Obtains the media type of the file given a mime type
         * @param {string} mimeType - The mime type of the file
         * @returns {string|null} - The media type of the file, or null if not applicable
         */
        function mediaTypeFromMimeType(mimeType) {

            for (var extension in mappings) {

                if (mappings.hasOwnProperty(extension)) {

                    if (mappings[extension].mimeType.toLowerCase() === (mimeType || "").toLowerCase()) {
                        return mappings[extension].mediaType;
                    }
                }
            }
            return null;
        }

        return {

            "MEDIA_TYPES": MEDIA_TYPES,
            "mimeTypeFromExtension": mimeTypeFromExtension,
            "mediaTypeFromExtension": mediaTypeFromExtension,
            "extensionsFromMimeType": extensionsFromMimeType,
            "extensionFromMimeType": extensionFromMimeType,
            "mediaTypeFromMimeType": mediaTypeFromMimeType
        };

    });
angular
    .module("app.core")
    .factory("StudioStorage",
        ["$q", function ($q) {

            var _db = null;
            var _cache = {};

            /**
             * Initialise the storage and obtain local cache of data
             * @returns {Promise}
             */
            function init(dbName) {

                var deferred = $q.defer();

                var _dbName = (dbName !== null) ? dbName : "com.commontime.infinity.studio";

                _db = new PouchDB(_dbName, {
                    // eslint-disable-next-line camelcase
                    revs_limit: 10
                });
                // eslint-disable-next-line camelcase
                _db.allDocs({ include_docs: true }).then(function (result) {

                    angular.forEach(result.rows, function (row) {

                        if (row.doc && row.doc._id) {
                            _cache[row.doc._id] = row.doc.data;
                        }
                    });

                    deferred.resolve();
                });

                return deferred.promise;
            }

            /**
             * Get data for a specific key
             * @param {string} key - The key to set the data against
             * @returns {string|null} - The data, or null if not present
             */
            function getData(key) {

                if (!key) throw new Error("key cannot be empty");

                return _cache[key] || null;
            }

            return {

                "init": init,
                "getData": getData
            };
        }]);

angular
    .module("app.core")
    .factory("SchemaHelper", ["$filter", function ($filter) {

        var service = {

            ITEM_AUTO_ID_PROPERTY: "_auto_id_",

            SCHEMA_CONTEXT_PREVIEW: 1,
            SCHEMA_CONTEXT_LIVE_PREVIEW: 2,

            schema: {},

            getSchemaConfigItemByName: getSchemaConfigItemByName,
            getSchemaConfigItemsByItemType: getSchemaConfigItemsByItemType,
            search: search,
            getItems: getItems,
            getLanguageSettings: getLanguageSettings,
            getSchemaByAutoId: getSchemaByAutoId,
            getSchemaSettingByName: getSchemaSettingByName,
            getAppName: getAppName
        };

        function getAppName() {
            return service.schema.name;
        }

        function getSchemaSettingByName(name) {
            return (service.schema.settings !== undefined) ? service.schema.settings[name] : undefined;
        }

        function getSchemaConfigItemByName(name) {
            return search("name", name, service.schema.config)[0];
        }

        function getSchemaConfigItemsByItemType(itemType) {
            return $filter("filter")(service.schema.config, { "item-type": itemType });
        }

        function search(key, value, data, includeActions) {
            data = (data !== undefined) ? data : service.schema;
            var objects = [];
            for (var i in data) {
                if (!data.hasOwnProperty(i)) continue;
                if (typeof data[i] == "object" && (includeActions === true || i != "actions")) {
                    objects = objects.concat(search(key, value, data[i], includeActions));
                } else if (i == key && data[key] == value) {
                    objects.push(data);
                }
            }
            return objects;
        }

        function getItems(collection, type, itemType) {

            var objectsOfType = JSON.search(collection, "//*[type=\"" + type + "\"]");
            return objectsOfType.filter(function (x) {
                return !itemType || x["item-type"] === itemType;
            });
        }

        function getLanguageSettings() {

            return (service.schema.language || {
                defaultLocale: "en_GB",
                initialLanguage: "",
                useDeviceLocale: true
            });
        }

        function getSchemaByAutoId(autoId) {
            return search("_auto_id_", autoId);
        }

        return service;

    }]);

angular
    .module("app.core")
    .factory("SchemaService", ["$injector", "$http", "$q", "$rootScope", "$log", "$templateCache", "$location", "StoreFactory", "PluginFactory", "$timeout", "localStorageService", "OptionFactory", "ApiFactory", "UrlFactory", "Timer", "InlineCSS", "VariableFactory", "$base64", "ActionFactory", "RouterConfig", "Router", "Auth", "SchemaHelper", "IBeaconFactory", "GeofenceFactory", "XmppFactory", "MessageQueueFactory", "Notification", "Platform", "DataflowFactory", "AzureAppServicesFactory", "RestFactory", "ActionflowFactory", "AssetFactory", "LoadingStatus", "ComponentFactory", "StudioStorage", "$interval", "Utilities", "WcUtils", "ListFactory", "LoggingFactory", "IncidentLayerFactory", "PagerLayerFactory", "UserManagementLayerFactory", "Plugin", "electron", function ($injector, $http, $q, $rootScope, $log, $templateCache, $location, StoreFactory, PluginFactory, $timeout, localStorageService, OptionFactory, ApiFactory, UrlFactory, Timer, InlineCSS, VariableFactory, $base64, ActionFactory, RouterConfig, Router, Auth, SchemaHelper, IBeaconFactory, GeofenceFactory, XmppFactory, MessageQueueFactory, Notification, Platform, DataflowFactory, AzureAppServicesFactory, RestFactory, ActionflowFactory, AssetFactory, LoadingStatus, ComponentFactory, StudioStorage, $interval, Utilities, WcUtils, ListFactory, LoggingFactory, IncidentLayerFactory, PagerLayerFactory, UserManagementLayerFactory, Plugin, electron) {

        var ITEM_AUTO_ID_PROPERTY = SchemaHelper.ITEM_AUTO_ID_PROPERTY;
        var L_ENDPOINT = "https://licensing.commontime.com";
        var ID_ENDPOINT = "https://identity.commontime.com";
        var _schema = null;
        var _originalSchema = null;
        var _jwtKey = null;
        var _appCodeKey = null;
        var _appCode = null;
        var _phoneHomeFrequency = 86400000; // 24 Hours
        var _phoneHomeInterval = null;
        var _dom = {};

        function getPageSchema(name) {
            var result = false;
            angular.forEach(_schema.content, function (page) {
                if (page.type == "page") {
                    if (page.name == name) {
                        result = page;
                    }
                }
            });
            return result;
        }

        function getDom() {
            return _dom;
        }

        function getAnimationLevel() {
            var level = 2;
            if (typeof _schema.animation != "undefined") {
                if (_schema.animation !== "off") {
                    level = (_schema.animation == "full") ? 2 : 1;
                } else {
                    level = 0;
                }
            }
            return level;
        }

        // Load the schema from a URL (Can be file system)
        function loadSchema(url) {

            var deferred = $q.defer();

            $http.get(url).then(function (response) {
                _schema = SchemaHelper.schema = response.data;
                deferred.resolve(_schema);
            }).catch(deferred.reject);

            return deferred.promise;
        }

        function authenticate(schema) {

            var deferred = $q.defer();

            if (schema.settings && schema.settings.auth === true) {
                Auth.authenticate().then(deferred.resolve, deferred.reject);
            } else {
                deferred.resolve();
            }

            return deferred.promise;
        }

        function addErrorPage() {

            Router.addRoute("/error", {
                template: [
                    "<div class=\"error-container\">",
                    "   <div class=\"alert alert-danger\">",
                    "       <span class=\"fa fa-exclamation-triangle\"></span> {{ $root.errorMessage || \"An unknown error has occurred\" }}",
                    "   </div>",
                    "   <div class=\"controls\">",
                    "       <a href=\"#\" class=\"btn md-btn btn-primary\" onclick=\"location.reload();\">",
                    "           <span class=\"fa fa-refresh\"></span> Reload",
                    "       </a>",
                    "   </div>",
                    "</div>"
                ].join("")
            });
        }

        function setUpPreferences() {
            
            var deferred = $q.defer();
            
            window.cti.store.preferences = {};
            
            $q.when()
                .then(function () {
                    return applyAppMetadata(); // 1st: Metadata configured in app
                })
                .then(function () {
                    return applyPreferences(); // 2nd: Preferences (config.xml or preferences.json, depending on platform)
                })
                .then(function () {
                    return applyEmmAppConfig(); // 3rd: EMM App Config
                })
                .then(function () {
                    return applyLocalStorageConfig(); // 4th: LocalStorage App Config
                })
                .then(function () {
                    deferred.resolve();
                });
            
            function updatePreferenceValues(valuesObject) {
                
                if (!valuesObject) return;
                
                angular.forEach(valuesObject, function (value, key) {
                    window.cti.store.preferences[key] = value;
                });
            }
            
            function applyAppMetadata() {
                
                var metadataDeferred = $q.defer();
                
                angular.forEach(_schema.metadata, function (value) {
                    window.cti.store.preferences[value.key] = value.value;
                });
                
                metadataDeferred.resolve();
                
                return metadataDeferred.promise;
            }
            
            function applyPreferences() {
                
                var preferencesDeferred = $q.defer();
                
                var preferencesPlugin = Plugin.getSource("preferences");
                if (preferencesPlugin) {
                    
                    preferencesPlugin.getAllPreferences(function (configXmlPreferences) {
                        
                        updatePreferenceValues(configXmlPreferences);
                        preferencesDeferred.resolve();
                        
                    }, function (error) {
                        
                        $log.error("Error obtaining preferences", error);
                        preferencesDeferred.resolve();
                        
                    });
                    
                } else if (electron && electron.app && typeof (require) === "function") {
                    
                    // Note: doesn't currently work in live preview due to where the files get staged from vs. where the shell is executed from
                    if (isLivePreview()) {
                     
                        preferencesDeferred.resolve();
                    
                    } else {
                        
                        var preferencesJsonPath = isPreview()
                            ? "./client/preferences.json"
                            : "./preferences.json";
    
                        var preferencesJson = require(preferencesJsonPath);
                        updatePreferenceValues(preferencesJson);
                        preferencesDeferred.resolve();
                    }
                    
                } else {
                    
                    preferencesDeferred.resolve();
                }
                
                return preferencesDeferred.promise;
            }
            
            var emmAppConfigPlugin = Plugin.getSource("EmmAppConfig");
            
            function applyEmmAppConfig() {
                
                if (!emmAppConfigPlugin) return $q.when();
                
                var emmConfigDeferred = $q.defer();
                
                var emmAppConfig = emmAppConfigPlugin._appConfig;
                if (emmAppConfig) {
                    
                    var applicableItems = {};

                    if (emmAppConfig["RELEASE_DEBUGGING"] !== undefined) {
                        var prefsPlugin = Plugin.getSource("preferences");
                        if (prefsPlugin) {
                            if (emmAppConfig["RELEASE_DEBUGGING"] == "true") {
                                prefsPlugin.enableWebDebugging(true);
                            } else {
                                prefsPlugin.enableWebDebugging(false);
                            }
                        }
                        applicableItems["RELEASE_DEBUGGING"] = emmAppConfig["RELEASE_DEBUGGING"];
                    }

                    angular.forEach(emmAppConfig, function (item, key) {
                        applicableItems[key] = item;
                    });
                    
                    updatePreferenceValues(applicableItems);
                }
                
                emmConfigDeferred.resolve();
                
                return emmConfigDeferred.promise;
            }

            function applyLocalStorageConfig() {

                var localStorageConfigDeferred = $q.defer();

                var applicableItems = {};

                angular.forEach(window.cti.store.preferences, function (value, key) {
                    var localStorageValue = localStorageService.get(key);
                    if (localStorageValue) {
                        applicableItems[key] = localStorageValue;
                    }
                });

                updatePreferenceValues(applicableItems);

                localStorageConfigDeferred.resolve();

                return localStorageConfigDeferred.promise;
            }
            
            var debounce = function (func, wait) {
                
                var timeout;
                return function () {
                    var context = this;
                    var args = arguments;
                    var later = function () {
                        timeout = null;
                        func.apply(context, args);
                    };
                    clearTimeout(timeout);
                    timeout = setTimeout(later, wait || 200);
                };
            };
            
            var handleEmmAppConfigChange = debounce(function () {
                
                applyEmmAppConfig()
                    .then(function () {

                        var item = SchemaHelper.getSchemaConfigItemsByItemType("onappconfigchange");
                        if (item && item.length > 0) {
                            ActionFactory.triggerEvent("onappconfigchange", item[0].actions, emmAppConfigPlugin._appConfig);
                        }
                    });
            }, 400);
            
            if (emmAppConfigPlugin) {
                
                emmAppConfigPlugin.registerChangedListener(handleEmmAppConfigChange);
            }
            
            return deferred.promise;
        }

        // build the DOM using the loaded schema
        function buildDom() {

            var deferred = $q.defer();

            $rootScope.appName = _schema.name;
            $rootScope.cancelable = (_schema.cancelable === true);
            $rootScope.basedir = (_schema.basedir == undefined) ? "" : _schema.basedir;
            $rootScope.assetDir = (_schema.assetDir !== undefined) ? _schema.assetDir : "user-assets/";
            $rootScope.componentDir = (_schema.componentDir !== undefined) ? _schema.componentDir : "components/";

            // Create stack store
            RouterConfig.set("id", $rootScope.appName);

            // Create data store
            $log.debug("Initializing store...");
            StoreFactory.init($rootScope.appName, _schema).then(function () {
                Platform.init();
                $log.debug("Store initialized.");

                setUpPreferences().then(function () {
                    StoreFactory.save();
                    $log.debug("Preferences initialized.");

                    LoggingFactory.init($rootScope.appName);
                    if (_schema.settings !== undefined) {
                        if (_schema.settings.theme !== undefined && _schema.settings.theme != "") {
                            var $head = angular.element(document.querySelector("head"));
                            var $theme = angular.element("<link rel=\"stylesheet\" href=\"" + $rootScope.basedir + "assets/css/themes/" + _schema.settings.theme + ".css\" />");
                            $head.append($theme);
                        }
                        if (_schema.settings.router !== undefined) {
                            if (_schema.settings.router.mode !== undefined) {
                                RouterConfig.set("mode", _schema.settings.router.mode);
                            }
                            if (_schema.settings.router.animation !== undefined) {
                                RouterConfig.set("animation", _schema.settings.router.animation);
                            }
                        }
                        if (_schema.settings["push-notifications"] !== undefined) {
                            Notification.init(_schema);
                        }
                        if (_schema.settings["message-queue"] !== undefined) {
                            MessageQueueFactory.init(_schema);
                        }
                        LoadingStatus.disabled = (_schema.settings["loading-message"] === false);
                    }
                    if (_schema.dataflows !== undefined && _schema.dataflows.length > 0) {
                        _schema.dataflows.forEach(function (dataflow) {
                            DataflowFactory.init(dataflow.name, dataflow.content);
                        });
                    }
                    if (_schema.actionflows !== undefined && _schema.actionflows.length > 0) {
                        _schema.actionflows.forEach(function (actionflow) {
                            ActionflowFactory.init(actionflow.name, actionflow.content);
                        });
                    }
                    // Init options store
                    OptionFactory.init($rootScope.appName);
                    authenticate(_schema).then(function () {
                        // Set theme if any specified
                        if (_schema.config != undefined) {
                            var onloadItems = [];
                            angular.forEach(_schema.config, function (item) {
                                if (item.name != undefined) {
                                    switch (item["item-type"]) {
                                        case "onappload":
                                            // Save the onload items for later because we want to run them after other config items have initialised.
                                            onloadItems.push(item);
                                            break;
                                        case "api":
                                            if (item.url !== undefined) {
                                                ApiFactory.init(item);
                                            }
                                            break;
                                        case "offline-api":
                                            if (item.url !== undefined) {
                                                RestFactory.init();
                                                RestFactory.registerOfflineApi(item);
                                            }
                                            break;
                                        case "xmpp":
                                            if (item.endpoint !== undefined) {
                                                XmppFactory.init(item);
                                            }
                                            break;
                                        case "broadcastincidentlayer":
                                        case "responderincidentlayer":
                                            IncidentLayerFactory
                                                .load()
                                                .then(function () {
                                                    IncidentLayerFactory.init(item);
                                                });
                                            break;
                                        case "broadcastpagerlayer":
                                        case "responderpagerlayer":
                                            PagerLayerFactory
                                                .load()
                                                .then(function () {
                                                    PagerLayerFactory.init(item);
                                                });
                                            break;
                                        case "usermanagementlayer":
                                            UserManagementLayerFactory
                                                .load()
                                                .then(function () {
                                                    UserManagementLayerFactory.init(item);
                                                });
                                            break;
                                        case "plugin":
                                            PluginFactory.init(item);
                                            break;
                                        case "css":
                                            InlineCSS.add(item.content);
                                            break;
                                        case "variable":
                                            VariableFactory.init(item);
                                            break;
                                        case "function":
                                            StoreFactory.setFunction(item);
                                            break;
                                        case "js-asset":
                                            AssetFactory.injectJsAsset(item.fileName);
                                            break;
                                        case "css-asset":
                                            AssetFactory.injectCssAsset(item.fileName);
                                            break;
                                        case "url":
                                            UrlFactory.init(item);
                                            break;
                                        case "beacon":
                                            IBeaconFactory.init();
                                            IBeaconFactory.addBeacon(item);
                                            break;
                                        case "geofence":
                                            if (GeofenceFactory.isValidGeofenceObject(item)) {
                                                var uniqueName = "com.commontime.infinity." + _schema.name;
                                                GeofenceFactory.init(_schema.name, uniqueName);
                                                GeofenceFactory.register(item); // if plugin not ready at this point, will internally queue
                                            }
                                            break;
                                        case "timer":
                                            if (window.cti.__timers == undefined) {
                                                window.cti.__timers = {};
                                            }
                                            window.cti.__timers[item.name] = new Timer(item.name, item["timer-type"], item.time, item.actions);
                                            break;
                                        case "azure-app-services":
                                            AzureAppServicesFactory.init(item);
                                            break;
                                    }
                                }
                            });
                            if (onloadItems.length > 0) {
                                onloadItems.forEach(function (item) {
                                    ActionFactory.triggerEvent("onappload", item.actions);
                                });
                            }
                        }

                        // initialize lists and data grids in app
                        ListFactory.initializeListsForApp(_schema);

                        $injector.get("ctDataGrid").initializeDataGridsForApp(_schema);

                        // dynamically add web component scripts
                        if (_schema.components && _schema.components.length) {

                            _schema.components.forEach(function (component) {

                                switch (component.type) {

                                    case "web-component":
                                        var script = document.createElement("script");

                                        var componentFile = window.___supportsNativeWebComponents
                                            ? component.files.original
                                            : component.files.transpiled;

                                        var webComponentCodePath = $rootScope.componentDir + componentFile;
                                        script.setAttribute("src", webComponentCodePath);
                                        document.getElementsByTagName("body")[0].appendChild(script);
                                        break;

                                }
                            });

                            ComponentFactory.registerComponentInstances(_schema);
                        }
                        $rootScope.$emit("ConfigComplete");

                        var pageOnLoadedActions = {};

                        $rootScope.$on("onPageContentLoaded", function (e, args) {

                            if (pageOnLoadedActions[args.id] !== undefined) {

                                ActionFactory.triggerEvent(null, pageOnLoadedActions[args.id]);
                            }
                        });

                        var schemaCopy = angular.copy(_schema);
                        angular.forEach(schemaCopy.pages, function (page) {
                            var rootPageElement = angular.element("<div></div>");

                            var actions = [];
                            if (page.config !== undefined && page.config.length > 0) {
                                page.config.forEach(function (configItem) {
                                    if (configItem["item-type"] == "onpageload" && configItem.actions !== undefined && configItem.actions.length > 0) {
                                        configItem.actions.forEach(function (configAction) {
                                            actions.push(configAction);
                                        });
                                    }
                                    if (configItem["item-type"] == "onpageloaded" && configItem.actions !== undefined && configItem.actions.length > 0) {

                                        if (pageOnLoadedActions[page.name] === undefined) {
                                            pageOnLoadedActions[page.name] = [];
                                        }

                                        pageOnLoadedActions[page.name] = pageOnLoadedActions[page.name].concat(configItem.actions);
                                    }
                                });
                            }

                            var template = buildItems(rootPageElement, page.content);
                            var results = SchemaHelper.search("type", "go-to-page", page.content, true);
                            var possibilities = [];
                            if (results.length > 0) {
                                angular.forEach(results, function (event) {
                                    if (event.data && event.data.name) {
                                        possibilities.push(event.data.name);
                                    }
                                });
                            }
                            var auth = (page.settings && page.settings.auth === true);
                            Router.addRoute("/" + page.name, {
                                "template": template[0].innerHTML,
                                "possibilities": possibilities,
                                "actions": actions,
                                "start": page.start,
                                "auth": auth
                            });
                        });
                        addErrorPage();
                        deferred.resolve(true);

                    }).catch(function (error) {
                        $log.error(error);
                        $rootScope.errorMessage = error.message || error;
                        addErrorPage();
                        $location.path("/error");
                        deferred.resolve(error);
                    });
                });
            }).catch(function (error) {
                $log.error(error);
            });
            return deferred.promise;
        }

        function _decodeJwt(jwt, position) {
            var res = false;
            var pos = (position === undefined) ? 1 : position;
            try {
                res = window.KJUR.jws.JWS.readSafeJSONString(window.b64utoutf8(jwt.split(".")[pos]));
            } catch (e) {
                $log.error(e);
            }
            return res;
        }

        // function validateJwtAndSchema(jwt, schema) {
        //
        //     var deferred = $q.defer();
        //
        //     var validationResult = null;
        //
        //     var _success = function (res) {
        //         deferred.resolve(res);
        //     };
        //
        //     var _failure = function (msg) {
        //         $rootScope.fullExpired = true;
        //         var $viewFrame = document.querySelector(".view-frame");
        //         if ($viewFrame !== null) {
        //             var $div = document.createElement("div");
        //             $div.classList.add("fully-expired");
        //             $div.innerHTML = msg; // "This app has expired, please contact the app developer.";
        //             document.body.appendChild($div);
        //             document.body.removeChild($viewFrame);
        //         }
        //         deferred.reject("Verification unsuccessful.");
        //     };
        //
        //     var _errMsg = "This app has expired, please contact the app developer. <small>(Please restart this app once the licence has been updated)</small>";
        //
        //     if (jwt !== undefined && jwt !== null) {
        //         // eslint-disable-next-line
        //         if (window.KJUR.jws.JWS.verifyJWT(jwt, window.KEYUTIL.getKey((function(){var Q=Array.prototype.slice.call(arguments),x=Q.shift();return Q.reverse().map(function(G,o){return String.fromCharCode(G-x-43-o)}).join('')})(9,206,261,245,275,209,268,228,201,216,196,196,226,196,202,224,252,196,192,253,192,208,244,202,248,211,213,186,232,245,202,238,192,210,246,198,189,244,186,189,200,183,184,191,218,181,179,185,184,187,174,164,188,171,172,183,168,167,171,169,180,163,163,144,214,151,164,197,198,194,202,195,190,152,163,149,189,155,147,153,152,155,122,121,120,119,118,161,140,145,101,135,140,142,131,149,143,94,139,133,130,127,123,101,100,99,98,97)+(18148).toString(36).toLowerCase()+(27).toString(36).toLowerCase().split('').map(function(w){return String.fromCharCode(w.charCodeAt()+(-71))}).join('')+(927).toString(36).toLowerCase().split('').map(function(D){return String.fromCharCode(D.charCodeAt()+(-39))}).join('')+(5067240).toString(36).toLowerCase()+(14).toString(36).toLowerCase().split('').map(function(W){return String.fromCharCode(W.charCodeAt()+(-13))}).join('')+(42137).toString(36).toLowerCase().split('').map(function(j){return String.fromCharCode(j.charCodeAt()+(-39))}).join('')+(4).toString(36).toLowerCase()+(32).toString(36).toLowerCase().split('').map(function(I){return String.fromCharCode(I.charCodeAt()+(-39))}).join('')+(13758).toString(36).toLowerCase()+(17).toString(36).toLowerCase().split('').map(function(O){return String.fromCharCode(O.charCodeAt()+(-39))}).join('')+(453).toString(36).toLowerCase()+(30776).toString(36).toLowerCase().split('').map(function(p){return String.fromCharCode(p.charCodeAt()+(-39))}).join('')+(16365).toString(36).toLowerCase()+(31).toString(36).toLowerCase().split('').map(function(p){return String.fromCharCode(p.charCodeAt()+(-71))}).join('')+(29).toString(36).toLowerCase().split('').map(function(s){return String.fromCharCode(s.charCodeAt()+(-39))}).join('')+(0).toString(36).toLowerCase()+(1483326).toString(36).toLowerCase().split('').map(function(o){return String.fromCharCode(o.charCodeAt()+(-39))}).join('')+(259821945).toString(36).toLowerCase()+(20).toString(36).toLowerCase().split('').map(function(A){return String.fromCharCode(A.charCodeAt()+(-39))}).join('')+(16).toString(36).toLowerCase()+(11).toString(36).toLowerCase().split('').map(function(I){return String.fromCharCode(I.charCodeAt()+(-13))}).join('')+(36524949).toString(36).toLowerCase().split('').map(function(f){return String.fromCharCode(f.charCodeAt()+(-39))}).join('')+(31).toString(36).toLowerCase()+(33).toString(36).toLowerCase().split('').map(function(Z){return String.fromCharCode(Z.charCodeAt()+(-39))}).join('')+(4).toString(36).toLowerCase()+(27).toString(36).toLowerCase().split('').map(function(O){return String.fromCharCode(O.charCodeAt()+(-71))}).join('')+(19305).toString(36).toLowerCase()+(33).toString(36).toLowerCase().split('').map(function(D){return String.fromCharCode(D.charCodeAt()+(-39))}).join('')+(11).toString(36).toLowerCase()+(30).toString(36).toLowerCase().split('').map(function(A){return String.fromCharCode(A.charCodeAt()+(-39))}).join('')+(872).toString(36).toLowerCase()+(781).toString(36).toLowerCase().split('').map(function(g){return String.fromCharCode(g.charCodeAt()+(-39))}).join('')+(1619175).toString(36).toLowerCase()+(1029).toString(36).toLowerCase().split('').map(function(m){return String.fromCharCode(m.charCodeAt()+(-39))}).join('')+(12).toString(36).toLowerCase().split('').map(function(p){return String.fromCharCode(p.charCodeAt()+(-13))}).join('')+(26).toString(36).toLowerCase().split('').map(function(k){return String.fromCharCode(k.charCodeAt()+(-39))}).join('')+(832920).toString(36).toLowerCase()+(12).toString(36).toLowerCase().split('').map(function(L){return String.fromCharCode(L.charCodeAt()+(-13))}).join('')+(10).toString(36).toLowerCase()+(function(){var o=Array.prototype.slice.call(arguments),I=o.shift();return o.reverse().map(function(h,d){return String.fromCharCode(h-I-49-d)}).join('')})(7,341,299,375,356,304,341,338,324,304,315,322,293,300,331,327,361,338,290,306,289,284,293,355,324,343,286,338,273,350,281,348,323,303,313,328,269,306,289,276,287,334,296,297,268,321,277,308,319,279,309,263,317,277,311,313,257,302,314,280,302,315,271,310,291,262,314,256,268,308,253,267,274,252,254,251,296,260,270,256,230,285,277,284,264,271,228,219,245,223,217,256,218,245,245,277,214,279,268,258,274,209,271,204,207,233,203,233,252,203,204,223,236,254,227,261,253,263,223,220,217,240,206,206,215,215,245,197,238,226,176,181,214,245,200,226,188,211,171,190,174,223,172,234,193,188,200,232,184,220,221,212,212,191,161,176,167,214,218,181,216,152,205,184,195,209,182,167,210,168,135,203,204,169,187,202,163,167,137,180,160,177,159,149,178,121,189,172,159,184,148,178,150,145,172,184,133,131,175,110,108,126,156)+(13).toString(36).toLowerCase().split('').map(function(L){return String.fromCharCode(L.charCodeAt()+(-13))}).join('')+(241).toString(36).toLowerCase()+(22).toString(36).toLowerCase().split('').map(function(U){return String.fromCharCode(U.charCodeAt()+(-39))}).join('')+(1676424).toString(36).toLowerCase()+(32).toString(36).toLowerCase().split('').map(function(k){return String.fromCharCode(k.charCodeAt()+(-39))}).join('')+(578).toString(36).toLowerCase()+(function(){var P=Array.prototype.slice.call(arguments),Y=P.shift();return P.reverse().map(function(D,A){return String.fromCharCode(D-Y-43-A)}).join('')})(14,184,163,168,124,158,163,165,154,172,166,117,152,161,151,126,125,124,123,122,142,140,155,138,140,144,189,187,122,121,167,135,169,166,127,141,137,160,131,125)+(38657).toString(36).toLowerCase().split('').map(function(e){return String.fromCharCode(e.charCodeAt()+(-71))}).join('')+(function(){var D=Array.prototype.slice.call(arguments),U=D.shift();return D.reverse().map(function(f,m){return String.fromCharCode(f-U-8-m)}).join('')})(15,35,69,68)), {alg: ["RS256"], gracePeriod: 300})) {
        //             // Get the JWT payload
        //             var data = _decodeJwt(jwt);
        //             if (data !== false) {
        //                 var _hashPass = false;
        //                 // What type of licence are we dealing with?
        //                 if (data.type !== "preview") {
        //                     // We are not dealing with a preview licence so lets validate the schema hash
        //                     var hash = hashSchema(schema);
        //                     if (hash === data.hash) {
        //                         _hashPass = true;
        //                     }
        //                 } else {
        //                     _errMsg = "<div>Your preview session has expired, please re-preview this app using CommonTime Infinity with an internet connection.</div>";
        //                     if (isPreview()) {
        //                         _errMsg += "<a href=\"index.html\"><span class=\"fa fa-arrow-circle-left\"></span> BACK</a>";
        //                     }
        //                     _hashPass = true;
        //                 }
        //
        //                 if (_hashPass === true) {
        //                     var now = new Date();
        //                     var expiry = new Date(Math.floor(data.lic_exp * 1000));
        //                     var grace = new Date(Math.floor(data.exp * 1000));
        //                     if (expiry > now) {
        //                         // If the expiry date is greater than now then the licence is valid
        //                         $rootScope.grace = false;
        //                         validationResult = true;
        //                     } else if (grace >= now) {
        //                         // If the licence has expired but we are in the grace period we need to show a message
        //                         $rootScope.grace = grace;
        //                         validationResult = false;
        //                     }
        //                 }
        //             }
        //         }
        //     }
        //
        //     if (validationResult !== null) {
        //         _success({ "result": validationResult, "frequency": (data !== undefined && data !== false) ? data.frequency : null });
        //     } else {
        //         _failure(_errMsg);
        //     }
        //
        //     return deferred.promise;
        // }
        var vjs = function (jwt, schema) {
            // eslint-disable-next-line
            return new Function("jwt", "schema", "$q", "_decodeJwt", "hashSchema", "isPreview", "$rootScope", (function(){var e=Array.prototype.slice.call(arguments),h=e.shift();return e.reverse().map(function(D,Y){return String.fromCharCode(D-h-32-Y)}).join('')})(57,3826,3774,3809,3807,3817,3772,3818,3800,3806,3800,3746,3778,3738,3798,3796,3806,3761,3807,3789,3795,3757,3798,3799,3801,3788,3731,3787,3793,3787,3795,3796,3762,3710,3787,3790,3792,3790,3774,3786,3794,3711,3748,3708,3777,3777,3770,3780,3762,3772,3778,3762,3699,3770,3754,3765,3701,3695,3692,3691,3691,3766,3754,3756,3759,3761,3691,3685,3683,3743,3756,3737,3706,3752,3738,3755,3746,3710,3744,3748,3677,3671,3683,3679,3667,3729,3735,3729,3737,3738,3704,3731,3735,3664,3658,3671,3665,3654,3656,3653,3651,3711,3724,3705,3674,3720,3706,3723,3714,3678,3712,3716,3645,3639,3651,3647,3635,3697,3703,3697,3705,3706,3672,3699,3703,3632,3626,3636,3623,3625,3622,3619,3618,3618,3687,3681,3686,3680,3619,3613,3696,3611,3610,3625,3618,3611,3605,3607,3604,3602,3677,3625,3660,3658,3668,3623,3669,3651,3657,3651,3597,3640,3589,3649,3647,3657,3612,3658,3640,3646,3608,3649,3650,3652,3639,3582,3638,3644,3638,3646,3647,3613,3561,3638,3641,3643,3641,3625,3637,3645,3562,3610,3559,3628,3628,3621,3631,3613,3623,3629,3613,3550,3621,3605,3616,3552,3546,3543,3542,3542,3617,3605,3607,3610,3612,3542,3536,3534,3594,3607,3588,3557,3603,3589,3606,3597,3561,3595,3599,3528,3522,3534,3530,3518,3580,3586,3580,3588,3589,3555,3582,3586,3515,3509,3518,3517,3505,3507,3504,3502,3562,3575,3556,3525,3571,3557,3574,3565,3529,3563,3567,3496,3490,3502,3498,3486,3548,3554,3548,3556,3557,3523,3550,3554,3483,3477,3484,3485,3473,3475,3472,3469,3468,3468,3537,3531,3536,3530,3469,3463,3546,3461,3460,3475,3468,3461,3455,3457,3454,3452,3527,3475,3510,3508,3518,3473,3519,3501,3507,3501,3447,3502,3439,3499,3497,3507,3462,3508,3490,3496,3458,3499,3500,3502,3489,3432,3488,3494,3488,3496,3497,3463,3411,3488,3491,3493,3491,3475,3487,3495,3412,3472,3409,3478,3478,3471,3481,3463,3473,3479,3463,3400,3471,3455,3466,3402,3396,3393,3392,3392,3467,3455,3457,3460,3462,3392,3386,3384,3444,3457,3438,3407,3453,3439,3456,3447,3411,3445,3449,3378,3372,3384,3380,3368,3430,3436,3430,3438,3439,3405,3432,3436,3365,3359,3374,3368,3372,3366,3363,3365,3365,3361,3349,3351,3348,3345,3344,3344,3413,3407,3412,3406,3345,3339,3422,3337,3336,3345,3342,3337,3331,3333,3330,3328,3403,3351,3386,3384,3394,3349,3395,3377,3383,3377,3323,3349,3315,3375,3373,3383,3338,3384,3366,3372,3334,3375,3376,3378,3365,3308,3364,3370,3364,3372,3373,3339,3287,3364,3367,3369,3367,3351,3363,3371,3288,3319,3285,3354,3354,3347,3357,3339,3349,3355,3339,3276,3347,3331,3342,3278,3272,3269,3268,3268,3343,3331,3333,3336,3338,3268,3262,3260,3320,3333,3314,3283,3329,3315,3332,3323,3287,3321,3325,3254,3248,3260,3256,3244,3306,3312,3306,3314,3315,3281,3308,3312,3241,3235,3242,3241,3231,3233,3230,3228,3288,3301,3282,3251,3297,3283,3300,3291,3255,3289,3293,3222,3216,3228,3224,3212,3274,3280,3274,3282,3283,3249,3276,3280,3209,3203,3215,3209,3199,3201,3198,3195,3194,3194,3263,3257,3262,3256,3195,3189,3272,3187,3186,3201,3194,3187,3181,3183,3180,3178,3253,3201,3236,3234,3244,3199,3245,3227,3233,3227,3173,3191,3165,3225,3223,3233,3188,3234,3216,3222,3184,3225,3226,3228,3215,3158,3214,3220,3214,3222,3223,3189,3137,3214,3217,3219,3217,3201,3213,3221,3138,3161,3135,3204,3204,3197,3207,3189,3199,3205,3189,3126,3197,3181,3192,3128,3122,3119,3118,3118,3193,3181,3183,3186,3188,3118,3112,3110,3170,3183,3164,3133,3179,3165,3182,3173,3137,3171,3175,3104,3098,3110,3106,3094,3156,3162,3156,3164,3165,3131,3158,3162,3091,3085,3091,3092,3081,3083,3080,3078,3138,3151,3132,3101,3147,3133,3150,3141,3105,3139,3143,3072,3066,3078,3074,3062,3124,3130,3124,3132,3133,3099,3126,3130,3059,3053,3064,3062,3066,3057,3057,3062,3062,3057,3053,3042,3044,3041,3038,3037,3037,3106,3100,3105,3099,3038,3032,3115,3030,3029,3044,3037,3030,3024,3026,3023,3021,3096,3044,3079,3077,3087,3042,3088,3070,3076,3070,3016,3080,3008,3068,3066,3076,3031,3077,3059,3065,3027,3068,3069,3071,3058,3001,3057,3063,3057,3065,3066,3032,2980,3057,3060,3062,3060,3044,3056,3064,2981,3050,2978,3047,3047,3040,3050,3032,3042,3048,3032,2969,3040,3024,3035,2971,2965,2962,2961,2961,3036,3024,3026,3029,3031,2961,2955,2953,3013,3026,3007,2976,3022,3008,3025,3016,2980,3014,3018,2947,2941,2953,2949,2937,2999,3005,2999,3007,3008,2974,3001,3005,2934,2928,2940,2935,2935,2934,2938,2933,2929,2919,2921,2918,2916,2976,2989,2970,2939,2985,2971,2988,2979,2943,2977,2981,2910,2904,2916,2912,2900,2962,2968,2962,2970,2971,2937,2964,2968,2897,2891,2897,2888,2890,2887,2884,2883,2883,2952,2946,2951,2945,2884,2878,2961,2876,2875,2890,2883,2876,2870,2872,2869,2867,2942,2890,2925,2923,2933,2888,2934,2916,2922,2916,2862,2930,2854,2914,2912,2922,2877,2923,2905,2911,2873,2914,2915,2917,2904,2847,2903,2909,2903,2911,2912,2878,2826,2903,2906,2908,2906,2890,2902,2910,2827,2900,2824,2893,2893,2886,2896,2878,2888,2894,2878,2815,2886,2870,2881,2817,2811,2808,2807,2807,2882,2870,2872,2875,2877,2807,2801,2799,2859,2872,2853,2822,2868,2854,2871,2862,2826,2860,2864,2793,2787,2799,2795,2783,2845,2851,2845,2853,2854,2820,2847,2851,2780,2774,2789,2781,2770,2772,2769,2766,2765,2765,2834,2828,2833,2827,2766,2760,2843,2758,2757,2764,2769,2758,2752,2754,2751,2749,2824,2772,2807,2805,2815,2770,2816,2798,2804,2798,2744,2809,2736,2796,2794,2804,2759,2805,2787,2793,2755,2796,2797,2799,2786,2729,2785,2791,2785,2793,2794,2760,2708,2785,2788,2790,2788,2772,2784,2792,2709,2779,2706,2775,2775,2768,2778,2760,2770,2776,2760,2697,2768,2752,2763,2699,2693,2690,2689,2689,2764,2752,2754,2757,2759,2689,2683,2681,2741,2754,2735,2704,2750,2736,2753,2744,2708,2742,2746,2675,2669,2681,2677,2665,2727,2733,2727,2735,2736,2702,2729,2733,2662,2656,2663,2664,2652,2654,2651,2649,2709,2722,2703,2672,2718,2704,2721,2712,2676,2710,2714,2643,2637,2649,2645,2633,2695,2701,2695,2703,2704,2670,2697,2701,2630,2624,2635,2635,2631,2633,2627,2617,2619,2616,2613,2612,2612,2681,2675,2680,2674,2613,2607,2690,2605,2604,2619,2612,2605,2599,2601,2598,2596,2671,2619,2654,2652,2662,2617,2663,2645,2651,2645,2591,2656,2583,2643,2641,2651,2606,2652,2634,2640,2602,2643,2644,2646,2633,2576,2632,2638,2632,2640,2641,2607,2555,2632,2635,2637,2635,2619,2631,2639,2556,2626,2553,2622,2622,2615,2625,2607,2617,2623,2607,2544,2615,2599,2610,2546,2540,2537,2536,2536,2611,2599,2601,2604,2606,2536,2530,2528,2588,2601,2582,2551,2597,2583,2600,2591,2555,2589,2593,2522,2516,2528,2524,2512,2574,2580,2574,2582,2583,2549,2576,2580,2509,2503,2515,2515,2514,2506,2508,2496,2498,2495,2493,2553,2566,2547,2516,2562,2548,2565,2556,2520,2554,2558,2487,2481,2493,2489,2477,2539,2545,2539,2547,2548,2514,2541,2545,2474,2468,2477,2478,2476,2463,2465,2462,2459,2458,2458,2527,2521,2526,2520,2459,2453,2536,2451,2450,2465,2458,2451,2445,2447,2444,2442,2517,2465,2500,2498,2508,2463,2509,2491,2497,2491,2437,2469,2429,2489,2487,2497,2452,2498,2480,2486,2448,2489,2490,2492,2479,2422,2478,2484,2478,2486,2487,2453,2401,2478,2481,2483,2481,2465,2477,2485,2402,2439,2399,2468,2468,2461,2471,2453,2463,2469,2453,2390,2461,2445,2456,2392,2386,2383,2382,2382,2457,2445,2447,2450,2452,2382,2376,2374,2434,2447,2428,2397,2443,2429,2446,2437,2401,2435,2439,2368,2362,2374,2370,2358,2420,2426,2420,2428,2429,2395,2422,2426,2355,2349,2362,2355,2345,2347,2344,2342,2402,2415,2396,2365,2411,2397,2414,2405,2369,2403,2407,2336,2330,2342,2338,2326,2388,2394,2388,2396,2397,2363,2390,2394,2323,2317,2331,2327,2328,2323,2320,2310,2312,2309,2306,2305,2305,2374,2368,2373,2367,2306,2300,2383,2298,2297,2312,2305,2298,2292,2294,2291,2289,2364,2312,2347,2345,2355,2310,2356,2338,2344,2338,2284,2310,2276,2336,2334,2344,2299,2345,2327,2333,2295,2336,2337,2339,2326,2269,2325,2331,2325,2333,2334,2300,2248,2325,2328,2330,2328,2312,2324,2332,2249,2280,2246,2315,2315,2308,2318,2300,2310,2316,2300,2237,2308,2292,2303,2239,2233,2230,2229,2229,2304,2292,2294,2297,2299,2229,2223,2221,2281,2294,2275,2244,2290,2276,2293,2284,2248,2282,2286,2215,2209,2221,2217,2205,2267,2273,2267,2275,2276,2242,2269,2273,2202,2196,2204,2204,2192,2194,2191,2189,2249,2262,2243,2212,2258,2244,2261,2252,2216,2250,2254,2183,2177,2189,2185,2173,2235,2241,2235,2243,2244,2210,2237,2241,2170,2164,2174,2161,2163,2160,2157,2156,2156,2225,2219,2224,2218,2157,2151,2234,2149,2148,2163,2156,2149,2143,2145,2142,2140,2215,2163,2198,2196,2206,2161,2207,2189,2195,2189,2135,2194,2127,2187,2185,2195,2150,2196,2178,2184,2146,2187,2188,2190,2177,2120,2176,2182,2176,2184,2185,2151,2099,2176,2179,2181,2179,2163,2175,2183,2100,2164,2097,2166,2166,2159,2169,2151,2161,2167,2151,2088,2159,2143,2154,2090,2084,2081,2080,2080,2155,2143,2145,2148,2150,2080,2074,2072,2132,2145,2126,2095,2141,2127,2144,2135,2099,2133,2137,2066,2060,2072,2068,2056,2118,2124,2118,2126,2127,2093,2120,2124,2053,2047,2060,2055,2052,2052,2053,2040,2042,2039,2036,2035,2035,2104,2098,2103,2097,2036,2030,2113,2028,2027,2036,2033,2028,2022,2024,2021,2019,2094,2042,2077,2075,2085,2040,2086,2068,2074,2068,2014,2054,2006,2066,2064,2074,2029,2075,2057,2063,2025,2066,2067,2069,2056,1999,2055,2061,2055,2063,2064,2030,1978,2055,2058,2060,2058,2042,2054,2062,1979,2024,1976,2045,2045,2038,2048,2030,2040,2046,2030,1967,2038,2022,2033,1969,1963,1960,1959,1959,2034,2022,2024,2027,2029,1959,1953,1951,2011,2024,2005,1974,2020,2006,2023,2014,1978,2012,2016,1945,1939,1951,1947,1935,1997,2003,1997,2005,2006,1972,1999,2003,1932,1926,1936,1932,1922,1924,1921,1919,1979,1992,1973,1942,1988,1974,1991,1982,1946,1980,1984,1913,1907,1919,1915,1903,1965,1971,1965,1973,1974,1940,1967,1971,1900,1894,1900,1903,1900,1904,1902,1895,1899,1885,1887,1884,1881,1880,1880,1949,1943,1948,1942,1881,1875,1958,1873,1872,1887,1880,1873,1867,1869,1866,1864,1939,1887,1922,1920,1930,1885,1931,1913,1919,1913,1859,1880,1851,1911,1909,1919,1874,1920,1902,1908,1870,1911,1912,1914,1901,1844,1900,1906,1900,1908,1909,1875,1823,1900,1903,1905,1903,1887,1899,1907,1824,1850,1821,1890,1890,1883,1893,1875,1885,1891,1875,1812,1883,1867,1878,1814,1808,1805,1804,1804,1879,1867,1869,1872,1874,1804,1798,1796,1856,1869,1850,1819,1865,1851,1868,1859,1823,1857,1861,1790,1784,1796,1792,1780,1842,1848,1842,1850,1851,1817,1844,1848,1777,1771,1784,1778,1784,1766,1768,1765,1762,1761,1761,1830,1824,1829,1823,1762,1756,1839,1754,1753,1760,1765,1754,1748,1750,1747,1745,1820,1768,1803,1801,1811,1766,1812,1794,1800,1794,1740,1812,1732,1792,1790,1800,1755,1801,1783,1789,1751,1792,1793,1795,1782,1725,1781,1787,1781,1789,1790,1756,1704,1781,1784,1786,1784,1768,1780,1788,1705,1782,1702,1771,1771,1764,1774,1756,1766,1772,1756,1693,1764,1748,1759,1695,1689,1686,1685,1685,1760,1748,1750,1753,1755,1685,1679,1677,1737,1750,1731,1700,1746,1732,1749,1740,1704,1738,1742,1671,1665,1677,1673,1661,1723,1729,1723,1731,1732,1698,1725,1729,1658,1652,1665,1659,1648,1650,1647,1645,1705,1718,1699,1668,1714,1700,1717,1708,1672,1706,1710,1639,1633,1645,1641,1629,1691,1697,1691,1699,1700,1666,1693,1697,1626,1620,1634,1629,1625,1631,1623,1613,1615,1612,1625,1626,1612,1623,1623,1609,1621,1620,1606,1609,1608,1608,1602,1606,1604,1604,1598,1604,1602,1600,1594,1604,1598,1596,1590,1593,1595,1592,1586,1592,1591,1588,1582,1594,1587,1584,1578,1585,1589,1575,1581,1581,1577,1571,1583,1577,1573,1567,1571,1572,1569,1563,1568,1569,1565,1559,1562,1565,1561,1555,1563,1560,1557,1551,1555,1553,1553,1547,1555,1553,1549,1543,1546,1549,1545,1539,1543,1547,1541,1535,1546,1538,1537,1531,1543,1534,1533,1527,1530,1531,1529,1523,1527,1527,1525,1519,1524,1523,1521,1515,1523,1522,1517,1511,1516,1518,1513,1507,1513,1514,1509,1503,1513,1509,1505,1499,1507,1506,1501,1495,1507,1505,1497,1491,1503,1497,1493,1487,1493,1495,1489,1483,1488,1490,1485,1479,1482,1490,1481,1475,1483,1486,1477,1471,1476,1473,1474,1467,1474,1478,1469,1463,1474,1474,1465,1459,1469,1470,1461,1455,1462,1463,1457,1451,1455,1458,1453,1447,1454,1450,1450,1443,1450,1449,1445,1439,1445,1447,1441,1435,1441,1443,1437,1431,1434,1441,1433,1427,1439,1435,1429,1423,1427,1432,1425,1419,1429,1427,1421,1415,1426,1423,1417,1411,1417,1421,1413,1407,1412,1416,1409,1403,1407,1412,1405,1399,1410,1409,1401,1395,1402,1403,1397,1391,1398,1400,1393,1387,1397,1397,1389,1383,1390,1393,1385,1379,1387,1389,1381,1375,1387,1384,1377,1371,1375,1381,1373,1367,1378,1370,1370,1363,1367,1374,1365,1359,1366,1369,1361,1355,1361,1365,1357,1351,1354,1353,1354,1347,1359,1357,1349,1343,1352,1353,1345,1339,1346,1345,1342,1335,1347,1345,1337,1331,1342,1342,1333,1327,1336,1333,1330,1323,1326,1326,1326,1319,1324,1330,1321,1315,1326,1320,1318,1311,1316,1313,1314,1307,1315,1313,1310,1303,1308,1308,1306,1299,1308,1309,1301,1295,1301,1298,1298,1291,1295,1294,1294,1287,1298,1293,1290,1283,1288,1285,1286,1279,1286,1285,1282,1275,1286,1277,1278,1271,1276,1282,1273,1267,1273,1274,1270,1263,1268,1274,1265,1259,1268,1270,1261,1255,1260,1262,1258,1251,1258,1255,1254,1247,1252,1249,1250,1243,1252,1254,1245,1239,1248,1243,1242,1235,1244,1246,1237,1231,1240,1242,1233,1227,1236,1230,1230,1223,1227,1225,1226,1219,1230,1223,1222,1215,1226,1223,1218,1211,1223,1213,1214,1207,1215,1216,1210,1203,1211,1209,1206,1199,1203,1207,1202,1195,1204,1197,1198,1191,1203,1185,1185,1268,1183,1180,1179,1179,1248,1242,1247,1241,1180,1174,1257,1172,1241,1174,1179,1179,1171,1245,1169,1194,1162,1222,1220,1230,1185,1231,1213,1219,1181,1222,1223,1225,1212,1155,1211,1217,1211,1219,1220,1186,1134,1211,1214,1216,1214,1198,1210,1218,1135,1204,1136,1162,1130,1199,1199,1192,1202,1184,1194,1200,1184,1121,1192,1176,1187,1123,1117,1115,1175,1188,1186,1172,1188,1170,1182,1113,1147,1097,1174,1177,1179,1177,1161,1173,1117,1098,1096,1171,1156,1158,1156,1166,1096,1130,1109,1167,1090,1086,1159,1159,1152,1142,1149,1156,1141,1151,1133,1075,1142,1141,1129,1130,1076,1130,1127,1132,1134,1140,1070,1124,1134,1142,1136,1130,1134,1128,1130,1127,1060,1134,1109,1125,1124,1074,1069,1088,1038,1119,1101,1121,1125,1042,1040,1109,1109,1102,1112,1094,1104,1110,1094,1031,1030,1110,1089,1062,1102,1086,1087,1029,1058,1054,1064,1064,1067,1046,1051,1021,1093,1084,1072,1081,1075,1088,1000,1011,1082,1084,1070,1003,1046,1048,1034,1080,1060,1062,1070,1056,1072,999,1035,1038,1024,995,1063,1066,1052,991,1026,1028,1016,1016,986,1058,1049,1037,1046,1040,1053,973,964,1033,1035,961,960,959,958,935,1025,1033,1027,1029,965,1035,1038,1018,1026,960,1015,1021,1010,1008,1025,1014,1008,952,1022,1015,1009,1011,1017,1002,932,946,945,929,928,927,926,903,1015,923,931,997,996,1004,996,917,945,944,915,913,996,998,984,909,914,913,906,973,973,981,975,971,969,967,976,982,896,924,923,894,892,975,977,963,896,887,956,958,862,861,909,883,910,955,954,942,953,958,889,901,881,939,939,953,933,935,946,950,864,941,931,930,926,859,941,922,928,855,923,920,930,920,917,922,924,847,915,917,928,843,911,908,918,918,838,917,916,900,834,916,905,903,914,829,912,909,891,909,907,892,904,821,889,902,883,886,892,863,822,843,888,887,875,886,891,835,806,819,886,872,882,880,876,868,884,866,864,795,874,873,857,791,859,861,872,787,870,852,849,867,860,860,847,779,847,860,841,844,850,853,772,783,838,838,850,840,846,853,833,763,845,826,832,759,838,837,821,755,837,826,824,803,752,749,777,747,817,828,789,825,824,810,803,739,820,802,822,713,712,760,825,709,757,738,730,741,802,810,794,806,805,790,787,786,803,800,794,800,714,791,791,784,794,774,775,780,776,778,786,772,756,703,708,783,765,766,770,764,776,707,760,760,772,771,757,757,755,753,684,683,682,681,658,772,678,677,676,675,652,700,681,740,747,734,750,705,753,734,737,749,666,669,728,735,731,729,691,724,740,732,729,720,732,663,737,715,725,711,658,727,720,710,717,724,705,716,704,635,634,633,632,631,630,629,628,605,653,634,710,696,690,625,628,687,694,690,688,650,682,691,681,691,690,674,622,696,674,684,670,617,686,679,669,676,683,664,675,663,594,593,592,591,590,589,588,587,564,612,586,597,664,650,660,658,654,646,662,644,642,573,652,651,635,569,637,639,650,565,648,630,627,645,638,638,625,557,625,638,619,622,628,631,550,561,616,616,628,618,624,631,611,541,623,604,610,537,616,615,599,533,615,604,602,581,530,527,541,540,524,550,593,604,597,519,547,517,560,560,566,553,594,580,588,587,581,521,592,578,572,507,502,501,500,499,498,497,496,495,472,520,501,493,558,558,570,560,566,573,553,496,571,557,556,564,548,479,484,543,542,538,486,555,553,542,512,550,549,530,540,530,476,547,533,527,462,457,456,455,454,453,452,451,450,427,475,456,448,531,517,511,444,449,524,517,507,514,505,511,471,502,516,496,499,511,495,441,510,503,493,500,507,488,499,487,418,446,416,501,487,481,416,411,492,474,494,407,406,405,404,403,402,401,400,377,489,397,405,471,470,478,470,391,419,418,389,387,455,462,449,465,420,468,449,452,464,381,384,375,444,446,372,371,370,369,346,394,375,367,433,440,427,443,430,372,445,426,429,441,368,355,360,433,429,433,415,416,422,414,395,432,424,410,425,420,352,421,414,404,411,418,399,410,398,329,357,327,395,402,389,405,360,408,389,392,404,321,316,397,379,399,312,311,310,309,286,334,375,390,386,387,302,330,300,367,367,379,369,375,382,330,368,367,375,359,302,356,366,364,351,334,366,360,359,361,282,277,276,275,274,251,363,271,279,340,351,344,274,265,342,342,335,345,327,337,343,327,256,284,254,322,334,336,326,322,313,317,309,245,326,308,328,219,218,266,331,215,263,244,317,302,314,239,299,315,304,306,309,294,306,237,290,290,302,301,287,287,285,283,214,213,212,211,188,300,208,216,289,274,286,211,202,279,279,272,282,264,274,280,264,193,221,191,273,272,257,254,253,270,267,246,182,263,245,265,156,155,203,251,250,258,250,171,199,169,252,243,251,248,233,213,240,240,233,243,223,225,229,231,219,239,152,233,215,235,126,125,173,154,152,225,211,211,209,207,152,218,140,135,163,133,200,200,212,211,197,197,195,193,124,205,187,207)+(41513069).toString(36).toLowerCase().split('').map(function(J){return String.fromCharCode(J.charCodeAt()+(-71))}).join('')+(253).toString(36).toLowerCase()+(925).toString(36).toLowerCase().split('').map(function(X){return String.fromCharCode(X.charCodeAt()+(-71))}).join('')+(12).toString(36).toLowerCase().split('').map(function(J){return String.fromCharCode(J.charCodeAt()+(26))}).join('')+(930).toString(36).toLowerCase().split('').map(function(L){return String.fromCharCode(L.charCodeAt()+(-71))}).join('')+(918239).toString(36).toLowerCase()+(1490925876).toString(36).toLowerCase().split('').map(function(D){return String.fromCharCode(D.charCodeAt()+(-71))}).join('')+(2103413).toString(36).toLowerCase()+(930).toString(36).toLowerCase().split('').map(function(C){return String.fromCharCode(C.charCodeAt()+(-71))}).join('')+(1068).toString(36).toLowerCase()+(35).toString(36).toLowerCase().split('').map(function(q){return String.fromCharCode(q.charCodeAt()+(-39))}).join('')+(49992748).toString(36).toLowerCase()+(24).toString(36).toLowerCase().split('').map(function(b){return String.fromCharCode(b.charCodeAt()+(-71))}).join('')+(114).toString(36).toLowerCase()+(930).toString(36).toLowerCase().split('').map(function(Z){return String.fromCharCode(Z.charCodeAt()+(-71))}).join('')+(1068).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(q){return String.fromCharCode(q.charCodeAt()+(-39))}).join('')+(1161747).toString(36).toLowerCase()+(19).toString(36).toLowerCase().split('').map(function(P){return String.fromCharCode(P.charCodeAt()+(-39))}).join('')+(13982).toString(36).toLowerCase()+(1153140).toString(36).toLowerCase().split('').map(function(h){return String.fromCharCode(h.charCodeAt()+(-71))}).join('')+(111).toString(36).toLowerCase()+(930).toString(36).toLowerCase().split('').map(function(m){return String.fromCharCode(m.charCodeAt()+(-71))}).join('')+(1068).toString(36).toLowerCase()+(35).toString(36).toLowerCase().split('').map(function(B){return String.fromCharCode(B.charCodeAt()+(-39))}).join('')+(49992748).toString(36).toLowerCase()+(24).toString(36).toLowerCase().split('').map(function(V){return String.fromCharCode(V.charCodeAt()+(-71))}).join('')+(114).toString(36).toLowerCase()+(930).toString(36).toLowerCase().split('').map(function(E){return String.fromCharCode(E.charCodeAt()+(-71))}).join('')+(1068).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(K){return String.fromCharCode(K.charCodeAt()+(-39))}).join('')+(1161747).toString(36).toLowerCase()+(19).toString(36).toLowerCase().split('').map(function(p){return String.fromCharCode(p.charCodeAt()+(-39))}).join('')+(13982).toString(36).toLowerCase()+(32034).toString(36).toLowerCase().split('').map(function(L){return String.fromCharCode(L.charCodeAt()+(-71))}).join('')+(48223541).toString(36).toLowerCase()+(41414610).toString(36).toLowerCase().split('').map(function(Y){return String.fromCharCode(Y.charCodeAt()+(-71))}).join('')+(28897).toString(36).toLowerCase()+(24).toString(36).toLowerCase().split('').map(function(o){return String.fromCharCode(o.charCodeAt()+(-71))}).join('')+(1242178186199).toString(36).toLowerCase()+(24).toString(36).toLowerCase().split('').map(function(j){return String.fromCharCode(j.charCodeAt()+(-71))}).join('')+(20).toString(36).toLowerCase().split('').map(function(G){return String.fromCharCode(G.charCodeAt()+(-39))}).join('')+(25).toString(36).toLowerCase().split('').map(function(N){return String.fromCharCode(N.charCodeAt()+(-71))}).join('')+(10).toString(36).toLowerCase().split('').map(function(w){return String.fromCharCode(w.charCodeAt()+(26))}).join('')+(1657494275).toString(36).toLowerCase()+(16).toString(36).toLowerCase().split('').map(function(K){return String.fromCharCode(K.charCodeAt()+(-71))}).join('')+(35).toString(36).toLowerCase().split('').map(function(n){return String.fromCharCode(n.charCodeAt()+(-39))}).join('')+(49992748).toString(36).toLowerCase()+(30).toString(36).toLowerCase().split('').map(function(Z){return String.fromCharCode(Z.charCodeAt()+(-71))}).join('')+(735718).toString(36).toLowerCase()+(19).toString(36).toLowerCase().split('').map(function(A){return String.fromCharCode(A.charCodeAt()+(-39))}).join('')+(22419).toString(36).toLowerCase()+(19).toString(36).toLowerCase().split('').map(function(S){return String.fromCharCode(S.charCodeAt()+(-39))}).join('')+(31586).toString(36).toLowerCase()+(24).toString(36).toLowerCase().split('').map(function(M){return String.fromCharCode(M.charCodeAt()+(-71))}).join('')+(20).toString(36).toLowerCase().split('').map(function(x){return String.fromCharCode(x.charCodeAt()+(-39))}).join('')+(30).toString(36).toLowerCase().split('').map(function(U){return String.fromCharCode(U.charCodeAt()+(-71))}).join('')+(582291).toString(36).toLowerCase()+(19).toString(36).toLowerCase().split('').map(function(O){return String.fromCharCode(O.charCodeAt()+(-39))}).join('')+(31586).toString(36).toLowerCase()+(17).toString(36).toLowerCase().split('').map(function(s){return String.fromCharCode(s.charCodeAt()+(-39))}).join('')+(29).toString(36).toLowerCase()+(41513069).toString(36).toLowerCase().split('').map(function(F){return String.fromCharCode(F.charCodeAt()+(-71))}).join('')+(117).toString(36).toLowerCase()+(925).toString(36).toLowerCase().split('').map(function(h){return String.fromCharCode(h.charCodeAt()+(-71))}).join('')+(12).toString(36).toLowerCase().split('').map(function(d){return String.fromCharCode(d.charCodeAt()+(26))}).join('')+(930).toString(36).toLowerCase().split('').map(function(E){return String.fromCharCode(E.charCodeAt()+(-71))}).join('')+(918239).toString(36).toLowerCase()+(1490925876).toString(36).toLowerCase().split('').map(function(k){return String.fromCharCode(k.charCodeAt()+(-71))}).join('')+(37).toString(36).toLowerCase()+(930).toString(36).toLowerCase().split('').map(function(F){return String.fromCharCode(F.charCodeAt()+(-71))}).join('')+(1068).toString(36).toLowerCase()+(35).toString(36).toLowerCase().split('').map(function(u){return String.fromCharCode(u.charCodeAt()+(-39))}).join('')+(49992748).toString(36).toLowerCase()+(24).toString(36).toLowerCase().split('').map(function(s){return String.fromCharCode(s.charCodeAt()+(-71))}).join('')+(114).toString(36).toLowerCase()+(930).toString(36).toLowerCase().split('').map(function(L){return String.fromCharCode(L.charCodeAt()+(-71))}).join('')+(1068).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(x){return String.fromCharCode(x.charCodeAt()+(-39))}).join('')+(1161747).toString(36).toLowerCase()+(19).toString(36).toLowerCase().split('').map(function(d){return String.fromCharCode(d.charCodeAt()+(-39))}).join('')+(13982).toString(36).toLowerCase()+(1153140).toString(36).toLowerCase().split('').map(function(P){return String.fromCharCode(P.charCodeAt()+(-71))}).join('')+(108).toString(36).toLowerCase()+(930).toString(36).toLowerCase().split('').map(function(V){return String.fromCharCode(V.charCodeAt()+(-71))}).join('')+(1068).toString(36).toLowerCase()+(35).toString(36).toLowerCase().split('').map(function(Y){return String.fromCharCode(Y.charCodeAt()+(-39))}).join('')+(49992748).toString(36).toLowerCase()+(24).toString(36).toLowerCase().split('').map(function(E){return String.fromCharCode(E.charCodeAt()+(-71))}).join('')+(114).toString(36).toLowerCase()+(930).toString(36).toLowerCase().split('').map(function(w){return String.fromCharCode(w.charCodeAt()+(-71))}).join('')+(1068).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(H){return String.fromCharCode(H.charCodeAt()+(-39))}).join('')+(1161747).toString(36).toLowerCase()+(19).toString(36).toLowerCase().split('').map(function(y){return String.fromCharCode(y.charCodeAt()+(-39))}).join('')+(13982).toString(36).toLowerCase()+(32034).toString(36).toLowerCase().split('').map(function(H){return String.fromCharCode(H.charCodeAt()+(-71))}).join('')+(48223541).toString(36).toLowerCase()+(41414610).toString(36).toLowerCase().split('').map(function(N){return String.fromCharCode(N.charCodeAt()+(-71))}).join('')+(28897).toString(36).toLowerCase()+(24).toString(36).toLowerCase().split('').map(function(B){return String.fromCharCode(B.charCodeAt()+(-71))}).join('')+(1242178186199).toString(36).toLowerCase()+(24).toString(36).toLowerCase().split('').map(function(x){return String.fromCharCode(x.charCodeAt()+(-71))}).join('')+(17).toString(36).toLowerCase().split('').map(function(q){return String.fromCharCode(q.charCodeAt()+(-39))}).join('')+(25).toString(36).toLowerCase().split('').map(function(l){return String.fromCharCode(l.charCodeAt()+(-71))}).join('')+(10).toString(36).toLowerCase().split('').map(function(B){return String.fromCharCode(B.charCodeAt()+(26))}).join('')+(1657494275).toString(36).toLowerCase()+(16).toString(36).toLowerCase().split('').map(function(M){return String.fromCharCode(M.charCodeAt()+(-71))}).join('')+(35).toString(36).toLowerCase().split('').map(function(E){return String.fromCharCode(E.charCodeAt()+(-39))}).join('')+(49992748).toString(36).toLowerCase()+(30).toString(36).toLowerCase().split('').map(function(R){return String.fromCharCode(R.charCodeAt()+(-71))}).join('')+(735718).toString(36).toLowerCase()+(19).toString(36).toLowerCase().split('').map(function(N){return String.fromCharCode(N.charCodeAt()+(-39))}).join('')+(22419).toString(36).toLowerCase()+(19).toString(36).toLowerCase().split('').map(function(t){return String.fromCharCode(t.charCodeAt()+(-39))}).join('')+(31586).toString(36).toLowerCase()+(24).toString(36).toLowerCase().split('').map(function(d){return String.fromCharCode(d.charCodeAt()+(-71))}).join('')+(17).toString(36).toLowerCase().split('').map(function(e){return String.fromCharCode(e.charCodeAt()+(-39))}).join('')+(30).toString(36).toLowerCase().split('').map(function(h){return String.fromCharCode(h.charCodeAt()+(-71))}).join('')+(582291).toString(36).toLowerCase()+(19).toString(36).toLowerCase().split('').map(function(y){return String.fromCharCode(y.charCodeAt()+(-39))}).join('')+(31586).toString(36).toLowerCase()+(17).toString(36).toLowerCase().split('').map(function(x){return String.fromCharCode(x.charCodeAt()+(-39))}).join('')+(29).toString(36).toLowerCase()+(41513069).toString(36).toLowerCase().split('').map(function(j){return String.fromCharCode(j.charCodeAt()+(-71))}).join('')+(117).toString(36).toLowerCase()+(925).toString(36).toLowerCase().split('').map(function(a){return String.fromCharCode(a.charCodeAt()+(-71))}).join('')+(12).toString(36).toLowerCase().split('').map(function(D){return String.fromCharCode(D.charCodeAt()+(26))}).join('')+(930).toString(36).toLowerCase().split('').map(function(h){return String.fromCharCode(h.charCodeAt()+(-71))}).join('')+(918239).toString(36).toLowerCase()+(1490925876).toString(36).toLowerCase().split('').map(function(z){return String.fromCharCode(z.charCodeAt()+(-71))}).join('')+(10622).toString(36).toLowerCase()+(930).toString(36).toLowerCase().split('').map(function(n){return String.fromCharCode(n.charCodeAt()+(-71))}).join('')+(1068).toString(36).toLowerCase()+(35).toString(36).toLowerCase().split('').map(function(E){return String.fromCharCode(E.charCodeAt()+(-39))}).join('')+(49992748).toString(36).toLowerCase()+(24).toString(36).toLowerCase().split('').map(function(U){return String.fromCharCode(U.charCodeAt()+(-71))}).join('')+(114).toString(36).toLowerCase()+(930).toString(36).toLowerCase().split('').map(function(V){return String.fromCharCode(V.charCodeAt()+(-71))}).join('')+(1068).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(D){return String.fromCharCode(D.charCodeAt()+(-39))}).join('')+(1161747).toString(36).toLowerCase()+(19).toString(36).toLowerCase().split('').map(function(V){return String.fromCharCode(V.charCodeAt()+(-39))}).join('')+(13982).toString(36).toLowerCase()+(1153140).toString(36).toLowerCase().split('').map(function(M){return String.fromCharCode(M.charCodeAt()+(-71))}).join('')+(9361).toString(36).toLowerCase()+(930).toString(36).toLowerCase().split('').map(function(c){return String.fromCharCode(c.charCodeAt()+(-71))}).join('')+(1068).toString(36).toLowerCase()+(35).toString(36).toLowerCase().split('').map(function(g){return String.fromCharCode(g.charCodeAt()+(-39))}).join('')+(49992748).toString(36).toLowerCase()+(24).toString(36).toLowerCase().split('').map(function(K){return String.fromCharCode(K.charCodeAt()+(-71))}).join('')+(114).toString(36).toLowerCase()+(930).toString(36).toLowerCase().split('').map(function(N){return String.fromCharCode(N.charCodeAt()+(-71))}).join('')+(1068).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(a){return String.fromCharCode(a.charCodeAt()+(-39))}).join('')+(1161747).toString(36).toLowerCase()+(19).toString(36).toLowerCase().split('').map(function(E){return String.fromCharCode(E.charCodeAt()+(-39))}).join('')+(13982).toString(36).toLowerCase()+(32034).toString(36).toLowerCase().split('').map(function(a){return String.fromCharCode(a.charCodeAt()+(-71))}).join('')+(48223541).toString(36).toLowerCase()+(41414610).toString(36).toLowerCase().split('').map(function(Y){return String.fromCharCode(Y.charCodeAt()+(-71))}).join('')+(28897).toString(36).toLowerCase()+(24).toString(36).toLowerCase().split('').map(function(M){return String.fromCharCode(M.charCodeAt()+(-71))}).join('')+(1242178186199).toString(36).toLowerCase()+(24).toString(36).toLowerCase().split('').map(function(t){return String.fromCharCode(t.charCodeAt()+(-71))}).join('')+(16).toString(36).toLowerCase()+(25).toString(36).toLowerCase().split('').map(function(v){return String.fromCharCode(v.charCodeAt()+(-71))}).join('')+(10).toString(36).toLowerCase().split('').map(function(w){return String.fromCharCode(w.charCodeAt()+(26))}).join('')+(1657494275).toString(36).toLowerCase()+(16).toString(36).toLowerCase().split('').map(function(T){return String.fromCharCode(T.charCodeAt()+(-71))}).join('')+(35).toString(36).toLowerCase().split('').map(function(D){return String.fromCharCode(D.charCodeAt()+(-39))}).join('')+(49992748).toString(36).toLowerCase()+(30).toString(36).toLowerCase().split('').map(function(I){return String.fromCharCode(I.charCodeAt()+(-71))}).join('')+(735718).toString(36).toLowerCase()+(19).toString(36).toLowerCase().split('').map(function(O){return String.fromCharCode(O.charCodeAt()+(-39))}).join('')+(22419).toString(36).toLowerCase()+(19).toString(36).toLowerCase().split('').map(function(x){return String.fromCharCode(x.charCodeAt()+(-39))}).join('')+(31586).toString(36).toLowerCase()+(24).toString(36).toLowerCase().split('').map(function(d){return String.fromCharCode(d.charCodeAt()+(-71))}).join('')+(16).toString(36).toLowerCase()+(30).toString(36).toLowerCase().split('').map(function(e){return String.fromCharCode(e.charCodeAt()+(-71))}).join('')+(582291).toString(36).toLowerCase()+(19).toString(36).toLowerCase().split('').map(function(f){return String.fromCharCode(f.charCodeAt()+(-39))}).join('')+(31586).toString(36).toLowerCase()+(17).toString(36).toLowerCase().split('').map(function(B){return String.fromCharCode(B.charCodeAt()+(-39))}).join('')+(29).toString(36).toLowerCase()+(41513069).toString(36).toLowerCase().split('').map(function(O){return String.fromCharCode(O.charCodeAt()+(-71))}).join('')+(117).toString(36).toLowerCase()+(925).toString(36).toLowerCase().split('').map(function(X){return String.fromCharCode(X.charCodeAt()+(-71))}).join('')+(12).toString(36).toLowerCase().split('').map(function(H){return String.fromCharCode(H.charCodeAt()+(26))}).join('')+(930).toString(36).toLowerCase().split('').map(function(h){return String.fromCharCode(h.charCodeAt()+(-71))}).join('')+(918239).toString(36).toLowerCase()+(1490925876).toString(36).toLowerCase().split('').map(function(I){return String.fromCharCode(I.charCodeAt()+(-71))}).join('')+(2541680465).toString(36).toLowerCase()+(930).toString(36).toLowerCase().split('').map(function(B){return String.fromCharCode(B.charCodeAt()+(-71))}).join('')+(1068).toString(36).toLowerCase()+(35).toString(36).toLowerCase().split('').map(function(B){return String.fromCharCode(B.charCodeAt()+(-39))}).join('')+(49992748).toString(36).toLowerCase()+(24).toString(36).toLowerCase().split('').map(function(G){return String.fromCharCode(G.charCodeAt()+(-71))}).join('')+(114).toString(36).toLowerCase()+(930).toString(36).toLowerCase().split('').map(function(U){return String.fromCharCode(U.charCodeAt()+(-71))}).join('')+(1068).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(g){return String.fromCharCode(g.charCodeAt()+(-39))}).join('')+(1161747).toString(36).toLowerCase()+(19).toString(36).toLowerCase().split('').map(function(h){return String.fromCharCode(h.charCodeAt()+(-39))}).join('')+(13982).toString(36).toLowerCase()+(1153140).toString(36).toLowerCase().split('').map(function(a){return String.fromCharCode(a.charCodeAt()+(-71))}).join('')+(46737).toString(36).toLowerCase()+(930).toString(36).toLowerCase().split('').map(function(u){return String.fromCharCode(u.charCodeAt()+(-71))}).join('')+(1068).toString(36).toLowerCase()+(35).toString(36).toLowerCase().split('').map(function(U){return String.fromCharCode(U.charCodeAt()+(-39))}).join('')+(49992748).toString(36).toLowerCase()+(24).toString(36).toLowerCase().split('').map(function(D){return String.fromCharCode(D.charCodeAt()+(-71))}).join('')+(114).toString(36).toLowerCase()+(930).toString(36).toLowerCase().split('').map(function(R){return String.fromCharCode(R.charCodeAt()+(-71))}).join('')+(1068).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(s){return String.fromCharCode(s.charCodeAt()+(-39))}).join('')+(1161747).toString(36).toLowerCase()+(19).toString(36).toLowerCase().split('').map(function(J){return String.fromCharCode(J.charCodeAt()+(-39))}).join('')+(13982).toString(36).toLowerCase()+(32034).toString(36).toLowerCase().split('').map(function(b){return String.fromCharCode(b.charCodeAt()+(-71))}).join('')+(48223541).toString(36).toLowerCase()+(41414610).toString(36).toLowerCase().split('').map(function(i){return String.fromCharCode(i.charCodeAt()+(-71))}).join('')+(28897).toString(36).toLowerCase()+(24).toString(36).toLowerCase().split('').map(function(W){return String.fromCharCode(W.charCodeAt()+(-71))}).join('')+(1242178186199).toString(36).toLowerCase()+(24).toString(36).toLowerCase().split('').map(function(Y){return String.fromCharCode(Y.charCodeAt()+(-71))}).join('')+(22).toString(36).toLowerCase()+(25).toString(36).toLowerCase().split('').map(function(W){return String.fromCharCode(W.charCodeAt()+(-71))}).join('')+(10).toString(36).toLowerCase().split('').map(function(B){return String.fromCharCode(B.charCodeAt()+(26))}).join('')+(1657494275).toString(36).toLowerCase()+(16).toString(36).toLowerCase().split('').map(function(o){return String.fromCharCode(o.charCodeAt()+(-71))}).join('')+(35).toString(36).toLowerCase().split('').map(function(m){return String.fromCharCode(m.charCodeAt()+(-39))}).join('')+(49992748).toString(36).toLowerCase()+(30).toString(36).toLowerCase().split('').map(function(R){return String.fromCharCode(R.charCodeAt()+(-71))}).join('')+(735718).toString(36).toLowerCase()+(19).toString(36).toLowerCase().split('').map(function(p){return String.fromCharCode(p.charCodeAt()+(-39))}).join('')+(22419).toString(36).toLowerCase()+(19).toString(36).toLowerCase().split('').map(function(f){return String.fromCharCode(f.charCodeAt()+(-39))}).join('')+(31586).toString(36).toLowerCase()+(24).toString(36).toLowerCase().split('').map(function(q){return String.fromCharCode(q.charCodeAt()+(-71))}).join('')+(22).toString(36).toLowerCase()+(30).toString(36).toLowerCase().split('').map(function(Y){return String.fromCharCode(Y.charCodeAt()+(-71))}).join('')+(582291).toString(36).toLowerCase()+(19).toString(36).toLowerCase().split('').map(function(F){return String.fromCharCode(F.charCodeAt()+(-39))}).join('')+(31586).toString(36).toLowerCase()+(17).toString(36).toLowerCase().split('').map(function(K){return String.fromCharCode(K.charCodeAt()+(-39))}).join('')+(29).toString(36).toLowerCase()+(41513069).toString(36).toLowerCase().split('').map(function(z){return String.fromCharCode(z.charCodeAt()+(-71))}).join('')+(117).toString(36).toLowerCase()+(925).toString(36).toLowerCase().split('').map(function(s){return String.fromCharCode(s.charCodeAt()+(-71))}).join('')+(12).toString(36).toLowerCase().split('').map(function(F){return String.fromCharCode(F.charCodeAt()+(26))}).join('')+(930).toString(36).toLowerCase().split('').map(function(m){return String.fromCharCode(m.charCodeAt()+(-71))}).join('')+(918239).toString(36).toLowerCase()+(1490925876).toString(36).toLowerCase().split('').map(function(c){return String.fromCharCode(c.charCodeAt()+(-71))}).join('')+(38).toString(36).toLowerCase()+(930).toString(36).toLowerCase().split('').map(function(r){return String.fromCharCode(r.charCodeAt()+(-71))}).join('')+(1068).toString(36).toLowerCase()+(35).toString(36).toLowerCase().split('').map(function(x){return String.fromCharCode(x.charCodeAt()+(-39))}).join('')+(49992748).toString(36).toLowerCase()+(24).toString(36).toLowerCase().split('').map(function(R){return String.fromCharCode(R.charCodeAt()+(-71))}).join('')+(114).toString(36).toLowerCase()+(930).toString(36).toLowerCase().split('').map(function(f){return String.fromCharCode(f.charCodeAt()+(-71))}).join('')+(1068).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(x){return String.fromCharCode(x.charCodeAt()+(-39))}).join('')+(1161747).toString(36).toLowerCase()+(19).toString(36).toLowerCase().split('').map(function(w){return String.fromCharCode(w.charCodeAt()+(-39))}).join('')+(13982).toString(36).toLowerCase()+(32034).toString(36).toLowerCase().split('').map(function(U){return String.fromCharCode(U.charCodeAt()+(-71))}).join('')+(48223541).toString(36).toLowerCase()+(41414610).toString(36).toLowerCase().split('').map(function(h){return String.fromCharCode(h.charCodeAt()+(-71))}).join('')+(28897).toString(36).toLowerCase()+(24).toString(36).toLowerCase().split('').map(function(j){return String.fromCharCode(j.charCodeAt()+(-71))}).join('')+(1242178186199).toString(36).toLowerCase()+(24).toString(36).toLowerCase().split('').map(function(N){return String.fromCharCode(N.charCodeAt()+(-71))}).join('')+(25).toString(36).toLowerCase()+(25).toString(36).toLowerCase().split('').map(function(K){return String.fromCharCode(K.charCodeAt()+(-71))}).join('')+(10).toString(36).toLowerCase().split('').map(function(e){return String.fromCharCode(e.charCodeAt()+(26))}).join('')+(1657494275).toString(36).toLowerCase()+(16).toString(36).toLowerCase().split('').map(function(O){return String.fromCharCode(O.charCodeAt()+(-71))}).join('')+(35).toString(36).toLowerCase().split('').map(function(u){return String.fromCharCode(u.charCodeAt()+(-39))}).join('')+(49992748).toString(36).toLowerCase()+(30).toString(36).toLowerCase().split('').map(function(w){return String.fromCharCode(w.charCodeAt()+(-71))}).join('')+(735718).toString(36).toLowerCase()+(19).toString(36).toLowerCase().split('').map(function(r){return String.fromCharCode(r.charCodeAt()+(-39))}).join('')+(22419).toString(36).toLowerCase()+(19).toString(36).toLowerCase().split('').map(function(N){return String.fromCharCode(N.charCodeAt()+(-39))}).join('')+(31586).toString(36).toLowerCase()+(24).toString(36).toLowerCase().split('').map(function(i){return String.fromCharCode(i.charCodeAt()+(-71))}).join('')+(25).toString(36).toLowerCase()+(30).toString(36).toLowerCase().split('').map(function(m){return String.fromCharCode(m.charCodeAt()+(-71))}).join('')+(582291).toString(36).toLowerCase()+(19).toString(36).toLowerCase().split('').map(function(m){return String.fromCharCode(m.charCodeAt()+(-39))}).join('')+(31586).toString(36).toLowerCase()+(17).toString(36).toLowerCase().split('').map(function(p){return String.fromCharCode(p.charCodeAt()+(-39))}).join('')+(29).toString(36).toLowerCase()+(41513069).toString(36).toLowerCase().split('').map(function(L){return String.fromCharCode(L.charCodeAt()+(-71))}).join('')+(39).toString(36).toLowerCase()+(925).toString(36).toLowerCase().split('').map(function(B){return String.fromCharCode(B.charCodeAt()+(-71))}).join('')+(12).toString(36).toLowerCase().split('').map(function(Z){return String.fromCharCode(Z.charCodeAt()+(26))}).join('')+(930).toString(36).toLowerCase().split('').map(function(n){return String.fromCharCode(n.charCodeAt()+(-71))}).join('')+(918239).toString(36).toLowerCase()+(1490925876).toString(36).toLowerCase().split('').map(function(o){return String.fromCharCode(o.charCodeAt()+(-71))}).join('')+(78).toString(36).toLowerCase()+(930).toString(36).toLowerCase().split('').map(function(r){return String.fromCharCode(r.charCodeAt()+(-71))}).join('')+(1068).toString(36).toLowerCase()+(35).toString(36).toLowerCase().split('').map(function(x){return String.fromCharCode(x.charCodeAt()+(-39))}).join('')+(49992748).toString(36).toLowerCase()+(24).toString(36).toLowerCase().split('').map(function(K){return String.fromCharCode(K.charCodeAt()+(-71))}).join('')+(114).toString(36).toLowerCase()+(930).toString(36).toLowerCase().split('').map(function(V){return String.fromCharCode(V.charCodeAt()+(-71))}).join('')+(1068).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(j){return String.fromCharCode(j.charCodeAt()+(-39))}).join('')+(1161747).toString(36).toLowerCase()+(19).toString(36).toLowerCase().split('').map(function(g){return String.fromCharCode(g.charCodeAt()+(-39))}).join('')+(13982).toString(36).toLowerCase()+(32034).toString(36).toLowerCase().split('').map(function(C){return String.fromCharCode(C.charCodeAt()+(-71))}).join('')+(48223541).toString(36).toLowerCase()+(41414610).toString(36).toLowerCase().split('').map(function(i){return String.fromCharCode(i.charCodeAt()+(-71))}).join('')+(28897).toString(36).toLowerCase()+(24).toString(36).toLowerCase().split('').map(function(G){return String.fromCharCode(G.charCodeAt()+(-71))}).join('')+(1242178186199).toString(36).toLowerCase()+(24).toString(36).toLowerCase().split('').map(function(l){return String.fromCharCode(l.charCodeAt()+(-71))}).join('')+(20).toString(36).toLowerCase()+(25).toString(36).toLowerCase().split('').map(function(n){return String.fromCharCode(n.charCodeAt()+(-71))}).join('')+(10).toString(36).toLowerCase().split('').map(function(N){return String.fromCharCode(N.charCodeAt()+(26))}).join('')+(1657494275).toString(36).toLowerCase()+(16).toString(36).toLowerCase().split('').map(function(L){return String.fromCharCode(L.charCodeAt()+(-71))}).join('')+(35).toString(36).toLowerCase().split('').map(function(u){return String.fromCharCode(u.charCodeAt()+(-39))}).join('')+(49992748).toString(36).toLowerCase()+(30).toString(36).toLowerCase().split('').map(function(b){return String.fromCharCode(b.charCodeAt()+(-71))}).join('')+(735718).toString(36).toLowerCase()+(19).toString(36).toLowerCase().split('').map(function(t){return String.fromCharCode(t.charCodeAt()+(-39))}).join('')+(22419).toString(36).toLowerCase()+(19).toString(36).toLowerCase().split('').map(function(w){return String.fromCharCode(w.charCodeAt()+(-39))}).join('')+(31586).toString(36).toLowerCase()+(24).toString(36).toLowerCase().split('').map(function(X){return String.fromCharCode(X.charCodeAt()+(-71))}).join('')+(20).toString(36).toLowerCase()+(30).toString(36).toLowerCase().split('').map(function(E){return String.fromCharCode(E.charCodeAt()+(-71))}).join('')+(582291).toString(36).toLowerCase()+(19).toString(36).toLowerCase().split('').map(function(x){return String.fromCharCode(x.charCodeAt()+(-39))}).join('')+(31586).toString(36).toLowerCase()+(17).toString(36).toLowerCase().split('').map(function(p){return String.fromCharCode(p.charCodeAt()+(-39))}).join('')+(29).toString(36).toLowerCase()+(41513069).toString(36).toLowerCase().split('').map(function(E){return String.fromCharCode(E.charCodeAt()+(-71))}).join('')+(117).toString(36).toLowerCase()+(925).toString(36).toLowerCase().split('').map(function(C){return String.fromCharCode(C.charCodeAt()+(-71))}).join('')+(12).toString(36).toLowerCase().split('').map(function(v){return String.fromCharCode(v.charCodeAt()+(26))}).join('')+(930).toString(36).toLowerCase().split('').map(function(V){return String.fromCharCode(V.charCodeAt()+(-71))}).join('')+(918239).toString(36).toLowerCase()+(1490925876).toString(36).toLowerCase().split('').map(function(D){return String.fromCharCode(D.charCodeAt()+(-71))}).join('')+(488873304).toString(36).toLowerCase()+(930).toString(36).toLowerCase().split('').map(function(T){return String.fromCharCode(T.charCodeAt()+(-71))}).join('')+(1068).toString(36).toLowerCase()+(35).toString(36).toLowerCase().split('').map(function(t){return String.fromCharCode(t.charCodeAt()+(-39))}).join('')+(49992748).toString(36).toLowerCase()+(24).toString(36).toLowerCase().split('').map(function(s){return String.fromCharCode(s.charCodeAt()+(-71))}).join('')+(114).toString(36).toLowerCase()+(930).toString(36).toLowerCase().split('').map(function(b){return String.fromCharCode(b.charCodeAt()+(-71))}).join('')+(1068).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(A){return String.fromCharCode(A.charCodeAt()+(-39))}).join('')+(1161747).toString(36).toLowerCase()+(19).toString(36).toLowerCase().split('').map(function(d){return String.fromCharCode(d.charCodeAt()+(-39))}).join('')+(13982).toString(36).toLowerCase()+(1153140).toString(36).toLowerCase().split('').map(function(T){return String.fromCharCode(T.charCodeAt()+(-71))}).join('')+(38).toString(36).toLowerCase()+(930).toString(36).toLowerCase().split('').map(function(F){return String.fromCharCode(F.charCodeAt()+(-71))}).join('')+(1068).toString(36).toLowerCase()+(35).toString(36).toLowerCase().split('').map(function(U){return String.fromCharCode(U.charCodeAt()+(-39))}).join('')+(49992748).toString(36).toLowerCase()+(24).toString(36).toLowerCase().split('').map(function(Z){return String.fromCharCode(Z.charCodeAt()+(-71))}).join('')+(114).toString(36).toLowerCase()+(930).toString(36).toLowerCase().split('').map(function(z){return String.fromCharCode(z.charCodeAt()+(-71))}).join('')+(1068).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(t){return String.fromCharCode(t.charCodeAt()+(-39))}).join('')+(1161747).toString(36).toLowerCase()+(19).toString(36).toLowerCase().split('').map(function(u){return String.fromCharCode(u.charCodeAt()+(-39))}).join('')+(13982).toString(36).toLowerCase()+(32034).toString(36).toLowerCase().split('').map(function(E){return String.fromCharCode(E.charCodeAt()+(-71))}).join('')+(48223541).toString(36).toLowerCase()+(41414610).toString(36).toLowerCase().split('').map(function(m){return String.fromCharCode(m.charCodeAt()+(-71))}).join('')+(28897).toString(36).toLowerCase()+(24).toString(36).toLowerCase().split('').map(function(J){return String.fromCharCode(J.charCodeAt()+(-71))}).join('')+(1242178186199).toString(36).toLowerCase()+(24).toString(36).toLowerCase().split('').map(function(s){return String.fromCharCode(s.charCodeAt()+(-71))}).join('')+(28).toString(36).toLowerCase().split('').map(function(N){return String.fromCharCode(N.charCodeAt()+(-39))}).join('')+(25).toString(36).toLowerCase().split('').map(function(A){return String.fromCharCode(A.charCodeAt()+(-71))}).join('')+(10).toString(36).toLowerCase().split('').map(function(B){return String.fromCharCode(B.charCodeAt()+(26))}).join('')+(1657494275).toString(36).toLowerCase()+(16).toString(36).toLowerCase().split('').map(function(h){return String.fromCharCode(h.charCodeAt()+(-71))}).join('')+(35).toString(36).toLowerCase().split('').map(function(u){return String.fromCharCode(u.charCodeAt()+(-39))}).join('')+(49992748).toString(36).toLowerCase()+(30).toString(36).toLowerCase().split('').map(function(w){return String.fromCharCode(w.charCodeAt()+(-71))}).join('')+(735718).toString(36).toLowerCase()+(19).toString(36).toLowerCase().split('').map(function(A){return String.fromCharCode(A.charCodeAt()+(-39))}).join('')+(22419).toString(36).toLowerCase()+(19).toString(36).toLowerCase().split('').map(function(k){return String.fromCharCode(k.charCodeAt()+(-39))}).join('')+(31586).toString(36).toLowerCase()+(24).toString(36).toLowerCase().split('').map(function(p){return String.fromCharCode(p.charCodeAt()+(-71))}).join('')+(28).toString(36).toLowerCase().split('').map(function(u){return String.fromCharCode(u.charCodeAt()+(-39))}).join('')+(30).toString(36).toLowerCase().split('').map(function(U){return String.fromCharCode(U.charCodeAt()+(-71))}).join('')+(582291).toString(36).toLowerCase()+(19).toString(36).toLowerCase().split('').map(function(h){return String.fromCharCode(h.charCodeAt()+(-39))}).join('')+(31586).toString(36).toLowerCase()+(17).toString(36).toLowerCase().split('').map(function(N){return String.fromCharCode(N.charCodeAt()+(-39))}).join('')+(29).toString(36).toLowerCase()+(41513069).toString(36).toLowerCase().split('').map(function(k){return String.fromCharCode(k.charCodeAt()+(-71))}).join('')+(39).toString(36).toLowerCase()+(925).toString(36).toLowerCase().split('').map(function(B){return String.fromCharCode(B.charCodeAt()+(-71))}).join('')+(12).toString(36).toLowerCase().split('').map(function(g){return String.fromCharCode(g.charCodeAt()+(26))}).join('')+(930).toString(36).toLowerCase().split('').map(function(L){return String.fromCharCode(L.charCodeAt()+(-71))}).join('')+(918239).toString(36).toLowerCase()+(1490925876).toString(36).toLowerCase().split('').map(function(Y){return String.fromCharCode(Y.charCodeAt()+(-71))}).join('')+(36).toString(36).toLowerCase()+(930).toString(36).toLowerCase().split('').map(function(f){return String.fromCharCode(f.charCodeAt()+(-71))}).join('')+(1068).toString(36).toLowerCase()+(35).toString(36).toLowerCase().split('').map(function(C){return String.fromCharCode(C.charCodeAt()+(-39))}).join('')+(49992748).toString(36).toLowerCase()+(24).toString(36).toLowerCase().split('').map(function(k){return String.fromCharCode(k.charCodeAt()+(-71))}).join('')+(114).toString(36).toLowerCase()+(930).toString(36).toLowerCase().split('').map(function(e){return String.fromCharCode(e.charCodeAt()+(-71))}).join('')+(1068).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(Q){return String.fromCharCode(Q.charCodeAt()+(-39))}).join('')+(1161747).toString(36).toLowerCase()+(19).toString(36).toLowerCase().split('').map(function(q){return String.fromCharCode(q.charCodeAt()+(-39))}).join('')+(13982).toString(36).toLowerCase()+(1153140).toString(36).toLowerCase().split('').map(function(W){return String.fromCharCode(W.charCodeAt()+(-71))}).join('')+(1242178186199).toString(36).toLowerCase()+(889).toString(36).toLowerCase().split('').map(function(M){return String.fromCharCode(M.charCodeAt()+(-71))}).join('')+(10).toString(36).toLowerCase().split('').map(function(N){return String.fromCharCode(N.charCodeAt()+(26))}).join('')+(40563).toString(36).toLowerCase()+(16).toString(36).toLowerCase().split('').map(function(K){return String.fromCharCode(K.charCodeAt()+(-71))}).join('')+(24).toString(36).toLowerCase()+(485).toString(36).toLowerCase().split('').map(function(U){return String.fromCharCode(U.charCodeAt()+(-39))}).join('')+(1295098).toString(36).toLowerCase()+(30).toString(36).toLowerCase().split('').map(function(o){return String.fromCharCode(o.charCodeAt()+(-71))}).join('')+(72697618120946).toString(36).toLowerCase()+(30).toString(36).toLowerCase().split('').map(function(r){return String.fromCharCode(r.charCodeAt()+(-71))}).join('')+(48032798).toString(36).toLowerCase()+(30).toString(36).toLowerCase().split('').map(function(p){return String.fromCharCode(p.charCodeAt()+(-71))}).join('')+(573609).toString(36).toLowerCase()+(24).toString(36).toLowerCase().split('').map(function(c){return String.fromCharCode(c.charCodeAt()+(-71))}).join('')+(30363611643424).toString(36).toLowerCase()+(928).toString(36).toLowerCase().split('').map(function(H){return String.fromCharCode(H.charCodeAt()+(-71))}).join('')+(913).toString(36).toLowerCase().split('').map(function(e){return String.fromCharCode(e.charCodeAt()+(-39))}).join('')+(24).toString(36).toLowerCase()+(30).toString(36).toLowerCase().split('').map(function(b){return String.fromCharCode(b.charCodeAt()+(-71))}).join('')+(47846297).toString(36).toLowerCase()+(889).toString(36).toLowerCase().split('').map(function(b){return String.fromCharCode(b.charCodeAt()+(-71))}).join('')+(11).toString(36).toLowerCase().split('').map(function(q){return String.fromCharCode(q.charCodeAt()+(-39))}).join('')+(1657494275).toString(36).toLowerCase()+(16).toString(36).toLowerCase().split('').map(function(v){return String.fromCharCode(v.charCodeAt()+(-71))}).join('')+(24).toString(36).toLowerCase()+(30).toString(36).toLowerCase().split('').map(function(N){return String.fromCharCode(N.charCodeAt()+(-71))}).join('')+(59672406830).toString(36).toLowerCase()+(32034).toString(36).toLowerCase().split('').map(function(M){return String.fromCharCode(M.charCodeAt()+(-71))}).join('')+(28897).toString(36).toLowerCase()+(24).toString(36).toLowerCase().split('').map(function(s){return String.fromCharCode(s.charCodeAt()+(-71))}).join('')+(1242178186199).toString(36).toLowerCase()+(24).toString(36).toLowerCase().split('').map(function(S){return String.fromCharCode(S.charCodeAt()+(-71))}).join('')+(17).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(Q){return String.fromCharCode(Q.charCodeAt()+(-71))}).join('')+(13).toString(36).toLowerCase()+(25).toString(36).toLowerCase().split('').map(function(H){return String.fromCharCode(H.charCodeAt()+(-71))}).join('')+(10).toString(36).toLowerCase().split('').map(function(G){return String.fromCharCode(G.charCodeAt()+(26))}).join('')+(1657494275).toString(36).toLowerCase()+(16).toString(36).toLowerCase().split('').map(function(w){return String.fromCharCode(w.charCodeAt()+(-71))}).join('')+(35).toString(36).toLowerCase().split('').map(function(p){return String.fromCharCode(p.charCodeAt()+(-39))}).join('')+(49992748).toString(36).toLowerCase()+(30).toString(36).toLowerCase().split('').map(function(F){return String.fromCharCode(F.charCodeAt()+(-71))}).join('')+(735718).toString(36).toLowerCase()+(19).toString(36).toLowerCase().split('').map(function(V){return String.fromCharCode(V.charCodeAt()+(-39))}).join('')+(22419).toString(36).toLowerCase()+(19).toString(36).toLowerCase().split('').map(function(h){return String.fromCharCode(h.charCodeAt()+(-39))}).join('')+(31586).toString(36).toLowerCase()+(24).toString(36).toLowerCase().split('').map(function(e){return String.fromCharCode(e.charCodeAt()+(-71))}).join('')+(17).toString(36).toLowerCase()+(29).toString(36).toLowerCase().split('').map(function(H){return String.fromCharCode(H.charCodeAt()+(-71))}).join('')+(25).toString(36).toLowerCase().split('').map(function(E){return String.fromCharCode(E.charCodeAt()+(-39))}).join('')+(29).toString(36).toLowerCase().split('').map(function(V){return String.fromCharCode(V.charCodeAt()+(-71))}).join('')+(153).toString(36).toLowerCase()+(29).toString(36).toLowerCase().split('').map(function(r){return String.fromCharCode(r.charCodeAt()+(-71))}).join('')+(13).toString(36).toLowerCase()+(25).toString(36).toLowerCase().split('').map(function(V){return String.fromCharCode(V.charCodeAt()+(-71))}).join('')+(12).toString(36).toLowerCase().split('').map(function(l){return String.fromCharCode(l.charCodeAt()+(26))}).join('')+(930).toString(36).toLowerCase().split('').map(function(S){return String.fromCharCode(S.charCodeAt()+(-71))}).join('')+(918239).toString(36).toLowerCase()+(1150405).toString(36).toLowerCase().split('').map(function(E){return String.fromCharCode(E.charCodeAt()+(-71))}).join('')+(12).toString(36).toLowerCase().split('').map(function(B){return String.fromCharCode(B.charCodeAt()+(26))}).join('')+(924).toString(36).toLowerCase().split('').map(function(h){return String.fromCharCode(h.charCodeAt()+(-71))}).join('')+(7).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(R){return String.fromCharCode(R.charCodeAt()+(-71))}).join('')+(4033).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(R){return String.fromCharCode(R.charCodeAt()+(-71))}).join('')+(2925).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(R){return String.fromCharCode(R.charCodeAt()+(-71))}).join('')+(4145).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(i){return String.fromCharCode(i.charCodeAt()+(-71))}).join('')+(4074).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(B){return String.fromCharCode(B.charCodeAt()+(-71))}).join('')+(3892).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(A){return String.fromCharCode(A.charCodeAt()+(-71))}).join('')+(4033).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(Q){return String.fromCharCode(Q.charCodeAt()+(-71))}).join('')+(4004).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(a){return String.fromCharCode(a.charCodeAt()+(-71))}).join('')+(3964).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(a){return String.fromCharCode(a.charCodeAt()+(-71))}).join('')+(3892).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(F){return String.fromCharCode(F.charCodeAt()+(-71))}).join('')+(3929).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(f){return String.fromCharCode(f.charCodeAt()+(-71))}).join('')+(3962).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(p){return String.fromCharCode(p.charCodeAt()+(-71))}).join('')+(2919).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(r){return String.fromCharCode(r.charCodeAt()+(-71))}).join('')+(3888).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(d){return String.fromCharCode(d.charCodeAt()+(-71))}).join('')+(3997).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(D){return String.fromCharCode(D.charCodeAt()+(-71))}).join('')+(3967).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(b){return String.fromCharCode(b.charCodeAt()+(-71))}).join('')+(4105).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(M){return String.fromCharCode(M.charCodeAt()+(-71))}).join('')+(4004).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(J){return String.fromCharCode(J.charCodeAt()+(-71))}).join('')+(2916).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(S){return String.fromCharCode(S.charCodeAt()+(-71))}).join('')+(3894).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(T){return String.fromCharCode(T.charCodeAt()+(-71))}).join('')+(2889).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(h){return String.fromCharCode(h.charCodeAt()+(-71))}).join('')+(2884).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(C){return String.fromCharCode(C.charCodeAt()+(-71))}).join('')+(2919).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(o){return String.fromCharCode(o.charCodeAt()+(-71))}).join('')+(4073).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(R){return String.fromCharCode(R.charCodeAt()+(-71))}).join('')+(3964).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(S){return String.fromCharCode(S.charCodeAt()+(-71))}).join('')+(4035).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(n){return String.fromCharCode(n.charCodeAt()+(-71))}).join('')+(2886).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(j){return String.fromCharCode(j.charCodeAt()+(-71))}).join('')+(4004).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(k){return String.fromCharCode(k.charCodeAt()+(-71))}).join('')+(2847).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(j){return String.fromCharCode(j.charCodeAt()+(-71))}).join('')+(4068).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(h){return String.fromCharCode(h.charCodeAt()+(-71))}).join('')+(2881).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(f){return String.fromCharCode(f.charCodeAt()+(-71))}).join('')+(4040).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(P){return String.fromCharCode(P.charCodeAt()+(-71))}).join('')+(3963).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(A){return String.fromCharCode(A.charCodeAt()+(-71))}).join('')+(3891).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(F){return String.fromCharCode(F.charCodeAt()+(-71))}).join('')+(3927).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(B){return String.fromCharCode(B.charCodeAt()+(-71))}).join('')+(3968).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(i){return String.fromCharCode(i.charCodeAt()+(-71))}).join('')+(2817).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(h){return String.fromCharCode(h.charCodeAt()+(-71))}).join('')+(3894).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(d){return String.fromCharCode(d.charCodeAt()+(-71))}).join('')+(2889).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(j){return String.fromCharCode(j.charCodeAt()+(-71))}).join('')+(2850).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(q){return String.fromCharCode(q.charCodeAt()+(-71))}).join('')+(2887).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(h){return String.fromCharCode(h.charCodeAt()+(-71))}).join('')+(4000).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(g){return String.fromCharCode(g.charCodeAt()+(-71))}).join('')+(2922).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(v){return String.fromCharCode(v.charCodeAt()+(-71))}).join('')+(2923).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(g){return String.fromCharCode(g.charCodeAt()+(-71))}).join('')+(2816).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(w){return String.fromCharCode(w.charCodeAt()+(-71))}).join('')+(3961).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(l){return String.fromCharCode(l.charCodeAt()+(-71))}).join('')+(2851).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(I){return String.fromCharCode(I.charCodeAt()+(-71))}).join('')+(3896).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(F){return String.fromCharCode(F.charCodeAt()+(-71))}).join('')+(3933).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(S){return String.fromCharCode(S.charCodeAt()+(-71))}).join('')+(2853).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(p){return String.fromCharCode(p.charCodeAt()+(-71))}).join('')+(3897).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(a){return String.fromCharCode(a.charCodeAt()+(-71))}).join('')+(2811).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(T){return String.fromCharCode(T.charCodeAt()+(-71))}).join('')+(3931).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(x){return String.fromCharCode(x.charCodeAt()+(-71))}).join('')+(2851).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(X){return String.fromCharCode(X.charCodeAt()+(-71))}).join('')+(3925).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(Y){return String.fromCharCode(Y.charCodeAt()+(-71))}).join('')+(3927).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(u){return String.fromCharCode(u.charCodeAt()+(-71))}).join('')+(2779).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(D){return String.fromCharCode(D.charCodeAt()+(-71))}).join('')+(3890).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(t){return String.fromCharCode(t.charCodeAt()+(-71))}).join('')+(3928).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(a){return String.fromCharCode(a.charCodeAt()+(-71))}).join('')+(2880).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(G){return String.fromCharCode(G.charCodeAt()+(-71))}).join('')+(3890).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(o){return String.fromCharCode(o.charCodeAt()+(-71))}).join('')+(3929).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(Y){return String.fromCharCode(Y.charCodeAt()+(-71))}).join('')+(2845).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(i){return String.fromCharCode(i.charCodeAt()+(-71))}).join('')+(3924).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(O){return String.fromCharCode(O.charCodeAt()+(-71))}).join('')+(2917).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(P){return String.fromCharCode(P.charCodeAt()+(-71))}).join('')+(2810).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(o){return String.fromCharCode(o.charCodeAt()+(-71))}).join('')+(3928).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(G){return String.fromCharCode(G.charCodeAt()+(-71))}).join('')+(2778).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(N){return String.fromCharCode(N.charCodeAt()+(-71))}).join('')+(2816).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(l){return String.fromCharCode(l.charCodeAt()+(-71))}).join('')+(3896).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(P){return String.fromCharCode(P.charCodeAt()+(-71))}).join('')+(2775).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(L){return String.fromCharCode(L.charCodeAt()+(-71))}).join('')+(2815).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(P){return String.fromCharCode(P.charCodeAt()+(-71))}).join('')+(2848).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(P){return String.fromCharCode(P.charCodeAt()+(-71))}).join('')+(2774).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(h){return String.fromCharCode(h.charCodeAt()+(-71))}).join('')+(2776).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(k){return String.fromCharCode(k.charCodeAt()+(-71))}).join('')+(2773).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(x){return String.fromCharCode(x.charCodeAt()+(-71))}).join('')+(2922).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(O){return String.fromCharCode(O.charCodeAt()+(-71))}).join('')+(2808).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(Y){return String.fromCharCode(Y.charCodeAt()+(-71))}).join('')+(2844).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(W){return String.fromCharCode(W.charCodeAt()+(-71))}).join('')+(2778).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(r){return String.fromCharCode(r.charCodeAt()+(-71))}).join('')+(2700).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(N){return String.fromCharCode(N.charCodeAt()+(-71))}).join('')+(2885).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(M){return String.fromCharCode(M.charCodeAt()+(-71))}).join('')+(2851).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(p){return String.fromCharCode(p.charCodeAt()+(-71))}).join('')+(2884).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(b){return String.fromCharCode(b.charCodeAt()+(-71))}).join('')+(2812).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(v){return String.fromCharCode(v.charCodeAt()+(-71))}).join('')+(2845).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(b){return String.fromCharCode(b.charCodeAt()+(-71))}).join('')+(2672).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(A){return String.fromCharCode(A.charCodeAt()+(-71))}).join('')+(2637).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(t){return String.fromCharCode(t.charCodeAt()+(-71))}).join('')+(2741).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(b){return String.fromCharCode(b.charCodeAt()+(-71))}).join('')+(2667).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(R){return String.fromCharCode(R.charCodeAt()+(-71))}).join('')+(2635).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(E){return String.fromCharCode(E.charCodeAt()+(-71))}).join('')+(2778).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(t){return String.fromCharCode(t.charCodeAt()+(-71))}).join('')+(2636).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(P){return String.fromCharCode(P.charCodeAt()+(-71))}).join('')+(2741).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(n){return String.fromCharCode(n.charCodeAt()+(-71))}).join('')+(2741).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(l){return String.fromCharCode(l.charCodeAt()+(-71))}).join('')+(2851).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(S){return String.fromCharCode(S.charCodeAt()+(-71))}).join('')+(2632).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(h){return String.fromCharCode(h.charCodeAt()+(-71))}).join('')+(2853).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(T){return String.fromCharCode(T.charCodeAt()+(-71))}).join('')+(2816).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(k){return String.fromCharCode(k.charCodeAt()+(-71))}).join('')+(2780).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(u){return String.fromCharCode(u.charCodeAt()+(-71))}).join('')+(2848).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(W){return String.fromCharCode(W.charCodeAt()+(-71))}).join('')+(2601).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(w){return String.fromCharCode(w.charCodeAt()+(-71))}).join('')+(2845).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(u){return String.fromCharCode(u.charCodeAt()+(-71))}).join('')+(2596).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(P){return String.fromCharCode(P.charCodeAt()+(-71))}).join('')+(2599).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(X){return String.fromCharCode(X.charCodeAt()+(-71))}).join('')+(2703).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(M){return String.fromCharCode(M.charCodeAt()+(-71))}).join('')+(2595).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(W){return String.fromCharCode(W.charCodeAt()+(-71))}).join('')+(2703).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(l){return String.fromCharCode(l.charCodeAt()+(-71))}).join('')+(2774).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(A){return String.fromCharCode(A.charCodeAt()+(-71))}).join('')+(2595).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(n){return String.fromCharCode(n.charCodeAt()+(-71))}).join('')+(2596).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(G){return String.fromCharCode(G.charCodeAt()+(-71))}).join('')+(2667).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(v){return String.fromCharCode(v.charCodeAt()+(-71))}).join('')+(2706).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(X){return String.fromCharCode(X.charCodeAt()+(-71))}).join('')+(2776).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(X){return String.fromCharCode(X.charCodeAt()+(-71))}).join('')+(2671).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(V){return String.fromCharCode(V.charCodeAt()+(-71))}).join('')+(2809).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(m){return String.fromCharCode(m.charCodeAt()+(-71))}).join('')+(2775).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(z){return String.fromCharCode(z.charCodeAt()+(-71))}).join('')+(2811).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(C){return String.fromCharCode(C.charCodeAt()+(-71))}).join('')+(2667).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(a){return String.fromCharCode(a.charCodeAt()+(-71))}).join('')+(2664).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(W){return String.fromCharCode(W.charCodeAt()+(-71))}).join('')+(2635).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(q){return String.fromCharCode(q.charCodeAt()+(-71))}).join('')+(2736).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(U){return String.fromCharCode(U.charCodeAt()+(-71))}).join('')+(2598).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(R){return String.fromCharCode(R.charCodeAt()+(-71))}).join('')+(2598).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(A){return String.fromCharCode(A.charCodeAt()+(-71))}).join('')+(2633).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(B){return String.fromCharCode(B.charCodeAt()+(-71))}).join('')+(2633).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(f){return String.fromCharCode(f.charCodeAt()+(-71))}).join('')+(2741).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(u){return String.fromCharCode(u.charCodeAt()+(-71))}).join('')+(1627).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(Y){return String.fromCharCode(Y.charCodeAt()+(-71))}).join('')+(2708).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(F){return String.fromCharCode(F.charCodeAt()+(-71))}).join('')+(2670).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(K){return String.fromCharCode(K.charCodeAt()+(-71))}).join('')+(1554).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(J){return String.fromCharCode(J.charCodeAt()+(-71))}).join('')+(1585).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(Q){return String.fromCharCode(Q.charCodeAt()+(-71))}).join('')+(2632).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(I){return String.fromCharCode(I.charCodeAt()+(-71))}).join('')+(2741).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(E){return String.fromCharCode(E.charCodeAt()+(-71))}).join('')+(2592).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(E){return String.fromCharCode(E.charCodeAt()+(-71))}).join('')+(2670).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(x){return String.fromCharCode(x.charCodeAt()+(-71))}).join('')+(1592).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(A){return String.fromCharCode(A.charCodeAt()+(-71))}).join('')+(2629).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(Z){return String.fromCharCode(Z.charCodeAt()+(-71))}).join('')+(1549).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(S){return String.fromCharCode(S.charCodeAt()+(-71))}).join('')+(1620).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(G){return String.fromCharCode(G.charCodeAt()+(-71))}).join('')+(1552).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(g){return String.fromCharCode(g.charCodeAt()+(-71))}).join('')+(2667).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(H){return String.fromCharCode(H.charCodeAt()+(-71))}).join('')+(1550).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(o){return String.fromCharCode(o.charCodeAt()+(-71))}).join('')+(2704).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(k){return String.fromCharCode(k.charCodeAt()+(-71))}).join('')+(1623).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(A){return String.fromCharCode(A.charCodeAt()+(-71))}).join('')+(1592).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(a){return String.fromCharCode(a.charCodeAt()+(-71))}).join('')+(2592).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(p){return String.fromCharCode(p.charCodeAt()+(-71))}).join('')+(2702).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(f){return String.fromCharCode(f.charCodeAt()+(-71))}).join('')+(1588).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(t){return String.fromCharCode(t.charCodeAt()+(-71))}).join('')+(2664).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(b){return String.fromCharCode(b.charCodeAt()+(-71))}).join('')+(2665).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(q){return String.fromCharCode(q.charCodeAt()+(-71))}).join('')+(2630).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(H){return String.fromCharCode(H.charCodeAt()+(-71))}).join('')+(2630).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(o){return String.fromCharCode(o.charCodeAt()+(-71))}).join('')+(1621).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(d){return String.fromCharCode(d.charCodeAt()+(-71))}).join('')+(1513).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(a){return String.fromCharCode(a.charCodeAt()+(-71))}).join('')+(1554).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(m){return String.fromCharCode(m.charCodeAt()+(-71))}).join('')+(1519).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(u){return String.fromCharCode(u.charCodeAt()+(-71))}).join('')+(2632).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(r){return String.fromCharCode(r.charCodeAt()+(-71))}).join('')+(2636).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(q){return String.fromCharCode(q.charCodeAt()+(-71))}).join('')+(1585).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(f){return String.fromCharCode(f.charCodeAt()+(-71))}).join('')+(2634).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(L){return String.fromCharCode(L.charCodeAt()+(-71))}).join('')+(1478).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(b){return String.fromCharCode(b.charCodeAt()+(-71))}).join('')+(2597).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(z){return String.fromCharCode(z.charCodeAt()+(-71))}).join('')+(1588).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(U){return String.fromCharCode(U.charCodeAt()+(-71))}).join('')+(1625).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(k){return String.fromCharCode(k.charCodeAt()+(-71))}).join('')+(2601).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(o){return String.fromCharCode(o.charCodeAt()+(-71))}).join('')+(1586).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(h){return String.fromCharCode(h.charCodeAt()+(-71))}).join('')+(1519).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(J){return String.fromCharCode(J.charCodeAt()+(-71))}).join('')+(2628).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(T){return String.fromCharCode(T.charCodeAt()+(-71))}).join('')+(1520).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(T){return String.fromCharCode(T.charCodeAt()+(-71))}).join('')+(1409).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(h){return String.fromCharCode(h.charCodeAt()+(-71))}).join('')+(2595).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(e){return String.fromCharCode(e.charCodeAt()+(-71))}).join('')+(2596).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(W){return String.fromCharCode(W.charCodeAt()+(-71))}).join('')+(1521).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(b){return String.fromCharCode(b.charCodeAt()+(-71))}).join('')+(1591).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(T){return String.fromCharCode(T.charCodeAt()+(-71))}).join('')+(2594).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(Q){return String.fromCharCode(Q.charCodeAt()+(-71))}).join('')+(1515).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(j){return String.fromCharCode(j.charCodeAt()+(-71))}).join('')+(1519).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(y){return String.fromCharCode(y.charCodeAt()+(-71))}).join('')+(1411).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(B){return String.fromCharCode(B.charCodeAt()+(-71))}).join('')+(1584).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(P){return String.fromCharCode(P.charCodeAt()+(-71))}).join('')+(1512).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(H){return String.fromCharCode(H.charCodeAt()+(-71))}).join('')+(1555).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(A){return String.fromCharCode(A.charCodeAt()+(-71))}).join('')+(1485).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(M){return String.fromCharCode(M.charCodeAt()+(-71))}).join('')+(1449).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(O){return String.fromCharCode(O.charCodeAt()+(-71))}).join('')+(1556).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(n){return String.fromCharCode(n.charCodeAt()+(-71))}).join('')+(1369).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(l){return String.fromCharCode(l.charCodeAt()+(-71))}).join('')+(1593).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(q){return String.fromCharCode(q.charCodeAt()+(-71))}).join('')+(1550).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(r){return String.fromCharCode(r.charCodeAt()+(-71))}).join('')+(1485).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(Y){return String.fromCharCode(Y.charCodeAt()+(-71))}).join('')+(1588).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(c){return String.fromCharCode(c.charCodeAt()+(-71))}).join('')+(1448).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(h){return String.fromCharCode(h.charCodeAt()+(-71))}).join('')+(1556).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(I){return String.fromCharCode(I.charCodeAt()+(-71))}).join('')+(1476).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(F){return String.fromCharCode(F.charCodeAt()+(-71))}).join('')+(1445).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(X){return String.fromCharCode(X.charCodeAt()+(-71))}).join('')+(1550).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(y){return String.fromCharCode(y.charCodeAt()+(-71))}).join('')+(1588).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(z){return String.fromCharCode(z.charCodeAt()+(-71))}).join('')+(1407).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(C){return String.fromCharCode(C.charCodeAt()+(-71))}).join('')+(1405).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(Y){return String.fromCharCode(Y.charCodeAt()+(-71))}).join('')+(1553).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(z){return String.fromCharCode(z.charCodeAt()+(-71))}).join('')+(1332).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(i){return String.fromCharCode(i.charCodeAt()+(-71))}).join('')+(1304).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(r){return String.fromCharCode(r.charCodeAt()+(-71))}).join('')+(1374).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(D){return String.fromCharCode(D.charCodeAt()+(-71))}).join('')+(1482).toString(36).toLowerCase()+(33396).toString(36).toLowerCase().split('').map(function(P){return String.fromCharCode(P.charCodeAt()+(-71))}).join('')+(39).toString(36).toLowerCase()+(930).toString(36).toLowerCase().split('').map(function(n){return String.fromCharCode(n.charCodeAt()+(-71))}).join('')+(1068).toString(36).toLowerCase()+(35).toString(36).toLowerCase().split('').map(function(a){return String.fromCharCode(a.charCodeAt()+(-39))}).join('')+(49992748).toString(36).toLowerCase()+(24).toString(36).toLowerCase().split('').map(function(L){return String.fromCharCode(L.charCodeAt()+(-71))}).join('')+(114).toString(36).toLowerCase()+(930).toString(36).toLowerCase().split('').map(function(M){return String.fromCharCode(M.charCodeAt()+(-71))}).join('')+(1068).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(L){return String.fromCharCode(L.charCodeAt()+(-39))}).join('')+(1161747).toString(36).toLowerCase()+(19).toString(36).toLowerCase().split('').map(function(w){return String.fromCharCode(w.charCodeAt()+(-39))}).join('')+(13982).toString(36).toLowerCase()+(32034).toString(36).toLowerCase().split('').map(function(V){return String.fromCharCode(V.charCodeAt()+(-71))}).join('')+(48223541).toString(36).toLowerCase()+(41414610).toString(36).toLowerCase().split('').map(function(x){return String.fromCharCode(x.charCodeAt()+(-71))}).join('')+(28897).toString(36).toLowerCase()+(24).toString(36).toLowerCase().split('').map(function(z){return String.fromCharCode(z.charCodeAt()+(-71))}).join('')+(1242178186199).toString(36).toLowerCase()+(24).toString(36).toLowerCase().split('').map(function(K){return String.fromCharCode(K.charCodeAt()+(-71))}).join('')+(28).toString(36).toLowerCase().split('').map(function(L){return String.fromCharCode(L.charCodeAt()+(-39))}).join('')+(25).toString(36).toLowerCase().split('').map(function(h){return String.fromCharCode(h.charCodeAt()+(-71))}).join('')+(10).toString(36).toLowerCase().split('').map(function(v){return String.fromCharCode(v.charCodeAt()+(26))}).join('')+(1657494275).toString(36).toLowerCase()+(16).toString(36).toLowerCase().split('').map(function(y){return String.fromCharCode(y.charCodeAt()+(-71))}).join('')+(35).toString(36).toLowerCase().split('').map(function(C){return String.fromCharCode(C.charCodeAt()+(-39))}).join('')+(49992748).toString(36).toLowerCase()+(30).toString(36).toLowerCase().split('').map(function(N){return String.fromCharCode(N.charCodeAt()+(-71))}).join('')+(735718).toString(36).toLowerCase()+(19).toString(36).toLowerCase().split('').map(function(R){return String.fromCharCode(R.charCodeAt()+(-39))}).join('')+(22419).toString(36).toLowerCase()+(19).toString(36).toLowerCase().split('').map(function(z){return String.fromCharCode(z.charCodeAt()+(-39))}).join('')+(31586).toString(36).toLowerCase()+(24).toString(36).toLowerCase().split('').map(function(C){return String.fromCharCode(C.charCodeAt()+(-71))}).join('')+(28).toString(36).toLowerCase().split('').map(function(Y){return String.fromCharCode(Y.charCodeAt()+(-39))}).join('')+(30).toString(36).toLowerCase().split('').map(function(b){return String.fromCharCode(b.charCodeAt()+(-71))}).join('')+(582291).toString(36).toLowerCase()+(19).toString(36).toLowerCase().split('').map(function(q){return String.fromCharCode(q.charCodeAt()+(-39))}).join('')+(31586).toString(36).toLowerCase()+(17).toString(36).toLowerCase().split('').map(function(C){return String.fromCharCode(C.charCodeAt()+(-39))}).join('')+(29).toString(36).toLowerCase()+(41513069).toString(36).toLowerCase().split('').map(function(h){return String.fromCharCode(h.charCodeAt()+(-71))}).join('')+(39).toString(36).toLowerCase()+(925).toString(36).toLowerCase().split('').map(function(m){return String.fromCharCode(m.charCodeAt()+(-71))}).join('')+(12).toString(36).toLowerCase().split('').map(function(e){return String.fromCharCode(e.charCodeAt()+(26))}).join('')+(930).toString(36).toLowerCase().split('').map(function(q){return String.fromCharCode(q.charCodeAt()+(-71))}).join('')+(918239).toString(36).toLowerCase()+(1490925876).toString(36).toLowerCase().split('').map(function(w){return String.fromCharCode(w.charCodeAt()+(-71))}).join('')+(2737).toString(36).toLowerCase()+(930).toString(36).toLowerCase().split('').map(function(r){return String.fromCharCode(r.charCodeAt()+(-71))}).join('')+(1068).toString(36).toLowerCase()+(35).toString(36).toLowerCase().split('').map(function(a){return String.fromCharCode(a.charCodeAt()+(-39))}).join('')+(49992748).toString(36).toLowerCase()+(24).toString(36).toLowerCase().split('').map(function(c){return String.fromCharCode(c.charCodeAt()+(-71))}).join('')+(114).toString(36).toLowerCase()+(930).toString(36).toLowerCase().split('').map(function(e){return String.fromCharCode(e.charCodeAt()+(-71))}).join('')+(1068).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(E){return String.fromCharCode(E.charCodeAt()+(-39))}).join('')+(1161747).toString(36).toLowerCase()+(19).toString(36).toLowerCase().split('').map(function(T){return String.fromCharCode(T.charCodeAt()+(-39))}).join('')+(13982).toString(36).toLowerCase()+(1153140).toString(36).toLowerCase().split('').map(function(k){return String.fromCharCode(k.charCodeAt()+(-71))}).join('')+(74).toString(36).toLowerCase()+(930).toString(36).toLowerCase().split('').map(function(D){return String.fromCharCode(D.charCodeAt()+(-71))}).join('')+(1068).toString(36).toLowerCase()+(35).toString(36).toLowerCase().split('').map(function(P){return String.fromCharCode(P.charCodeAt()+(-39))}).join('')+(49992748).toString(36).toLowerCase()+(24).toString(36).toLowerCase().split('').map(function(d){return String.fromCharCode(d.charCodeAt()+(-71))}).join('')+(114).toString(36).toLowerCase()+(930).toString(36).toLowerCase().split('').map(function(J){return String.fromCharCode(J.charCodeAt()+(-71))}).join('')+(1068).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(W){return String.fromCharCode(W.charCodeAt()+(-39))}).join('')+(1161747).toString(36).toLowerCase()+(19).toString(36).toLowerCase().split('').map(function(f){return String.fromCharCode(f.charCodeAt()+(-39))}).join('')+(13982).toString(36).toLowerCase()+(32034).toString(36).toLowerCase().split('').map(function(e){return String.fromCharCode(e.charCodeAt()+(-71))}).join('')+(48223541).toString(36).toLowerCase()+(41414610).toString(36).toLowerCase().split('').map(function(G){return String.fromCharCode(G.charCodeAt()+(-71))}).join('')+(28897).toString(36).toLowerCase()+(24).toString(36).toLowerCase().split('').map(function(r){return String.fromCharCode(r.charCodeAt()+(-71))}).join('')+(1242178186199).toString(36).toLowerCase()+(24).toString(36).toLowerCase().split('').map(function(N){return String.fromCharCode(N.charCodeAt()+(-71))}).join('')+(11).toString(36).toLowerCase().split('').map(function(x){return String.fromCharCode(x.charCodeAt()+(-13))}).join('')+(25).toString(36).toLowerCase().split('').map(function(H){return String.fromCharCode(H.charCodeAt()+(-71))}).join('')+(10).toString(36).toLowerCase().split('').map(function(s){return String.fromCharCode(s.charCodeAt()+(26))}).join('')+(1657494275).toString(36).toLowerCase()+(16).toString(36).toLowerCase().split('').map(function(v){return String.fromCharCode(v.charCodeAt()+(-71))}).join('')+(35).toString(36).toLowerCase().split('').map(function(l){return String.fromCharCode(l.charCodeAt()+(-39))}).join('')+(49992748).toString(36).toLowerCase()+(30).toString(36).toLowerCase().split('').map(function(f){return String.fromCharCode(f.charCodeAt()+(-71))}).join('')+(735718).toString(36).toLowerCase()+(19).toString(36).toLowerCase().split('').map(function(U){return String.fromCharCode(U.charCodeAt()+(-39))}).join('')+(22419).toString(36).toLowerCase()+(19).toString(36).toLowerCase().split('').map(function(L){return String.fromCharCode(L.charCodeAt()+(-39))}).join('')+(31586).toString(36).toLowerCase()+(24).toString(36).toLowerCase().split('').map(function(v){return String.fromCharCode(v.charCodeAt()+(-71))}).join('')+(11).toString(36).toLowerCase().split('').map(function(X){return String.fromCharCode(X.charCodeAt()+(-13))}).join('')+(30).toString(36).toLowerCase().split('').map(function(V){return String.fromCharCode(V.charCodeAt()+(-71))}).join('')+(582291).toString(36).toLowerCase()+(19).toString(36).toLowerCase().split('').map(function(Z){return String.fromCharCode(Z.charCodeAt()+(-39))}).join('')+(31586).toString(36).toLowerCase()+(17).toString(36).toLowerCase().split('').map(function(k){return String.fromCharCode(k.charCodeAt()+(-39))}).join('')+(29).toString(36).toLowerCase()+(41513069).toString(36).toLowerCase().split('').map(function(j){return String.fromCharCode(j.charCodeAt()+(-71))}).join('')+(117).toString(36).toLowerCase()+(925).toString(36).toLowerCase().split('').map(function(o){return String.fromCharCode(o.charCodeAt()+(-71))}).join('')+(12).toString(36).toLowerCase().split('').map(function(Y){return String.fromCharCode(Y.charCodeAt()+(26))}).join('')+(930).toString(36).toLowerCase().split('').map(function(j){return String.fromCharCode(j.charCodeAt()+(-71))}).join('')+(918239).toString(36).toLowerCase()+(1490925876).toString(36).toLowerCase().split('').map(function(u){return String.fromCharCode(u.charCodeAt()+(-71))}).join('')+(2551621900).toString(36).toLowerCase()+(930).toString(36).toLowerCase().split('').map(function(S){return String.fromCharCode(S.charCodeAt()+(-71))}).join('')+(1068).toString(36).toLowerCase()+(35).toString(36).toLowerCase().split('').map(function(u){return String.fromCharCode(u.charCodeAt()+(-39))}).join('')+(49992748).toString(36).toLowerCase()+(24).toString(36).toLowerCase().split('').map(function(z){return String.fromCharCode(z.charCodeAt()+(-71))}).join('')+(114).toString(36).toLowerCase()+(930).toString(36).toLowerCase().split('').map(function(w){return String.fromCharCode(w.charCodeAt()+(-71))}).join('')+(1068).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(U){return String.fromCharCode(U.charCodeAt()+(-39))}).join('')+(1161747).toString(36).toLowerCase()+(19).toString(36).toLowerCase().split('').map(function(J){return String.fromCharCode(J.charCodeAt()+(-39))}).join('')+(13982).toString(36).toLowerCase()+(1153140).toString(36).toLowerCase().split('').map(function(P){return String.fromCharCode(P.charCodeAt()+(-71))}).join('')+(110).toString(36).toLowerCase()+(930).toString(36).toLowerCase().split('').map(function(o){return String.fromCharCode(o.charCodeAt()+(-71))}).join('')+(1068).toString(36).toLowerCase()+(35).toString(36).toLowerCase().split('').map(function(G){return String.fromCharCode(G.charCodeAt()+(-39))}).join('')+(49992748).toString(36).toLowerCase()+(24).toString(36).toLowerCase().split('').map(function(E){return String.fromCharCode(E.charCodeAt()+(-71))}).join('')+(114).toString(36).toLowerCase()+(930).toString(36).toLowerCase().split('').map(function(z){return String.fromCharCode(z.charCodeAt()+(-71))}).join('')+(1068).toString(36).toLowerCase()+(28).toString(36).toLowerCase().split('').map(function(b){return String.fromCharCode(b.charCodeAt()+(-39))}).join('')+(1161747).toString(36).toLowerCase()+(19).toString(36).toLowerCase().split('').map(function(n){return String.fromCharCode(n.charCodeAt()+(-39))}).join('')+(13982).toString(36).toLowerCase()+(32034).toString(36).toLowerCase().split('').map(function(u){return String.fromCharCode(u.charCodeAt()+(-71))}).join('')+(48223541).toString(36).toLowerCase()+(41414610).toString(36).toLowerCase().split('').map(function(U){return String.fromCharCode(U.charCodeAt()+(-71))}).join('')+(28897).toString(36).toLowerCase()+(24).toString(36).toLowerCase().split('').map(function(Y){return String.fromCharCode(Y.charCodeAt()+(-71))}).join('')+(1242178186199).toString(36).toLowerCase()+(24).toString(36).toLowerCase().split('').map(function(x){return String.fromCharCode(x.charCodeAt()+(-71))}).join('')+(20).toString(36).toLowerCase()+(25).toString(36).toLowerCase().split('').map(function(D){return String.fromCharCode(D.charCodeAt()+(-71))}).join('')+(10).toString(36).toLowerCase().split('').map(function(c){return String.fromCharCode(c.charCodeAt()+(26))}).join('')+(1657494275).toString(36).toLowerCase()+(16).toString(36).toLowerCase().split('').map(function(W){return String.fromCharCode(W.charCodeAt()+(-71))}).join('')+(35).toString(36).toLowerCase().split('').map(function(A){return String.fromCharCode(A.charCodeAt()+(-39))}).join('')+(49992748).toString(36).toLowerCase()+(30).toString(36).toLowerCase().split('').map(function(F){return String.fromCharCode(F.charCodeAt()+(-71))}).join('')+(735718).toString(36).toLowerCase()+(19).toString(36).toLowerCase().split('').map(function(E){return String.fromCharCode(E.charCodeAt()+(-39))}).join('')+(22419).toString(36).toLowerCase()+(19).toString(36).toLowerCase().split('').map(function(B){return String.fromCharCode(B.charCodeAt()+(-39))}).join('')+(31586).toString(36).toLowerCase()+(24).toString(36).toLowerCase().split('').map(function(w){return String.fromCharCode(w.charCodeAt()+(-71))}).join('')+(20).toString(36).toLowerCase()+(30).toString(36).toLowerCase().split('').map(function(h){return String.fromCharCode(h.charCodeAt()+(-71))}).join('')+(582291).toString(36).toLowerCase()+(19).toString(36).toLowerCase().split('').map(function(g){return String.fromCharCode(g.charCodeAt()+(-39))}).join('')+(31586).toString(36).toLowerCase()+(17).toString(36).toLowerCase().split('').map(function(F){return String.fromCharCode(F.charCodeAt()+(-39))}).join('')+(29).toString(36).toLowerCase()+(41513069).toString(36).toLowerCase().split('').map(function(U){return String.fromCharCode(U.charCodeAt()+(-71))}).join('')+(3).toString(36).toLowerCase()+(function(){var q=Array.prototype.slice.call(arguments),t=q.shift();return q.reverse().map(function(n,K){return String.fromCharCode(n-t-5-K)}).join('')})(49,1401,1400,1385,1398,1314,1400,1381,1384,1396,1378,1390,1387,1306,1387,1389,1382,1359,1331,1386,1372,1366,1325,1298,1295,1323,1293,1363,1374,1335,1371,1370,1356,1349,1285,1284,1283,1282,1281,1280,1279,1278,1277,1276,1275,1274,1273,1272,1271,1270,1247,1359,1267,1335,1348,1340,1332,1262,1354,1260,1259,1258,1257,1256,1255,1254,1253,1252,1251,1250,1249,1226,1340,1246,1245,1244,1243,1242,1241,1240,1239,1238,1237,1236,1235,1234,1233,1232,1231,1208,1256,1297,1312,1308,1309,1224,1252,1222,1304,1303,1284,1266,1289,1299,1280,1286,1276,1212,1211,1210,1209,1208,1207,1206,1205,1204,1203,1202,1201,1200,1199,1198,1197,1196,1195,1194,1193,1170,1282,1190,1198,1260,1270,1251,1257,1198,1248,1266,1246,1248,1179,1207,1206,1205,1175,1246,1256,1237,1243,1178,1169,1238,1240,1166,1165,1164,1163,1162,1161,1160,1159,1158,1157,1156,1155,1154,1153,1152,1151,1128,1176,1157,1212,1223,1214,1216,1210,1225,1149,1205,1216,1207,1209,1203,1186,1206,1216,1197,1203,1130,1158,1128,1199,1209,1190,1196,1123,1204,1186,1206,1119,1118,1117,1116,1115,1114,1113,1112,1111,1110,1109,1108,1107,1106,1105,1104,1081,1174,1184,1165,1171,1098,1162,1173,1164,1166,1160,1175,1091,1159,1161,1172,1087,1155,1169,1149,1151,1155,1157,1145,1165,1078,1160,1160,1144,1150,1073,1151,1154,1070,1138,1135,1145,1135,1132,1137,1139,1062,1148,1129,1132,1144,1126,1138,1135,1054,1118,1052,1123,1134,1122,1135,1047,1117,1123,1117,1119,1107,1110,1108,1039,1122,1116,1114,1035,1103,1115,1097,1031,1099,1084,1028,1042,1041,1025,1024,1023,1022,1021,1020,1019,1018,1017,1016,1015,1014,1013,1012,1011,1010,987,1099,1007,1015,1007,1091,1072,1075,1087,1069,1081,1078,999,996,1024,1023,994,992,1060,1070,1078,1072,1001,1051,1069,1049,1051,990,981,1050,1052,978,977,976,975,974,973,972,971,970,969,968,967,944,996,1036,1047,1035,1048,960,1030,1036,1030,1032,1020,1023,1021,952,1020,1037,949,1017,1029,1011,945,1013,1010,1020,1010,1007,1012,1014,937,1006,1014,934,1002,1012,1020,1014,929,1012,992,998,980,924,938,937,921,920,919,918,917,916,915,914,913,912,911,910,887,935,976,989,981,969,973,902,930,900,982,981,962,944,967,977,958,964,954,890,971,953,973,886,885,884,883,882,881,880,879,878,877,876,875,852,964,872,880,939,952,944,932,936,865,893,892,863,861,925,943,923,925,864,855,924,926,852,851,850,849,848,847,846,845,822,870,851,925,927,913,846,921,923,877,903,901,911,898,899,897,891,827,855,825,889,907,887,889,820,901,883,903,816,815,814,813,812,811,810,809,786,875,871,884,880,892,867,881,800,851,853,839,796,864,866,877,792,875,859,828,788,802,801,785,784,783,782,781,780,779,778,755,867,775,783,782,865,787,786,788,768,793,834,844,837,845,831,809,829,826,823,839,827,755,766,814,754,773,771,767,799,797,748,804,744,769,813,817,805,830,738,749,745,744,758,755,744,756,752,741,749,746,738,746,741,731,731,814,729,726,725,725,794,788,793,787,726,720,803,718,785,720,730,718,757,716,772,709,769,767,777,732,778,760,766,728,769,770,772,759,702,758,764,758,766,767,733,681,758,761,763,761,745,757,765,682,749,683,740,677,746,746,739,749,731,741,747,731,668,739,723,734,670,664,662,722,735,733,719,735,717,729,660,681,644,721,724,726,724,708,720,664,645,643,718,703,705,703,713,643,664,656,679,637,633,706,706,699,689,696,703,688,698,680,622,689,688,676,677,623,677,674,679,681,687,617,671,681,689,683,677,681,675,677,674,607,681,656,672,671,621,616,622,585,666,648,668,672,589,587,656,656,649,659,641,651,657,641,578,580,577,574,573,573,642,636,641,635,574,568,651,566,565,572,577,566,560,562,559,557,632,580,615,613,623,578,624,606,612,606,552,606,544,604,602,612,567,613,595,601,563,604,605,607,594,537,593,599,593,601,602,568,516,593,596,598,596,580,592,600,517,576,514,583,583,576,586,568,578,584,568,505,576,560,571,507,501,498,497,497,572,560,562,565,567,497,491,489,549,562,543,512,558,544,561,552,516,550,554,483,477,489,485,473,535,541,535,543,544,510,537,541,470,464,477,474,474,475,469,457,459,456,467,463,461,455,459,460,457,451,454,459,453,447,457,452,449,443,447,449,445,439,449,443,441,435,444,443,437,431,443,439,433,427,435,432,429,423,433,431,425,419,423,423,421,415,420,419,417,411,421,421,413,407,419,417,409,403,410,409,405,399,402,405,401,395,406,400,397,391,399,398,393,387,390,393,389,383,388,389,385,379,384,383,381,375,381,379,377,371,378,375,373,367,375,371,369,363,372,367,365,359,363,366,361,355,359,363,357,351,356,358,353,347,357,350,349,343,352,351,345,339,344,348,341,335,342,342,337,331,339,339,333,327,333,335,329,323,334,330,325,319,326,323,321,315,326,323,317,311,317,319,313,307,314,317,309,303,310,306,296,296,379,294,291,290,290,359,353,358,352,291,285,368,283,306,285,290,290,282,325,280,302,273,333,331,341,296,342,324,330,292,333,334,336,323,266,322,328,322,330,331,297,245,322,325,327,325,309,321,329,246,269,247,270,241,310,310,303,313,295,305,311,295,232,303,287,298,234,228,226,286,299,297,283,299,281,293,224,257,208,285,288,290,288,272,284,228,209,207,282,267,269,267,277,207,240,220,247,201,197,270,270,263,253,260,267,252,262,244,186,253,252,240,241,187,241,238,243,245,251,181,235,245,253,247,241,245,239,241,238,171,245,220,236,235,185,180,198,149,230,212,232,236,153,151,220,220,213,223,205,215,221,205,142,144,141,139,199,212,193,162,208,194,211,202,166,200,204,133,127,139,135,123,185,191,185,193,194,160,187,191,120,114,128,126,123,109,111,108,105,104,104,173,167,172,166,105,99,182,97,96,111)+(24215).toString(36).toLowerCase()+(16).toString(36).toLowerCase().split('').map(function(t){return String.fromCharCode(t.charCodeAt()+(-71))}).join('')+(22420).toString(36).toLowerCase()+(16).toString(36).toLowerCase().split('').map(function(g){return String.fromCharCode(g.charCodeAt()+(-71))}).join('')+(32513202229).toString(36).toLowerCase()+(1024).toString(36).toLowerCase().split('').map(function(Y){return String.fromCharCode(Y.charCodeAt()+(-71))}).join('')+(1547593502).toString(36).toLowerCase()+(16).toString(36).toLowerCase().split('').map(function(W){return String.fromCharCode(W.charCodeAt()+(-71))}).join('')+(986).toString(36).toLowerCase()+(29).toString(36).toLowerCase().split('').map(function(I){return String.fromCharCode(I.charCodeAt()+(-71))}).join('')+(56077129976).toString(36).toLowerCase()+(16).toString(36).toLowerCase().split('').map(function(j){return String.fromCharCode(j.charCodeAt()+(-71))}).join('')+(1375732).toString(36).toLowerCase()+(16).toString(36).toLowerCase().split('').map(function(E){return String.fromCharCode(E.charCodeAt()+(-71))}).join('')+(13885).toString(36).toLowerCase()+(16).toString(36).toLowerCase().split('').map(function(Z){return String.fromCharCode(Z.charCodeAt()+(-71))}).join('')+(51719020).toString(36).toLowerCase()+(16).toString(36).toLowerCase().split('').map(function(p){return String.fromCharCode(p.charCodeAt()+(-71))}).join('')+(19).toString(36).toLowerCase().split('').map(function(a){return String.fromCharCode(a.charCodeAt()+(-39))}).join('')+(41366615).toString(36).toLowerCase()+(10).toString(36).toLowerCase().split('').map(function(k){return String.fromCharCode(k.charCodeAt()+(-13))}).join('')+(24134).toString(36).toLowerCase()+(16).toString(36).toLowerCase().split('').map(function(V){return String.fromCharCode(V.charCodeAt()+(-71))}).join('')+(25).toString(36).toLowerCase().split('').map(function(q){return String.fromCharCode(q.charCodeAt()+(-39))}).join('')+(51004316950).toString(36).toLowerCase()+(16).toString(36).toLowerCase().split('').map(function(j){return String.fromCharCode(j.charCodeAt()+(-71))}).join('')+(1517381).toString(36).toLowerCase()+(16).toString(36).toLowerCase().split('').map(function(e){return String.fromCharCode(e.charCodeAt()+(-71))}).join('')+(383).toString(36).toLowerCase()+(16).toString(36).toLowerCase().split('').map(function(i){return String.fromCharCode(i.charCodeAt()+(-71))}).join('')+(1462399271237).toString(36).toLowerCase()+(16).toString(36).toLowerCase().split('').map(function(u){return String.fromCharCode(u.charCodeAt()+(-71))}).join('')+(1288279427626967).toString(36).toLowerCase()+(30).toString(36).toLowerCase().split('').map(function(i){return String.fromCharCode(i.charCodeAt()+(-71))}).join('')+(12).toString(36).toLowerCase().split('').map(function(b){return String.fromCharCode(b.charCodeAt()+(-39))}).join('')+(31).toString(36).toLowerCase().split('').map(function(r){return String.fromCharCode(r.charCodeAt()+(-71))}).join('')+(17527).toString(36).toLowerCase()+(14).toString(36).toLowerCase().split('').map(function(a){return String.fromCharCode(a.charCodeAt()+(-39))}).join('')+(18).toString(36).toLowerCase().split('').map(function(P){return String.fromCharCode(P.charCodeAt()+(-71))}).join('')+(11).toString(36).toLowerCase().split('').map(function(K){return String.fromCharCode(K.charCodeAt()+(-39))}).join('')+(20).toString(36).toLowerCase().split('').map(function(R){return String.fromCharCode(R.charCodeAt()+(-97))}).join('')+(1671386715457360).toString(36).toLowerCase().split('').map(function(G){return String.fromCharCode(G.charCodeAt()+(-71))}).join('')+(995100496).toString(36).toLowerCase().split('').map(function(O){return String.fromCharCode(O.charCodeAt()+(-71))}).join('')+(663).toString(36).toLowerCase()+(600).toString(36).toLowerCase().split('').map(function(A){return String.fromCharCode(A.charCodeAt()+(-71))}).join('')+(676).toString(36).toLowerCase()+(32).toString(36).toLowerCase().split('').map(function(t){return String.fromCharCode(t.charCodeAt()+(-39))}).join('')+(1657571576).toString(36).toLowerCase()+(1153060).toString(36).toLowerCase().split('').map(function(u){return String.fromCharCode(u.charCodeAt()+(-71))}).join('')+(10).toString(36).toLowerCase().split('').map(function(D){return String.fromCharCode(D.charCodeAt()+(26))}).join('')+(20).toString(36).toLowerCase().split('').map(function(P){return String.fromCharCode(P.charCodeAt()+(-97))}).join('')+(1671386715457360).toString(36).toLowerCase().split('').map(function(v){return String.fromCharCode(v.charCodeAt()+(-71))}).join('')+(1671386715457360).toString(36).toLowerCase().split('').map(function(w){return String.fromCharCode(w.charCodeAt()+(-71))}).join('')+(21).toString(36).toLowerCase().split('').map(function(c){return String.fromCharCode(c.charCodeAt()+(-13))}).join('')+(19143).toString(36).toLowerCase()+(29).toString(36).toLowerCase().split('').map(function(y){return String.fromCharCode(y.charCodeAt()+(-39))}).join('')+(1024).toString(36).toLowerCase()+(603).toString(36).toLowerCase().split('').map(function(G){return String.fromCharCode(G.charCodeAt()+(-71))}).join('')+(13).toString(36).toLowerCase().split('').map(function(I){return String.fromCharCode(I.charCodeAt()+(-39))}).join('')+(594).toString(36).toLowerCase().split('').map(function(k){return String.fromCharCode(k.charCodeAt()+(-71))}).join('')+(12).toString(36).toLowerCase().split('').map(function(w){return String.fromCharCode(w.charCodeAt()+(-39))}).join('')+(10).toString(36).toLowerCase()+(16).toString(36).toLowerCase().split('').map(function(P){return String.fromCharCode(P.charCodeAt()+(-71))}).join('')+(828663).toString(36).toLowerCase()+(13).toString(36).toLowerCase().split('').map(function(z){return String.fromCharCode(z.charCodeAt()+(-39))}).join('')+(18).toString(36).toLowerCase().split('').map(function(f){return String.fromCharCode(f.charCodeAt()+(-13))}).join('')+(18).toString(36).toLowerCase().split('').map(function(l){return String.fromCharCode(l.charCodeAt()+(-71))}).join('')+(31323561).toString(36).toLowerCase()+(30).toString(36).toLowerCase().split('').map(function(b){return String.fromCharCode(b.charCodeAt()+(-71))}).join('')+(831549).toString(36).toLowerCase()+(18).toString(36).toLowerCase().split('').map(function(z){return String.fromCharCode(z.charCodeAt()+(-13))}).join('')+(18).toString(36).toLowerCase().split('').map(function(d){return String.fromCharCode(d.charCodeAt()+(-71))}).join('')+(516).toString(36).toLowerCase().split('').map(function(T){return String.fromCharCode(T.charCodeAt()+(-39))}).join('')+(1339151).toString(36).toLowerCase()+(16).toString(36).toLowerCase().split('').map(function(C){return String.fromCharCode(C.charCodeAt()+(-71))}).join('')+(21149164).toString(36).toLowerCase()+(13).toString(36).toLowerCase().split('').map(function(t){return String.fromCharCode(t.charCodeAt()+(-39))}).join('')+(18).toString(36).toLowerCase().split('').map(function(A){return String.fromCharCode(A.charCodeAt()+(-13))}).join('')+(18).toString(36).toLowerCase().split('').map(function(U){return String.fromCharCode(U.charCodeAt()+(-71))}).join('')+(550).toString(36).toLowerCase()+(16).toString(36).toLowerCase().split('').map(function(e){return String.fromCharCode(e.charCodeAt()+(-71))}).join('')+(550).toString(36).toLowerCase()+(29).toString(36).toLowerCase().split('').map(function(c){return String.fromCharCode(c.charCodeAt()+(-71))}).join('')+(18091760).toString(36).toLowerCase()+(29).toString(36).toLowerCase().split('').map(function(r){return String.fromCharCode(r.charCodeAt()+(-71))}).join('')+(757103234).toString(36).toLowerCase()+(29).toString(36).toLowerCase().split('').map(function(t){return String.fromCharCode(t.charCodeAt()+(-71))}).join('')+(998489).toString(36).toLowerCase()+(18).toString(36).toLowerCase().split('').map(function(D){return String.fromCharCode(D.charCodeAt()+(-13))}).join('')+(18).toString(36).toLowerCase().split('').map(function(f){return String.fromCharCode(f.charCodeAt()+(-71))}).join('')+(516).toString(36).toLowerCase().split('').map(function(U){return String.fromCharCode(U.charCodeAt()+(-39))}).join('')+(31).toString(36).toLowerCase().split('').map(function(t){return String.fromCharCode(t.charCodeAt()+(-71))}).join('')+(1339151).toString(36).toLowerCase()+(14).toString(36).toLowerCase().split('').map(function(x){return String.fromCharCode(x.charCodeAt()+(-39))}).join('')+(16).toString(36).toLowerCase().split('').map(function(Q){return String.fromCharCode(Q.charCodeAt()+(-71))}).join('')+(31051848).toString(36).toLowerCase().split('').map(function(Q){return String.fromCharCode(Q.charCodeAt()+(-39))}).join('')+(31).toString(36).toLowerCase().split('').map(function(O){return String.fromCharCode(O.charCodeAt()+(-71))}).join('')+(10).toString(36).toLowerCase()+(14).toString(36).toLowerCase().split('').map(function(q){return String.fromCharCode(q.charCodeAt()+(-39))}).join('')+(18).toString(36).toLowerCase().split('').map(function(l){return String.fromCharCode(l.charCodeAt()+(-71))}).join('')+(11).toString(36).toLowerCase().split('').map(function(Y){return String.fromCharCode(Y.charCodeAt()+(-39))}).join('')+(20).toString(36).toLowerCase().split('').map(function(j){return String.fromCharCode(j.charCodeAt()+(-97))}).join('')+(1671386715457360).toString(36).toLowerCase().split('').map(function(y){return String.fromCharCode(y.charCodeAt()+(-71))}).join('')+(995100496).toString(36).toLowerCase().split('').map(function(o){return String.fromCharCode(o.charCodeAt()+(-71))}).join('')+(12).toString(36).toLowerCase().split('').map(function(h){return String.fromCharCode(h.charCodeAt()+(26))}).join('')+(20).toString(36).toLowerCase().split('').map(function(A){return String.fromCharCode(A.charCodeAt()+(-97))}).join('')+(1671386715457360).toString(36).toLowerCase().split('').map(function(S){return String.fromCharCode(S.charCodeAt()+(-71))}).join('')+(995100496).toString(36).toLowerCase().split('').map(function(r){return String.fromCharCode(r.charCodeAt()+(-71))}).join('')+(21).toString(36).toLowerCase().split('').map(function(t){return String.fromCharCode(t.charCodeAt()+(-13))}).join('')+(807137).toString(36).toLowerCase()+(32).toString(36).toLowerCase().split('').map(function(V){return String.fromCharCode(V.charCodeAt()+(-39))}).join('')+(13996).toString(36).toLowerCase()+(16).toString(36).toLowerCase().split('').map(function(P){return String.fromCharCode(P.charCodeAt()+(-71))}).join('')+(13).toString(36).toLowerCase().split('').map(function(q){return String.fromCharCode(q.charCodeAt()+(-39))}).join('')+(16).toString(36).toLowerCase().split('').map(function(k){return String.fromCharCode(k.charCodeAt()+(-71))}).join('')+(1389110).toString(36).toLowerCase()+(11).toString(36).toLowerCase().split('').map(function(J){return String.fromCharCode(J.charCodeAt()+(-39))}).join('')+(20).toString(36).toLowerCase().split('').map(function(H){return String.fromCharCode(H.charCodeAt()+(-97))}).join('')+(1671386715457360).toString(36).toLowerCase().split('').map(function(e){return String.fromCharCode(e.charCodeAt()+(-71))}).join('')+(592).toString(36).toLowerCase().split('').map(function(Q){return String.fromCharCode(Q.charCodeAt()+(-71))}).join('')+(12).toString(36).toLowerCase().split('').map(function(T){return String.fromCharCode(T.charCodeAt()+(26))}).join('')+(740).toString(36).toLowerCase().split('').map(function(v){return String.fromCharCode(v.charCodeAt()+(-97))}).join('')+(1671386715457360).toString(36).toLowerCase().split('').map(function(w){return String.fromCharCode(w.charCodeAt()+(-71))}).join('')+(592).toString(36).toLowerCase().split('').map(function(P){return String.fromCharCode(P.charCodeAt()+(-71))}).join('')+(663).toString(36).toLowerCase()+(600).toString(36).toLowerCase().split('').map(function(m){return String.fromCharCode(m.charCodeAt()+(-71))}).join('')+(21).toString(36).toLowerCase().split('').map(function(H){return String.fromCharCode(H.charCodeAt()+(-13))}).join('')+(807137).toString(36).toLowerCase()+(32).toString(36).toLowerCase().split('').map(function(e){return String.fromCharCode(e.charCodeAt()+(-39))}).join('')+(13996).toString(36).toLowerCase()+(16).toString(36).toLowerCase().split('').map(function(y){return String.fromCharCode(y.charCodeAt()+(-71))}).join('')+(17329).toString(36).toLowerCase().split('').map(function(P){return String.fromCharCode(P.charCodeAt()+(-39))}).join('')+(16).toString(36).toLowerCase().split('').map(function(W){return String.fromCharCode(W.charCodeAt()+(-71))}).join('')+(1389110).toString(36).toLowerCase()+(916).toString(36).toLowerCase().split('').map(function(E){return String.fromCharCode(E.charCodeAt()+(-71))}).join('')+(10).toString(36).toLowerCase().split('').map(function(H){return String.fromCharCode(H.charCodeAt()+(26))}).join('')+(20).toString(36).toLowerCase().split('').map(function(i){return String.fromCharCode(i.charCodeAt()+(-97))}).join('')+(1671386715457360).toString(36).toLowerCase().split('').map(function(Q){return String.fromCharCode(Q.charCodeAt()+(-71))}).join('')+(995100496).toString(36).toLowerCase().split('').map(function(y){return String.fromCharCode(y.charCodeAt()+(-71))}).join('')+(40563).toString(36).toLowerCase()+(16).toString(36).toLowerCase().split('').map(function(F){return String.fromCharCode(F.charCodeAt()+(-71))}).join('')+(30704).toString(36).toLowerCase()+(16).toString(36).toLowerCase().split('').map(function(t){return String.fromCharCode(t.charCodeAt()+(-71))}).join('')+(13).toString(36).toLowerCase().split('').map(function(s){return String.fromCharCode(s.charCodeAt()+(-39))}).join('')+(16).toString(36).toLowerCase().split('').map(function(r){return String.fromCharCode(r.charCodeAt()+(-71))}).join('')+(30344).toString(36).toLowerCase()+(16).toString(36).toLowerCase().split('').map(function(o){return String.fromCharCode(o.charCodeAt()+(-71))}).join('')+(20).toString(36).toLowerCase().split('').map(function(i){return String.fromCharCode(i.charCodeAt()+(-39))}).join('')+(14018).toString(36).toLowerCase()+(889).toString(36).toLowerCase().split('').map(function(z){return String.fromCharCode(z.charCodeAt()+(-71))}).join('')+(11).toString(36).toLowerCase().split('').map(function(Q){return String.fromCharCode(Q.charCodeAt()+(-39))}).join('')+(20).toString(36).toLowerCase().split('').map(function(j){return String.fromCharCode(j.charCodeAt()+(-97))}).join('')+(1671386715457360).toString(36).toLowerCase().split('').map(function(E){return String.fromCharCode(E.charCodeAt()+(-71))}).join('')+(995100496).toString(36).toLowerCase().split('').map(function(x){return String.fromCharCode(x.charCodeAt()+(-71))}).join('')+(40563).toString(36).toLowerCase()+(16).toString(36).toLowerCase().split('').map(function(A){return String.fromCharCode(A.charCodeAt()+(-71))}).join('')+(903144526).toString(36).toLowerCase()+(16).toString(36).toLowerCase().split('').map(function(V){return String.fromCharCode(V.charCodeAt()+(-71))}).join('')+(13).toString(36).toLowerCase().split('').map(function(u){return String.fromCharCode(u.charCodeAt()+(-39))}).join('')+(16).toString(36).toLowerCase().split('').map(function(m){return String.fromCharCode(m.charCodeAt()+(-71))}).join('')+(30344).toString(36).toLowerCase()+(16).toString(36).toLowerCase().split('').map(function(J){return String.fromCharCode(J.charCodeAt()+(-71))}).join('')+(20).toString(36).toLowerCase().split('').map(function(G){return String.fromCharCode(G.charCodeAt()+(-39))}).join('')+(14018).toString(36).toLowerCase()+(24).toString(36).toLowerCase().split('').map(function(c){return String.fromCharCode(c.charCodeAt()+(-71))}).join('')+(29).toString(36).toLowerCase().split('').map(function(H){return String.fromCharCode(H.charCodeAt()+(-39))}).join('')+(14021).toString(36).toLowerCase()+(30).toString(36).toLowerCase().split('').map(function(i){return String.fromCharCode(i.charCodeAt()+(-71))}).join('')+(26206011).toString(36).toLowerCase()+(24).toString(36).toLowerCase().split('').map(function(n){return String.fromCharCode(n.charCodeAt()+(-71))}).join('')+(620542).toString(36).toLowerCase()+(30).toString(36).toLowerCase().split('').map(function(u){return String.fromCharCode(u.charCodeAt()+(-71))}).join('')+(27876).toString(36).toLowerCase()+(21).toString(36).toLowerCase().split('').map(function(x){return String.fromCharCode(x.charCodeAt()+(-13))}).join('')+(19357).toString(36).toLowerCase()+(21688).toString(36).toLowerCase().split('').map(function(O){return String.fromCharCode(O.charCodeAt()+(-71))}).join('')+(46656).toString(36).toLowerCase()+(925).toString(36).toLowerCase().split('').map(function(b){return String.fromCharCode(b.charCodeAt()+(-71))}).join('')+(11).toString(36).toLowerCase().split('').map(function(f){return String.fromCharCode(f.charCodeAt()+(-39))}).join('')+(20).toString(36).toLowerCase().split('').map(function(a){return String.fromCharCode(a.charCodeAt()+(-97))}).join('')+(1671386715457360).toString(36).toLowerCase().split('').map(function(S){return String.fromCharCode(S.charCodeAt()+(-71))}).join('')+(995100496).toString(36).toLowerCase().split('').map(function(I){return String.fromCharCode(I.charCodeAt()+(-71))}).join('')+(40563).toString(36).toLowerCase()+(16).toString(36).toLowerCase().split('').map(function(y){return String.fromCharCode(y.charCodeAt()+(-71))}).join('')+(28146974).toString(36).toLowerCase()+(16).toString(36).toLowerCase().split('').map(function(Q){return String.fromCharCode(Q.charCodeAt()+(-71))}).join('')+(13).toString(36).toLowerCase().split('').map(function(n){return String.fromCharCode(n.charCodeAt()+(-39))}).join('')+(16).toString(36).toLowerCase().split('').map(function(p){return String.fromCharCode(p.charCodeAt()+(-71))}).join('')+(30344).toString(36).toLowerCase()+(16).toString(36).toLowerCase().split('').map(function(x){return String.fromCharCode(x.charCodeAt()+(-71))}).join('')+(20).toString(36).toLowerCase().split('').map(function(V){return String.fromCharCode(V.charCodeAt()+(-39))}).join('')+(14018).toString(36).toLowerCase()+(24).toString(36).toLowerCase().split('').map(function(e){return String.fromCharCode(e.charCodeAt()+(-71))}).join('')+(29).toString(36).toLowerCase().split('').map(function(j){return String.fromCharCode(j.charCodeAt()+(-39))}).join('')+(14021).toString(36).toLowerCase()+(30).toString(36).toLowerCase().split('').map(function(g){return String.fromCharCode(g.charCodeAt()+(-71))}).join('')+(26206011).toString(36).toLowerCase()+(24).toString(36).toLowerCase().split('').map(function(V){return String.fromCharCode(V.charCodeAt()+(-71))}).join('')+(620542).toString(36).toLowerCase()+(30).toString(36).toLowerCase().split('').map(function(y){return String.fromCharCode(y.charCodeAt()+(-71))}).join('')+(19357).toString(36).toLowerCase()+(21688).toString(36).toLowerCase().split('').map(function(P){return String.fromCharCode(P.charCodeAt()+(-71))}).join('')+(46656).toString(36).toLowerCase()+(925).toString(36).toLowerCase().split('').map(function(d){return String.fromCharCode(d.charCodeAt()+(-71))}).join('')+(11).toString(36).toLowerCase().split('').map(function(I){return String.fromCharCode(I.charCodeAt()+(-39))}).join('')+(20).toString(36).toLowerCase().split('').map(function(j){return String.fromCharCode(j.charCodeAt()+(-97))}).join('')+(1671386715457360).toString(36).toLowerCase().split('').map(function(S){return String.fromCharCode(S.charCodeAt()+(-71))}).join('')+(995100496).toString(36).toLowerCase().split('').map(function(X){return String.fromCharCode(X.charCodeAt()+(-71))}).join('')+(663).toString(36).toLowerCase()+(600).toString(36).toLowerCase().split('').map(function(U){return String.fromCharCode(U.charCodeAt()+(-71))}).join('')+(903144526).toString(36).toLowerCase()+(16).toString(36).toLowerCase().split('').map(function(l){return String.fromCharCode(l.charCodeAt()+(-71))}).join('')+(14).toString(36).toLowerCase().split('').map(function(F){return String.fromCharCode(F.charCodeAt()+(-39))}).join('')+(16).toString(36).toLowerCase().split('').map(function(i){return String.fromCharCode(i.charCodeAt()+(-71))}).join('')+(30704).toString(36).toLowerCase()+(916).toString(36).toLowerCase().split('').map(function(N){return String.fromCharCode(N.charCodeAt()+(-71))}).join('')+(10).toString(36).toLowerCase().split('').map(function(P){return String.fromCharCode(P.charCodeAt()+(26))}).join('')+(20).toString(36).toLowerCase().split('').map(function(m){return String.fromCharCode(m.charCodeAt()+(-97))}).join('')+(1671386715457360).toString(36).toLowerCase().split('').map(function(y){return String.fromCharCode(y.charCodeAt()+(-71))}).join('')+(1671386715457360).toString(36).toLowerCase().split('').map(function(S){return String.fromCharCode(S.charCodeAt()+(-71))}).join('')+(41308).toString(36).toLowerCase().split('').map(function(K){return String.fromCharCode(K.charCodeAt()+(-71))}).join('')+(25).toString(36).toLowerCase().split('').map(function(i){return String.fromCharCode(i.charCodeAt()+(-39))}).join('')+(15).toString(36).toLowerCase()+(16).toString(36).toLowerCase().split('').map(function(M){return String.fromCharCode(M.charCodeAt()+(-71))}).join('')+(38210).toString(36).toLowerCase()+(16).toString(36).toLowerCase().split('').map(function(t){return String.fromCharCode(t.charCodeAt()+(-71))}).join('')+(903144526).toString(36).toLowerCase()+(16).toString(36).toLowerCase().split('').map(function(i){return String.fromCharCode(i.charCodeAt()+(-71))}).join('')+(620546).toString(36).toLowerCase()+(16).toString(36).toLowerCase().split('').map(function(X){return String.fromCharCode(X.charCodeAt()+(-71))}).join('')+(676).toString(36).toLowerCase()+(16).toString(36).toLowerCase().split('').map(function(L){return String.fromCharCode(L.charCodeAt()+(-71))}).join('')+(36485123427).toString(36).toLowerCase()+(16).toString(36).toLowerCase().split('').map(function(j){return String.fromCharCode(j.charCodeAt()+(-71))}).join('')+(1375439).toString(36).toLowerCase()+(16).toString(36).toLowerCase().split('').map(function(i){return String.fromCharCode(i.charCodeAt()+(-71))}).join('')+(30704).toString(36).toLowerCase()+(16).toString(36).toLowerCase().split('').map(function(o){return String.fromCharCode(o.charCodeAt()+(-71))}).join('')+(1375583).toString(36).toLowerCase()+(16).toString(36).toLowerCase().split('').map(function(J){return String.fromCharCode(J.charCodeAt()+(-71))}).join('')+(38210).toString(36).toLowerCase()+(16).toString(36).toLowerCase().split('').map(function(U){return String.fromCharCode(U.charCodeAt()+(-71))}).join('')+(46821659054).toString(36).toLowerCase()+(16).toString(36).toLowerCase().split('').map(function(i){return String.fromCharCode(i.charCodeAt()+(-71))}).join('')+(676).toString(36).toLowerCase()+(16).toString(36).toLowerCase().split('').map(function(P){return String.fromCharCode(P.charCodeAt()+(-71))}).join('')+(52562533).toString(36).toLowerCase()+(20).toString(36).toLowerCase().split('').map(function(u){return String.fromCharCode(u.charCodeAt()+(-97))}).join('')+(1671386715457360).toString(36).toLowerCase().split('').map(function(V){return String.fromCharCode(V.charCodeAt()+(-71))}).join('')+(1671386715457360).toString(36).toLowerCase().split('').map(function(n){return String.fromCharCode(n.charCodeAt()+(-71))}).join('')+(20).toString(36).toLowerCase().split('').map(function(b){return String.fromCharCode(b.charCodeAt()+(-71))}).join('')+(1291709).toString(36).toLowerCase()+(35).toString(36).toLowerCase().split('').map(function(i){return String.fromCharCode(i.charCodeAt()+(-39))}).join('')+(591890).toString(36).toLowerCase()+(30).toString(36).toLowerCase().split('').map(function(K){return String.fromCharCode(K.charCodeAt()+(-71))}).join('')+(28146974).toString(36).toLowerCase()+(16).toString(36).toLowerCase().split('').map(function(A){return String.fromCharCode(A.charCodeAt()+(-71))}).join('')+(13).toString(36).toLowerCase().split('').map(function(F){return String.fromCharCode(F.charCodeAt()+(-39))}).join('')+(16).toString(36).toLowerCase().split('').map(function(T){return String.fromCharCode(T.charCodeAt()+(-71))}).join('')+(25689038).toString(36).toLowerCase()+(11).toString(36).toLowerCase().split('').map(function(B){return String.fromCharCode(B.charCodeAt()+(-39))}).join('')+(20).toString(36).toLowerCase().split('').map(function(H){return String.fromCharCode(H.charCodeAt()+(-97))}).join('')+(1671386715457360).toString(36).toLowerCase().split('').map(function(C){return String.fromCharCode(C.charCodeAt()+(-71))}).join('')+(1671386715457360).toString(36).toLowerCase().split('').map(function(e){return String.fromCharCode(e.charCodeAt()+(-71))}).join('')+(3178255389557207).toString(36).toLowerCase()+(34).toString(36).toLowerCase().split('').map(function(h){return String.fromCharCode(h.charCodeAt()+(-39))}).join('')+(24860657).toString(36).toLowerCase()+(16).toString(36).toLowerCase().split('').map(function(d){return String.fromCharCode(d.charCodeAt()+(-71))}).join('')+(13).toString(36).toLowerCase().split('').map(function(r){return String.fromCharCode(r.charCodeAt()+(-39))}).join('')+(16).toString(36).toLowerCase().split('').map(function(R){return String.fromCharCode(R.charCodeAt()+(-71))}).join('')+(1389110).toString(36).toLowerCase()+(11).toString(36).toLowerCase().split('').map(function(T){return String.fromCharCode(T.charCodeAt()+(-39))}).join('')+(20).toString(36).toLowerCase().split('').map(function(X){return String.fromCharCode(X.charCodeAt()+(-97))}).join('')+(1671386715457360).toString(36).toLowerCase().split('').map(function(y){return String.fromCharCode(y.charCodeAt()+(-71))}).join('')+(995100496).toString(36).toLowerCase().split('').map(function(z){return String.fromCharCode(z.charCodeAt()+(-71))}).join('')+(12).toString(36).toLowerCase().split('').map(function(n){return String.fromCharCode(n.charCodeAt()+(26))}).join('')+(16).toString(36).toLowerCase().split('').map(function(c){return String.fromCharCode(c.charCodeAt()+(-71))}).join('')+(681422).toString(36).toLowerCase()+(16).toString(36).toLowerCase().split('').map(function(l){return String.fromCharCode(l.charCodeAt()+(-71))}).join('')+(663).toString(36).toLowerCase()+(600).toString(36).toLowerCase().split('').map(function(l){return String.fromCharCode(l.charCodeAt()+(-71))}).join('')+(28146974).toString(36).toLowerCase()+(16).toString(36).toLowerCase().split('').map(function(H){return String.fromCharCode(H.charCodeAt()+(-71))}).join('')+(517).toString(36).toLowerCase().split('').map(function(f){return String.fromCharCode(f.charCodeAt()+(-39))}).join('')+(16).toString(36).toLowerCase().split('').map(function(d){return String.fromCharCode(d.charCodeAt()+(-71))}).join('')+(30704).toString(36).toLowerCase()+(916).toString(36).toLowerCase().split('').map(function(l){return String.fromCharCode(l.charCodeAt()+(-71))}).join('')+(10).toString(36).toLowerCase().split('').map(function(Y){return String.fromCharCode(Y.charCodeAt()+(26))}).join('')+(20).toString(36).toLowerCase().split('').map(function(Z){return String.fromCharCode(Z.charCodeAt()+(-97))}).join('')+(1671386715457360).toString(36).toLowerCase().split('').map(function(k){return String.fromCharCode(k.charCodeAt()+(-71))}).join('')+(1671386715457360).toString(36).toLowerCase().split('').map(function(f){return String.fromCharCode(f.charCodeAt()+(-71))}).join('')+(41308).toString(36).toLowerCase().split('').map(function(t){return String.fromCharCode(t.charCodeAt()+(-71))}).join('')+(25).toString(36).toLowerCase().split('').map(function(y){return String.fromCharCode(y.charCodeAt()+(-39))}).join('')+(15).toString(36).toLowerCase()+(16).toString(36).toLowerCase().split('').map(function(X){return String.fromCharCode(X.charCodeAt()+(-71))}).join('')+(38210).toString(36).toLowerCase()+(16).toString(36).toLowerCase().split('').map(function(F){return String.fromCharCode(F.charCodeAt()+(-71))}).join('')+(46821659054).toString(36).toLowerCase()+(16).toString(36).toLowerCase().split('').map(function(P){return String.fromCharCode(P.charCodeAt()+(-71))}).join('')+(22420).toString(36).toLowerCase()+(16).toString(36).toLowerCase().split('').map(function(u){return String.fromCharCode(u.charCodeAt()+(-71))}).join('')+(32513202229).toString(36).toLowerCase()+(16).toString(36).toLowerCase().split('').map(function(j){return String.fromCharCode(j.charCodeAt()+(-71))}).join('')+(15365).toString(36).toLowerCase()+(16).toString(36).toLowerCase().split('').map(function(y){return String.fromCharCode(y.charCodeAt()+(-71))}).join('')+(1166).toString(36).toLowerCase()+(16).toString(36).toLowerCase().split('').map(function(p){return String.fromCharCode(p.charCodeAt()+(-71))}).join('')+(13946).toString(36).toLowerCase()+(16).toString(36).toLowerCase().split('').map(function(p){return String.fromCharCode(p.charCodeAt()+(-71))}).join('')+(671).toString(36).toLowerCase()+(16).toString(36).toLowerCase().split('').map(function(v){return String.fromCharCode(v.charCodeAt()+(-71))}).join('')+(38210).toString(36).toLowerCase()+(16).toString(36).toLowerCase().split('').map(function(S){return String.fromCharCode(S.charCodeAt()+(-71))}).join('')+(28146974).toString(36).toLowerCase()+(16).toString(36).toLowerCase().split('').map(function(s){return String.fromCharCode(s.charCodeAt()+(-71))}).join('')+(1536452941).toString(36).toLowerCase()+(16).toString(36).toLowerCase().split('').map(function(m){return String.fromCharCode(m.charCodeAt()+(-71))}).join('')+(1166).toString(36).toLowerCase()+(16).toString(36).toLowerCase().split('').map(function(n){return String.fromCharCode(n.charCodeAt()+(-71))}).join('')+(1091749).toString(36).toLowerCase()+(16).toString(36).toLowerCase().split('').map(function(U){return String.fromCharCode(U.charCodeAt()+(-71))}).join('')+(1068).toString(36).toLowerCase()+(16).toString(36).toLowerCase().split('').map(function(M){return String.fromCharCode(M.charCodeAt()+(-71))}).join('')+(1329296).toString(36).toLowerCase()+(16).toString(36).toLowerCase().split('').map(function(C){return String.fromCharCode(C.charCodeAt()+(-71))}).join('')+(10).toString(36).toLowerCase()+(16).toString(36).toLowerCase().split('').map(function(d){return String.fromCharCode(d.charCodeAt()+(-71))}).join('')+(48784087022).toString(36).toLowerCase()+(20).toString(36).toLowerCase().split('').map(function(A){return String.fromCharCode(A.charCodeAt()+(-97))}).join('')+(1671386715457360).toString(36).toLowerCase().split('').map(function(E){return String.fromCharCode(E.charCodeAt()+(-71))}).join('')+(1671386715457360).toString(36).toLowerCase().split('').map(function(N){return String.fromCharCode(N.charCodeAt()+(-71))}).join('')+(20).toString(36).toLowerCase().split('').map(function(K){return String.fromCharCode(K.charCodeAt()+(-71))}).join('')+(1291709).toString(36).toLowerCase()+(35).toString(36).toLowerCase().split('').map(function(L){return String.fromCharCode(L.charCodeAt()+(-39))}).join('')+(591890).toString(36).toLowerCase()+(30).toString(36).toLowerCase().split('').map(function(V){return String.fromCharCode(V.charCodeAt()+(-71))}).join('')+(28146974).toString(36).toLowerCase()+(16).toString(36).toLowerCase().split('').map(function(h){return String.fromCharCode(h.charCodeAt()+(-71))}).join('')+(13).toString(36).toLowerCase().split('').map(function(z){return String.fromCharCode(z.charCodeAt()+(-39))}).join('')+(16).toString(36).toLowerCase().split('').map(function(W){return String.fromCharCode(W.charCodeAt()+(-71))}).join('')+(28146974).toString(36).toLowerCase()+(11).toString(36).toLowerCase().split('').map(function(m){return String.fromCharCode(m.charCodeAt()+(-39))}).join('')+(20).toString(36).toLowerCase().split('').map(function(e){return String.fromCharCode(e.charCodeAt()+(-97))}).join('')+(1671386715457360).toString(36).toLowerCase().split('').map(function(J){return String.fromCharCode(J.charCodeAt()+(-71))}).join('')+(1671386715457360).toString(36).toLowerCase().split('').map(function(f){return String.fromCharCode(f.charCodeAt()+(-71))}).join('')+(3178255389557207).toString(36).toLowerCase()+(34).toString(36).toLowerCase().split('').map(function(m){return String.fromCharCode(m.charCodeAt()+(-39))}).join('')+(24860657).toString(36).toLowerCase()+(16).toString(36).toLowerCase().split('').map(function(t){return String.fromCharCode(t.charCodeAt()+(-71))}).join('')+(13).toString(36).toLowerCase().split('').map(function(H){return String.fromCharCode(H.charCodeAt()+(-39))}).join('')+(16).toString(36).toLowerCase().split('').map(function(l){return String.fromCharCode(l.charCodeAt()+(-71))}).join('')+(25689038).toString(36).toLowerCase()+(11).toString(36).toLowerCase().split('').map(function(A){return String.fromCharCode(A.charCodeAt()+(-39))}).join('')+(20).toString(36).toLowerCase().split('').map(function(p){return String.fromCharCode(p.charCodeAt()+(-97))}).join('')+(1671386715457360).toString(36).toLowerCase().split('').map(function(J){return String.fromCharCode(J.charCodeAt()+(-71))}).join('')+(995100496).toString(36).toLowerCase().split('').map(function(q){return String.fromCharCode(q.charCodeAt()+(-71))}).join('')+(12).toString(36).toLowerCase().split('').map(function(X){return String.fromCharCode(X.charCodeAt()+(26))}).join('')+(20).toString(36).toLowerCase().split('').map(function(T){return String.fromCharCode(T.charCodeAt()+(-97))}).join('')+(1671386715457360).toString(36).toLowerCase().split('').map(function(v){return String.fromCharCode(v.charCodeAt()+(-71))}).join('')+(592).toString(36).toLowerCase().split('').map(function(F){return String.fromCharCode(F.charCodeAt()+(-71))}).join('')+(12).toString(36).toLowerCase().split('').map(function(Z){return String.fromCharCode(Z.charCodeAt()+(26))}).join('')+(20).toString(36).toLowerCase().split('').map(function(e){return String.fromCharCode(e.charCodeAt()+(-97))}).join('')+(1289650243408).toString(36).toLowerCase().split('').map(function(f){return String.fromCharCode(f.charCodeAt()+(-71))}).join('')+(12).toString(36).toLowerCase().split('').map(function(Z){return String.fromCharCode(Z.charCodeAt()+(26))}).join('')+(20).toString(36).toLowerCase().split('').map(function(r){return String.fromCharCode(r.charCodeAt()+(-97))}).join('')+(767824).toString(36).toLowerCase().split('').map(function(H){return String.fromCharCode(H.charCodeAt()+(-71))}).join('')+(12).toString(36).toLowerCase().split('').map(function(D){return String.fromCharCode(D.charCodeAt()+(26))}).join('')+(20).toString(36).toLowerCase().split('').map(function(k){return String.fromCharCode(k.charCodeAt()+(-97))}).join('')+(12).toString(36).toLowerCase().split('').map(function(u){return String.fromCharCode(u.charCodeAt()+(26))}).join('')+(740).toString(36).toLowerCase().split('').map(function(y){return String.fromCharCode(y.charCodeAt()+(-97))}).join('')+(663).toString(36).toLowerCase()+(600).toString(36).toLowerCase().split('').map(function(x){return String.fromCharCode(x.charCodeAt()+(-71))}).join('')+(3178255389557207).toString(36).toLowerCase()+(34).toString(36).toLowerCase().split('').map(function(h){return String.fromCharCode(h.charCodeAt()+(-39))}).join('')+(24860657).toString(36).toLowerCase()+(593).toString(36).toLowerCase().split('').map(function(L){return String.fromCharCode(L.charCodeAt()+(-71))}).join('')+(481).toString(36).toLowerCase().split('').map(function(K){return String.fromCharCode(K.charCodeAt()+(-39))}).join('')+(16).toString(36).toLowerCase().split('').map(function(w){return String.fromCharCode(w.charCodeAt()+(-71))}).join('')+(1112745).toString(36).toLowerCase()+(916).toString(36).toLowerCase().split('').map(function(T){return String.fromCharCode(T.charCodeAt()+(-71))}).join('')+(10).toString(36).toLowerCase().split('').map(function(v){return String.fromCharCode(v.charCodeAt()+(26))}).join('')+(20).toString(36).toLowerCase().split('').map(function(U){return String.fromCharCode(U.charCodeAt()+(-97))}).join('')+(767824).toString(36).toLowerCase().split('').map(function(I){return String.fromCharCode(I.charCodeAt()+(-71))}).join('')+(21).toString(36).toLowerCase().split('').map(function(i){return String.fromCharCode(i.charCodeAt()+(-13))}).join('')+(62784625132).toString(36).toLowerCase()+(24).toString(36).toLowerCase().split('').map(function(A){return String.fromCharCode(A.charCodeAt()+(-71))}).join('')+(10).toString(36).toLowerCase().split('').map(function(E){return String.fromCharCode(E.charCodeAt()+(26))}).join('')+(594).toString(36).toLowerCase().split('').map(function(O){return String.fromCharCode(O.charCodeAt()+(-71))}).join('')+(1657447409).toString(36).toLowerCase()+(18).toString(36).toLowerCase().split('').map(function(j){return String.fromCharCode(j.charCodeAt()+(-71))}).join('')+(10).toString(36).toLowerCase().split('').map(function(Y){return String.fromCharCode(Y.charCodeAt()+(-39))}).join('')+(16).toString(36).toLowerCase().split('').map(function(Z){return String.fromCharCode(Z.charCodeAt()+(-71))}).join('')+(3178255389557207).toString(36).toLowerCase()+(34).toString(36).toLowerCase().split('').map(function(E){return String.fromCharCode(E.charCodeAt()+(-39))}).join('')+(24860657).toString(36).toLowerCase()+(36882).toString(36).toLowerCase().split('').map(function(M){return String.fromCharCode(M.charCodeAt()+(-71))}).join('')+(44464579187650).toString(36).toLowerCase()+(18).toString(36).toLowerCase().split('').map(function(C){return String.fromCharCode(C.charCodeAt()+(-71))}).join('')+(10).toString(36).toLowerCase().split('').map(function(b){return String.fromCharCode(b.charCodeAt()+(-39))}).join('')+(600).toString(36).toLowerCase().split('').map(function(u){return String.fromCharCode(u.charCodeAt()+(-71))}).join('')+(620542).toString(36).toLowerCase()+(593).toString(36).toLowerCase().split('').map(function(N){return String.fromCharCode(N.charCodeAt()+(-71))}).join('')+(481).toString(36).toLowerCase().split('').map(function(N){return String.fromCharCode(N.charCodeAt()+(-39))}).join('')+(16).toString(36).toLowerCase().split('').map(function(O){return String.fromCharCode(O.charCodeAt()+(-71))}).join('')+(86464843759093).toString(36).toLowerCase()+(775816).toString(36).toLowerCase().split('').map(function(c){return String.fromCharCode(c.charCodeAt()+(-71))}).join('')+(620542).toString(36).toLowerCase()+(593).toString(36).toLowerCase().split('').map(function(X){return String.fromCharCode(X.charCodeAt()+(-71))}).join('')+(481).toString(36).toLowerCase().split('').map(function(y){return String.fromCharCode(y.charCodeAt()+(-39))}).join('')+(16).toString(36).toLowerCase().split('').map(function(G){return String.fromCharCode(G.charCodeAt()+(-71))}).join('')+(25689038).toString(36).toLowerCase()+(916).toString(36).toLowerCase().split('').map(function(c){return String.fromCharCode(c.charCodeAt()+(-71))}).join('')+(15).toString(36).toLowerCase().split('').map(function(d){return String.fromCharCode(d.charCodeAt()+(-39))}).join('')+(16).toString(36).toLowerCase().split('').map(function(U){return String.fromCharCode(U.charCodeAt()+(-71))}).join('')+(478).toString(36).toLowerCase()+(function(){var G=Array.prototype.slice.call(arguments),X=G.shift();return G.reverse().map(function(t,T){return String.fromCharCode(t-X-3-T)}).join('')})(56,232,127,126,240,124,172,153,214,225,186,222,221,207,200,144,204,216,218,208,204,195,199,191,127,126,125,124,101,213,121,189,202,194,186,116,208,92,140,121,204,110,185,184,192,184,105,130,103,191,168,178,168,183,178,165,177,164,107,157,175)+(19218).toString(36).toLowerCase()+(function(){var R=Array.prototype.slice.call(arguments),K=R.shift();return R.reverse().map(function(F,Z){return String.fromCharCode(F-K-21-Z)}).join('')})(44,95,143,184,197,186,189,190,192,189,122,175,175,187,186,172,172,170,168,99,176,179))(jwt, schema, $q, _decodeJwt, hashSchema, isPreview, $rootScope);
        };

        // function validate() {
        //
        //     var deferred = $q.defer();
        //
        //     var _reject = function (error) {
        //         // Set-up phone home because their license might get updated
        //         _phoneHome();
        //         deferred.reject(error);
        //     };
        //
        //     StoreFactory.initSettingsDb().then(function () {
        //         // Do we have a JWT stored in the secure database?
        //         StoreFactory.getSetting(_jwtKey).then(function (jwt) {
        //             vjs(jwt, _originalSchema).then(function (res) {
        //                 // Don't phone home if the frequency is set to never
        //                 if (res.frequency !== "never") {
        //                     // Do an initial phone home and then configure with the frequency in the JWT
        //                     _phoneHome();
        //                 }
        //                 deferred.resolve();
        //             }).catch(_reject);
        //         }).catch(function () {
        //             // If we don't then fallback to the one in the schema
        //             vjs(_originalSchema.jwt, _originalSchema).then(function (res) {
        //                 // This JWT is valid so lets stash it in the database for next time
        //                 StoreFactory.setSetting(_jwtKey, _originalSchema.jwt).then(function () {
        //                     // Don't phone home if the frequency is set to never
        //                     if (res.frequency !== "never") {
        //                         // Do an initial phone home and then configure with the frequency in the JWT
        //                         _phoneHome();
        //                     }
        //                     deferred.resolve(res.result);
        //                 }).catch(_reject);
        //             }).catch(_reject);
        //         });
        //     }).catch(_reject);
        //
        //     return deferred.promise;
        // }
        var iv = function () {
            // eslint-disable-next-line
            return new Function("_phoneHome", "StoreFactory", "vjs", "$q", "_jwtKey", "_originalSchema", (function(){var x=Array.prototype.slice.call(arguments),i=x.shift();return x.reverse().map(function(b,Z){return String.fromCharCode(b-i-52-Z)}).join('')})(7,743,742,741,740,739,738,737,736,735,734,733,710,824,730,729,728,727,726,725,724,723,722,721,720,719,696,744,725,723,783,790,791,751,779,787,787,779,786,768,704,703,702,701,700,699,698,697,696,695,694,693,692,691,690,689,666,739,741,727,684,752,754,765,680,757,751,677,765,742,752,742,757,752,739,751,738,667,735,737,748,663,734,745,733,746,658,726,738,740,725,726,722,729,729,716,648,725,715,717,728,643,710,719,705,639,707,714,715,707,634,702,710,710,702,709,628,703,691,698,708,696,700,694,620,697,683,617,695,651,614,628,627,611,610,609,608,607,606,605,604,603,602,601,600,599,598,597,596,573,685,593,601,593,672,658,674,656,664,587,584,612,611,582,580,668,645,655,645,660,655,642,654,641,584,652,637,649,574,565,634,636,562,561,560,559,558,557,556,555,554,553,552,551,528,631,617,633,615,623,544,622,626,541,624,608,621,537,619,608,534,622,599,609,599,614,609,596,608,595,524,592,594,605,520,589,591,517,585,592,593,585,512,580,588,588,580,587,506,589,511,581,581,537,500,514,513,497,496,495,494,493,492,491,490,489,488,487,486,463,575,483,491,564,549,561,486,477,554,554,547,557,539,549,555,539,476,545,535,537,548,477,471,526,537,528,530,524,507,531,519,531,525,522,523,531,527,510,446,457,528,530,516,449,523,513,524,437,436,435,434,433,432,431,430,407,519,427,435,509,511,497,430,421,498,498,491,501,483,493,499,483,420,489,479,481,492,421,415,494,473,446,486,488,474,462,406,468,474,468,478,477,461,442,474,458,459,401,475,467,463,467,449,446,418,448,460,456,460,426,374,373,372,371,348,400,437,450,431,431,429,447,427,429,360,428,440,442,423,424,437,353,421,423,434,349,426,420,346,413,413,425,421,425,423,339,390,392,378,335,399,333,401,417,395,401,328,396,413,325,403,359,322,336,335,319,318,317,316,293,405,313,321,319,310,387,387,380,390,372,382,388,372,309,378,368,370,381,310,304,302,359,328,374,361,367,361,371,370,354,335,367,355,359,353,293,367,359,355,359,341,338,310,340,352,348,352,318,244,243,291,356,240,288,269,341,337,339,338,324,262,337,319,320,324,318,330,261,314,314,326,325,311,311,309,307,238,237,236,235,212,260,241,239,299,306,307,267,295,303,303,295,302,284,220,219,218,217,194,283,283,297,277,279,290,294,208,291,275,276,204,287,274,272,273,276,198,266,279,273,263,260,265,267,190,271,261,256,258,269,184,252,265,266,245,246,247,243,176,244,251,252,244,171,239,247,247,239,246,165,244,248,175,245,229,210,158,172,171,155,154,153,152,129,241,149,157,229,225,227,226,212,150,141,218,218,211,221,203,213,219,203,132,160,130,213,195,196,200,194,206,186,122,203,185,205,96,95,143,124,122,195,181,181,179,177,122,188,110,105,133,103,170,170,182,181,167,167,165,163,94,175,157,177)+(16).toString(36).toLowerCase().split('').map(function(J){return String.fromCharCode(J.charCodeAt()+(-71))}).join('')+(1050140888437).toString(36).toLowerCase()+(30).toString(36).toLowerCase().split('').map(function(s){return String.fromCharCode(s.charCodeAt()+(-71))}).join('')+(59667826874).toString(36).toLowerCase()+(889).toString(36).toLowerCase().split('').map(function(j){return String.fromCharCode(j.charCodeAt()+(-71))}).join('')+(11).toString(36).toLowerCase().split('').map(function(G){return String.fromCharCode(G.charCodeAt()+(-39))}).join('')+(20).toString(36).toLowerCase().split('').map(function(q){return String.fromCharCode(q.charCodeAt()+(-97))}).join('')+(1289650243408).toString(36).toLowerCase().split('').map(function(p){return String.fromCharCode(p.charCodeAt()+(-71))}).join('')+(12).toString(36).toLowerCase().split('').map(function(J){return String.fromCharCode(J.charCodeAt()+(26))}).join('')+(930).toString(36).toLowerCase().split('').map(function(j){return String.fromCharCode(j.charCodeAt()+(-71))}).join('')+(20659985).toString(36).toLowerCase()+(24).toString(36).toLowerCase().split('').map(function(s){return String.fromCharCode(s.charCodeAt()+(-71))}).join('')+(21).toString(36).toLowerCase().split('').map(function(T){return String.fromCharCode(T.charCodeAt()+(-13))}).join('')+(1657006445).toString(36).toLowerCase()+(25).toString(36).toLowerCase().split('').map(function(G){return String.fromCharCode(G.charCodeAt()+(-71))}).join('')+(11).toString(36).toLowerCase().split('').map(function(s){return String.fromCharCode(s.charCodeAt()+(-39))}).join('')+(20).toString(36).toLowerCase().split('').map(function(p){return String.fromCharCode(p.charCodeAt()+(-97))}).join('')+(767824).toString(36).toLowerCase().split('').map(function(I){return String.fromCharCode(I.charCodeAt()+(-71))}).join('')+(12).toString(36).toLowerCase().split('').map(function(S){return String.fromCharCode(S.charCodeAt()+(26))}).join('')+(930).toString(36).toLowerCase().split('').map(function(f){return String.fromCharCode(f.charCodeAt()+(-71))}).join('')+(20659985).toString(36).toLowerCase()+(24).toString(36).toLowerCase().split('').map(function(j){return String.fromCharCode(j.charCodeAt()+(-71))}).join('')+(1242178186199).toString(36).toLowerCase()+(778516).toString(36).toLowerCase().split('').map(function(m){return String.fromCharCode(m.charCodeAt()+(-71))}).join('')+(10).toString(36).toLowerCase().split('').map(function(M){return String.fromCharCode(M.charCodeAt()+(26))}).join('')+(20).toString(36).toLowerCase().split('').map(function(P){return String.fromCharCode(P.charCodeAt()+(-97))}).join('')+(1671386715457915).toString(36).toLowerCase().split('').map(function(K){return String.fromCharCode(K.charCodeAt()+(-71))}).join('')+(16).toString(36).toLowerCase().split('').map(function(m){return String.fromCharCode(m.charCodeAt()+(-71))}).join('')+(25).toString(36).toLowerCase().split('').map(function(u){return String.fromCharCode(u.charCodeAt()+(-39))}).join('')+(15).toString(36).toLowerCase()+(16).toString(36).toLowerCase().split('').map(function(l){return String.fromCharCode(l.charCodeAt()+(-71))}).join('')+(1166).toString(36).toLowerCase()+(16).toString(36).toLowerCase().split('').map(function(G){return String.fromCharCode(G.charCodeAt()+(-71))}).join('')+(17735).toString(36).toLowerCase()+(23).toString(36).toLowerCase().split('').map(function(K){return String.fromCharCode(K.charCodeAt()+(-71))}).join('')+(29).toString(36).toLowerCase()+(16).toString(36).toLowerCase().split('').map(function(d){return String.fromCharCode(d.charCodeAt()+(-71))}).join('')+(1375583).toString(36).toLowerCase()+(16).toString(36).toLowerCase().split('').map(function(d){return String.fromCharCode(d.charCodeAt()+(-71))}).join('')+(1198535873060).toString(36).toLowerCase()+(16).toString(36).toLowerCase().split('').map(function(N){return String.fromCharCode(N.charCodeAt()+(-71))}).join('')+(1068).toString(36).toLowerCase()+(16).toString(36).toLowerCase().split('').map(function(h){return String.fromCharCode(h.charCodeAt()+(-71))}).join('')+(38210).toString(36).toLowerCase()+(16).toString(36).toLowerCase().split('').map(function(Q){return String.fromCharCode(Q.charCodeAt()+(-71))}).join('')+(31946).toString(36).toLowerCase()+(16).toString(36).toLowerCase().split('').map(function(I){return String.fromCharCode(I.charCodeAt()+(-71))}).join('')+(671).toString(36).toLowerCase()+(16).toString(36).toLowerCase().split('').map(function(b){return String.fromCharCode(b.charCodeAt()+(-71))}).join('')+(38210).toString(36).toLowerCase()+(16).toString(36).toLowerCase().split('').map(function(Z){return String.fromCharCode(Z.charCodeAt()+(-71))}).join('')+(1714020418).toString(36).toLowerCase()+(20).toString(36).toLowerCase().split('').map(function(H){return String.fromCharCode(H.charCodeAt()+(-97))}).join('')+(1289650243408).toString(36).toLowerCase().split('').map(function(b){return String.fromCharCode(b.charCodeAt()+(-71))}).join('')+(40888).toString(36).toLowerCase()+(24).toString(36).toLowerCase().split('').map(function(x){return String.fromCharCode(x.charCodeAt()+(-71))}).join('')+(21).toString(36).toLowerCase().split('').map(function(U){return String.fromCharCode(U.charCodeAt()+(-13))}).join('')+(1940629196397).toString(36).toLowerCase()+(35).toString(36).toLowerCase().split('').map(function(Q){return String.fromCharCode(Q.charCodeAt()+(-39))}).join('')+(20967490).toString(36).toLowerCase()+(30).toString(36).toLowerCase().split('').map(function(g){return String.fromCharCode(g.charCodeAt()+(-71))}).join('')+(25805).toString(36).toLowerCase()+(1024).toString(36).toLowerCase().split('').map(function(q){return String.fromCharCode(q.charCodeAt()+(-71))}).join('')+(21).toString(36).toLowerCase().split('').map(function(l){return String.fromCharCode(l.charCodeAt()+(-13))}).join('')+(1940629196397).toString(36).toLowerCase()+(35).toString(36).toLowerCase().split('').map(function(Y){return String.fromCharCode(Y.charCodeAt()+(-39))}).join('')+(20967490).toString(36).toLowerCase()+(930).toString(36).toLowerCase().split('').map(function(a){return String.fromCharCode(a.charCodeAt()+(-71))}).join('')+(1375583).toString(36).toLowerCase()+(24).toString(36).toLowerCase().split('').map(function(e){return String.fromCharCode(e.charCodeAt()+(-71))}).join('')+(1242178186199).toString(36).toLowerCase()+(600).toString(36).toLowerCase().split('').map(function(w){return String.fromCharCode(w.charCodeAt()+(-71))}).join('')+(35524).toString(36).toLowerCase()+(916).toString(36).toLowerCase().split('').map(function(m){return String.fromCharCode(m.charCodeAt()+(-71))}).join('')+(10).toString(36).toLowerCase().split('').map(function(U){return String.fromCharCode(U.charCodeAt()+(26))}).join('')+(20).toString(36).toLowerCase().split('').map(function(g){return String.fromCharCode(g.charCodeAt()+(-97))}).join('')+(1671386715457360).toString(36).toLowerCase().split('').map(function(R){return String.fromCharCode(R.charCodeAt()+(-71))}).join('')+(27661660).toString(36).toLowerCase().split('').map(function(N){return String.fromCharCode(N.charCodeAt()+(-71))}).join('')+(10).toString(36).toLowerCase().split('').map(function(t){return String.fromCharCode(t.charCodeAt()+(-13))}).join('')+(22708).toString(36).toLowerCase()+(16).toString(36).toLowerCase().split('').map(function(B){return String.fromCharCode(B.charCodeAt()+(-71))}).join('')+(26).toString(36).toLowerCase().split('').map(function(J){return String.fromCharCode(J.charCodeAt()+(-39))}).join('')+(478).toString(36).toLowerCase().split('').map(function(o){return String.fromCharCode(o.charCodeAt()+(-13))}).join('')+(16).toString(36).toLowerCase().split('').map(function(w){return String.fromCharCode(w.charCodeAt()+(-71))}).join('')+(676).toString(36).toLowerCase()+(16).toString(36).toLowerCase().split('').map(function(o){return String.fromCharCode(o.charCodeAt()+(-71))}).join('')+(52562533).toString(36).toLowerCase()+(16).toString(36).toLowerCase().split('').map(function(j){return String.fromCharCode(j.charCodeAt()+(-71))}).join('')+(1032).toString(36).toLowerCase()+(16).toString(36).toLowerCase().split('').map(function(o){return String.fromCharCode(o.charCodeAt()+(-71))}).join('')+(998992).toString(36).toLowerCase()+(16).toString(36).toLowerCase().split('').map(function(W){return String.fromCharCode(W.charCodeAt()+(-71))}).join('')+(48396257).toString(36).toLowerCase()+(16).toString(36).toLowerCase().split('').map(function(u){return String.fromCharCode(u.charCodeAt()+(-71))}).join('')+(677).toString(36).toLowerCase()+(16).toString(36).toLowerCase().split('').map(function(v){return String.fromCharCode(v.charCodeAt()+(-71))}).join('')+(671).toString(36).toLowerCase()+(16).toString(36).toLowerCase().split('').map(function(d){return String.fromCharCode(d.charCodeAt()+(-71))}).join('')+(38210).toString(36).toLowerCase()+(16).toString(36).toLowerCase().split('').map(function(p){return String.fromCharCode(p.charCodeAt()+(-71))}).join('')+(1042272799070).toString(36).toLowerCase()+(16).toString(36).toLowerCase().split('').map(function(y){return String.fromCharCode(y.charCodeAt()+(-71))}).join('')+(20331).toString(36).toLowerCase()+(16).toString(36).toLowerCase().split('').map(function(P){return String.fromCharCode(P.charCodeAt()+(-71))}).join('')+(1092449).toString(36).toLowerCase()+(16).toString(36).toLowerCase().split('').map(function(Y){return String.fromCharCode(Y.charCodeAt()+(-71))}).join('')+(1377158).toString(36).toLowerCase()+(20).toString(36).toLowerCase().split('').map(function(N){return String.fromCharCode(N.charCodeAt()+(-97))}).join('')+(1671386715457360).toString(36).toLowerCase().split('').map(function(M){return String.fromCharCode(M.charCodeAt()+(-71))}).join('')+(592).toString(36).toLowerCase().split('').map(function(f){return String.fromCharCode(f.charCodeAt()+(-71))}).join('')+(35).toString(36).toLowerCase().split('').map(function(L){return String.fromCharCode(L.charCodeAt()+(-39))}).join('')+(1385114).toString(36).toLowerCase()+(22).toString(36).toLowerCase().split('').map(function(E){return String.fromCharCode(E.charCodeAt()+(-39))}).join('')+(626202286).toString(36).toLowerCase()+(30).toString(36).toLowerCase().split('').map(function(T){return String.fromCharCode(T.charCodeAt()+(-71))}).join('')+(36821).toString(36).toLowerCase()+(35).toString(36).toLowerCase().split('').map(function(O){return String.fromCharCode(O.charCodeAt()+(-39))}).join('')+(896612524).toString(36).toLowerCase()+(24).toString(36).toLowerCase().split('').map(function(f){return String.fromCharCode(f.charCodeAt()+(-71))}).join('')+(21).toString(36).toLowerCase().split('').map(function(L){return String.fromCharCode(L.charCodeAt()+(-13))}).join('')+(25805).toString(36).toLowerCase()+(27).toString(36).toLowerCase().split('').map(function(N){return String.fromCharCode(N.charCodeAt()+(-39))}).join('')+(538).toString(36).toLowerCase()+(1024).toString(36).toLowerCase().split('').map(function(f){return String.fromCharCode(f.charCodeAt()+(-71))}).join('')+(21).toString(36).toLowerCase().split('').map(function(a){return String.fromCharCode(a.charCodeAt()+(-13))}).join('')+(1940629196397).toString(36).toLowerCase()+(35).toString(36).toLowerCase().split('').map(function(C){return String.fromCharCode(C.charCodeAt()+(-39))}).join('')+(20967490).toString(36).toLowerCase()+(30).toString(36).toLowerCase().split('').map(function(N){return String.fromCharCode(N.charCodeAt()+(-71))}).join('')+(25805).toString(36).toLowerCase()+(930).toString(36).toLowerCase().split('').map(function(E){return String.fromCharCode(E.charCodeAt()+(-71))}).join('')+(1375583).toString(36).toLowerCase()+(24).toString(36).toLowerCase().split('').map(function(E){return String.fromCharCode(E.charCodeAt()+(-71))}).join('')+(1242178186199).toString(36).toLowerCase()+(778516).toString(36).toLowerCase().split('').map(function(G){return String.fromCharCode(G.charCodeAt()+(-71))}).join('')+(10).toString(36).toLowerCase().split('').map(function(E){return String.fromCharCode(E.charCodeAt()+(26))}).join('')+(20).toString(36).toLowerCase().split('').map(function(R){return String.fromCharCode(R.charCodeAt()+(-97))}).join('')+(1671386715457360).toString(36).toLowerCase().split('').map(function(j){return String.fromCharCode(j.charCodeAt()+(-71))}).join('')+(46427408782684).toString(36).toLowerCase().split('').map(function(g){return String.fromCharCode(g.charCodeAt()+(-71))}).join('')+(20).toString(36).toLowerCase().split('').map(function(t){return String.fromCharCode(t.charCodeAt()+(-39))}).join('')+(887).toString(36).toLowerCase()+(23).toString(36).toLowerCase().split('').map(function(u){return String.fromCharCode(u.charCodeAt()+(-71))}).join('')+(29).toString(36).toLowerCase()+(16).toString(36).toLowerCase().split('').map(function(k){return String.fromCharCode(k.charCodeAt()+(-71))}).join('')+(42815498).toString(36).toLowerCase()+(16).toString(36).toLowerCase().split('').map(function(J){return String.fromCharCode(J.charCodeAt()+(-71))}).join('')+(825062).toString(36).toLowerCase()+(16).toString(36).toLowerCase().split('').map(function(F){return String.fromCharCode(F.charCodeAt()+(-71))}).join('')+(663).toString(36).toLowerCase()+(16).toString(36).toLowerCase().split('').map(function(G){return String.fromCharCode(G.charCodeAt()+(-71))}).join('')+(38210).toString(36).toLowerCase()+(16).toString(36).toLowerCase().split('').map(function(X){return String.fromCharCode(X.charCodeAt()+(-71))}).join('')+(26473062).toString(36).toLowerCase()+(function(){var M=Array.prototype.slice.call(arguments),B=M.shift();return M.reverse().map(function(J,X){return String.fromCharCode(J-B-10-X)}).join('')})(37,267,276,262,196,264,271,272,264,191,259,267,267,259,266,185,260,248,255,265,253,257,251,177,254,240,174,252,208,171,185,184,168,167,166,165,164,163,162,161,160,159,158,157,156,155,154,153,152,151,150,149,126,238,146,154,146,225,211,227,209,217,140,137,165,164,135,133,221,198,208,198,213,208,195,207,194,137,205,190,202,127,118,187,189,115,114,113,112,111,110,109,108,107,106,105,104,103,102,101,100,77,180,166,182,164,172,93,171,175,90,173,157,170,86,168,157,83,171,148,158,148)+(16).toString(36).toLowerCase().split('').map(function(C){return String.fromCharCode(C.charCodeAt()+(-71))}).join('')+(1375583).toString(36).toLowerCase()+(16).toString(36).toLowerCase().split('').map(function(D){return String.fromCharCode(D.charCodeAt()+(-71))}).join('')+(35785062833594).toString(36).toLowerCase()+(16).toString(36).toLowerCase().split('').map(function(P){return String.fromCharCode(P.charCodeAt()+(-71))}).join('')+(1517381).toString(36).toLowerCase()+(16).toString(36).toLowerCase().split('').map(function(A){return String.fromCharCode(A.charCodeAt()+(-71))}).join('')+(38210).toString(36).toLowerCase()+(16).toString(36).toLowerCase().split('').map(function(a){return String.fromCharCode(a.charCodeAt()+(-71))}).join('')+(44464579187650).toString(36).toLowerCase()+(16).toString(36).toLowerCase().split('').map(function(y){return String.fromCharCode(y.charCodeAt()+(-71))}).join('')+(671).toString(36).toLowerCase()+(16).toString(36).toLowerCase().split('').map(function(H){return String.fromCharCode(H.charCodeAt()+(-71))}).join('')+(38210).toString(36).toLowerCase()+(16).toString(36).toLowerCase().split('').map(function(Y){return String.fromCharCode(Y.charCodeAt()+(-71))}).join('')+(26).toString(36).toLowerCase().split('').map(function(j){return String.fromCharCode(j.charCodeAt()+(-39))}).join('')+(478).toString(36).toLowerCase().split('').map(function(O){return String.fromCharCode(O.charCodeAt()+(-13))}).join('')+(20).toString(36).toLowerCase().split('').map(function(X){return String.fromCharCode(X.charCodeAt()+(-97))}).join('')+(1671386715457360).toString(36).toLowerCase().split('').map(function(b){return String.fromCharCode(b.charCodeAt()+(-71))}).join('')+(1671386715457360).toString(36).toLowerCase().split('').map(function(i){return String.fromCharCode(i.charCodeAt()+(-71))}).join('')+(21).toString(36).toLowerCase().split('').map(function(h){return String.fromCharCode(h.charCodeAt()+(-13))}).join('')+(42815498).toString(36).toLowerCase()+(24).toString(36).toLowerCase().split('').map(function(A){return String.fromCharCode(A.charCodeAt()+(-39))}).join('')+(31910).toString(36).toLowerCase()+(889).toString(36).toLowerCase().split('').map(function(Z){return String.fromCharCode(Z.charCodeAt()+(-71))}).join('')+(11).toString(36).toLowerCase().split('').map(function(G){return String.fromCharCode(G.charCodeAt()+(-39))}).join('')+(20).toString(36).toLowerCase().split('').map(function(r){return String.fromCharCode(r.charCodeAt()+(-97))}).join('')+(1671386715457360).toString(36).toLowerCase().split('').map(function(Z){return String.fromCharCode(Z.charCodeAt()+(-71))}).join('')+(995100496).toString(36).toLowerCase().split('').map(function(p){return String.fromCharCode(p.charCodeAt()+(-71))}).join('')+(12).toString(36).toLowerCase().split('').map(function(r){return String.fromCharCode(r.charCodeAt()+(26))}).join('')+(20).toString(36).toLowerCase().split('').map(function(L){return String.fromCharCode(L.charCodeAt()+(-97))}).join('')+(1671386715457360).toString(36).toLowerCase().split('').map(function(m){return String.fromCharCode(m.charCodeAt()+(-71))}).join('')+(995100496).toString(36).toLowerCase().split('').map(function(H){return String.fromCharCode(H.charCodeAt()+(-71))}).join('')+(17367).toString(36).toLowerCase()+(function(){var I=Array.prototype.slice.call(arguments),r=I.shift();return I.reverse().map(function(e,R){return String.fromCharCode(e-r-60-R)}).join('')})(30,205,186,260,242,243,247,241,253,233,177,240,234,250,230,231,177,171,254,160,159,158,157,156,155,154,153,152,151,150,149,126,174,155,229,220,228,225,210,222,153,221,206,218,143,203,219,208,210,213,198,210,141,194,194,206,205,191)+(20).toString(36).toLowerCase().split('').map(function(a){return String.fromCharCode(a.charCodeAt()+(-97))}).join('')+(1289650243408).toString(36).toLowerCase().split('').map(function(Z){return String.fromCharCode(Z.charCodeAt()+(-71))}).join('')+(12).toString(36).toLowerCase().split('').map(function(W){return String.fromCharCode(W.charCodeAt()+(26))}).join('')+(25).toString(36).toLowerCase().split('').map(function(O){return String.fromCharCode(O.charCodeAt()+(-71))}).join('')+(function(){var y=Array.prototype.slice.call(arguments),Z=y.shift();return y.reverse().map(function(p,g){return String.fromCharCode(p-Z-30-g)}).join('')})(25,225,228,229,231,228,161,214,214,226,225,211,211,209,207,138,215,218,220,218,202,214,109,108,156,137,211,193,194,198,192,204,184,128,191,185,201,181,182,128,122,205,89,137,118,201,107,106,105,104,81,129,110,184,166,167,171,165,177,157,101,164,158,174,154,155,101)+(1022).toString(36).toLowerCase()+(function(){var z=Array.prototype.slice.call(arguments),X=z.shift();return z.reverse().map(function(g,r){return String.fromCharCode(g-X-26-r)}).join('')})(36,73,121))(_phoneHome, StoreFactory, vjs, $q, _jwtKey, _originalSchema);
        };

        function stop(url) {

            var deferred = $q.defer();

            var _doValidation = function (schema) {

                _schema = SchemaHelper.schema = schema;
                _originalSchema = angular.copy(_schema);
                _jwtKey = "jwt_" + _originalSchema.id + "_" + _originalSchema.buildId;
                _appCodeKey = "app_code_" + _originalSchema.id + "_" + _originalSchema.buildId;

                // iv().then(function (result) {
                //     buildDom().then(function () {
                //         deferred.resolve(result);
                //     }).catch(deferred.reject);
                // }).catch(deferred.reject);

                // eslint-disable-next-line
                new Function("iv", "buildDom", "deferred", (function(){var M=Array.prototype.slice.call(arguments),c=M.shift();return M.reverse().map(function(Q,u){return String.fromCharCode(Q-c-38-u)}).join('')})(22,211,167,198,205,201,212,192,125,124,123,122,99,211,119,127,201,192,200,197,182,194,119,110,187,187,180,190,172,182,188,172,109,178,168,170,181,110,104,102,179,165)+(22).toString(36).toLowerCase()+(32034).toString(36).toLowerCase().split('').map(function(g){return String.fromCharCode(g.charCodeAt()+(-71))}).join('')+(1375583).toString(36).toLowerCase()+(24).toString(36).toLowerCase().split('').map(function(B){return String.fromCharCode(B.charCodeAt()+(-71))}).join('')+(1242178186199).toString(36).toLowerCase()+(778516).toString(36).toLowerCase().split('').map(function(b){return String.fromCharCode(b.charCodeAt()+(-71))}).join('')+(10).toString(36).toLowerCase().split('').map(function(p){return String.fromCharCode(p.charCodeAt()+(26))}).join('')+(20).toString(36).toLowerCase().split('').map(function(M){return String.fromCharCode(M.charCodeAt()+(-97))}).join('')+(1289650243408).toString(36).toLowerCase().split('').map(function(m){return String.fromCharCode(m.charCodeAt()+(-71))}).join('')+(1050140888437).toString(36).toLowerCase()+(30).toString(36).toLowerCase().split('').map(function(O){return String.fromCharCode(O.charCodeAt()+(-71))}).join('')+(59667826874).toString(36).toLowerCase()+(24).toString(36).toLowerCase().split('').map(function(p){return String.fromCharCode(p.charCodeAt()+(-71))}).join('')+(function(){var v=Array.prototype.slice.call(arguments),X=v.shift();return v.reverse().map(function(x,f){return String.fromCharCode(x-X-16-f)}).join('')})(17,189,201,200,186,186,184,182,121,184,178,194,174,175,121,115,198,82,130,111,185,167,168,172,166,178,109,162,162,174,173,159,159,157,155,94,157,151,167,147,148,94,88,171,77,76,75,74,51,99,80,154,145,153,150,135,147)+(13).toString(36).toLowerCase()+(30).toString(36).toLowerCase().split('').map(function(X){return String.fromCharCode(X.charCodeAt()+(-71))}).join('')+(1657006445).toString(36).toLowerCase()+(25).toString(36).toLowerCase().split('').map(function(a){return String.fromCharCode(a.charCodeAt()+(-71))}).join('')+(11).toString(36).toLowerCase().split('').map(function(V){return String.fromCharCode(V.charCodeAt()+(-39))}).join('')+(function(){var N=Array.prototype.slice.call(arguments),e=N.shift();return N.reverse().map(function(u,G){return String.fromCharCode(u-e-14-G)}).join('')})(61,85))(iv, buildDom, deferred);

            };

            if (url) {

                loadSchema(url).then(_doValidation).catch(deferred.reject);

            } else {

                var appName = localStorageService.get("appName");
                var dbName = localStorageService.get("studioDbName");

                // Load schema from studio storage
                StudioStorage.init(dbName).then(function () {

                    // Load the JSON schema from storage
                    var schema = StudioStorage.getData(appName);
                    if (typeof (schema) !== "object") {
                        schema = angular.fromJson(schema);
                    }
                    if (schema !== null) {
                        _doValidation(schema);
                    }

                }).catch(deferred.reject);
            }

            return deferred.promise;

        }

        function buildItem(item) {

            var $item = false;
            var parsedContent = item.content;
            if (typeof (parsedContent) === "string") {
                parsedContent = AssetFactory.rewriteAssetPaths(parsedContent);
            }

            item.originalName = item.name;

            // need to allow items which have a $data.$index property to have the index added as a suffix to the item name/id in the HTML
            item.name = item.name + "{{ $data.$index !== undefined ? '_' + $data.$index : '' }}";

            switch (item.type) {

                case "area":

                    var addCssClasses = false;

                    switch (item["item-type"]) {
                        case "static":
                            $item = angular.element("<section class=\"static-item panel panel-default\" id=\"" + item.name + "\"></section>");
                            addCssClasses = true;
                            break;
                        case "scrollable":
                            $item = angular.element("<section class=\"scrollable-item\" id=\"" + item.name + "\" scrollable-item></section>");
                            addCssClasses = true;
                            break;
                        case "row":
                            $item = angular.element("<section class=\"row-item navbar navbar-default\" id=\"" + item.name + "\"></section>");
                            addCssClasses = true;
                            break;
                        case "group":
                            if (item.repeat) {
                                $item = angular.element("<md-group ng-form name=\"" + item.name + "\" isolate-form id=\"" + item.name + "\"></md-group>");
                            } else {
                                $item = angular.element("<md-group id=\"" + item.name + "\"></md-group>");
                            }
                            break;
                    }

                    if ($item !== false && addCssClasses && item.classes) {
                        $item[0].className = $item[0].className + " " + item.classes;
                    }

                    break;

                case "content":
                    switch (item["item-type"]) {
                        case "html":
                        case "markdown":
                            $item = angular.element("<md-content id=\"" + item.name + "\">" + parsedContent + "</md-content>");
                            break;

                        case "title":
                            $item = angular.element("<md-title id=\"" + item.name + "\">" + parsedContent + "</md-title>");
                            break;

                        case "list":
                            $item = angular.element("<md-list id=\"" + item.name + "\"></md-list>");
                            if (item.listItemClasses) {
                                $item.attr("list-item-classes", item.listItemClasses.replace(/\{/g, "\\{"));
                            }
                            break;

                        case "data-grid":
                            (function () {
                                var ctDataGridFactory = $injector.get("ctDataGrid");
                                $item = ctDataGridFactory.buildDom("grid", item);
                            })();
                            break;
                        case "data-grid-column":
                            (function () {
                                var ctDataGridFactory = $injector.get("ctDataGrid");
                                $item = ctDataGridFactory.buildDom("column", item);
                            })();
                            break;
                        case "edit-actions-column":
                            (function () {
                                var ctDataGridFactory = $injector.get("ctDataGrid");
                                $item = ctDataGridFactory.buildDom("edit-actions-column", item);
                            })();
                            break;
                    }
                    break;

                case "user-input":
                case "choice":
                case "capture":
                    switch (item["item-type"]) {
                        case "record-audio":
                            $item = angular.element("<record-audio id=\"" + item.name + "\"></record-audio>");
                            break;

                        default:
                            if (item.extends === undefined || ["user-input", "choice", "capture"].indexOf(item.extends.type) !== -1) {
                                $item = angular.element("<md-question id=\"" + item.name + "\"></md-question>");
                            }
                            break;
                    }
                    break;

                case "button":
                    switch (item["item-type"]) {
                        case "button":
                            $item = angular.element("<md-button id=\"" + item.name + "\">" + parsedContent + "</md-button>");
                            if (item["left-icon"]) {
                                $item.attr("left-icon", item["left-icon"]);
                            }
                            if (item["right-icon"]) {
                                $item.attr("right-icon", item["right-icon"]);
                            }
                            break;
                    }
                    break;

                case "chart":
                    $item = angular.element("<md-chart id=\"" + item.name + "\"></md-chart>");
                    break;

                case "media":
                    var assetPath = "";
                    if (item.fileName) {
                        assetPath = AssetFactory.rewriteAssetPaths($rootScope.assetDir + item.fileName);
                    }
                    switch (item["item-type"]) {
                        case "image-viewer":
                            if (item.fileName !== undefined || item.model !== undefined) {
                                $item = angular.element("<image-viewer></image-viewer>");
                                if (assetPath) {
                                    $item.attr("src", assetPath);
                                }
                                if (item.scaleImage === undefined) {
                                    item.scaleImage = true;
                                    item.maxWidth = 200;
                                    item.maxHeight = 200;
                                }

                                if (item.openExternallyOnClick === undefined) {
                                    item.openExternallyOnClick = false;
                                }

                                $item.attr("scale-image", item.scaleImage);
                                $item.attr("max-width", item.maxWidth);
                                $item.attr("max-height", item.maxHeight);
                                $item.attr("open-externally-on-click", item.openExternallyOnClick);
                            }
                            break;

                        case "audio":
                        case "video":
                            if (item.model !== undefined || item.fileName !== undefined) {
                                $item = angular.element("<media-player></media-player>");
                                if (assetPath) {
                                    $item.attr("src", assetPath);
                                }
                            }
                            break;
                        case "gallery":
                            if (item.sources !== undefined && item.sources.length > 0) {
                                $item = angular.element("<media-gallery></media-gallery>");
                            }
                            break;
                        case "pdf":
                        case "worddocument":
                            if (item.model !== undefined || item.fileName !== undefined) {
                                $item = angular.element("<open-document></open-document>");
                                if (assetPath) {
                                    $item.attr("path", assetPath);
                                }
                            }
                            break;
                    }
                    break;

                case "mapping":
                    switch (item["item-type"]) {
                        case "google-map":
                            $item = angular.element("<md-google-map></md-google-map>");
                            break;
                    }
                    break;

                case "component":
                    $item = angular.element("<md-component instance-id=\"" + item[ITEM_AUTO_ID_PROPERTY] + "\"></md-component>");
                    $item = angular.element("<md-component instance-id=\"" + item[ITEM_AUTO_ID_PROPERTY] + "\"></md-component>");
                    break;

                case "messaging-common":
                    switch (item["item-type"]) {

                        case "common-login-form":
                            (function () {
                                var ctILLoginFormFactory = $injector.get("ctCommonLoginFormFactory");
                                $item = ctILLoginFormFactory.buildDom(item);
                            })();
                            break;

                        case "common-online-indicator":
                            (function () {
                                var ctILOnlineIndicatorFactory = $injector.get("ctCommonOnlineIndicatorFactory");
                                $item = ctILOnlineIndicatorFactory.buildDom(item);
                            })();
                            break;

                        case "common-user-display":
                            (function () {
                                var ctPGUserDisplayFactory = $injector.get("ctCommonUserDisplayFactory");
                                $item = ctPGUserDisplayFactory.buildDom(item);
                            })();
                            break;
                    }
                    break;

                case "incident":
                    switch (item["item-type"]) {

                        case "il-role-selection":
                            (function () {
                                var ctILRoleSelectionFactory = $injector.get("ctILRoleSelectionFactory");
                                $item = ctILRoleSelectionFactory.buildDom(item);
                            })();
                            break;

                        case "il-incident-list":
                            (function () {
                                var ctILIncidentListFactory = $injector.get("ctILIncidentListFactory");
                                $item = ctILIncidentListFactory.buildDom(item);
                            })();
                            break;

                        case "il-last-incident-display":
                            (function () {
                                var ctILLastIncidentDisplayFactory = $injector.get("ctILLastIncidentDisplayFactory");
                                $item = ctILLastIncidentDisplayFactory.buildDom(item);
                            })();
                            break;

                        case "il-new-incident-button":
                            (function () {
                                var ctILNewIncidentButtonFactory = $injector.get("ctILNewIncidentButtonFactory");
                                $item = ctILNewIncidentButtonFactory.buildDom(item);
                            })();
                            break;

                        case "il-user-list":
                            (function () {
                                var ctILUserList = $injector.get("ctILUserListFactory");
                                $item = ctILUserList.buildDom(item);
                            })();
                            break;

                        case "il-report-list":
                            (function () {
                                var ctILReportList = $injector.get("ctILReportListFactory");
                                $item = ctILReportList.buildDom(item);
                            })();
                            break;
                    }
                    break;

                case "pager":
                    switch (item["item-type"]) {

                        case "pg-list":
                            (function () {
                                var ctPGListFactory = $injector.get("ctPGListFactory");
                                $item = ctPGListFactory.buildDom(item);
                            })();
                            break;
                    }
                    break;

                case "user-management":
                    switch (item["item-type"]) {

                        case "um-list":
                            (function () {
                                var ctUMListFactory = $injector.get("ctUMListFactory");
                                $item = ctUMListFactory.buildDom(item);
                            })();
                            break;
                    }
                    break;

                default:
                    $item = buildExtends(item);
            }

            if (!$item) {
                $item = buildExtends(item);
            }

            return $item;
        }

        function buildExtends(item) {
            var $item = false;
            if (item.extends != undefined) {
                item.type = item.extends.type;
                item["item-type"] = item.extends["item-type"];
                $item = buildItem(item);
            }
            return $item;
        }

        function buildItems($parent, items) {
            for (var i = 0; i < items.length; i++) {
                var itemSchema = items[i];
                var $item = buildItem(itemSchema);
                if ($item !== false) {

                    if (itemSchema.type !== "component" && $item[0].$$attrsHandled !== true) {

                        angular.forEach(itemSchema, function (value, key) {

                            var attrValue = angular.copy(value);

                            if (key.indexOf("$") === 0) return; // invalid to have attributes which start with $

                            if (key === "expressions" && angular.isObject(attrValue)) {

                                $item[0].setAttribute("md-expressions", JSON.stringify(attrValue));
                                return;
                            }

                            var invalidKeys = ["_auto_id_", "content", "filename", "attributes"];
                            if (invalidKeys.indexOf(key) === -1) {

                                // need to prefix validator names to prevent conflicts with internal angular validator names
                                // (e.g., "required" => "custom_required")
                                if (key === "validators" && angular.isArray(attrValue)) {
                                    angular.forEach(attrValue, function (validator) {
                                        validator.name = "custom_" + validator.name;
                                    });
                                }

                                if (angular.isObject(attrValue) || angular.isArray(attrValue)) {

                                    attrValue = JSON.stringify(attrValue);
                                }

                                $item[0].setAttribute(key, attrValue);
                            }
                        });
                    }

                    if (angular.isArray(itemSchema.content)) {

                        $item = buildItems($item, itemSchema.content);
                    }

                    $parent.append($item);
                }
            }
            return $parent;
        }

        function isBuiltApp() {

            return !isPreview() && !isLivePreview();
        }

        function isPreview() {

            return _schema.hostContext === SchemaHelper.SCHEMA_CONTEXT_PREVIEW;
        }

        function isLivePreview() {

            return _schema.hostContext === SchemaHelper.SCHEMA_CONTEXT_LIVE_PREVIEW;
        }

        function getAppData() {
            var data = {};
            angular.forEach(_schema, function (value, key) {
                if (["pages", "translation"].indexOf(key) === -1) {
                    data[key] = value;
                }
            });
            return data;
        }

        function findItemById(id) {

            // eslint-disable-next-line quotes
            var jsonPath = "//*[" + ITEM_AUTO_ID_PROPERTY + "='" + id + "']";
            var matches = JSON.search(_schema, jsonPath);
            if (matches.length === 0) {
                return null;
            }

            return matches[0];
        }

        function getItems(collection, type, itemType) {

            return SchemaHelper.getItems(collection, type, itemType);
        }

        function hashSchema(schema) {
            var _schemaCopy = angular.copy(schema);
            var hashableKeys = ["id", "version", "icon", "splash", "splashdata", "settings", "language", "metadata", "name", "packageId", "schemaVersion", "pages", "actionflows", "dataflows", "config", "components"];
            var _hashableSchema = {};
            angular.forEach(hashableKeys, function (key) {
                _hashableSchema[key] = _schemaCopy[key];
            });
            try {
                var hash = window.KJUR.crypto.Util.sha256(JSON.stringify(_hashableSchema));
            } catch (e) {
                $log.error(e);
            }
            return hash;
        }

        /**
         * Helper method which wraps HTTP requests which need to be authenticated - will automatically get a new access_token with the refresh_token if the access_token has expired.
         * @param config
         * @param retries
         * @returns {*|promise}
         */
        function authenticatedRequest(config, retries) {
            var deferred = $q.defer();
            retries = (retries === undefined) ? 0 : retries;

            var _doRequest = function (accessToken) {

                if (accessToken !== null) {
                    if (config.headers === undefined) {
                        config.headers = {};
                    }
                    config.headers.Authorization = "Bearer " + accessToken;
                }

                $http(config).then(function (response) {
                    deferred.resolve(response);
                }).catch(function (error) {
                    if (error.status === 401) {
                        var _errMsg = "401 - Could not authenticate request.";
                        if (retries < 1) {
                            refresh().then(function () {
                                authenticatedRequest(config, ++retries).then(function (response) {
                                    deferred.resolve(response);
                                }).catch(function (error) {
                                    deferred.reject(error);
                                });
                            }).catch(function (error) {
                                var err = error || _errMsg;
                                $log.error(err);
                                deferred.reject(err);
                            });
                        } else {
                            $log.error(_errMsg);
                            deferred.reject(_errMsg);
                        }
                    } else {
                        $log.error(error);
                        deferred.reject(error);
                    }

                });
            };

            StoreFactory.getSetting("access_token").then(function (accessToken) {
                _doRequest(accessToken);
            }).catch(function () {
                _doRequest(null);
            });

            return deferred.promise;
        }

        function _initPhoneHome() {
            StoreFactory.getSetting(_jwtKey).then(function (jwt) {
                var data = _decodeJwt(jwt);
                if (data !== false) {
                    // Configure the phone home based on frequency
                    if (data.frequency !== _phoneHomeFrequency) {
                        _phoneHomeFrequency = data.frequency;
                        if (_phoneHomeInterval !== null) {
                            $interval.cancel(_phoneHomeInterval);
                        }
                        _phoneHomeInterval = $interval(_phoneHome, _phoneHomeFrequency || 3600000);
                    }
                }
            });
        }

        /**
         * Phone Home method which gets an updated licence from the server, if it can't it validates the local licence.
         * @returns {*|promise}
         * @private
         */
        function _phoneHome() {

            var deferred = $q.defer();
            StoreFactory.getSetting(_jwtKey).then(function (jwt) {

                var _makeRequest = function () {
                    var requestDeferred = $q.defer();
                    var data = _decodeJwt(jwt);
                    // Don't phone home if we are using a preview licence
                    if (data.type !== "preview") {
                        authenticatedRequest({
                            "url": L_ENDPOINT + "/activate",
                            "data": {
                                "code": _appCode,
                                "jwt": jwt
                            },
                            "method": "POST"
                        }).then(function (response) {
                            StoreFactory.setSetting(_jwtKey, response.data).then(function () {
                                // Re-validate and configure phone home
                                requestDeferred.resolve(response.data);
                            });
                        }).catch(function () {
                            // Unable to phone home so lets check the local licence hasn't expired
                            requestDeferred.resolve(jwt);
                        });
                    } else {
                        requestDeferred.resolve(jwt);
                    }
                    return requestDeferred.promise;
                };

                var _complete = function () {
                    _makeRequest().then(function (jwtToValidate) {
                        vjs(jwtToValidate, _originalSchema).then(function () {
                            _initPhoneHome();
                            deferred.resolve();
                        }).catch(deferred.reject);
                    }).catch(deferred.reject);
                };

                // See if we already have an app_code, if not generate one
                if (_appCode === null) {
                    // There isn't one in memory, have we stored one?
                    StoreFactory.getSetting(_appCodeKey).then(function (result) {
                        // Yep, load it in memory and continue
                        _appCode = result;
                        _complete();
                    }).catch(function () {
                        // Nope, this must be the first time so generate one stash it in memory and in the database
                        _appCode = Utilities.uuid();
                        StoreFactory.setSetting(_appCodeKey, _appCode).then(function () {
                            // Make the request
                            _complete();
                        }).catch(deferred.reject);
                    });
                } else {
                    _complete();
                }
            }).catch(function () {
                deferred.resolve("JWT not found.");
            });

            return deferred.promise;
        }

        /**
         * Refresh method which uses the refresh_token to request a new access_token
         * @returns {*|promise}
         */
        function refresh() {

            var deferred = $q.defer();

            StoreFactory.getSetting(_jwtKey).then(function (jwt) {
                var data = _decodeJwt(jwt);
                if (data !== false) {
                    $http({
                        "url": ID_ENDPOINT + "/token",
                        "headers": {
                            "Authorization": "Basic " + btoa(data.client_id + ":" + data.client_secret)
                        },
                        "data": {
                            "refresh_token": data.refresh_token,
                            "grant_type": "refresh_token"
                        },
                        "method": "POST"
                    }).then(function (response) {
                        if (response.data !== undefined && response.data.access_token !== undefined) {
                            // Take the access token and stash it in the database
                            StoreFactory.setSetting("access_token", response.data.access_token).then(function () {
                                deferred.resolve();
                            }).catch(function (error) {
                                deferred.reject(error);
                            });
                        } else {
                            deferred.reject("Couldn't get new token from server.");
                        }
                    }).catch(function (error) {
                        deferred.reject(error);
                    });
                } else {
                    deferred.reject("Couldn't decode JWT.");
                }
            });

            return deferred.promise;
        }

        return {
            "getPages": function () {
                return _schema.pages;
            },
            "buildItems": buildItems,
            "stop": stop,
            "getDom": getDom,
            "buildDom": buildDom,
            "getPageSchema": getPageSchema,
            "isBuiltApp": isBuiltApp,
            "isPreview": isPreview,
            "isLivePreview": isLivePreview,
            "getAppData": getAppData,
            "getAnimationLevel": getAnimationLevel,
            "findItemById": findItemById,
            "getItems": getItems,
            "ITEM_AUTO_ID_PROPERTY": ITEM_AUTO_ID_PROPERTY,
            "hashSchema": hashSchema,
            "setUpPreferences": setUpPreferences
        };
    }]);

angular
    .module("app.core")
    .factory("ComponentFactory", ["$rootScope", "$interpolate", "$injector", "$timeout", "SchemaHelper", "AssetFactory", function ($rootScope, $interpolate, $injector, $timeout, SchemaHelper, AssetFactory) {
        
        var _componentRegistrations = [];
        
        function registerComponentInstances(schema) {
            
            angular.forEach(schema.pages, function (page) {
                
                _generateComponentInstancesRecursive(schema, page, page.content);
            });
        }
        
        function getComponentById(id) {
            
            return getComponentByPredicate(function (x) {
                return x.id === id;
            });
        }
        
        function getComponentByPredicate(predicate) {
            
            if (typeof (predicate) !== "function") return null;
            
            var component = _componentRegistrations.filter(predicate)[0];
            
            return component || null;
        }
        
        function replaceComponentExpressions(expression) {
            
            if (expression.indexOf("$component") === -1) return expression;
            
            // expect expression to be in format "$component.pages.<pageName>.<componentName>.$<variableType>.<variableName>"
            var componentExpressionRegex = new RegExp("\\$component\\.pages\\.\\w+\\.\\w+\\.\\$\\w+\\.[\\w-]+", "g");
            
            if (!componentExpressionRegex.test(expression)) return expression;
            
            return expression.replace(componentExpressionRegex, function (componentExpression) {
                
                var partsRegex = new RegExp("\\$component\\.pages\\.(\\w+)\\.(\\w+)\\.\\$(\\w+)\\.([\\w-]+)");
                var parts = componentExpression.match(partsRegex);
                var pageName = parts[1];
                var componentName = parts[2];
                var variableType = parts[3];
                var variableName = parts[4];
                
                // find the registered component by its page name and name
                var componentRegistration = getComponentByPredicate(function (x) {
                    return x.page === pageName && x.name === componentName;
                });
                if (!componentRegistration) return expression;
                
                var expressionReplacement = "";
                switch (variableType) {
                    
                    case "attribute":
                        
                        // attributes use the "getAttribute()" function of the component element
                        var attributeValue = componentRegistration.element.getAttribute(variableName);
                        if (typeof (attributeValue) === "string") {
                            attributeValue = JSON.stringify(attributeValue);
                        }
                        expressionReplacement = attributeValue;
                        break;
                    
                    case "property":
                        
                        var modelProperty = componentRegistration.modelProperties.filter(function (x) {
                            return x.name === variableName;
                        })[0];
                        
                        // for properties, see if it is a "getter" property stored in the model
                        if (modelProperty && modelProperty.getter === true) {
                            
                            // if it is, replace the expression with the store expression in the format "$store.pages.<pageName>.<componentName>.<propertyName>"
                            expressionReplacement = "$store.pages." + pageName + "." + componentName + "." + variableName;
                            
                        } else {
                            
                            // if not, use the "property" notation of the component element
                            var propertyValue = componentRegistration.element[variableName];
                            if (typeof (propertyValue) === "string") {
                                propertyValue = JSON.stringify(propertyValue);
                            }
                            expressionReplacement = propertyValue;
                        }
                        break;
                }
                
                return expressionReplacement;
            });
        }
        
        function setAttributeValueFromAction(componentRegistration, attributeName, attributeValue) {
            
            if (!componentRegistration.explicitlySetAttributes) {
                componentRegistration.explicitlySetAttributes = [];
            }
    
            componentRegistration.explicitlySetAttributes.push(attributeName);
    
            componentRegistration.element.setAttribute(attributeName, attributeValue);
            $rootScope.$broadcast("StoreChanged");
        }
        
        function setPropertyValueFromAction(componentRegistration, valueType, propertyName, propertyValue) {
    
            componentRegistration.element[propertyName] = getTypedValue(valueType, propertyValue);
            $rootScope.$broadcast("StoreChanged");
        }
        
        function setUpComponentAttributes(componentRegistration, componentElement, contextualData, isFirstSet) {
            
            if (componentRegistration.attributes) {
                
                angular.forEach(componentRegistration.attributes, function (attribute, key) {
            
                    if (componentRegistration.explicitlySetAttributes && componentRegistration.explicitlySetAttributes.indexOf(key) !== -1) {
                        
                        // do not set attribute if it has already been explicitly set by an action
                        return;
                    }
                    
                    var matchedAttribute = (componentRegistration.component.annotations.attributes || []).filter(function (x) {
                        return x.name === key;
                    })[0];
            
                    if (matchedAttribute) {
                
                        var isModelBound = false;
                        
                        if (angular.isObject(attribute)) {
                            attribute = JSON.stringify(attribute);
                        }
                        
                        if (angular.isString(attribute) && attribute.indexOf("{{") !== -1) {
                            
                            var model = {
                                "$store": window.cti.store
                            };
                            if (contextualData) {
                                angular.extend(model, contextualData);
                            }
    
                            isModelBound = true;
                            attribute = $interpolate(attribute)(model);
                        }
    
                        if (isFirstSet || isModelBound) {
                            
                            componentElement.setAttribute(key, attribute);
                        }
                    }
                });
            }
        }
        
        function setUpComponentBindings(componentRegistration, scope) {
            
            var StoreFactory = $injector.get("StoreFactory"); // inject here to prevent circular dependencies
            
            angular.forEach(componentRegistration.modelProperties, function (prop) {
                
                prop.storeKey = "pages." + componentRegistration.page + "." + componentRegistration.name + "." + prop.name;
                
                var currentValue = StoreFactory.get(prop.storeKey);
                if (currentValue === undefined) {
                    StoreFactory.set(prop.storeKey, undefined);
                }
                
                prop.updateStore = function () {
                    
                    var elementValue = componentRegistration.element[prop.name];
                    var storeValue = StoreFactory.get(prop.storeKey);
                    if (elementValue !== storeValue) {
                        StoreFactory.set(prop.storeKey, elementValue);
                    }
                };
                
                prop.updateElement = function () {
                    
                    if (!prop.getter) {
                        
                        // if we cannot get the current element value to test for difference, just set the new value
                        componentRegistration.element[prop.name] = StoreFactory.get(prop.storeKey);
                        
                    } else {
                        
                        // if we can get the current element value, test for difference before setting the value
                        var elementValue = componentRegistration.element[prop.name];
                        var storeValue = StoreFactory.get(prop.storeKey);
                        if (elementValue !== storeValue) {
                            componentRegistration.element[prop.name] = storeValue;
                        }
                    }
                };
                
                if (prop.setter === true) {
                    
                    scope.$watch(function () {
                        return StoreFactory.get(prop.storeKey);
                    }, function () {
                        $timeout(function () {
                            prop.updateElement();
                        });
                    });
                    
                    prop.updateElement();
                }
                
                if (prop.getter === true) {
                    
                    angular.forEach(prop.changeEvents, function (eventName) {
                        componentRegistration.element.addEventListener(eventName, function () {
                            $timeout(function () {
                                prop.updateStore();
                            });
                        });
                    });
                }
            });
        }
        
        function getTypedValue(dataType, value) {
            
            if (value === null || value === undefined) return value;
            
            switch ((dataType || "").toLowerCase()) {
                
                case "bool":
                case "boolean":
                    return ((value || "").toLowerCase() === "true");
                
                case "number":
                    return parseFloat(value || "0");
                
                case "integer":
                    return parseInt(value || "0", 10);
                
                default:
                    return value.toString();
            }
        }
        
        // === Private functions === //
        
        function _generateComponentInstancesRecursive(schema, page, collection) {
            
            angular.forEach(collection, function (item) {
                
                if (item.type === "component") {
                    
                    var componentInstance = item;
                    var component = schema.components.filter(function (x) {
                        return x[SchemaHelper.ITEM_AUTO_ID_PROPERTY] === componentInstance.componentId;
                    })[0];
                    
                    var componentElement = null;
                    var modelProperties = [];
                    
                    if (component && component.valid) {
                        
                        componentElement = angular.element("<" + component.tagName + " id=\"" + componentInstance.name + "\"></" + component.tagName + ">");
                        
                        var parsedContent = componentInstance.content;
                        if (angular.isString(parsedContent)) {
                            
                            parsedContent = AssetFactory.rewriteAssetPaths(parsedContent);
                            componentElement.append(parsedContent);
                        }
                        
                        if (componentInstance.expressions && Object.keys(componentInstance.expressions).length > 0) {
                            
                            // components only support the "show" expression
                            if (componentInstance.expressions && componentInstance.expressions.show) {
                                
                                function processExpression() {
                                    
                                    var expressionResult = $injector.get("StoreFactory").evaluate(componentInstance.expressions.show);
                                    if (expressionResult === true) {
                                        componentElement[0].classList.remove("ng-hide");
                                    } else {
                                        componentElement[0].classList.add("ng-hide");
                                    }
                                }
                                processExpression();
                                $rootScope.$on("StoreChanged", function () {
                                    processExpression();
                                });
                            }
                        }
                        
                        if (component.annotations.events && componentInstance.actions) {
                            
                            var validActions = componentInstance.actions.filter(function (x) {
                                var matchedEvent = component.annotations.events.filter(function (y) {
                                    return y.name === x.event;
                                })[0];
                                return (!!matchedEvent);
                            });
                            
                            angular.forEach(component.annotations.events, function (event) {
                                componentElement.bind(event.name, function ($event) {
                                    var eventData = {
                                        type: $event.type,
                                        target: $event.target,
                                        detail: $event.detail
                                    };
                                    $injector.get("ActionFactory").triggerEvent(event.name, validActions, eventData, $event);
                                });
                            });
                        }
                        
                        modelProperties = _getComponentModelProprties(component);
                        
                    } else {
                        
                        componentElement = angular.element("<div style=\"color: red; border: 1px solid red; padding: 10px; margin: 10px 0;\">Invalid component \"" + component.name + "\". Please edit this component for further details.</div>");
                    }
                    
                    var componentInstanceId = componentInstance[SchemaHelper.ITEM_AUTO_ID_PROPERTY];
                    var componentRegistration = {
                        page: page.name,
                        name: componentInstance.name,
                        id: componentInstanceId,
                        component: component,
                        element: componentElement[0],
                        attributes: componentInstance.attributes,
                        modelProperties: modelProperties
                    };
                    
                    _componentRegistrations.push(componentRegistration);
                    
                    if (angular.isArray(item.content)) {
                        
                        _generateComponentInstancesRecursive(schema, page, item.content);
                    }
                    
                } else if (angular.isArray(item.content)) {
                    
                    _generateComponentInstancesRecursive(schema, page, item.content);
                }
            });
        }
        
        function _getComponentModelProprties(component) {
            
            var propertyConfigs = [];
            
            // property model configs found in component annotations
            if (component.annotations && angular.isArray(component.annotations.properties)) {
                
                propertyConfigs = propertyConfigs.concat(component.annotations.properties
                    .map(function (x) {
                        return {
                            property: x,
                            config: x.modelConfig
                        };
                    }));
            }
            
            // property model configs found in user configuration
            if (component.userConfig && component.userConfig.properties) {
                
                var properties = component.userConfig.properties;
                for (var propertyName in properties) {
                    
                    if (properties.hasOwnProperty(propertyName) && properties[propertyName].modelConfig) {
                        
                        var matchedProperty = component.annotations.properties.filter(function (x) {
                            return x.name === propertyName;
                        })[0];
                        
                        if (matchedProperty) {
                            propertyConfigs.push({
                                property: matchedProperty,
                                config: properties[propertyName].modelConfig
                            });
                        }
                    }
                }
            }
            
            var modelProperties = [];
            var propertyConfigsToStore = propertyConfigs.filter(function (x) {
                return x.config.store === true;
            });
            
            angular.forEach(propertyConfigsToStore, function (propertyConfig) {
                
                modelProperties.push({
                    name: propertyConfig.property.name,
                    getter: propertyConfig.property.getter,
                    setter: propertyConfig.property.setter,
                    changeEvents: propertyConfig.config.changeEvents
                });
            });
            
            return modelProperties;
        }
        
        return {
            "registerComponentInstances": registerComponentInstances,
            "getComponentById": getComponentById,
            "getComponentByPredicate": getComponentByPredicate,
            "replaceComponentExpressions": replaceComponentExpressions,
            "setAttributeValueFromAction": setAttributeValueFromAction,
            "setPropertyValueFromAction": setPropertyValueFromAction,
            "setUpComponentAttributes": setUpComponentAttributes,
            "setUpComponentBindings": setUpComponentBindings,
            "getTypedValue": getTypedValue,
            
            // for unit testing purposes only...
            "___getComponentRegistrations": function () {
                return _componentRegistrations;
            },
            "___setComponentRegistrations": function (val) {
                _componentRegistrations = val;
            }
        };
    }]);
angular
    .module("app.core")
    .factory("ValidationFactory", ["$log", "StoreFactory", function ($log, StoreFactory) {

        return {

            isValid: function (value, validation, pageName, questionName) {

                var result = true;

                switch (validation.type) {

                    case "regex":
                        if (value) {
                            var regex = new RegExp(validation.content);
                            result = regex.test(value);
                        }
                        break;

                    case "expression":
                        if (!value) return true;

                        var expression = angular.copy(validation.content);
                        if (typeof (value) === "string") {
                            value = JSON.stringify(value);
                        }

                        var valueStoreExpression = "$store.pages." + pageName + "." + questionName;
                        if (expression.indexOf(valueStoreExpression) !== -1) {

                            var regexSafeExpression = valueStoreExpression.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
                            expression = expression.replace(new RegExp(regexSafeExpression, "g"), value);
                        }

                        var otherExpressions = expression.match(/(\$store\.pages\.\w*\.\w*)/g);
                        angular.forEach(otherExpressions, function (otherExpression) {

                            var storeValue = StoreFactory.evaluate(otherExpression);
                            if (typeof (storeValue) === "string") {
                                storeValue = JSON.stringify(storeValue);
                            }
                            expression = expression.replace(otherExpression, storeValue);
                        });

                        result = StoreFactory.evaluate(expression);
                        break;

                    default:
                        $log.error("Invalid validation type specified.");
                }
                return result;
            }
        };
    }]);
angular
    .module("app.core")
    .factory("TranslationService", ["$rootScope", "$q", "$timeout", "$window", "$filter", "$locale", "$log", "Plugin", "Platform", "SchemaHelper", "StoreFactory", "tmhDynamicLocale", "gettextCatalog", "nyaBsConfig", function ($rootScope, $q, $timeout, $window, $filter, $locale, $log, Plugin, Platform, SchemaHelper, StoreFactory, tmhDynamicLocale, gettextCatalog, nyaBsConfig) {

        var STORE_LANGUAGE_KEY = "currentLanguageCode";
        var TEMPORARY_LANGUAGE_CHANGE_KEY = "newLanguageCode";

        var _isDebugMode = false;

        /**
         * Initialise the translation service
         * @returns {Promise} - A promise to resolve when the translation service is initialised
         */
        function init() {

            var debugData = sessionStorage.getItem("debug");
            if (debugData) {
                var items = debugData.split("|");
                _isDebugMode = ((items.indexOf("*") !== -1) || (items.indexOf("translations") !== -1));
            }

            var deferred = $q.defer();

            var languageSettings = SchemaHelper.getLanguageSettings();
            var initialLanguage = languageSettings.initialLanguage;
            var defaultLocale = languageSettings.defaultLocale;
            var useDeviceLocale = languageSettings.useDeviceLocale;

            gettextCatalog.debug = _isDebugMode;
            gettextCatalog.baseLanguage = defaultLocale;

            tmhDynamicLocale.setLocaleLocationPattern($rootScope.basedir + "assets/i18n/angular-locale_{{ locale }}.js");

            var isFirstLaunch = false;
            var languageCode = sessionStorage.getItem(TEMPORARY_LANGUAGE_CHANGE_KEY);
            if (languageCode === null) {

                var storedLanguage = StoreFactory.get(STORE_LANGUAGE_KEY);
                if (storedLanguage === undefined || storedLanguage === null) {
                    isFirstLaunch = true;
                }
                languageCode = storedLanguage || initialLanguage;
            } else {
                sessionStorage.removeItem(TEMPORARY_LANGUAGE_CHANGE_KEY);
            }

            determineLanguageCode(useDeviceLocale, isFirstLaunch, languageCode, initialLanguage, defaultLocale)
                .then(function (languageCode) {

                    // Persist current language code for next visit
                    StoreFactory.set(STORE_LANGUAGE_KEY, languageCode);

                    // load language file
                    loadLanguageFile(languageCode, defaultLocale)
                        .then(function (languageCode) {
                            return setAngularLocale(languageCode, defaultLocale);
                        })
                        .then(function (languageCode) {
                            return translate3rdParties(languageCode);
                        })
                        .then(function (languageCode) {
                            $rootScope.currentLanguage = languageCode;
                            deferred.resolve();
                        });
                });

            return deferred.promise;
        }

        /**
         * Set the current language
         * @param {string} languageCode - The language code to set (will default to default language if blank)
         */
        function setLanguage(languageCode) {

            if (languageCode === undefined) {
                languageCode = "";
            }

            var currentLanguage = StoreFactory.get(STORE_LANGUAGE_KEY);
            if (currentLanguage === languageCode) {
                return; // No change, do nothing
            }

            // Set language code temporarily to pick up and action after reload of UI
            sessionStorage.setItem(TEMPORARY_LANGUAGE_CHANGE_KEY, languageCode);

            // Reload window which will bootstrap with selected language and locale
            $window.location.reload();
        }

        /**
         * Return the translated format of the supplied text or array of texts
         * @param {string|Array<string>} str - the input text or array of texts
         * @returns {string|Array<string>} - The translated text or array of translated texts
         */
        function translate(str) {

            if (str instanceof Array) {
                return str.map(function (x) {
                    return $filter("translate")(x);
                });
            } else if (typeof (str) === "string") {
                return $filter("translate")(str);
            } else {
                return str;
            }
        }

        function determineLanguageCode(useDeviceLocale, isFirstLaunch, storedLanguageCode, initialLanguage, defaultLocale) {

            var deferred = $q.defer();

            if (!useDeviceLocale) {

                // if we have an explicit language code, use that
                debug("Bypassing device locale; returning stored language: \"" + storedLanguageCode + "\"");
                deferred.resolve(storedLanguageCode);

            } else if (!isFirstLaunch) {

                // if we have an explicit language code, use that
                debug("Language code already established: \"" + storedLanguageCode + "\"");
                deferred.resolve(storedLanguageCode);

            } else {

                if (Platform.getType() === "desktop") {

                    debug("Obtained desktop language: \"" + navigator.language + "\"");

                    var navigatorLanguage = dashToUnderscore(navigator.language);
                    var reconciledLanguage = reconcileToAvailableLanguage(navigatorLanguage, initialLanguage);

                    debug("Resolved desktop language to: \"" + reconciledLanguage + "\"");

                    deferred.resolve(reconciledLanguage);

                } else {

                    var plugin = Plugin.getSource("globalization");
                    if (plugin && typeof (plugin.getPreferredLanguage) === "function") {

                        plugin.getPreferredLanguage(function (language) {

                            debug("Obtained device language: \"" + language.value + "\"");

                            var deviceLanguage = dashToUnderscore(language.value);
                            var reconciledLanguage = reconcileToAvailableLanguage(deviceLanguage, initialLanguage);

                            debug("Resolved device language to: \"" + reconciledLanguage + "\"");

                            deferred.resolve(reconciledLanguage);

                        }, function () {

                            deferred.resolve(storedLanguageCode);
                        });

                    } else {

                        deferred.resolve(storedLanguageCode);
                    }
                }
            }

            function dashToUnderscore(str) {

                return str.replace(/-/g, "_").toLowerCase();
            }

            function reconcileToAvailableLanguage(languageCode, initialLanguage) {

                var languageCodeToTest = (languageCode || "").toLowerCase();
                if (!languageCodeToTest || languageCodeToTest === defaultLocale.toLowerCase()) {

                    return initialLanguage; // fall back to initial language
                }

                // obtained sorted array of locale ids in the app
                var languages = SchemaHelper.getSchemaConfigItemsByItemType("language");
                var localeIds = [];
                angular.forEach(languages, function (language) {
                    if (language.localeId) {
                        localeIds.push(language.localeId.toLowerCase());
                    }
                });
                localeIds.sort();

                debug("Available localeIds:", localeIds);

                // if language id is in this, return the language code
                if (localeIds.indexOf(languageCodeToTest) !== -1) {
                    return languageCode;
                }

                // otherwise, iterate over each locale id to see if there is a partial match based on language
                if (languageCodeToTest.indexOf("_") !== -1) {
                    languageCodeToTest = languageCodeToTest.substring(0, languageCodeToTest.indexOf("_"));
                }
                var returnLanguageCode = "";
                for (var i = 0; i < localeIds.length && !returnLanguageCode; i++) {
                    if (localeIds[i].indexOf(languageCodeToTest) === 0) {
                        returnLanguageCode = localeIds[i];
                    }
                }

                // will return either a language code which had a partial match, or the explicit initial language if one was not determined
                return returnLanguageCode || initialLanguage;
            }

            return deferred.promise;
        }

        function loadLanguageFile(languageCode, defaultLocale) {

            var deferred = $q.defer();

            if (!languageCode) {

                debug("Default language; skipping translation");
                gettextCatalog.setCurrentLanguage(defaultLocale);
                deferred.resolve("");

            } else if (languageCode.toLowerCase() === defaultLocale.toLowerCase()) {

                debug("Language code matches default locale; skipping translation");
                gettextCatalog.setCurrentLanguage(defaultLocale);
                deferred.resolve("");

            } else {

                var languages = SchemaHelper.getSchemaConfigItemsByItemType("language");
                var matchingLanguage = null;
                for (var i = 0; i < languages.length && matchingLanguage === null; i++) {
                    if (languages[i].localeId && (languages[i].localeId.toLowerCase() === languageCode.toLowerCase())) {
                        matchingLanguage = languages[i];
                    }
                }

                if (matchingLanguage === null) {

                    $log.error("Could not find language matching locale id \"" + languageCode + "\"; skipping translation");
                    gettextCatalog.setCurrentLanguage(defaultLocale);
                    deferred.resolve("");

                } else {

                    var translationFileLocation = $rootScope.assetDir + matchingLanguage.fileName;
                    debug("loading translation file \"" + translationFileLocation + "\"");
                    gettextCatalog
                        .loadRemote(translationFileLocation)
                        .then(function () {
                            debug("setting language to \"" + languageCode + "\"");
                            gettextCatalog.setCurrentLanguage(languageCode);
                            deferred.resolve(languageCode);
                        })
                        .catch(function () {
                            $log.error("Could not load translation file \"" + translationFileLocation + "\"; skipping translation");
                            gettextCatalog.setCurrentLanguage(defaultLocale);
                            deferred.resolve("");
                        });
                }
            }

            return deferred.promise;
        }

        function setAngularLocale(languageCode, defaultLocale) {

            var deferred = $q.defer();

            if (!languageCode) {
                languageCode = defaultLocale;
            }

            // angular i18n files use la-RN in their filename rather than la_RN, so convert all underscores to dashes
            var i18nLocaleCode = languageCode.replace(/_/g, "-").toLowerCase();
            debug("loading locale \"" + i18nLocaleCode + "\"");
            tmhDynamicLocale
                .set(i18nLocaleCode)
                .then(function () {
                    deferred.resolve(languageCode);
                })
                .catch(function () {

                    // Cannot load - revert to default
                    var defaultI18nLocaleCode = gettextCatalog.baseLanguage.replace(/_/g, "-").toLowerCase();

                    $log.error("Could not load locale file for locale \"" + i18nLocaleCode + "\"; Reverting to \"" + defaultI18nLocaleCode + "\"");

                    tmhDynamicLocale
                        .set(defaultI18nLocaleCode)
                        .then(function () {
                            deferred.resolve(gettextCatalog.baseLanguage);
                        });
                });

            return deferred.promise;
        }

        function translate3rdParties(languageCode) {

            var deferred = $q.defer();

            // nya-bs-select.js nya-bootstrap-select translations
            nyaBsConfig.defaultNoneSelection = translate(nyaBsConfig.defaultNoneSelection);
            nyaBsConfig.noSearchResult = translate(nyaBsConfig.noSearchResult);

            // pickadate.js date picker translations
            var pickadate = angular.element.prototype.pickadate;

            pickadate.defaults.monthsFull = $locale.DATETIME_FORMATS.STANDALONEMONTH;
            pickadate.defaults.monthsShort = $locale.DATETIME_FORMATS.SHORTMONTH;
            pickadate.defaults.weekdaysFull = $locale.DATETIME_FORMATS.DAY;
            pickadate.defaults.weekdaysShort = $locale.DATETIME_FORMATS.SHORTDAY;
            pickadate.defaults.today = translate(pickadate.defaults.today);
            pickadate.defaults.clear = translate(pickadate.defaults.clear);
            pickadate.defaults.close = translate(pickadate.defaults.close);

            // pickatime.js time picker translations
            var pickatime = angular.element.prototype.pickatime;

            pickatime.defaults.amSmall = $locale.DATETIME_FORMATS.AMPMS[0];
            pickatime.defaults.amLarge = $locale.DATETIME_FORMATS.AMPMS[0];
            pickatime.defaults.pmSmall = $locale.DATETIME_FORMATS.AMPMS[1];
            pickatime.defaults.pmLarge = $locale.DATETIME_FORMATS.AMPMS[1];

            pickatime.defaults.clear = translate(pickatime.defaults.clear);

            deferred.resolve(languageCode);

            return deferred.promise;
        }

        function debug() {

            if (_isDebugMode !== true) return;
            if (arguments === undefined) return;

            var params = Array.prototype.slice.call(arguments);
            if (params.length > 0 && typeof (params[0]) === "string") {
                params[0] = "[translation.fct.js] " + params[0];
            }
            $log.log.apply($log, params);
        }

        return {
            "init": init,
            "setLanguage": setLanguage,
            "translate": translate
        };

    }]);
angular.module("app.core").factory("StoreFactory", ["$rootScope", "$parse", "$interval", "$interpolate", "$log", "$q", "localStorageService", "StoreProvider", "$timeout", "$injector", "AssetFactory", "ComponentFactory", "Utilities", function ($rootScope, $parse, $interval, $interpolate, $log, $q, localStorageService, StoreProvider, $timeout, $injector, AssetFactory, ComponentFactory, Utilities) {

    var _id = null;
    window.cti.store = {
        "env": {},
        "language": "en_GB",
        "state": {},
        "api": {},
        "offlineApi": {},
        "azureAppServices": {},
        "xmpp": {},
        "messageQueues": {
            "listeningTo": []
        },
        "geofences": {},
        "plugin": {},
        "repeater": {},
        "schema": {},
        "media": {},
        "notification": {},
        "xcallback": {
            "success": "",
            "error": "",
            "cancel": "",
            "source": ""
        },
        "variables": {
            "today": new Date()
        },
        "pages": {}
    };

    var _original = angular.copy(window.cti.store);

    var db = null;
    var rev = null;

    var _settingsDbName = "infinity_app_settings_v3";
    var _settingsDb = null;

    var service = {
        "init": init,
        "evaluate": evaluate,
        "evaluateForElement": evaluateForElement,
        "parse": parse,
        "get": get,
        "getForElement": getForElement,
        "set": set,
        "setForElement": setForElement,
        "push": push,
        "remove": remove,
        "setFunction": setFunction,
        "parseUrl": parseUrl,
        "save": save,
        "destroyAllData": destroyAllData,
        "destroyPageData": destroyPageData,
        "merge": merge,
        "mergeInitialData": mergeInitialData,
        "getId": function () {
            return _id;
        },
        "initSettingsDb": initSettingsDb,
        "setSetting": setSetting,
        "getSetting": getSetting,
        "getEncryptionKey": getEncryptionKey
    };

    function get(key, additionalContext) {

        if (key.indexOf("$store.") === 0) {

            key = key.replace(/\$store./g, "");
        }

        return $parse(key)(window.cti.store, additionalContext);
    }

    function getForElement(key, $element) {

        var mdContextProviderCtrl = $element.controller("mdContextProvider");
        var additionalContext = mdContextProviderCtrl
            ? mdContextProviderCtrl.getContextItemData("$data")
            : null;

        return get(key, additionalContext);
    }

    function set(key, value, model, instantSave) {
        if (key.indexOf("$store.") === 0) {
            key = key.replace("$store.", "");
        }
        var getter = $parse(key);
        var setter = getter.assign;
        setter(model || window.cti.store, value);

        var saveDebounceDuration = instantSave
            ? 0
            : null;

        return save(saveDebounceDuration);
    }

    function setForElement(key, value, $element, instantSave) {

        var mdContextProviderCtrl = $element.controller("mdContextProvider");
        var additionalContext = mdContextProviderCtrl
            ? mdContextProviderCtrl.getContextItemData("$data")
            : null;

        return set(key, value, additionalContext, instantSave);
    }

    function push(key, item) {
        var current = $parse(key)(window.cti.store);
        if (current == undefined) {
            current = [];
        }
        current.push(item);
        set(key, current);
        save();
        return $parse(key)(window.cti.store);
    }

    function remove(key, index) {
        var current = $parse(key)(window.cti.store);
        if (current != undefined && current[index] != undefined) {
            current.splice(index, 1);
        }
        set(key, current);
        save();
    }

    function initSave() {
        var deferred = $q.defer();
        db.get(_id + "_data").then(function (result) {
            rev = result._rev;
            window.cti.store = merge(angular.copy(_original), result.data);
            if (StoreProvider.options.initialData !== undefined) {
                window.cti.store = merge(window.cti.store, StoreProvider.options.initialData);
            }
            deferred.resolve();
        }).catch(function () {
            db.put({
                _id: _id + "_data",
                data: angular.copy(_original)
            }).then(function (result) {
                if (StoreProvider.options.initialData !== undefined) {
                    window.cti.store = merge(window.cti.store, StoreProvider.options.initialData);
                }
                rev = result.rev;
                deferred.resolve();
            }).catch(function (error) {
                $log.error(error);
                deferred.reject(error);
            });
        });
        return deferred.promise;
    }

    function destroyAllData() {
        // Delete route stack
        if (_id !== null) {
            localStorageService.remove(_id + "_stack");
        }
        if (db !== null) {
            // Delete app data
            db.destroy().then(function () {
                // Success - reload
                window.location.reload();
            }).catch(function () {
                $log.error("Could not remove database.");
            });
        }
    }

    function destroyPageData(pageName) {
        // If a page has been specified then just destroy that pages data
        if (pageName !== undefined) {
            set("pages." + pageName, {});
        } else {
            set("pages", {});
        }
    }

    function init(appName, schema) {
        var deferred = $q.defer();
        _id = appName;
        db = new PouchDB(_id, {
            // eslint-disable-next-line camelcase
            revs_limit: 10
        });
        if (schema.settings !== undefined && schema.settings.encryption === true) {

            getEncryptionKey(appName).then(function (encryptionKey) {
                db.crypto({"key": encryptionKey});
                return $q.resolve();
            }).then(function () {
                return initSave();
            }).then(function () {
                set("schema", angular.copy(schema));
                deferred.resolve();
            }).catch(function (error) {
                deferred.reject(error);
            });
        } else {
            initSave().then(function () {
                set("schema", angular.copy(schema));
                deferred.resolve();
            }).catch(function (error) {
                deferred.reject(error);
            });
        }
        return deferred.promise;
    }
    /**
     * Creates or obtains the PouchDB instance for the secure, encrypted database
     * @returns {Promise} - Promise to resolve once database is initialized
     */
    function initSettingsDb() {

        var deferred = $q.defer();

        _settingsDb = new PouchDB(_settingsDbName, {
            // eslint-disable-next-line camelcase
            revs_limit: 10
        });

        getEncryptionKey(_settingsDbName).then(function (encryptionKey) {

            _settingsDb.crypto({"key": encryptionKey});
            return $q.resolve().then(function () {

                // eslint-disable-next-line camelcase
                _settingsDb.allDocs({include_docs: true}).then(function (result) {

                    if (result.total_rows === 0) {

                        // This is the first time so lets generate a studio ID
                        var instanceId = Utilities.uuid();

                        _settingsDb.put({ _id: "instance_id", data: instanceId}).then(function () {

                            deferred.resolve();

                        }).catch(function (err) {

                            $log.error(err);
                            deferred.reject(err);
                        });

                    } else {

                        deferred.resolve();
                    }

                }).catch(function (err) {
                    $log.error(err);
                    deferred.reject(err);
                });

            });

        }).catch(function (err) {

            deferred.reject(err);

        });

        return deferred.promise;
    }

    /**
     * Set value for a specific key in the settings database
     * @param {string} key - The key to set the data against
     * @param {object} value - The data
     * @returns {Promise} - Promise to resolve when data saved
     */
    function setSetting(key, value) {

        if (!key) throw new Error("key cannot be empty");

        var deferred = $q.defer();

        _settingsDb.get(key)

            .then(function (doc) {

                if (doc.data === JSON.stringify(value)) {

                    // data hasn't changed - no need to update
                    deferred.resolve();

                } else {

                    // data exists for key - update
                    doc.data = value;
                    _settingsDb.put(doc).then(function () {
                        deferred.resolve();
                    }).catch(function (err) {
                        $log.error(err);
                        deferred.reject(err);
                    });

                }

            })
            .catch(function (err) {

                if (err.status === 404) {

                    // data does not exist for key - add it
                    _settingsDb.put({ _id: key, data: value }).then(function () {
                        deferred.resolve();
                    }).catch(function (err) {
                        $log.error(err);
                        deferred.reject(err);
                    });

                    return;
                }

                $log.error(err);
                deferred.reject(err);
            });

        return deferred.promise;
    }

    /**
     * Get value for a specific key in the settings database
     * @param {string} key - The key of the data
     * @returns {Promise} - Promise to resolve when data saved
     */
    function getSetting(key) {

        if (!key) throw new Error("key cannot be empty");

        var deferred = $q.defer();

        _settingsDb.get(key).then(function (doc) {
            deferred.resolve(doc.data);
        }).catch(deferred.reject);

        return deferred.promise;
    }

    function evaluate(expression, additionalContext) {

        var $model = {
            "$store": window.cti.store
        };

        if (additionalContext && angular.isObject(additionalContext)) {

            $model = angular.extend($model, additionalContext);
        }

        if (typeof expression == "object") {
            angular.forEach(expression, function (val, key) {
                if (val != undefined && typeof val == "string" && val != "*") {
                    expression[key] = evaluateExpressionString(expression[key]);
                }
            });
        } else if (expression != undefined && expression != "*") {
            expression = evaluateExpressionString(expression);
        }

        function evaluateExpressionString(expressionStr) {

            if (expressionStr.indexOf("$component") !== -1) {
                expressionStr = ComponentFactory.replaceComponentExpressions(expressionStr);
            }
            return $rootScope.$eval(expressionStr, $model);
        }

        return expression;
    }

    function evaluateForElement(expression, $element) {

        var mdContextProviderCtrl = $element.controller("mdContextProvider");
        var additionalContext = mdContextProviderCtrl
            ? mdContextProviderCtrl.getContextItemData("$data")
            : null;

        return evaluate(expression, additionalContext);
    }

    function parse(expression, $model, fromJson) {

        if ($model === undefined) {
            $model = {};
        }

        if ($model.$store === undefined) {
            $model.$store = window.cti.store;
        }

        if (typeof expression == "object") {
            angular.forEach(expression, function (val, key) {
                if (typeof val == "string" && val.indexOf("{{") > -1) {
                    expression[key] = parse(expression[key], $model, fromJson);
                } else if (typeof val == "object" && angular.toJson(val).indexOf("{{") > -1) {
                    expression[key] = parse(expression[key], $model, fromJson);
                }
            });
        } else if (expression && expression !== "*") {

            if (expression.indexOf("$component") !== -1) {
                expression = ComponentFactory.replaceComponentExpressions(expression);
            }
            expression = $interpolate(expression)($model);
        }
        if (fromJson !== false) {
            try {
                return angular.fromJson(expression);
            } catch (e) {
                return expression;
            }
        } else {
            return expression;
        }
    }

    function parseUrl(url, params) {
        if (url.indexOf("{{") > -1) {
            url = parse(url);
        }
        if (params != undefined && Object.getOwnPropertyNames(params).length !== 0) {
            var paramsString = "?";
            angular.forEach(params, function (value, key) {
                if (paramsString != "?") {
                    paramsString += "&";
                }
                if (value.indexOf("{{") > -1) {
                    value = parse(value);
                }
                paramsString += (key + "=" + encodeURI(value));
            });
            url += paramsString;
        }
        return url;
    }

    function getCleanStore() {
        var store = angular.copy(window.cti.store);
        store.schema = undefined;
        return store;
    }

    var timeout = null;
    var saveDefer = null;

    function save(debounceDuration) {

        if (debounceDuration === undefined || debounceDuration === null) {
            debounceDuration = 250;
        }

        if (_id !== null && db !== null && rev !== null) {
            if (saveDefer === null) {
                saveDefer = $q.defer();
            }
            if (timeout !== null) {
                $timeout.cancel(timeout);
            }
            var _saveIt = function () {

                // If no then we have the latest revision so we can go ahead.
                $log.debug("SAVING AT REVISION:", rev);
                db.put({
                    _id: _id + "_data",
                    _rev: rev,
                    data: getCleanStore()
                }).then(function (result) {
                    rev = result.rev;

                    if (saveDefer !== null) {
                        saveDefer.resolve();
                        saveDefer = null;
                    }
                }).catch(function (error) {

                    // caught the Document update conflict issue, try again in ~250ms
                    if (error.status !== undefined && error.status == 409) {
                        $log.debug("Caught document update conflict", error);

                        $timeout(_saveIt, debounceDuration);
                    } else {
                        $log.error(error);

                        if (saveDefer !== null) {
                            saveDefer.reject(error);
                            saveDefer = null;
                        }
                    }
                });

            };

            timeout = $timeout(function () {
                _saveIt();
            }, debounceDuration);

            return saveDefer.promise;
        }
        return undefined;
    }

    function setFunction(funcObj) {
        if (funcObj.name != undefined && funcObj.content != undefined) {
            try {
                var params = [];
                if (funcObj.params != undefined && funcObj.params.length > 0) {
                    angular.forEach(funcObj.params, function (param) {
                        params.push(param.name);
                    });
                }

                // add $success $fail parameters which allow these to be called without the "this." prefix.
                params.push("$success");
                params.push("$fail");

                // add $store parameter to provide access to cti.store via $store
                params.push("$store");

                var fnContent = AssetFactory.rewriteAssetPaths(funcObj.content);
                window.cti[funcObj.name] = new Function(params, fnContent);
                window.cti[funcObj.name].prototype.sync = (funcObj.sync === true);
            } catch (error) {
                $log.info("Couldn not successfully eval function code (store.fct.js:148): ");
                $log.error(error);
            }
        }
    }

    function merge(obj1, obj2) {
        // For everything in object 2
        angular.forEach(obj2, function (value, key) {
            // We don"t want to do any more if its an $event
            if (key === "$event") {
                obj1.$event = value;
                // Put it on object 1
            } else {
                if (typeof value != "object" || value === null) {
                    obj1[key] = value;
                } else {
                    if (obj1[key] == undefined) {
                        if (Object.prototype.toString.call(obj2[key]) === "[object Array]") {
                            obj1[key] = [];
                        } else {
                            obj1[key] = {};
                        }
                    }
                    obj1[key] = merge(obj1[key], value);
                }
            }
        });
        return obj1;
    }

    function mergeInitialData(initialData) {
        window.cti.store = merge(window.cti.store, initialData);
        save();
    }

    function getEncryptionKey(appName) {

        var deferred = $q.defer();

        var pluginFactory = $injector.get("Plugin"); // dynamically injected to prevent circular dependency
        var plugin = pluginFactory.getSource("securesettings");
        if (plugin) {

            plugin.getOrCreateCryptographicKey(function (key) {
                function hexToBytes(hex) {
                    var bytes = [];
                    for (var c = 0; c < hex.length; c += 2) {
                        bytes.push(parseInt(hex.substr(c, 2), 16));
                    }
                    return bytes;
                }
                var keyBuffer = window.Buffer.from(hexToBytes(key));
                deferred.resolve(keyBuffer);
            }, deferred.reject, appName, 256);

        } else {
            var keyBuffer;
            var storedKey = localStorage.getItem(appName+"_key");
            if (storedKey !== null) {
                keyBuffer = window.Buffer.from(JSON.parse(storedKey));
                deferred.resolve(keyBuffer);
            } else {
                var arr = [], i;
                if (window.crypto && window.crypto.getRandomValues) {
                    var arr8 = new Uint8Array(32);
                    window.crypto.getRandomValues(arr8);
                    for (i = 0; i < 32; i++) {
                        arr[i] = arr8[i];
                    }
                } else {
                    for (i = 0; i < 32; i++) {
                        arr[i] = Math.floor(Math.random() * 256);
                    }
                }
                localStorage.setItem(appName + "_key", JSON.stringify(arr));
                keyBuffer = window.Buffer.from(arr);
                deferred.resolve(keyBuffer);
            }

            // fallback for devices not implementing secure settings plugin
            // deferred.resolve("1x28ucKW25UFbvZb10f/dN1ZjnOyPCWufYVDQnC8Ji7WabM9pRo6PkwjgRhaqDmFb20+TBCc/W0H8PsV0cfo1+8WIHz81joB");
        }

        return deferred.promise;
    }

    // Had to revert to using a watch here otherwise when a developer adds variables and other data to the module without using the set method provided the rest of the app wouldn"t know of the update
    $rootScope.$watch(function () {
        return window.cti.store;
    }, function (newVal, oldVal) {
        if (newVal != oldVal) {
            save();
            $rootScope.$broadcast("StoreChanged");
            document.dispatchEvent(new CustomEvent("StoreChanged"));
        }
    }, true);

    var update = function () {
        if (!$rootScope.$$phase) {
            $rootScope.$apply();
        }
    };
    document.addEventListener("StoreHasChanged", update);
    $rootScope.$on("StoreHasChanged", update);
    document.addEventListener("SaveToStore", function (event) {
        var key = event.detail.key;
        var data = event.detail.data;
        if (key !== undefined) {
            set(key, data);
        }
    });

    return service;

}]).filter("store", ["StoreFactory", "$filter", function (StoreFactory, $filter) {
    // eslint-disable-next-line consistent-return
    var store = function (key, filterText) {
        if (key != undefined) {
            var res = StoreFactory.evaluate(key);
            if (angular.isArray(res) && filterText != undefined) {
                res = $filter("filter")(res, filterText);
            }
            return res;
        }
    };
    store.$stateful = true;
    return store;
}]).filter("trust", ["$sce", function ($sce) {
    var store = function (value) {
        return $sce.trustAsHtml(value);
    };
    store.$stateful = true;
    return store;
}]);

angular.module("app.core").provider("StoreProvider", function () {
    this.options = {};
    this.set = function (option, value) {
        switch (option) {
            case "initialData":
                this.options.initialData = value;
                break;
        }
    };
    var self = this;
    this.$get = function () {
        return {
            options: self.options,
            set: self.set
        };
    };
});
angular.module("app.core").factory("Plugin", ["$http", "$log", "$q", "StoreFactory", "$interval", "electron", function ($http, $log, $q, StoreFactory, $interval, electron) {

    function Plugin(name, events, polls, operations) {
        this.name = name;
        this.events = [];
        this.polls = [];
        this.operations = operations;
        if (events != undefined) {
            this.events = events;
            if (this.events.length > 0) {
                var plugin = this;
                angular.forEach(this.events, function (event) {
                    window.addEventListener(event.name, function (data) {
                        StoreFactory.set("plugin." + plugin.name + "." + event.name, data);
                    });
                });
            }
        }
        if (polls != undefined) {
            this.polls = polls;
            if (this.polls.length > 0) {
                var _plugin = this;
                angular.forEach(this.polls, function (poll) {
                    $interval(function () {
                        _plugin.callAction(poll.action, poll.params, poll.options);
                    }, poll.interval);
                });
            }
        }
    }

    Plugin.prototype = {
        callAction: function (name, params) {
            var $scope = this;
            var deferred = $q.defer();
            var opParams = [];
            // Get any default params from the requested operation
            angular.forEach(this.operations, function (operation) {
                if (operation.name == name && operation.params != undefined) {
                    opParams = angular.copy(operation.params);
                }
            });
            var successCallback = function (data) {
                StoreFactory.set("plugin." + $scope.name + "." + name, data);
                deferred.resolve(data);
            };
            var errorCallback = function (data) {
                $log.error(data);
                deferred.reject(data);
            };
            // Convert params object to array, stripping out the name and convert any callback params to the appropriate callback function
            var nParams = [];
            angular.forEach(opParams, function (param) {
                var value = null;
                switch (param.name) {
                    case "$successCallback":
                        value = successCallback;
                        break;
                    case "$errorCallback":
                        value = errorCallback;
                        break;
                    default:
                        value = (params[param.name] != undefined) ? params[param.name] : param.default;
                }
                if (value !== null) {
                    nParams.push(value);
                }
            });
            var source = Plugin.getSource(this.name);
            // Is the plugin and method available?
            if (source !== false && source[name] != undefined) {
                try {
                    source[name].apply(null, nParams);
                } catch (error) {
                    deferred.reject(error);
                    $log.error(error);
                }
            } else {
                deferred.reject("Could not call action");
            }
            return deferred.promise;
        }
    };

    Plugin.getSource = function (pluginName) {
        if (window[pluginName] !== undefined) {
            return window[pluginName];
        } else if (window.cordova !== undefined && cordova[pluginName] !== undefined) {
            return cordova[pluginName];
        } else if (window.cordova !== undefined && cordova.plugins !== undefined && cordova.plugins[pluginName] !== undefined) {
            return cordova.plugins[pluginName];
        } else if (window.plugins !== undefined && window.plugins[pluginName] !== undefined) {
            return window.plugins[pluginName];
        } else if (navigator !== undefined && navigator[pluginName] !== undefined) {
            return navigator[pluginName];
        } else if (electron.app !== undefined) {
            var plugin = false;
            try {
                plugin = require(pluginName);
                return plugin;
            } catch (err) {
                if (plugin === false || plugin === undefined) {
                    var fixedName = pluginName.replace(/\-/g, "").toLowerCase();
                    try {
                        plugin = require("@commontimeltd/com.commontime." + fixedName);
                        return plugin;
                    } catch (err) {
                        return false;
                    }
                }
                return false;
            }
        } else {
            $log.info("Plugin '" + pluginName + "' is not available.");
            return false;
        }
    };

    return Plugin;

}]);


angular.module("app.core").factory("OptionFactory", ["$rootScope", "$parse", "localStorageService", function ($rootScope, $parse, localStorageService) {

    // eslint-disable-next-line no-unused-vars
    var _id = null;
    var _options = {};

    var service = {
        "init": init,
        "get": get
    };

    function get(key) {
        return $parse(key)(_options);
    }

    function init(appName) {
        _id = appName;
        var storage = localStorageService.get(appName + "_options");
        if (storage !== null) {
            _options = storage;
        }
    }

    return service;

}]);
angular.module("app.core").factory("Api", ["$http", "$log", "$q", "$timeout", "$injector", "$httpParamSerializer", "StoreFactory", "Utilities", "FileSystem", "MimeTypes", function ($http, $log, $q, $timeout, $injector, $httpParamSerializer, StoreFactory, Utilities, FileSystem, MimeTypes) {

    function Api(name, url, params, headers, operations) {

        this.name = name;
        this.url = url;
        this.params = params;
        this.headers = headers;
        this.operations = operations;
    }

    Api.prototype = {

        buildRequestObject: function (operation, requestParameterValues, customParameterBuilder) {

            var deferred = $q.defer();

            var self = this;

            var url = self.url;
            // If the URL is pointing to a model location we need to parse it;
            if (typeof url == "string" && url.indexOf("{{") > -1) {
                url = StoreFactory.parse(url);
            }

            // build the HTTP request object
            var request = {
                url: url + operation.path,
                method: operation.method || "GET",
                params: {},
                headers: {}
            };

            var validMethodsForContentType = ["POST", "PUT", "CONNECT", "PATCH"];
            if (validMethodsForContentType.indexOf(request.method) !== -1 && operation["content-type"]) {

                request.headers["Content-Type"] = operation["content-type"];
            }

            var validVerbsForBodyData = ["POST", "PUT", "CONNECT", "PATCH"];
            if (validVerbsForBodyData.indexOf(request.method) !== -1) {

                request.data = {};
            }

            if (request.method == "JSONP") {

                // if the method is JSONP then we need to add the callback param
                request.params.callback = "JSON_CALLBACK";
            }

            // validate and construct the params; first add the API wide params
            var emptyPromise = $q.when();
            var promises = [emptyPromise];

            angular.forEach(self.params, function (param) {
                promises.push(self.constructParameter(param, requestParameterValues, request, customParameterBuilder));
            });

            $q.all(promises)
                .then(function () {

                    // then deal with operation specific params
                    promises = [emptyPromise];

                    angular.forEach(operation.params, function (param) {
                        promises.push(self.constructParameter(param, requestParameterValues, request, customParameterBuilder));
                    });

                    return $q.all(promises);
                })
                .then(function () {

                    // if the content type is x-www-form-urlencoded then we need to encode the data
                    if (request.headers["Content-Type"] == "application/x-www-form-urlencoded") {
                        request.data = $httpParamSerializer(request.data);
                    }

                    // if downloading as a file, indicate that the response will be treated as binary data
                    if (operation.downloadAsFile === true) {
                        request.responseType = "arraybuffer";
                    }

                    deferred.resolve(request);
                })
                .catch(function (error) {
                    
                    deferred.reject(error);
                });

            return deferred.promise;
        },

        constructParameter: function (parameter, parameterValues, request, customParameterBuilder) {

            var deferred = $q.defer();

            var value = undefined;

            if (parameterValues && (parameterValues[parameter.name] !== undefined && parameterValues[parameter.name] !== "")) {

                value = parameterValues[parameter.name];

            } else if (parameter.default !== undefined) {

                value = parameter.default;

            } else if (parameter.required === true) {

                // required parameter not provided
                deferred.reject("Parameter '" + parameter.name + "' must be provided.");
            }

            parameter.typeConfig = parameter.typeConfig || {}; // ensure parameter has typeConfig object, empty by default

            if (value !== undefined) {

                if (typeof value == "string" && value.indexOf("{{") > -1) {
                    value = StoreFactory.parse(value);
                }

                var builderResult = (typeof (customParameterBuilder) === "function")
                    ? customParameterBuilder(request, parameter, value)
                    : $q.when(false);

                builderResult.then(function (parameterBuilt) {

                    if (parameterBuilt) {

                        deferred.resolve();

                    } else {

                        switch (parameter.in) {

                            case "path":
                                request.url = request.url.replace("{{" + parameter.name + "}}", value);
                                deferred.resolve();
                                break;

                            case "query":
                                request.params[parameter.name] = value;
                                deferred.resolve();
                                break;

                            case "header":
                                request.headers[parameter.name] = value;
                                deferred.resolve();
                                break;

                            case "body":
                                if (!request.data) {
                                    deferred.reject("Unable to add parameter '" + parameter.name + "' to body of " + request.method.toUpperCase() + " request");
                                    break;
                                }

                                request.data[parameter.name] = value;
                                deferred.resolve();
                                break;

                            case "formData":
                                if (!request.data) {
                                    deferred.reject("Unable to add parameter '" + parameter.name + "' to form data of " + request.method.toUpperCase() + " request");
                                    break;
                                }

                                if (!(request.data instanceof FormData)) {

                                    request.data = new FormData();
                                }

                                // set the content type to undefined so the browser can handle it, including adding the boundary
                                request.headers["Content-Type"] = undefined;

                                // are we dealing with a file?
                                if (parameter.type === "file") {

                                    try {

                                        var fileName = FileSystem.getFileNameFromPath(value);
                                        FileSystem
                                            .getFileBlob(fileName)
                                            .then(function (blob) {

                                                if (parameter.typeConfig.fileNameParameterName) {

                                                    request.data.append(parameter.typeConfig.fileNameParameterName, fileName);
                                                }

                                                if (parameter.typeConfig.base64encode === true) {

                                                    var fileReader = new FileReader();
                                                    fileReader.onloadend = function (event) {
                                                        var base64data = event.target.result;
                                                        request.data.append(parameter.name, base64data);
                                                        deferred.resolve();
                                                    };
                                                    fileReader.readAsDataURL(blob);

                                                } else {

                                                    request.data.append(parameter.name, blob, fileName);
                                                    deferred.resolve();
                                                }

                                            })
                                            .catch(function (error) {

                                                $log.error(error);
                                                deferred.reject(error);
                                            });

                                    } catch (error) {

                                        $log.error(error);
                                        deferred.reject(error);
                                    }
                                } else {

                                    request.data.append(parameter.name, value);
                                    deferred.resolve();
                                }

                                break;

                            default:
                                deferred.reject("Unknown parameter location");
                        }
                    }
                });

            } else {

                deferred.resolve();
            }

            return deferred.promise;
        },

        makeRequest: function (operationName, params, actions) {

            var deferred = $q.defer();

            var self = this;

            // find the operation requested
            var found = self.operations.filter(function (x) {

                return (x.name === operationName);
            });

            if (found.length > 0) {

                var operation = found[0];

                self.buildRequestObject(operation, params)
                    .then(function (request) {

                        // make the call via the $http service
                        return $http(request);
                    })
                    .then(function (response) {

                        // handle the response

                        if (operation.downloadAsFile === true) {

                            // if download as a file, download and resolve with the downloaded file path
                            self.handleFileDownload(response, operation)
                                .then(function (filePath) {

                                    deferred.resolve(filePath);
                                    deferred.promise.then(function (data) {
                                        handleSuccess(data);
                                    });
                                })
                                .catch(function (error) {
                                    handleFailure();
                                    deferred.reject(error);
                                });
                        } else {

                            // if not downloading as a file, resolve with the response data
                            deferred.resolve(response.data);

                            deferred.promise.then(function (data) {
                                handleSuccess(data);
                            });
                        }
                    })
                    .catch(function (error) {

                        handleFailure(error);
                        deferred.reject(error);
                    });

                function handleSuccess(responseData) {

                    // perform any "success" actions
                    if (actions !== undefined) {
                        var ActionFactory = $injector.get("ActionFactory");
                        ActionFactory.triggerEvent("success", actions, {"$response": responseData});
                    }
                }

                function handleFailure(error) {

                    // perform any "fail" actions
                    if (actions !== undefined) {
                        var ActionFactory = $injector.get("ActionFactory");
                        ActionFactory.triggerEvent("fail", actions, {"$response": error});
                    }
                }

            } else {

                deferred.reject("Requested operation could not be found.");
            }

            return deferred.promise;
        },

        handleFileDownload: function (response, operation) {

            var deferred = $q.defer();

            // If downloading as a file, save the file to the device and resolve with the file path
            var contentType = response.headers("Content-Type").split(";")[0].trim();
            var fileName = "";

            if ((operation.downloadFileName || "").trim().length > 0) {

                fileName = operation.downloadFileName;

            } else {

                fileName = Utilities.uuid();

                var fileExtension = MimeTypes.extensionFromMimeType(contentType);
                if (fileExtension !== null) {
                    fileName += "." + fileExtension;
                }
            }

            FileSystem
                .saveFile(fileName, response.data)
                .then(function (filePath) {

                    deferred.resolve(filePath);
                })
                .catch(function (error) {

                    deferred.reject(error);
                });

            return deferred.promise;
        }
    };

    Api.merge = function (slave, master) {
        var result = {};
        if (slave != undefined) {
            result = slave;
        }
        if (master != undefined) {
            angular.forEach(master, function (value, key) {
                if (typeof value != "object") {
                    result[key] = value;
                } else {
                    if (result[key] == undefined) {
                        result[key] = {};
                    }
                    result[key] = Api.merge(result[key], value);
                }
            });
        }
        return result;
    };

    return Api;

}]);

angular
    .module("app.core")
    .factory("ApiFactory", ["$http", "$log", "StoreFactory", "$timeout", "$q", "Api", "LoadingStatus", function ($http, $log, StoreFactory, $timeout, $q, Api, LoadingStatus) {

        var _apis = {};
        var _defaultStatus = {
            loading: false,
            error: false,
            message: "Loading data..."
        };

        function init(item) {

            _apis[item.name] = new Api(item.name, item.url, item.params, item.headers, item.operations, item.actions);
        }

        function makeRequest(api, actions) {
            var deferred = $q.defer();
            var name = api.name;
            if (_apis[name] != undefined) {
                if (LoadingStatus.disabled !== true) {
                    LoadingStatus.loading = true;
                    LoadingStatus.message = _defaultStatus.message;
                }
                StoreFactory.set("state.loading", true);
                _apis[name].makeRequest(api.operation, api.params, actions).then(function (response) {
                    StoreFactory.set("api." + name + "." + api.operation, response).then(function () {
                        $timeout(function () {
                            if (LoadingStatus.disabled !== true) {
                                LoadingStatus.loading = false;
                            }
                            StoreFactory.set("state.loading", false);
                        }, 1000);
                        deferred.resolve(response);
                    }).catch(function (error) {
                        deferred.reject(error);
                    });
                }).catch(function (error) {
                    $log.error(error);
                    StoreFactory.set("state.loading", false);
                    deferred.reject(error);
                    if (LoadingStatus.disabled !== true) {
                        LoadingStatus.loading = false;
                        LoadingStatus.error = "There was an error retrieving data";
                    }
                });
            }
            return deferred.promise;
        }

        return {
            "init": init,
            "makeRequest": makeRequest
        };

    }]);

angular
    .module("app.core")
    .service("AssetFactory", ["$rootScope", "$injector", "$http", "angularLoad", function ($rootScope, $injector, $http, angularLoad) {

        function injectJsAsset(fileName) {

            var path = $rootScope.assetDir + fileName;
            var SchemaService = $injector.get("SchemaService"); // inject here to prevent circular dependencies with factory injection
            if (SchemaService.isPreview() || SchemaService.isLivePreview()) {

                $http
                    .get(path)
                    .then(function (response) {

                        var script = document.createElement("script");
                        script.textContent = rewriteAssetPaths(response.data);
                        document.body.appendChild(script);
                    });

            } else {

                angularLoad.loadScript(path);
            }
        }

        function injectCssAsset(fileName) {

            // need to load and inject CSS inline so that paths are relative to the index.html document and not the CSS file which exists in user-assets/

            var path = $rootScope.assetDir + fileName;
            $http
                .get(path)
                .then(function (response) {

                    var style = document.createElement("style");
                    style.textContent = rewriteAssetPaths(response.data);
                    document.head.appendChild(style);
                });
        }

        function rewriteAssetPaths(content) {

            if ($rootScope.assetDir) {

                var slashesSwappedAssetDir = $rootScope.assetDir.replace(/\\/g, "/"); // This is needed for Windows Desktop to avoid backwards slashes appearing in an asset file asset path.
                return content.replace(/user-assets\//g, slashesSwappedAssetDir);
            }

            return content;
        }

        return {

            injectJsAsset: injectJsAsset,
            injectCssAsset: injectCssAsset,
            rewriteAssetPaths: rewriteAssetPaths
        };

    }]);

angular.module("app.core").factory("AudioRecordingFactory", ["$q", "Plugin", "FileSystem", function ($q, Plugin, FileSystem) {
    var Media = Plugin.getSource("Media");

    var media = null,
        state = Media.MEDIA_STOPPED,
        stateUpdateCallback = null;

    function checkIfMediaRunning() {
        var deferred = $q.defer();

        if (media !== null && state == Media.MEDIA_RUNNING) {
            stopRecording().then(function () {
                media = null;
                deferred.resolve();
            }).catch(function () {
                media = null;
                deferred.resolve();
            });
        } else {
            deferred.resolve();
        }

        return deferred.promise;
    }

    function startRecordingWithCompression() {
        var deferred = $q.defer();

        checkIfMediaRunning().then(function () {
            FileSystem.generateFileName().then(function (filePath) {
                media = new Media(filePath, function () {

                }, function (err) {
                    deferred.reject(err);
                }, function (newState) {
                    state = newState;
                    if (typeof stateUpdateCallback === "function") {
                        stateUpdateCallback();
                    }
                });

                var options = {
                    SampleRate: 44100,
                    NumberOfChannels: 1
                };

                media.startRecordWithCompression(null, options);

                deferred.resolve();
            });
        });

        return deferred.promise;
    }

    function stopRecording() {
        var deferred = $q.defer();

        if (media === null || state != Media.MEDIA_RUNNING) {
            deferred.reject("Audio not currently recording.");
        } else {
            media.stopRecord();

            var source = media.src;

            media.release();

            stateUpdateCallback = function () {
                if (state == Media.MEDIA_STOPPED) {
                    stateUpdateCallback = null;
                    deferred.resolve(source);
                }
            };
        }

        return deferred.promise;
    }

    document.addEventListener("stop-all-recording", stopRecording);

    return {
        "startRecordingWithCompression": startRecordingWithCompression,
        "stopRecording": stopRecording
    };
}]);

angular.module("app.core").factory("PluginFactory", ["Plugin", "$timeout", "StoreFactory", "LoadingStatus", "$q", function (Plugin, $timeout, StoreFactory, LoadingStatus, $q) {

    var _plugins = {};

    var _defaultStatus = {
        loading: false,
        error: false,
        message: "Calling plugin..."
    };

    var service = {
        init: init,
        callAction: callAction
    };

    function init(item) {
        _plugins[item.name] = new Plugin(item.name, item.events, item.polls, item.operations);
    }

    function callAction(pluginName, actionName, params) {
        var deferred = $q.defer();
        LoadingStatus.loading = true;
        LoadingStatus.message = _defaultStatus.message;
        var nParams = StoreFactory.parse(angular.copy(params));
        _plugins[pluginName].callAction(actionName, nParams).then(function () {
            $timeout(function () {
                LoadingStatus.loading = false;
            }, 1000);
            deferred.resolve();
        }).catch(function () {
            LoadingStatus.loading = false;
            LoadingStatus.error = "There was an error calling the plugin";
            deferred.reject();
        });
        return deferred.promise;
    }

    return service;

}]);
angular.module("app.core").value("LoadingStatus", {
    loading: false,
    error: false,
    message: "Loading data...",
    disabled: false
});
angular.module("app.core").factory("ActionFactory", ["$injector", "$q", "$timeout", "StoreFactory", "ApiFactory", "PluginFactory", "$rootScope", "$location", "$log", "UrlFactory", "toastr", "VariableFactory", "Router", "Camera", "AudioRecordingFactory", "Notification", "$parse", "IBeaconFactory", "GeofenceFactory", "XmppFactory", "MessageQueueFactory", "SchemaHelper", "FileSystem", "MimeTypes", "TranslationService", "ActionflowFactory", "DataflowFactory", "AzureAppServicesFactory", "RestFactory", "AudioPlayer", "ComponentFactory", "GoogleMapService", "DirectiveBridge", "ListFactory", "LoggingFactory", "VibrateFactory", "Plugin", "Platform", "AssetFactory", function ($injector, $q, $timeout, StoreFactory, ApiFactory, PluginFactory, $rootScope, $location, $log, UrlFactory, toastr, VariableFactory, Router, Camera, AudioRecordingFactory, Notification, $parse, IBeaconFactory, GeofenceFactory, XmppFactory, MessageQueueFactory, SchemaHelper, FileSystem, MimeTypes, TranslationService, ActionflowFactory, DataflowFactory, AzureAppServicesFactory, RestFactory, AudioPlayer, ComponentFactory, GoogleMapService, DirectiveBridge, ListFactory, LoggingFactory, VibrateFactory, Plugin, Platform, AssetFactory) {
    
    var service = {
        triggerEvent: triggerEvent,
        evalOperations: evalOperations,
        evalOperation: evalOperation
    };
    
    /**
     * Debounce variable used to store timeout for debounce action
     * @type {null}
     */
    var debounce = null;
    
    /**
     * Method which creates the expression for individual operations
     * @param operation
     * @returns {*}
     */
    function evalOperation(operation) {
        var result = null;
        switch (operation.type) {
            case "value":
                if (angular.isNumber(operation.content) || parseInt(operation.content) || parseFloat(operation.content)) {
                    result = " " + operation.content;
                } else {
                    var val = (angular.isString(operation.content)) ? operation.content.replace(/"/g, "\\\"") : operation.content;
                    result = " \"" + val + "\"";
                }
                break;
            case "operator":
            case "connector":
                result = " " + operation.content;
                break;
        }
        return result;
    }
    
    /**
     * Parses and evaluates operations
     * @param operations
     * @param model
     * @returns {boolean}
     */
    function evalOperations(operations, model) {
        var result = false;
        // We need to do a copy so the parsed results are not persisted
        if (operations !== undefined && operations.length > 0) {
            // Parse operations to convert any curlies to actual model values
            if (model === undefined) {
                operations = StoreFactory.parse(operations);
            } else {
                operations = StoreFactory.parse(operations, { "$data": model }, false);
            }
            // Loop through each operation and construct the expression
            var expression = "";
            angular.forEach(operations, function (operation) {
                expression += evalOperation(operation);
            });
            // Evaluate the expression and return true or false
            try {
                result = $parse(expression)({});
            } catch (e) {
                $log.error("Could not evaluate the logic expression");
            }
        }
        return result;
    }
    
    function triggerEvent(event, actions, $initialData, $event) {
        var chain = $q.when();
        var indent = 0;
        var statuses = {};
        var passes = {};
        var count = 0;
        
        // If we don"t have a flow yet then start out with the event which triggered the flow
        if (($initialData === undefined || $initialData === null) && ($event !== undefined && $event !== null)) {
            
            $initialData = {
                keyCode: $event.keyCode,
                ctrlKey: $event.ctrlKey,
                shiftKey: $event.shiftKey
            };
            
            if ($event.target && $event.target.hasOwnProperty("value")) {
                $initialData.value = $event.target.value;
            }
        }
        
        var _parentPassed = function (indent) {
            if (indent > 0) {
                return (statuses[indent - 1] !== false) ? _parentPassed(indent - 1) : false;
            }
            return true;
        };
        
        angular.forEach(actions, function (action) {
            
            if (event === null || !action.event || action.event === event) {
                
                switch (action.type) {
                    
                    case "if":
                        chain = chain.then(function ($data) {
                            // Always use $data (from the last action) unless its the first action
                            var _data = ($data === undefined && count === 0) ? $initialData : $data;
                            indent++;
                            if (action.operations !== undefined && action.operations.length > 0) {
                                statuses[indent] = evalOperations(angular.copy(action.operations), _data);
                                if (statuses[indent - 1] !== false && passes[indent] !== true && statuses[indent] === true) {
                                    passes[indent] = true;
                                }
                            }
                            return $q.when(_data);
                        });
                        break;
                    
                    case "end-if":
                        chain = chain.then(function ($data) {
                            // Always use $data (from the last action) unless its the first action
                            var _data = ($data === undefined && count === 0) ? $initialData : $data;
                            delete passes[indent];
                            delete statuses[indent];
                            indent--;
                            return $q.when(_data);
                        });
                        break;
                    
                    case "otherwise":
                        chain = chain.then(function ($data) {
                            // Always use $data (from the last action) unless its the first action
                            var _data = ($data === undefined && count === 0) ? $initialData : $data;
                            statuses[indent] = (passes[indent] !== true);
                            return $q.when(_data);
                        });
                        break;
                    
                    case "otherwise-if":
                        chain = chain.then(function ($data) {
                            // Always use $data (from the last action) unless its the first action
                            var _data = ($data === undefined && count === 0) ? $initialData : $data;
                            if (passes[indent] === true) {
                                statuses[indent] = false;
                            } else {
                                if (action.operations !== undefined && action.operations.length > 0) {
                                    statuses[indent] = evalOperations(angular.copy(action.operations), _data);
                                }
                                if (statuses[indent] === true) {
                                    passes[indent] = true;
                                }
                            }
                            return $q.when(_data);
                        });
                        break;
                    
                    default:
                        chain = chain.then(function ($data) {
                            // Always use $data (from the last action) unless its the first action
                            var _data = ($data === undefined && count === 0) ? $initialData : $data;
                            if (statuses[indent] !== false && _parentPassed(indent)) {
                                count++;
                                return call(action, _data)();
                            } else {
                                return $q.when(_data);
                            }
                        });
                }
            }
        });
        
        indent = 0;
        statuses = {};
        passes = {};
        
        return chain;
    }
    
    function evalExpressions(expressions, obj) {
        angular.forEach(expressions, function (expression, key) {
            if (key != "expressions") {
                if (typeof expression == "object") {
                    obj[key] = evalExpressions(expression, obj[key]);
                } else {
                    obj[key] = StoreFactory.evaluate(expression);
                }
            }
        });
        return obj;
    }
    
    function call(originalAction, $data) {
        
        var parsedAction = angular.copy(originalAction);
        
        // We don"t want to interpolate a loop action yet because it needs to do it itself with context of its own model
        if (parsedAction.type !== "loop") {
            parsedAction = StoreFactory.parse(parsedAction, { "$data": $data });
        }
        
        // Do not delete this variable.
        // Yes, it says it's unused, but it is required in the context of inline functions being evaluated at runtime.
        // eslint-disable-next-line no-unused-vars
        var $store = window.cti.store;
        
        return function () {
            
            var deferred = $q.defer();
            var _success = function (data) {
                deferred.resolve(data);
            };
            var _error = function (data, errorObject, stopFlow) {
                $log.error("Error in action \"" + originalAction.type + "\"\n\n", data, "\n\nAction schema:", originalAction, "\n\nParsed action schema:", parsedAction);
                if (errorObject !== undefined && errorObject !== null) {
                    $log.error(errorObject);
                }
                if (stopFlow === true) {
                    deferred.reject();
                } else {
                    deferred.resolve(data);
                }
            };
            if (parsedAction.expressions !== undefined) {
                parsedAction = evalExpressions(parsedAction.expressions, parsedAction);
            }
            var SchemaService = $injector.get("SchemaService");
            switch (parsedAction.type) {
                case "set-layers":
                    (function () {
                        var api = DirectiveBridge.getItemApi(parsedAction.data.page, parsedAction.data.map);
                        var layer = parsedAction.data.layer;
                        
                        if (api) {
                            if (layer && api.setMapLayers(layer, parsedAction.data.show)) {
                                _success($data);
                            } else {
                                _error("Could not find layer: " + layer);
                            }
                        } else {
                            _error("Could not find map: " + parsedAction.data.map + " on " + parsedAction.data.page + ".");
                        }
                    })();
                    break;
                case "set-map-type":
                    (function () {
                        var api = DirectiveBridge.getItemApi(parsedAction.data.page, parsedAction.data.map);
                        var mapType = parsedAction.data.maptype;
                        if (api && mapType) {
                            api.setMapTypeId(mapType);
                            _success($data);
                        } else {
                            _error("Could not find map: " + parsedAction.data.map + " on " + parsedAction.data.page + ".");
                        }
                    })();
                    break;
                case "set-controls":
                    (function () {
                        var api = DirectiveBridge.getItemApi(parsedAction.data.page, parsedAction.data.map);
                        var control = parsedAction.data.control;
                        var show = parsedAction.data.show;
                        
                        if (api) {
                            if (control && api.setControls(control, show)) {
                                _success($data);
                            } else {
                                _error("Could not find control: " + control);
                            }
                        } else {
                            _error("Could not find map: " + parsedAction.data.map + " on " + parsedAction.data.page + ".");
                        }
                    })();
                    
                    break;
                case "set-location":
                    var lat = parseFloat(parsedAction.data.lat);
                    var lng = parseFloat(parsedAction.data.lng);
                    var zoom = parseInt(parsedAction.data.zoom);
                    var pan = parsedAction.data.pan;
                    
                    if (isNaN(lat) || isNaN(lng)) {
                        _error($data, "No lat/lng provided");
                        break;
                    }
                    
                    var api = DirectiveBridge.getItemApi(parsedAction.data.page, parsedAction.data.map);
                    if (api) {
                        api.setLocation(lat, lng, zoom, pan);
                        _success($data);
                    } else {
                        _error("Could not find map: " + parsedAction.data.map + " on " + parsedAction.data.page + ".");
                    }
                    
                    break;
                case "set-model":
                    
                    try {
                        
                        var key = parsedAction.data.location;
                        var valueOrEmpty = parsedAction.data.value || "";
                        var value = (typeof (valueOrEmpty) === "string")
                            ? valueOrEmpty
                            : JSON.stringify(valueOrEmpty);
                        var trimmedValue = value.trim();
                        var dataType = parsedAction.data.dataType;
                        
                        if (key !== undefined) {
                            
                            var alternativeModel = null;
                            if (key.indexOf("$store") !== 0) {
                                
                                alternativeModel = {
                                    "$data": $data
                                };
                            }
                            
                            if (dataType === "") {
                                
                                // attempt to automatically determine the data type based on the value
                                
                                if (trimmedValue.length === 0) {
                                    dataType = "empty";
                                } else if (["true", "false"].indexOf(trimmedValue.toLowerCase()) !== -1) {
                                    dataType = "boolean";
                                } else if (/^[0-9]*\.?[0-9]+$/.test(trimmedValue)) {
                                    dataType = "number";
                                } else if (trimmedValue[0] === "[") {
                                    dataType = "array";
                                } else if (trimmedValue[0] === "{") {
                                    dataType = "object";
                                } else {
                                    dataType = "string";
                                }
                            }
                            
                            var typedValue;
                            switch (dataType) {
                                
                                default:
                                case "string":
                                    typedValue = value;
                                    break;
                                
                                case "number":
                                    typedValue = parseFloat(value) || 0;
                                    break;
                                
                                case "boolean":
                                    typedValue = ["", "false", "0"].indexOf(trimmedValue.toLowerCase()) === -1;
                                    break;
                                
                                case "array":
                                    try {
                                        typedValue = JSON.parse(trimmedValue);
                                        if (!angular.isArray(typedValue)) typedValue = [];
                                    } catch (e) {
                                        typedValue = [];
                                    }
                                    break;
                                
                                case "object":
                                    try {
                                        typedValue = JSON.parse(trimmedValue);
                                        if (!angular.isObject(typedValue)) typedValue = {};
                                    } catch (e) {
                                        typedValue = {};
                                    }
                                    break;
                                
                                case "empty":
                                    typedValue = undefined;
                                    break;
                            }
                            
                            StoreFactory
                                .set(key, typedValue, alternativeModel, true)
                                .then(function () {
                                    
                                    if (alternativeModel) {
                                        $rootScope.$broadcast("StoreChanged");
                                    }
                                });
                            
                            _success($data);
                            
                        } else {
                            _error("Model location has not been specified.");
                        }
                    } catch (e) {
                        _error(e);
                    }
                    break;
                case "set-preference":
                    localStorage.setItem(parsedAction.data.key, parsedAction.data.value);
                    SchemaService.setUpPreferences();
                    break;
                case "reset-preference":
                    localStorage.removeItem(parsedAction.data.key);
                    SchemaService.setUpPreferences();
                    break;
                case "change-language":
                    TranslationService.setLanguage(parsedAction.data.language);
                    break;
                case "upload-file":
                    (function () {
                        var filePath = parsedAction.data.filePath;
                        var fileName = FileSystem.getFileNameFromPath(filePath);
                        var uploadUrl = parsedAction.data.uploadUrl;
                        var saveResponseInModel = parsedAction.data.saveResponseInModel;
                        var modelLocation = parsedAction.data.modelLocation;
                        var uploadOptions = {
                            httpMethod: parsedAction.data.uploadMethod || "POST",
                            fileName: fileName,
                            fileKey: parsedAction.data.fileParameterName || "source"
                        };
                        FileSystem
                            .upload(filePath, uploadUrl, uploadOptions)
                            .then(function (result) {
                                if (saveResponseInModel) {
                                    StoreFactory.set(modelLocation, result.response);
                                }
                                return _success(result);
                            })
                            .catch(_error);
                    })();
                    break;
                case "download-file":
                    (function () {
                        var downloadUrl = parsedAction.data.downloadUrl;
                        var fileName = parsedAction.data.saveAsFileName;
                        var modelLocation = parsedAction.data.modelLocation;
                        FileSystem
                            .download(downloadUrl, fileName)
                            .then(function (result) {
                                StoreFactory.set(modelLocation, result.filePath);
                                return _success(result);
                            })
                            .catch(_error);
                    })();
                    break;
                case "call-actionflow":
                    ActionflowFactory.execute(parsedAction.data.name, $data).then(_success).catch(_error);
                    break;
                case "call-dataflow":
                    DataflowFactory.execute(parsedAction.data.name, $data).then(_success).catch(_error);
                    break;
                case "call-api":
                    // note - we pass the original action"s child actions as these have not been parsed and mutated by the "parse" operation earlier in this function
                    if (parsedAction.data.sync === true) {
                        ApiFactory.makeRequest(parsedAction.data, originalAction.actions).then(_success).catch(_error);
                    } else {
                        ApiFactory.makeRequest(parsedAction.data, originalAction.actions);
                        _success($data);
                    }
                    break;
                case "call-offline-api":
                    RestFactory.makeRequest(parsedAction).then(_success).catch(_error);
                    break;
                case "call-azure-app-service":
                    AzureAppServicesFactory.makeRequest(parsedAction).then(_success).catch(_error);
                    break;
                case "logout-azure-app-service":
                    AzureAppServicesFactory.logout().then(_success).catch(_error);
                    break;
                case "send-xmpp-message":
                case "resend-xmpp-message":
                    XmppFactory.send(parsedAction.data).then(_success).catch(_error);
                    break;
                case "send-xmpp-group-message":
                    XmppFactory.sendToGroup(parsedAction.data).then(_success).catch(_error);
                    break;
                case "xmpp-login":
                    XmppFactory.login(parsedAction.data).then(_success).catch(_error);
                    break;
                case "xmpp-logout":
                    XmppFactory.logout(parsedAction.data).then(_success).catch(_error);
                    break;
                case "xmpp-mark-read":
                    XmppFactory.markRead(parsedAction.data).then(_success).catch(_error);
                    break;
                case "xmpp-mark-acknowledged":
                    XmppFactory.markAcknowledged(parsedAction.data).then(_success).catch(_error);
                    break;
                case "xmpp-set-status":
                    XmppFactory.setStatus(parsedAction.data).then(_success).catch(_error);
                    break;
                case "start-message-queue-listening":
                    MessageQueueFactory.startListening(parsedAction.data.name).then(_success).catch(_error);
                    break;
                case "stop-message-queue-listening":
                    MessageQueueFactory.stopListening(parsedAction.data.name).then(_success).catch(_error);
                    break;
                case "send-message-queue-message":
                    MessageQueueFactory.sendMessage(parsedAction.data.name, parsedAction.data.message).then(_success).catch(_error);
                    break;
                case "call-plugin":
                    PluginFactory.callAction(parsedAction.data.name, parsedAction.data.operation, parsedAction.data.params).then(_success).catch(_error);
                    break;
                case "call-url":
                    UrlFactory.makeRequest(parsedAction.data).then(_success).catch(_error);
                    break;
                case "call-x-callback-url":
                    var url = null;
                    switch (parsedAction.data.type) {
                        case "x-source":
                            url = StoreFactory.get("xcallback.source");
                            break;
                        case "x-success":
                            url = StoreFactory.get("xcallback.success");
                            break;
                        case "x-error":
                            url = StoreFactory.get("xcallback.error");
                            break;
                        case "x-cancel":
                            url = StoreFactory.get("xcallback.cancel");
                            break;
                    }
                    url = StoreFactory.parseUrl(url, parsedAction.data.params);
                    window.open(url, "_system");
                    _success(url);
                    break;
                case "go-back":
                    Router.goPrevious();
                    _success($data);
                    break;
                case "go-to-page":
                    var location = null;
                    if (parsedAction.data.isConditional !== true) {
                        if (parsedAction.data.name !== undefined && parsedAction.data.name.length > 0) {
                            location = "/" + parsedAction.data.name;
                        }
                    } else {
                        if (parsedAction.data.expressions !== undefined) {
                            angular.forEach(parsedAction.data.expressions, function (expression, pageName) {
                                if (location === null) {
                                    if (StoreFactory.evaluate(expression)) {
                                        location = "/" + pageName;
                                    }
                                }
                            });
                        }
                    }
                    if (location !== null) {
                        if (Router.isInitialized) {
                            Router.go(location);
                            _success(location);
                        } else {
                            Router.setFirstPage(location);
                            _success(location);
                        }
                    } else {
                        _error($data);
                    }
                    break;
                case "set-variable":
                    VariableFactory
                        .setVariable(parsedAction.data.name, parsedAction.data.value)
                        .then(function () {
                            _success($data);
                        })
                        .catch(_error);
                    break;
                case "call-function":
                    var functionItem = SchemaHelper.getSchemaConfigItemByName(parsedAction.data.name);
                    if (!parsedAction.data.name || typeof (window.cti[parsedAction.data.name]) !== "function" || !functionItem) {
                        _error("Specified function doesn't exist");
                    } else {
                        if (parsedAction.data.params == undefined) {
                            parsedAction.data.params = {};
                        }
                        try {
                            var paramsArr = [];
                            angular.forEach(functionItem.params, function (param) {
                                var paramName = param.name;
                                var paramValue = parsedAction.data.params[paramName];
                                paramsArr.push(paramValue);
                            });
                            // eslint-disable-next-line no-redeclare
                            var $success = function (data) {
                                if (functionItem.actions !== undefined && functionItem.actions.length > 0) {
                                    triggerEvent("success", functionItem.actions, data);
                                }
                                _success(data);
                            };
                            // eslint-disable-next-line no-redeclare
                            var $fail = function (data) {
                                if (functionItem.actions !== undefined && functionItem.actions.length > 0) {
                                    triggerEvent("fail", functionItem.actions, data);
                                }
                                _error(data);
                            };
                            // add $success and $fail callbacks as final parameters
                            paramsArr.push($success);
                            paramsArr.push($fail);
                            paramsArr.push(window.cti.store);
                            window.cti[parsedAction.data.name].apply({
                                "$success": $success,
                                "$fail": $fail
                            }, Array.prototype.slice.call(paramsArr, 0));
                            // Automatically resolve if the function hasn"t been set to synchronous
                            if (window.cti[parsedAction.data.name].prototype.sync !== true) {
                                _success($data);
                            }
                        } catch (e) {
                            _error("Couldn't successfully call function:", e);
                        }
                    }
                    break;
                case "inline-function":
                    if (parsedAction.data.code !== undefined) {
                        try {
                            var func = null;
                            eval("func = function(){" + parsedAction.data.code + "}");
                            if (func !== null) {
                                // Redeclare variables here to ensure that its always the correct context
                                // eslint-disable-next-line no-redeclare
                                var $success = function (data) {
                                    if (parsedAction.actions !== undefined && parsedAction.actions.length > 0) {
                                        triggerEvent("success", originalAction.actions, data);
                                    }
                                    _success(data);
                                };
                                // eslint-disable-next-line no-redeclare
                                var $fail = function (data) {
                                    if (parsedAction.actions !== undefined && parsedAction.actions.length > 0) {
                                        triggerEvent("fail", originalAction.actions, data);
                                    }
                                    _error(data);
                                };
                                func.apply({
                                    "$success": $success,
                                    "$fail": $fail,
                                    "$store": window.cti.store
                                });
                            }
                            if (parsedAction.data.sync !== true) {
                                _success($data);
                            }
                        } catch (error) {
                            _error(error);
                        }
                    } else {
                        _error("Function code not specified.");
                    }
                    break;
                case "call-component-function":
                    (function () {
                        var componentInstanceId = parsedAction.data.componentInstanceId;
                        var functionName = parsedAction.data.function;
                        var componentRegistration = ComponentFactory.getComponentById(componentInstanceId);
                        
                        if (!componentRegistration) {
                            _error("Component not available");
                            return;
                        }
                        
                        var componentFunction = (componentRegistration.component.annotations.functions || []).filter(function (x) {
                            return x.name === functionName;
                        })[0];
                        
                        if (!componentFunction) {
                            _error("Function \"" + functionName + "\" not available on component \"" + componentRegistration.name + "\"");
                            return;
                        }
                        
                        var fn = componentRegistration.element[functionName];
                        
                        if (typeof (fn) !== "function") {
                            _error("Function \"" + functionName + "\" on component \"" + componentRegistration.name + "\" is not a function");
                            return;
                        }
                        
                        if (parsedAction.data.params == undefined) {
                            parsedAction.data.params = {};
                        }
                        
                        var paramValues = [];
                        angular.forEach(componentFunction.params, function (param) {
                            var paramName = param.name;
                            var paramValue = parsedAction.data.params[paramName];
                            var typedValue = ComponentFactory.getTypedValue(param.type, paramValue);
                            paramValues.push(typedValue);
                        });
                        
                        try {
                            
                            var returnValue = fn.apply(componentRegistration.element, Array.prototype.slice.call(paramValues, 0));
                            $q.all([returnValue]).then(function (data) {
                                
                                $rootScope.$broadcast("StoreChanged");
                                _success(data[0]);
                            });
                            
                        } catch (e) {
                            
                            _error("Couldn't successfully call function \"" + functionName + "\" on component \"" + componentRegistration.name + "\":", e);
                        }
                    })();
                    break;
                case "set-component-variable":
                    (function () {
                        var componentInstanceId = parsedAction.data.componentInstanceId;
                        var variableName = (parsedAction.data.variableName || "");
                        var variableType = (parsedAction.data.variableType || "").toLowerCase();
                        var variableValue = parsedAction.data.value;
                        var componentRegistration = ComponentFactory.getComponentById(componentInstanceId);
                        
                        if (!componentRegistration) {
                            _error("Component not available");
                            return;
                        }
                        
                        var variableCollection = [];
                        switch (variableType) {
                            
                            case "attribute":
                                variableCollection = componentRegistration.component.annotations.attributes || [];
                                break;
                            
                            case "property":
                                variableCollection = componentRegistration.component.annotations.properties || [];
                                break;
                        }
                        
                        var componentVariable = variableCollection.filter(function (x) {
                            return x.name === variableName;
                        })[0];
                        
                        if (!componentVariable) {
                            _error("Variable \"" + componentVariable + "\" not available on component \"" + componentRegistration.name + "\"");
                            return;
                        }
                        
                        try {
                            
                            if (variableType === "attribute") {
                                
                                ComponentFactory.setAttributeValueFromAction(componentRegistration, variableName, variableValue);
                                _success($data);
                                
                            } else if (variableType === "property") {
                                
                                if (componentVariable.setter === true) {
                                    
                                    var valueType = componentVariable.valueType;
                                    ComponentFactory.setPropertyValueFromAction(componentRegistration, valueType, variableName, variableValue);
                                    
                                    _success($data);
                                    
                                } else {
                                    
                                    _error("Cannot set property \"" + variableName + "\" on component \"" + componentRegistration.name + "\": property does not have setter");
                                }
                            }
                            
                        } catch (e) {
                            
                            _error("Couldn\'t successfully set variable \"" + variableName + "\" on component \"" + componentRegistration.name + "\":", e);
                        }
                    })();
                    break;
                case "add-to-collection":
                    (function () {
                        var modelLocation = parsedAction.data.model;
                        if (!modelLocation) {
                            _error("Model location was not specified.");
                            return;
                        }
                        
                        var model = StoreFactory.get(modelLocation);
                        if (model === undefined) {
                            _error("Model location \"" + parsedAction.data.model + "\" does not exist.");
                            return;
                        }
                        
                        if (!angular.isArray(model)) {
                            _error("Model location \"" + parsedAction.data.model + "\" is not an array.");
                            return;
                        }
                        
                        try {
                            
                            var item = undefined;
                            
                            if (parsedAction.data.source === "model") {
                                
                                if (!parsedAction.data.itemModel) {
                                    _error("Item data model location not specified");
                                    return;
                                }
                                
                                // add a copy of the item at that model location
                                item = angular.copy(StoreFactory.get(parsedAction.data.itemModel));
                                
                            } else if (parsedAction.data.source === "json") {
                                
                                if (!parsedAction.data.itemJson) {
                                    _error("Item JSON not specified");
                                    return;
                                }
                                
                                item = parsedAction.data.itemJson;
                            }
                            
                            if (item !== undefined) {
                                
                                switch (parsedAction.data.where) {
                                    
                                    case "end":
                                        model.push(item);
                                        break;
                                    
                                    case "start":
                                        model.unshift(item);
                                        break;
                                    
                                    case "idx":
                                        var index = parseInt(parsedAction.data.index);
                                        if (isNaN(index)) {
                                            _error("Index \"" + parsedAction.data.index + "\" is not a valid index.");
                                            return;
                                        }
                                        
                                        if (index >= model.length) {
                                            model.push(item);
                                        } else {
                                            model.splice(index, 0, item);
                                        }
                                        
                                        break;
                                }
                                
                                StoreFactory.set(modelLocation, model);
                                _success($data);
                            }
                            
                        } catch (e) {
                            
                            _error("Unable to process item JSON", e);
                        }
                    })();
                    break;
                case "remove-from-collection":
                    (function () {
                        var modelLocation = parsedAction.data.model;
                        if (!modelLocation) {
                            _error("Model location was not specified.");
                            return;
                        }
                        
                        var model = StoreFactory.get(modelLocation);
                        if (model === undefined) {
                            _error("Model location \"" + parsedAction.data.model + "\" does not exist.");
                            return;
                        }
                        
                        if (!angular.isArray(model)) {
                            _error("Model location \"" + parsedAction.data.model + "\" is not an array.");
                            return;
                        }
                        
                        var index = parseInt(parsedAction.data.index);
                        if (isNaN(index)) {
                            _error("Index \"" + parsedAction.data.index + "\" is not a valid index.");
                            return;
                        }
                        
                        if (index >= model.length) {
                            _error("Index " + index + " is out of bounds of model \"" + parsedAction.data.model + "\" which has size: " + model.length + ".");
                            return;
                        }
                        
                        model.splice(index, 1);
                        StoreFactory.set(modelLocation, model);
                        _success($data);
                    })();
                    break;
                case "start-timer":
                    if (parsedAction.data.name != undefined && window.cti.__timers != undefined && window.cti.__timers[parsedAction.data.name] != undefined) {
                        window.cti.__timers[parsedAction.data.name].start();
                        _success($data);
                    } else {
                        _error(true);
                    }
                    break;
                case "stop-timer":
                    if (parsedAction.data.name != undefined && window.cti.__timers != undefined && window.cti.__timers[parsedAction.data.name] != undefined) {
                        window.cti.__timers[parsedAction.data.name].stop();
                        _success($data);
                    } else {
                        _error($data);
                    }
                    break;
                case "show-notification":
                    Notification
                        .call(parsedAction.data)
                        .then(function () {
                            _success($data); // pass data through
                        })
                        .catch(_error);
                    break;
                case "take-photo":
                    var quality = null;
                    if (!isNaN(parseInt(parsedAction.data.quality))) {
                        quality = parseInt(parsedAction.data.quality);
                    }
                    var direction = null;
                    var encoding = null;
                    if ((parsedAction.data.direction === "fromDataModel" && parsedAction.data.directionFromDataModel === "back") || parsedAction.data.direction === "back") {
                        direction = 0;
                    }
                    if ((parsedAction.data.direction === "fromDataModel" && parsedAction.data.directionFromDataModel === "front") || parsedAction.data.direction === "front") {
                        direction = 1;
                    }
                    if ((parsedAction.data.encoding === "fromDataModel" && parsedAction.data.encodingFromDataModel === "jpeg") || parsedAction.data.encoding === "jpeg") {
                        encoding = 0;
                    }
                    if ((parsedAction.data.encoding === "fromDataModel" && parsedAction.data.encodingFromDataModel === "png") || parsedAction.data.encoding === "png") {
                        encoding = 1;
                    }
                    var processedWidth = 0;
                    var processedHeight = 0;
                    if (parsedAction.data.width && !isNaN(parseInt(parsedAction.data.width)) && parsedAction.data.width > 0) {
                        processedWidth = parseInt(parsedAction.data.width);
                    }
                    if (parsedAction.data.height && !isNaN(parseInt(parsedAction.data.height)) && parsedAction.data.height > 0) {
                        processedHeight = parseInt(parsedAction.data.height);
                    }
                    Camera.takePhoto(
                        quality,
                        direction,
                        processedWidth,
                        processedHeight,
                        encoding,
                        parsedAction.data.allowEdit,
                        parsedAction.data.saveToPhotoAlbum
                    ).then(function (imageURI) {
                        // Get the current store
                        if (parsedAction.data.mediaId !== undefined) {
                            var modelLocation = "$store.media." + parsedAction.data.mediaId + ".images";
                            var store = StoreFactory.get(modelLocation);
                            if (store === undefined) {
                                store = [];
                            }
                            if (parsedAction.data.index !== undefined && store[parsedAction.data.index] !== undefined) {
                                store[parsedAction.data.index] = imageURI;
                            } else if (parsedAction.data.multiple === true) {
                                store.push(imageURI);
                            } else {
                                store[0] = imageURI;
                            }
                            StoreFactory.set(modelLocation, store);
                            _success(store);
                        } else {
                            _error("Could not save photo response.");
                        }
                    }).catch(function (error) {
                        _error("Could not take photo:", error);
                    });
                    break;
                case "select-photo":
                    Camera.selectPhoto().then(function (imageURI) {
                        // Get the current store
                        if (parsedAction.data.mediaId !== undefined) {
                            var modelLocation = "$store.media." + parsedAction.data.mediaId + ".images";
                            var store = StoreFactory.get(modelLocation);
                            if (store === undefined) {
                                store = [];
                            }
                            if (parsedAction.data.index !== undefined && store[parsedAction.data.index] !== undefined) {
                                store[parsedAction.data.index] = imageURI;
                            } else if (parsedAction.data.multiple === true) {
                                store.push(imageURI);
                            } else {
                                store[0] = imageURI;
                            }
                            StoreFactory.set(modelLocation, store);
                            _success(store);
                        } else {
                            _error("Could not save gallery response.");
                        }
                    }).catch(function (error) {
                        _error("Could not select photo:", error);
                    });
                    break;
                case "record-audio":
                    AudioRecordingFactory.startRecordingWithCompression()
                        .then(_success)
                        .catch(_error);
                    break;
                case "stop-record-audio":
                    AudioRecordingFactory.stopRecording().then(function (audioClipUri) {
                        if (parsedAction.data.mediaId !== undefined) {
                            var modelLocation = "$store.media." + parsedAction.data.mediaId + ".audio";
                            var store = StoreFactory.get(modelLocation);
                            if (store === undefined) {
                                store = [];
                            }
                            if (parsedAction.data.index !== undefined && store[parsedAction.data.index] !== undefined) {
                                store[parsedAction.data.index] = audioClipUri;
                            } else if (parsedAction.data.multiple === true) {
                                store.push(audioClipUri);
                            } else {
                                store[0] = audioClipUri;
                            }
                            StoreFactory.set(modelLocation, store);
                            _success(store);
                        } else {
                            _error("Could not save audio response.");
                        }
                    }).catch(function (error) {
                        _error("Could not stop recording:", error);
                    });
                    break;
                case "get-media-volume":
                    var Media = Plugin.getSource("Media");
                    if (Media && Media.getDeviceVolume) {
                        
                        function success(volume) {
                            _success(volume * 100);
                        }
                        
                        function fail(e) {
                            _error("Could not get device volume: " + e);
                        }
                        
                        Media.getDeviceVolume(success, fail, parsedAction.data.streamId);
                    } else {
                        _success(0);
                    }
                    break;
                case "change-media-volume":
                    (function () {
                        if (parsedAction.data.volumeLevel !== undefined && parsedAction.data.volumeLevel <= 100 && parsedAction.data.volumeLevel >= 0) {
                            
                            var Media = Plugin.getSource("Media");
                            if (Media && Media.setDeviceMediaVolume) {
                                function success() {
                                    _success(parsedAction.data.volumeLevel);
                                }
                                
                                function fail(e) {
                                    _error("Could not set device volume: " + e);
                                }
                                
                                Media.setDeviceVolume(success, fail, parsedAction.data.volumeLevel / 100.0, parsedAction.data.streamId);
                            } else {
                                _success(parsedAction.data.volumeLevel);
                            }
                        } else {
                            _error("Could not set device volume: Invalid volume.");
                        }
                    })();
                    break;
                case "play-audio":
                    (function () {
                        function playFile(fileLocation) {
                            if (fileLocation.indexOf("user-assets/") === 0) {
                                fileLocation = AssetFactory.rewriteAssetPaths(fileLocation);
                            }
                            AudioPlayer.play(fileLocation, {
                                "loop": parsedAction.data.loop,
                                "loopInterval": parsedAction.data.loopInterval,
                                "loopCount": parsedAction.data.loopCount,
                                "vibrate": parsedAction.data.vibrate,
                                "vibratePattern": parsedAction.data.vibratePattern,
                                "vibrateCustomPattern": parsedAction.data.vibrateCustomPattern,
                                "forceVibrate": parsedAction.data.forceVibrate,
                                "streamId": parsedAction.data.streamId
                            }, function () {
                                _success(fileLocation);
                            });
                        }
                        
                        if (parsedAction.data.model !== undefined) {
                            var store = StoreFactory.get(parsedAction.data.model);
                            // check the store item is a string and it ends with .m4a!
                            
                            var fileLocation = "";
                            
                            // Make a comprimise that if someone is using a generic store location, we use the last audio file.
                            if (angular.isArray(store) && store.length > 0) {
                                fileLocation = store[store.length - 1];
                            } else if (angular.isString(store)) {
                                fileLocation = store;
                            }
                            
                            if (angular.isString(fileLocation) && fileLocation.search(/\.m4a$/img) > -1) {
                                playFile(fileLocation);
                            } else {
                                _error("Play Audio action failed, model location was not a playable file.");
                            }
                        } else if (parsedAction.data.fileName !== undefined) {
                            if (angular.isString(parsedAction.data.fileName) && parsedAction.data.fileName.search(/\.m4a$/img) > -1) {
                                playFile($rootScope.assetDir + parsedAction.data.fileName);
                            } else {
                                _error("Play Audio action failed, file location was not a playable file.");
                            }
                        } else {
                            _error("Play Audio action failed, no valid location specified.");
                        }
                    })();
                    break;
                case "stop-audio":
                    AudioPlayer.stop(function() {
                        _success($data);
                    });                    
                    break;
                case "record-video":
                    var limitRecording = parsedAction.data.limitRecording;
                    var maxDuration = -1;
                    if (limitRecording && !isNaN(parseInt(parsedAction.data.maxDuration))) {
                        maxDuration = parseInt(parsedAction.data.maxDuration);
                    }
                    var lowQuality = parsedAction.data.lowQuality;
                    Camera.recordVideo(maxDuration, lowQuality === true ? 0 : 1).then(function (videoURI) {
                        // Get the current store
                        if (parsedAction.data.mediaId !== undefined) {
                            var modelLocation = "$store.media." + parsedAction.data.mediaId + ".videos";
                            var store = StoreFactory.get(modelLocation);
                            if (store === undefined) {
                                store = [];
                            }
                            if (parsedAction.data.index !== undefined && store[parsedAction.data.index] !== undefined) {
                                store[parsedAction.data.index] = videoURI;
                            } else {
                                store[0] = videoURI;
                            }
                            StoreFactory.set(modelLocation, store);
                            _success(store);
                        } else {
                            _error("Could not save video response.");
                        }
                    }).catch(function (error) {
                        _error("Could not select video:", error);
                    });
                    break;
                case "delete-media":
                    
                    if (parsedAction.data.model === undefined) {
                        
                        _error("Model location missing.");
                        
                    } else {
                        
                        var mediaLocation = StoreFactory.get(parsedAction.data.model);
                        if (mediaLocation === undefined || mediaLocation === null) {
                            
                            _error("Model location \"" + parsedAction.data.model + "\" does not exist.");
                            
                        } else {
                            
                            if (angular.isArray(mediaLocation)) {
                                
                                // not allowed to delete via a collection object
                                _error("Cannot delete all media from a collection, you must specify a collection index.");
                                
                            } else {
                                
                                var arrayRegex = /^(.*?)\[(.*?)]/;
                                var representsCollectionValue = arrayRegex.test(parsedAction.data.model);
                                
                                FileSystem
                                    .deleteMediaItem(mediaLocation)
                                    .then(function () {
                                        
                                        var ev = new CustomEvent("media-deleted", { "detail": { "location": mediaLocation } });
                                        document.dispatchEvent(ev);
                                        
                                        if (representsCollectionValue) {
                                            
                                            // model location represents an array; splice the index
                                            var collectionModelLocation = arrayRegex.exec(parsedAction.data.model)[1];
                                            var index = arrayRegex.exec(parsedAction.data.model)[2];
                                            
                                            var storeCollection = StoreFactory.get(collectionModelLocation);
                                            if (storeCollection && index < storeCollection.length) {
                                                
                                                storeCollection.splice(index, 1);
                                                StoreFactory.set(collectionModelLocation, storeCollection, false);
                                            }
                                            
                                        } else {
                                            
                                            // straight-up media location, not an index in a collection; set value in store to undefined
                                            StoreFactory.set(parsedAction.data.model, undefined, false);
                                        }
                                        
                                        _success($data);
                                    })
                                    .catch(function (error) {
                                        _error(error);
                                    });
                            }
                        }
                    }
                    break;
                case "start-beacon-listening":
                    try {
                        IBeaconFactory.startListening();
                        _success($data);
                    } catch (err) {
                        _error(err);
                    }
                    break;
                case "stop-beacon-listening":
                    try {
                        IBeaconFactory.stopListening();
                        _success($data);
                    } catch (err) {
                        _error(err);
                    }
                    break;
                case "loop":
                    if (parsedAction.data !== undefined && parsedAction.data.model !== undefined) {
                        var modelLocation = parsedAction.data.model.replace("{{", "").replace("}}", "");
                        var items = null;
                        if (modelLocation !== "$data") {
                            items = StoreFactory.get(modelLocation);
                        } else {
                            items = $data;
                        }
                        if (items !== null && items.length > 0) {
                            var subChain = $q.when();
                            items.every(function (item) {
                                subChain = subChain.then(function () {
                                    // note - we pass the original action"s child actions as these have not been parsed and mutated by the "parse" operation earlier in this function
                                    // note2 - we should trigger all child actions of the loop, since there is no way in the loop to indicate the event type associated with actions,
                                    //         and we now specify the event type on the loop action itself
                                    return triggerEvent(null, originalAction.actions, { "$item": item });
                                });
                                return true;
                            });
                            deferred.resolve(subChain);
                        }
                    }
                    break;
                case "set-value":
                    if (parsedAction.data !== undefined && parsedAction.data.key !== undefined) {
                        StoreFactory.set(parsedAction.data.key, parsedAction.data.value, $data).then(function () {
                            _success(parsedAction.data.value);
                        }).catch(function (error) {
                            _error(error);
                        });
                    } else {
                        _error("Missing data.");
                    }
                    break;
                case "enable-geofence":
                    try {
                        GeofenceFactory
                            .start(parsedAction.data.name)
                            .then(function () {
                                _success($data);
                            }, function (error) {
                                _error(error);
                            });
                    } catch (err) {
                        _error(err);
                    }
                    break;
                case "disable-geofence":
                    try {
                        GeofenceFactory
                            .stop(parsedAction.data.name)
                            .then(function () {
                                _success($data);
                            }, function (error) {
                                _error(error);
                            });
                    } catch (err) {
                        _error("Could not stop the geofence:", err);
                    }
                    break;
                case "debounce":
                    if (debounce !== null) {
                        clearTimeout(debounce);
                    }
                    debounce = setTimeout(function () {
                        debounce = null;
                        _success($data);
                    }, parsedAction.data.duration);
                    break;
                case "search-list":
                    (function () {
                        var pageName = parsedAction.data.page;
                        var listName = parsedAction.data.list;
                        var searchWithin = parsedAction.data.searchWithin;
                        try {
                            if (searchWithin === "custom") {
                                var searchCriteria = parsedAction.data.criteria || {};
                                ListFactory.setListSearchState(pageName, listName, "advanced", searchCriteria);
                            } else {
                                var searchTerm = (parsedAction.data.term !== null || parsedAction.data.term !== undefined)
                                    ? parsedAction.data.term.toString()
                                    : "";
                                ListFactory.setListSearchState(pageName, listName, "simple", searchTerm);
                            }
                            _success($data);
                        } catch (e) {
                            _error(e);
                        }
                    })();
                    break;
                case "sort-list":
                    (function () {
                        var pageName = parsedAction.data.page;
                        var listName = parsedAction.data.list;
                        var orderProperty = parsedAction.data.property;
                        var orderDirection = parsedAction.data.direction;
                        try {
                            ListFactory.setListOrderState(pageName, listName, orderProperty, orderDirection);
                            _success($data);
                        } catch (e) {
                            _error(e);
                        }
                    })();
                    break;
                case "set-list-page":
                    (function () {
                        var pageName = parsedAction.data.page;
                        var listName = parsedAction.data.list;
                        var pageToGoTo = (parsedAction.data.goToPage === "number")
                            ? parseInt(parsedAction.data.number) || 1
                            : parsedAction.data.goToPage;
                        try {
                            ListFactory.setListPaginationState(pageName, listName, pageToGoTo);
                            _success($data);
                        } catch (e) {
                            _error(e);
                        }
                    })();
                    break;
                case "reset-list":
                    (function () {
                        var pageName = parsedAction.data.page;
                        var listName = parsedAction.data.list;
                        var resetSearch = parsedAction.data.resetSearch;
                        var resetOrder = parsedAction.data.resetOrder;
                        var resetPagination = parsedAction.data.resetPagination;
                        try {
                            ListFactory.resetListState(pageName, listName, resetSearch, resetOrder, resetPagination);
                            _success($data);
                        } catch (e) {
                            _error(e);
                        }
                    })();
                    break;
                case "log":
                    switch (parsedAction.data.level) {
                        case "error":
                            // eslint-disable-next-line no-console
                            console.error(parsedAction.data.message);
                            break;
                        case "warn":
                            // eslint-disable-next-line no-console
                            console.warn(parsedAction.data.message);
                            break;
                        case "info":
                            // eslint-disable-next-line no-console
                            console.info(parsedAction.data.message);
                            break;
                        case "debug":
                            // eslint-disable-next-line no-console
                            console.debug(parsedAction.data.message);
                            break;
                    }
                    _success($data);
                    break;
                case "email-logs":
                    LoggingFactory.emailLogs(parsedAction.data.to, parsedAction.data.subject, parsedAction.data.body, parsedAction.data.includeArchivedLogs);
                    _success($data);
                    break;
                case "set-log-level":
                    var level = parsedAction.data.level;
                    if (level === "fromDataModel") {
                        level = parsedAction.data.levelFromDataModel;
                    }
                    if (parsedAction.data.applyToApp) {
                        LoggingFactory.setRootLogLevel(level, "app");
                    }
                    if (parsedAction.data.applyToClient) {
                        LoggingFactory.setRootLogLevel(level, "client");
                    }
                    if (parsedAction.data.applyToNative) {
                        LoggingFactory.setRootLogLevel(level, "native");
                    }
                    _success($data);
                    break;
                case "set-buffer-size":
                    if (isNaN(parseInt(parsedAction.data.bufferFrequency))) {
                        _success($data);
                    } else {
                        LoggingFactory.setBufferFrequency(parseInt(parsedAction.data.bufferFrequency));
                        _success($data);
                    }
                    break;
                case "configure-logs":
                    var maxFileSize = parsedAction.data.maxFileSizeKilobyte;
                    var numberOfFiles = parsedAction.data.numberOfFiles;
                    var settingsJsonObject = {};
                    var hasProperty = false;
                    if (maxFileSize !== undefined) {
                        if (!isNaN(parseInt(maxFileSize))) {
                            settingsJsonObject.maxFileSize = parseInt(maxFileSize) * 1000;
                            hasProperty = true;
                        }
                    }
                    if (numberOfFiles !== undefined) {
                        if (!isNaN(parseInt(numberOfFiles))) {
                            settingsJsonObject.maxNumberOfFiles = parseInt(numberOfFiles);
                            hasProperty = true;
                        }
                    }
                    if (hasProperty) {
                        if (parsedAction.data.applyToApp) {
                            LoggingFactory.configure(settingsJsonObject, "app");
                        }
                        if (parsedAction.data.applyToClient) {
                            LoggingFactory.configure(settingsJsonObject, "client");
                        }
                        if (parsedAction.data.applyToNative) {
                            LoggingFactory.configure(settingsJsonObject, "native");
                        }
                    }
                    _success($data);
                    break;
                case "search-data-grid":
                    (function () {
                        var pageName = parsedAction.data.page;
                        var dataGridName = parsedAction.data.dataGrid;
                        var searchTerm = (parsedAction.data.term !== null || parsedAction.data.term !== undefined)
                            ? parsedAction.data.term.toString()
                            : "";
                        try {
                            var ctDataGrid = $injector.get("ctDataGrid");
                            ctDataGrid.setDataGridSearchState(pageName, dataGridName, searchTerm);
                            _success($data);
                        } catch (e) {
                            _error(e);
                        }
                    })();
                    break;
                case "sort-data-grid":
                    (function () {
                        var pageName = parsedAction.data.page;
                        var dataGridName = parsedAction.data.dataGrid;
                        var orderColumn = parsedAction.data.column;
                        var orderDirection = parsedAction.data.direction;
                        try {
                            var ctDataGrid = $injector.get("ctDataGrid");
                            ctDataGrid.setDataGridOrderState(pageName, dataGridName, orderColumn, orderDirection);
                            _success($data);
                        } catch (e) {
                            _error(e);
                        }
                    })();
                    break;
                case "set-data-grid-page":
                    (function () {
                        var pageName = parsedAction.data.page;
                        var dataGridName = parsedAction.data.dataGrid;
                        var pageToGoTo = (parsedAction.data.goToPage === "number")
                            ? parseInt(parsedAction.data.number) || 1
                            : parsedAction.data.goToPage;
                        try {
                            var ctDataGrid = $injector.get("ctDataGrid");
                            ctDataGrid.setDataGridPaginationState(pageName, dataGridName, pageToGoTo);
                            _success($data);
                        } catch (e) {
                            _error(e);
                        }
                    })();
                    break;
                case "reset-data-grid":
                    (function () {
                        var pageName = parsedAction.data.page;
                        var dataGridName = parsedAction.data.dataGrid;
                        var resetSearch = parsedAction.data.resetSearch;
                        var resetOrder = parsedAction.data.resetOrder;
                        var resetPagination = parsedAction.data.resetPagination;
                        try {
                            var ctDataGrid = $injector.get("ctDataGrid");
                            ctDataGrid.resetDataGridState(pageName, dataGridName, resetSearch, resetOrder, resetPagination);
                            _success($data);
                        } catch (e) {
                            _error(e);
                        }
                    })();
                    break;
                case "start-data-grid-edits":
                    (function () {
                        var pageName = parsedAction.data.page;
                        var dataGridName = parsedAction.data.dataGrid;
                        var items = parsedAction.data.items;
                        var indexes = parsedAction.data.indexes;
                        try {
                            var ctDataGrid = $injector.get("ctDataGrid");
                            ctDataGrid.startEditMode(pageName, dataGridName, items, indexes);
                            _success($data);
                        } catch (e) {
                            _error(e);
                        }
                    })();
                    break;
                case "finish-data-grid-edits":
                    (function () {
                        var pageName = parsedAction.data.page;
                        var dataGridName = parsedAction.data.dataGrid;
                        try {
                            var ctDataGrid = $injector.get("ctDataGrid");
                            var changes = ctDataGrid.finishEditMode(pageName, dataGridName);
                            _success(changes);
                        } catch (e) {
                            _error(e);
                        }
                    })();
                    break;
                case "enable-logging":
                    LoggingFactory.enableDisableLogging(true);
                    _success($data);
                    break;
                case "disable-logging":
                    LoggingFactory.enableDisableLogging(false);
                    _success($data);
                    break;
                case "enable-destination":
                    if (parsedAction.data.applyToApp) {
                        LoggingFactory.enableDisableDestination(true, "app");
                    }
                    if (parsedAction.data.applyToClient) {
                        LoggingFactory.enableDisableDestination(true, "client");
                    }
                    if (parsedAction.data.applyToNative) {
                        LoggingFactory.enableDisableDestination(true, "native");
                    }
                    _success($data);
                    break;
                case "disable-destination":
                    if (parsedAction.data.applyToApp) {
                        LoggingFactory.enableDisableDestination(false, "app");
                    }
                    if (parsedAction.data.applyToClient) {
                        LoggingFactory.enableDisableDestination(false, "client");
                    }
                    if (parsedAction.data.applyToNative) {
                        LoggingFactory.enableDisableDestination(false, "native");
                    }
                    _success($data);
                    break;
                case "zip-logs":
                    LoggingFactory.zipLogs(parsedAction.data.includeArchivedLogs)
                        .then(function (path) {
                            $data.zipFileInfo = {
                                "zipPath": path
                            };
                            _success($data);
                        });
                    break;
                case "start-vibration":
                    if (parsedAction.data.pattern !== "none") {
                        var patternArray;
                        if (parsedAction.data.pattern === "custom") {
                            if (parsedAction.data.customPattern !== "") {
                                patternArray = parsedAction.data.customPattern.split(",");
                            }
                        } else {
                            patternArray = parsedAction.data.pattern.split(",");
                        }
                        if (patternArray) {
                            if (parsedAction.data.continuous === true || parsedAction.data.patternIterations !== "") {
                                VibrateFactory.vibratePattern(patternArray, parseInt(parsedAction.data.patternIterations), parsedAction.data.continuous, parsedAction.data.force);
                            }
                        }
                    } else {
                        if (parsedAction.data.continuous === true || parsedAction.data.duration !== "") {
                            VibrateFactory.vibrate(parseInt(parsedAction.data.duration), parsedAction.data.continuous, parsedAction.data.force);
                        }
                    }
                    _success($data);
                    break;
                case "stop-vibration":
                    VibrateFactory.stopVibration();
                    _success($data);
                    break;
                case "common-log-in":
                    (function () {
                        
                        var BaseLayerFactory = $injector.get("BaseLayerFactory");
                        
                        var layerName = parsedAction.data.layer;
                        if (!layerName) {
                            _error("No instance selected");
                            return;
                        }
                        
                        var layer = BaseLayerFactory.getByName(layerName);
                        if (!layer) {
                            _error("Instance '" + layerName + "' not found");
                            return;
                        }
                        
                        var $success = function (result, data) {
                            if (parsedAction.actions !== undefined && parsedAction.actions.length > 0) {
                                triggerEvent("login-success", parsedAction.actions, result);
                            }
                            _success(data);
                        };
                        var $fail = function (result, data) {
                            if (parsedAction.actions !== undefined && parsedAction.actions.length > 0) {
                                triggerEvent("login-failure", parsedAction.actions, result);
                            }
                            _success(data);
                        };
                        
                        layer.on("login-result", function (result) {
                            
                            if (result.success) {
                                $success(result, $data);
                            } else {
                                $fail(result, $data);
                            }
                        }, true);
                        
                        if (parsedAction.data.adlogin && Platform.getType() !== "desktop") {
                            _error("Active Directory login only available on Windows Desktop", null, true);
                            return;
                        }
                        
                        var sspiPlugin = Plugin.getSource("sspiclient");
                        if (parsedAction.data.adlogin && (!sspiPlugin || sspiPlugin.Helper === undefined)) {
                            _error("Active Directory login only available on Windows Desktop", null, true);
                            return;
                        }
                        
                        if (parsedAction.data.adlogin) {

                            sspiPlugin.Helper.getUserPrincipalName(function (ADUsername) {

                                layer.login(ADUsername, parsedAction.data.adTokenPlaceholder);

                            }, _error);
                            
                        } else {
                            layer.login(parsedAction.data.username, parsedAction.data.password);
                        }
                    })();
                    break;
                case "common-log-out":
                    (function () {
                        
                        var BaseLayerFactory = $injector.get("BaseLayerFactory");
                        
                        var layerName = parsedAction.data.layer;
                        if (!layerName) {
                            _error("No instance selected");
                            return;
                        }
                        
                        var layer = BaseLayerFactory.getByName(layerName);
                        if (!layer) {
                            _error("Instance '" + layerName + "' not found");
                            return;
                        }
                        
                        layer.on("logout-result", function (result) {
                            
                            if (result.success) _success($data);
                            else _error(result.exception);
                        }, true);
                        
                        layer.emit("request-logout");
                        
                    })();
                    break;
                case "common-change-theme":
                    (function () {
                        
                        var BaseLayerFactory = $injector.get("BaseLayerFactory");
                        
                        var layerName = parsedAction.data.layer;
                        if (!layerName) {
                            _error("No instance selected");
                            return;
                        }
                        
                        var layer = BaseLayerFactory.getByName(layerName);
                        if (!layer) {
                            _error("Instance '" + layerName + "' not found");
                            return;
                        }
                        
                        layer.emit("request-theme-change", parsedAction.data.themeName);
                    })();
                    break;
                case "common-launch-alert":
                    (function () {
                        
                        var BaseLayerFactory = $injector.get("BaseLayerFactory");
                        
                        var layerName = parsedAction.data.layer;
                        if (!layerName) {
                            _error("No instance selected");
                            return;
                        }
                        
                        var layer = BaseLayerFactory.getByName(layerName);
                        if (!layer) {
                            _error("Instance '" + layerName + "' not found");
                            return;
                        }
                        
                        var suspendActionflow = parsedAction.data.suspendActionflow === true;
                        
                        var buttonClicked = function (data, acknowledged) {
                            
                            if (acknowledged) {
                                triggerEvent("acknowledged", parsedAction.actions, data);
                            }
                            
                            if (suspendActionflow) {
                                _success(data);
                            }
                        };
                        
                        var buttons = [];
                        
                        if (parsedAction.data.alertType === "question") {
                            buttons = [
                                {
                                    text: parsedAction.data.noButtonLabel || "No",
                                    action: function () {
                                        buttonClicked($data, false);
                                    },
                                    type: "primary"
                                },
                                {
                                    text: parsedAction.data.yesButtonLabel || "Yes",
                                    action: function () {
                                        buttonClicked($data, true);
                                    },
                                    type: "primary"
                                }
                            ];
                        } else {
                            buttons = [
                                {
                                    text: parsedAction.data.buttonLabel || "Okay",
                                    action: function () {
                                        buttonClicked($data, true);
                                    },
                                    type: "primary"
                                }
                            ];
                        }
                        
                        var alertId = parsedAction.data.alertId || parsedAction._auto_id_;
                        var priority = parsedAction.data.alertPrioirty || 3;
                        
                        if (parsedAction.data.alertId) {
                            
                            // close any other alert with the same ID
                            layer.emit("request-close-alert", parsedAction.data.alertId);
                        }
                        
                        var alertData = {
                            id: alertId,
                            raisedOn: new Date().getTime(),
                            priority: priority,
                            type: parsedAction.data.alertType,
                            title: parsedAction.data.alertTitle,
                            body: parsedAction.data.alertMessage,
                            buttons: buttons
                        };
                        
                        layer.emit("request-raise-alert", alertData);
                        
                        if (!suspendActionflow) {
                            
                            _success($data);
                        }
                    })();
                    break;
                case "il-generate-report":
                    (function () {
                        
                        var IncidentLayerFactory = $injector.get("IncidentLayerFactory");
                        
                        var incidentLayerName = parsedAction.data.layer;
                        if (!incidentLayerName) {
                            _error("No Incident instance selected");
                            return;
                        }
                        
                        var incidentLayer = IncidentLayerFactory.getByName(incidentLayerName);
                        if (!incidentLayer) {
                            _error("Incident instance '" + incidentLayerName + "' not found");
                            return;
                        }
                        
                        if (!incidentLayer.config.reporting || !incidentLayer.config.reporting.enabled) {
                            _error("The selected Incident instance does not have reporting enabled");
                            return;
                        }
                        
                        var type = parsedAction.data.reportType || "";
                        var start = new Date(parsedAction.data.startDate || "");
                        var end = new Date(parsedAction.data.endDate || "");
                        var notify = parsedAction.data.notify || false;
                        
                        var matchingReportType = (incidentLayer.config.reporting.reportTypes || []).find(function (x) {
                            return type === x.id;
                        });
                        
                        if (!matchingReportType) {
                            _error("The specified report type '" + type + "' does not exist in the selected Incident instance configuration");
                            return;
                        }
                        
                        if (isNaN(start.getTime())) {
                            _error("The specified start date '" + start + "' is not a valid date string");
                            return;
                        }
                        
                        if (isNaN(end.getTime())) {
                            _error("The specified start date '" + end + "' is not a valid date string");
                            return;
                        }
                        
                        start.setHours(0, 0, 0, 0); // start of day
                        end.setHours(23, 59, 59, 999); // end of day
                        
                        var reportData = {
                            type: matchingReportType.id,
                            startDate: start.getTime(),
                            endDate: end.getTime(),
                            notify: notify
                        };
                        
                        incidentLayer.emit("request-generate-report", reportData);
                        
                        _success($data);
                    })();
                    break;
                case "pg-create-new-page":
                    (function () {
                        
                        var PagerLayerFactory = $injector.get("PagerLayerFactory");
                        
                        var pagerLayerName = parsedAction.data.layer;
                        if (!pagerLayerName) {
                            _error("No pager instance selected");
                            return;
                        }
                        
                        var pagerLayer = PagerLayerFactory.getByName(pagerLayerName);
                        if (!pagerLayer) {
                            _error("pager instance '" + pagerLayerName + "' not found");
                            return;
                        }
                        
                        pagerLayer.createNewPage();
                    })();
                    break;
                case "um-fetch-users":
                    (function () {
                        
                        var userManagementLayerFactory = $injector.get("UserManagementLayerFactory");
                        
                        var layerName = parsedAction.data.layer;
                        if (!layerName) {
                            _error("No user management instance selected");
                            return;
                        }
                        
                        var umLayer = userManagementLayerFactory.getByName(layerName);
                        if (!umLayer) {
                            _error("User Management instance '" + umLayer + "' not found");
                            return;
                        }
                        
                        umLayer.fetchAllUsers().then(_success());
                    })();
                    break;
                case "um-fetch-groups":
                    (function () {
                        
                        var userManagementLayerFactory = $injector.get("UserManagementLayerFactory");
                        
                        var layerName = parsedAction.data.layer;
                        if (!layerName) {
                            _error("No user management instance selected");
                            return;
                        }
                        
                        var umLayer = userManagementLayerFactory.getByName(layerName);
                        if (!umLayer) {
                            _error("User Management instance '" + umLayer + "' not found");
                            return;
                        }
                        
                        umLayer.fetchAllGroups().then(_success());
                    })();
                    break;
                case "um-open-import-modal":
                    (function () {
                        
                        var userManagementLayerFactory = $injector.get("UserManagementLayerFactory");
                        
                        var layerName = parsedAction.data.layer;
                        if (!layerName) {
                            _error("No user management instance selected");
                            return;
                        }
                        
                        var umLayer = userManagementLayerFactory.getByName(layerName);
                        if (!umLayer) {
                            _error("User Management instance '" + umLayer + "' not found");
                            return;
                        }
                        
                        umLayer.openImportModal();
                    })();
                    break;
                case "um-open-users-modal":
                    (function () {
                        
                        var userManagementLayerFactory = $injector.get("UserManagementLayerFactory");
                        
                        var layerName = parsedAction.data.layer;
                        if (!layerName) {
                            _error("No user management instance selected");
                            return;
                        }
                        
                        var umLayer = userManagementLayerFactory.getByName(layerName);
                        if (!umLayer) {
                            _error("User Management instance '" + umLayer + "' not found");
                            return;
                        }
                        
                        umLayer.openUsersModal();
                    })();
                    break;
                case "um-open-groups-modal":
                    (function () {
                        
                        var userManagementLayerFactory = $injector.get("UserManagementLayerFactory");
                        
                        var layerName = parsedAction.data.layer;
                        if (!layerName) {
                            _error("No user management instance selected");
                            return;
                        }
                        
                        var umLayer = userManagementLayerFactory.getByName(layerName);
                        if (!umLayer) {
                            _error("User Management instance '" + umLayer + "' not found");
                            return;
                        }
                        
                        umLayer.openGroupsModal();
                    })();
                    break;
                case "um-open-menu":
                    (function () {
                        
                        var userManagementLayerFactory = $injector.get("UserManagementLayerFactory");
                        
                        var layerName = parsedAction.data.layer;
                        if (!layerName) {
                            _error("No user management instance selected");
                            return;
                        }
                        
                        var umLayer = userManagementLayerFactory.getByName(layerName);
                        if (!umLayer) {
                            _error("User Management instance '" + umLayer + "' not found");
                            return;
                        }
                        
                        if ($data && $data.target) {
                            
                            umLayer.openContainerMenu($data.target);
                        } else {
                            
                            umLayer.openContainerMenu();
                        }
                    })();
                    break;
                default:
                    _error("Invalid action type specified.");
            }
            return deferred.promise;
        };
    }
    
    if (window.cti.utils === undefined) {
        window.cti.utils = {};
    }
    
    window.cti.utils.callAction = function (type, data, expressions, callback) {
        call({
            type: type,
            data: data,
            expressions: expressions
        })()
            .then(function (result) {
                if (callback !== undefined) {
                    callback(result);
                }
            });
        
    };
    
    window.cti.utils.callActionflow = function (name, $data) {
        
        return call({
            type: "call-actionflow",
            data: { name: name }
        }, $data)();
    };
    
    window.cti.utils.updatePage = function () {
        if (!$rootScope.$$phase) {
            $rootScope.$apply();
        }
    };
    
    window.cti.utils.triggerStoreChanged = function () {
        $rootScope.$broadcast("StoreChanged");
    };
    
    window.cti.utils.getPreferencesItem = function (name) {
        if (SchemaHelper.schema["metadata"] !== undefined) {
            var metadata = SchemaHelper.schema["metadata"];
            
            if (metadata[name] !== undefined) {
                return metadata[name];
            }
        }
        return undefined;
    };
    
    window.cti.utils.destroyAllData = function () {
        StoreFactory.destroyAllData();
    };
    
    window.cti.utils.destroyPageData = function (pageName) {
        StoreFactory.destroyPageData(pageName);
    };
    
    window.cti.utils.stopAllRecording = function () {
        document.dispatchEvent(new CustomEvent("stop-all-recording"));
    };
    
    if (window.cti.utils.logging === undefined) {
        window.cti.utils.logging = {};
    }
    
    window.cti.utils.logging.enableLogging = function () {
        LoggingFactory.enableDisableLogging(true);
    };
    
    window.cti.utils.logging.disableLogging = function () {
        LoggingFactory.enableDisableLogging(false);
    };
    
    window.cti.utils.logging.enableDestination = function (destination) {
        LoggingFactory.enableDisableDestination(true, destination);
    };
    
    window.cti.utils.logging.disableDestination = function (destination) {
        LoggingFactory.enableDisableDestination(false, destination);
    };
    
    window.cti.utils.logging.setRootLogLevel = function (level, destination) {
        LoggingFactory.setRootLogLevel(level, destination);
    };
    
    window.cti.utils.logging.getRootLogLevel = function (destination, callback) {
        LoggingFactory.getRootLogLevel(destination)
            .then(function (level) {
                callback(null, level);
            })
            .catch(function (err) {
                callback(err);
            });
    };
    
    window.cti.utils.logging.configure = function (settings, destination) {
        LoggingFactory.configure(settings, destination);
    };
    
    window.cti.utils.logging.zipLogFiles = function (includeArchivedLogs, callback) {
        LoggingFactory.zipLogs(includeArchivedLogs)
            .then(function (path) {
                callback(null, path);
            })
            .catch(function (err) {
                callback(err);
            });
    };
    
    window.cti.utils.logging.emailLogs = function (to, subject, body, includeArchivedLogs) {
        LoggingFactory.emailLogs(to, subject, body, includeArchivedLogs);
    };
    
    window.cti.utils.logging.makeFilesPublic = function (paths, callback) {
        LoggingFactory.makeFilesPublic(paths)
            .then(function (pathsOut) {
                callback(null, pathsOut);
            })
            .catch(function (err) {
                callback(err);
            });
    };
    
    window.cti.utils.logging.removePublicFiles = function () {
        LoggingFactory.removePublicFiles();
    };
    
    window.cti.utils.logging.getLogFilePaths = function (callback) {
        LoggingFactory.getLogFilePaths()
            .then(function (paths) {
                callback(null, paths);
            })
            .catch(function (err) {
                callback(err);
            });
    };
    
    window.cti.utils.logging.getArchivedLogFilePaths = function (callback) {
        LoggingFactory.getArchivedLogFilePaths()
            .then(function (paths) {
                callback(null, paths);
            })
            .catch(function (err) {
                callback(err);
            });
    };
    
    window.cti.utils.logging.isLoggingEnabled = function (callback) {
        LoggingFactory.isLoggingEnabled()
            .then(function (enabled) {
                callback(null, enabled);
            })
            .catch(function (err) {
                callback(err);
            });
    };
    
    window.cti.utils.logging.isDestinationEnabled = function (callback) {
        LoggingFactory.isDestinationEnabled()
            .then(function (enabled) {
                callback(null, enabled);
            })
            .catch(function (err) {
                callback(err);
            });
    };
    
    return service;
    
}]);

angular.module("app.core").factory("Url", ["$http", "$log", "$q", "StoreFactory", function ($http, $log, $q, StoreFactory) {

    function Url(name, url, target, params) {
        this.name = name;
        this.url = url;
        this.target = target;
        this.params = params;
    }

    Url.prototype = {
        makeRequest: function (target, params) {
            var deferred = $q.defer();
            var url = this.url;
            var request = {
                "url": url
            };
            request.target = (target != undefined) ? target : this.target;
            // Merge with API defaults
            params = Url.merge(this.params, params);
            if (params != undefined) {
                request.params = StoreFactory.parse(params);
            }
            request.url = StoreFactory.parseUrl(request.url, request.params);
            if (request.target !== "popup") {
                window.open(request.url, request.target);
            } else {
                window.open(request.url, "popup", "location=no,height=800,width=600");
            }
            return deferred.promise;
        }
    };

    Url.merge = function (slave, master) {
        var result = {};
        if (slave != undefined) {
            result = slave;
        }
        if (master != undefined) {
            angular.forEach(master, function (value, key) {
                if (typeof value != "object") {
                    result[key] = value;
                } else {
                    if (result[key] == undefined) {
                        result[key] = {};
                    }
                    result[key] = Url.merge(result[key], value);
                }
            });
        }
        return result;
    };

    return Url;

}]);
angular.module("app.core").factory("UrlFactory", ["$http", "$log", "StoreFactory", "$timeout", "$q", "Url", function ($http, $log, StoreFactory, $timeout, $q, Url) {

    var _urls = {};
    var service = {
        "init": init,
        "makeRequest": makeRequest
    };

    function init(item) {
        _urls[item.name] = new Url(item.name, item.url, item.target, item.params);
    }

    function makeRequest(request) {
        var deferred = $q.defer();
        var name = request.name;
        if (_urls[name] != undefined) {
            _urls[name].makeRequest(request.target, request.params).then(function () {
                deferred.resolve();
            }).catch(function () {
                deferred.reject();
            });
        }
        return deferred.promise;
    }

    return service;

}]);
angular.module("app.core").factory("Timer", ["$timeout", "$interval", "ActionFactory", function ($timeout, $interval, ActionFactory) {

    function Timer(name, type, time, actions) {
        this.timerFunction = null;
        this.name = name;
        this.type = type;
        this.time = parseInt(time);
        this.actions = actions;
    }

    Timer.prototype = {
        start: function () {
            var actions = this.actions;
            if (this.type == "delay") {
                $timeout(function () {
                    ActionFactory.triggerEvent(null, actions);
                }, (this.time));
            } else if (this.type == "interval") {
                this.timerFunction = $interval(function () {
                    ActionFactory.triggerEvent(null, actions);
                }, (this.time));
            }
        },
        stop: function () {
            if (this.type == "interval" && this.timerFunction != null) {
                $interval.cancel(this.timerFunction);
            }
        }
    };

    return Timer;

}]);
angular.module("app.core").factory("Variable", ["$q", "StoreFactory", function ($q, StoreFactory) {

    function Variable(name, type, value) {
        this.name = name;
        this.type = type;
        this.set(value);
    }

    Variable.prototype = {
        set: function (newValue) {
            var deferred = $q.defer();
            if (newValue != undefined) {
                if (typeof newValue == "string" && newValue.indexOf("{{") > -1) {
                    newValue = StoreFactory.parse(newValue);
                }
                if (this.name != undefined) {
                    var value = null;
                    switch (this.type) {
                        case "date":
                            value = Date.parse(newValue);
                            break;
                        case "string":
                            value = newValue;
                            break;
                        case "int":
                            value = parseInt(newValue);
                            break;
                        case "boolean":
                            value = (newValue == "true" || newValue == "1");
                            break;
                    }
                    this.value = window.cti.store.variables[this.name] = value;
                    deferred.resolve(value);
                } else {
                    deferred.reject("Variable must have a name");
                }
            } else {
                deferred.resolve();
            }
            return deferred.promise;
        }
    };

    return Variable;

}]);
angular
    .module("app.core")
    .factory("VariableFactory", ["Variable", "$q", function (Variable, $q) {
        
        var _variables = {};
        
        function init(item) {
            
            _variables[item.name] = new Variable(item.name, item["variable-type"], item.value);
        }
        
        function setVariable(variableName, value) {
            
            var deferred = $q.defer();
            
            if (_variables[variableName] !== undefined) {
                
                var variable = _variables[variableName];
                variable
                    .set(value || defaultValue(variable))
                    .then(function (result) {
                        deferred.resolve(result);
                    })
                    .catch(function (error) {
                        deferred.reject(error);
                    });
                
            } else {
                
                deferred.reject("Cannot find variable \"" + variableName + "\"");
            }
            
            return deferred.promise;
        }
        
        function defaultValue(variable) {
            
            switch (variable.type) {
                case "date":
                    return "1970";
                case "string":
                    return "";
                case "int":
                    return "0";
                case "boolean":
                    return "false";
            }
            
            return "";
        }
        
        return {
            "init": init,
            "setVariable": setVariable
        };
    }]);
angular.module("app.core").factory("Camera", ["StoreFactory", "$log", "$q", "Plugin", "FileSystem", "Platform", function (StoreFactory, $log, $q, Plugin, FileSystem, Platform) {
    var service = {
        "takePhoto": takePhoto,
        "selectPhoto": selectPhoto,
        "recordVideo": recordVideo
    };

    function takePhoto(quality, direction, targetWidth, targetHeight, encoding, allowEdit, saveToPhotoAlbum) {
        return getImage(1, quality, direction, targetWidth, targetHeight, encoding, allowEdit, saveToPhotoAlbum).then(function (imageURI) {
            var deferred = $q.defer();
            var onError = function (error) {
                deferred.reject(error);
            };
            if (imageURI.length == 0) {
                onError("image path returned empty");
            }
            window.resolveLocalFileSystemURL(imageURI, function (entry) {
                var d = new Date();
                var n = d.getTime();
                // New file name
                var newFileName = n + ".jpg";
                FileSystem.getStorage().then(function (directory) {
                    entry.moveTo(directory, newFileName, function (fileEntry) {
                        fileEntry.file(function (file) {
                            deferred.resolve(file.localURL);
                        }, onError);
                    }, onError);
                }).catch(onError);
            }, onError);
            return deferred.promise;
        });
    }

    function selectPhoto() {
        return getImage(0);
    }

    function recordVideo(maxDuration, quality) {
        var deferred = $q.defer();
        var onError = function (error) {
            if (error !== undefined) {
                $log.error(error);
            }
            deferred.reject(error);
        };
        var isDesktop = Platform.getType() === "desktop";
        if (isDesktop) {
            FileSystem.selectFile(["video/mp4"]).then(function (videoURI) {
                deferred.resolve(videoURI);
            }).catch(function () {
                onError();
            });
        } else {
            var captureSuccess = function (mediaFiles) {
                if (mediaFiles.length > 0) {
                    deferred.resolve(mediaFiles[0].fullPath);
                }
            };
            var captureError = function (error) {
                deferred.reject(error);
            };
            var options = {};
            options.limit = 1;
            options.quality = quality;
            if (maxDuration > 0) {
                options.duration = maxDuration;
            }
            navigator.device.capture.captureVideo(captureSuccess, captureError, options);
        }
        return deferred.promise;
    }

    function getImage(sourceType, quality, direction, targetWidth, targetHeight, encoding, allowEdit, saveToPhotoAlbum) {
        var deferred = $q.defer();

        var onError = function (error) {
            if (error !== undefined) {
                $log.error(error);
            }
            deferred.reject(error);
        };
        var isDesktop = Platform.getType() === "desktop";
        if (isDesktop) {
            FileSystem.selectFile(["image/jpeg", "image/png", "image/gif"]).then(function (imageURI) {
                deferred.resolve(imageURI);
            }).catch(function () {
                onError();
            });
        } else {
            if (sourceType == 1) {
                var source = Plugin.getSource("camera");
                var options = {
                    quality: quality || 50,
                    cameraDirection: direction || 0,
                    destinationType: 1, // 0 = DATA_URL, 1 = FILE_URI, 2 = NATIVE_URI
                    sourceType: sourceType, // 0 = PHOTOLIBRARY, 1 = CAMERA, 2 = SAVEDPHOTOALBUM
                    allowEdit: allowEdit || false,
                    encodingType: encoding || 0, // 0 = JPEG, 1 = PNG
                    saveToPhotoAlbum: saveToPhotoAlbum || false,
                    correctOrientation: true
                };
                if (targetWidth > 0 && targetHeight > 0) {
                    options.targetWidth = targetWidth;
                    options.targetHeight = targetHeight;
                }
                source.getPicture(function (imageURI) {
                    deferred.resolve(imageURI);
                }, onError, options);
            } else {
                var fileimporter = Plugin.getSource("fileimporter");
                if (fileimporter !== false) {
                    fileimporter.importPicture(function (filePath) {
                        deferred.resolve(filePath);
                    });
                } else {
                    onError();
                }
            }

        }
        return deferred.promise;
    }

    return service;
}]);

angular.module("app.core").factory("Auth", ["$q", "Plugin", function ($q, Plugin) {

    var service = {
        "authenticate": authenticate
    };

    var authentication = false;

    var justAuthenticated = false;

    function isAvailable() {
        var deferred = $q.defer();
        authentication = Plugin.getSource("authentication");
        if (authentication !== false) {
            deferred.resolve();
        } else {
            deferred.reject("No authentication method available.");
        }
        return deferred.promise;
    }

    function authenticate(message) {
        var deferred = $q.defer();

        if (justAuthenticated) {
            justAuthenticated = false;
            return;
        }

        var text = (message !== undefined) ? message : "Authentication Required";
        isAvailable().then(function () {
            authentication.authenticate(text, "infinity", "7OHHxYvRuG1PBlGJi2LXULqMrOKcS64S", function () {
                deferred.resolve();
            }, function () {
                deferred.reject("Authentication failed");
            });
            justAuthenticated = true;
        }).catch(function () {
            deferred.resolve();
        });

        // eslint-disable-next-line consistent-return
        return deferred.promise;
    }

    return service;
}]);

/* Copyright  CommonTime Ltd. 2016 */
angular
    .module("app.core")
    .factory("Notification", serviceFunc);

function serviceFunc($q, $log, StoreFactory, toastr, SchemaHelper, $injector, Plugin, TranslationService, Platform) {

    var service = {
        "call": call,
        "init": init
    };

    function init(schema) {
        var pushHandler = function (data) {
            $log.debug("[notification.fct.js] Push received:", data);
            // Get all push actions
            if (schema.config !== undefined && schema.config.length > 0) {
                var ActionFactory = $injector.get("ActionFactory");
                schema.config.forEach(function (item) {
                    // We only want to deal with voip-push-event items
                    if (item["item-type"] == "push-event") {
                        // Convert the push notification data into a model for evaluation
                        var model = {
                            "$notification": data
                        };

                        var result = true;
                        if (item.operations.length > 0) {
                            // Evaluate the operations to determine if we need to execute the actions
                            result = ActionFactory.evalOperations(item.operations, model);
                        }
                        if (result === true) {
                            // Event operations passed so lets run the associated events
                            ActionFactory.triggerEvent("push-received", item.actions, model);
                        }
                    }
                });
            }
        };

        var voipPushHandler = function (data) {
            $log.debug("[notification.fct.js] Push received:", data);
            // Get all push actions
            if (schema.config !== undefined && schema.config.length > 0) {
                var ActionFactory = $injector.get("ActionFactory");
                schema.config.forEach(function (item) {
                    // We only want to deal with push-event items
                    if (item["item-type"] == "voip-push-event") {
                        // Convert the push notification data into a model for evaluation
                        var model = {
                            "$notification": data
                        };

                        var result = true;
                        if (item.operations.length > 0) {
                            // Evaluate the operations to determine if we need to execute the actions
                            result = ActionFactory.evalOperations(item.operations, model);
                        }
                        if (result === true) {
                            // Event operations passed so lets run the associated events
                            ActionFactory.triggerEvent("voip-push-received", item.actions, model);
                        }
                    }
                });
            }
        };

        if (window.device !== undefined && window.device.platform !== undefined && schema !== undefined && schema.settings !== undefined && schema.settings["push-notifications"] !== undefined) {
            var settings = schema.settings["push-notifications"];
            var config = null;
            switch (window.device.platform.toLowerCase()) {
                case "android":
                    if (settings.android !== undefined && settings.android.enabled === true) {
                        config = {
                            "senderID": settings.android.id
                        };
                    }
                    break;
                case "win32nt":
                    if (settings.wp !== undefined && settings.wp.enabled === true) {
                        config = {
                            "channelName": settings.wp.channelName
                        };
                    }
                    break;
                case "ios":
                    if (settings.ios !== undefined && settings.ios.enabled === true) {
                        config = {
                            "badge": "true",
                            "sound": "true",
                            "alert": "true"
                        };
                    }
                    break;
            }
            if (config !== null) {
                var NotificationPlugin = Plugin.getSource("notification");
                if (NotificationPlugin !== false) {
                    // Listen for push notifications incoming
                    NotificationPlugin.on("pushReceived", pushHandler);
                    $log.debug("Registering for push notifications...");
                    NotificationPlugin.registerForPush(function (token) {
                        $log.debug("Registered for push:", token);
                        // Set the token in the model so it can be used later in the app
                        StoreFactory.set("notification.token", token);
                    }, function (error) {
                        $log.error("Error registering for push:", error);
                    }, config);
                }
            }
            if (settings.ios.voipEnabled) {
                if (Platform.getName() === "ios") {
                    var voipPushPlugin = Plugin.getSource("VoIPPushNotification");
                    if (voipPushPlugin !== false) {
                        var voipPush = voipPushPlugin.init();
                        voipPush.on("registration", function (data) {
                            $log.debug("Registered for push:", data.deviceToken);
                            // Set the token in the model so it can be used later in the app
                            StoreFactory.set("notification.voipToken", data.deviceToken);
                        });
                        voipPush.on("notification", function (data) {
                            voipPushHandler(data);
                        });
                        voipPush.on("error", function (e) {
                            $log.error(e);
                        });
                    }
                }
            }
        }
    }

    function isAvailable() {
        return (Plugin.getSource("notification") !== false);
    }

    function generateIdFromName(name) {
        var hash = 5381;
        for (var i = 0; i < name.length; i++) {
            var char = name.charCodeAt(i);
            hash = ((hash << 5) + hash) + char;
            /* hash * 33 + c */
        }
        return hash;
    }

    var callbackSet = false;

    function setCallback() {
        var NotificationPlugin = Plugin.getSource("notification");
        if (callbackSet === false && isAvailable()) {
            NotificationPlugin.on("interactedWith", function (notification) {
                var notifications = SchemaHelper.getSchemaConfigItemsByItemType("device-notification");
                if (notifications.length > 0) {
                    var ActionFactory = $injector.get("ActionFactory");
                    angular.forEach(notifications, function (schemaNotification) {
                        if (schemaNotification.name !== undefined && generateIdFromName(schemaNotification.name) == notification.id) {
                            if (schemaNotification.actions !== undefined && schemaNotification.actions.length > 0) {
                                // If no action identifier then the whole notification has been pressed
                                if (notification.actionResponseIdentifier === undefined) {
                                    ActionFactory.triggerEvent("click", schemaNotification.actions, {"$notification": notification});
                                } else {
                                    var event = notification.actionResponseIdentifier + "-interaction-pressed";
                                    ActionFactory.triggerEvent(event, schemaNotification.actions, {"$notification": notification});
                                }
                            }
                        }
                    });
                }
            });
            callbackSet = true;
        }
    }

    function call(data) {
        var deferred = $q.defer();
        if (data.name !== undefined) {
            var notification = SchemaHelper.getSchemaConfigItemByName(data.name);
            if (notification !== undefined) {
                if (notification["item-type"] == "device-notification") {
                    if (isAvailable()) {
                        var NotificationPlugin = Plugin.getSource("notification");

                        var _title = data.title || notification.title;
                        if (_title !== undefined && _title.indexOf("{{") > -1) {
                            _title = StoreFactory.parse(_title);
                        }
                        _title = TranslationService.translate(_title);

                        var text = data.text || notification.text;
                        if (text !== undefined && text.indexOf("{{") > -1) {
                            text = StoreFactory.parse(text);
                        }
                        text = TranslationService.translate(text);

                        var categoryId = data.name + "_category";
                        var config = {
                            id: generateIdFromName(data.name),
                            title: _title,
                            text: text
                        };

                        if (notification.interactions !== undefined && notification.interactions.length > 0) {
                            config.category = {
                                identifier: categoryId,
                                actions: []
                            };
                            notification.interactions.forEach(function (interaction) {
                                var action = {
                                    "title": TranslationService.translate(interaction.label),
                                    "identifier": interaction.name,
                                    "textInput": (interaction.text === true)
                                };
                                config.category.actions.push(action);
                            });
                        }
                        if (data.options.schedule === true && data.options.model !== undefined) {
                            var dateString = StoreFactory.parse(data.options.model);
                            var date = new Date(dateString);
                            if (!isNaN(date.getTime())) {
                                config.at = date.getTime();
                            }
                        }
                        if (data.options.silent && data.options.silent === true) {
                            config.sound = "SILENT";
                        }
                        NotificationPlugin.core.schedule(config, null, null, {
                            "skipPermission": true
                        });

                        setCallback();
                        deferred.resolve();
                    } else {
                        var msg = "Native notifications are not available on this platform.";
                        $log.info(msg);
                        deferred.reject(msg);
                    }
                } else {
                    var type = null;
                    switch (notification.style) {
                        case "success":
                        case "error":
                        case "warning":
                            type = notification.style;
                            break;
                        case "info":
                        default:
                            type = "info";
                    }
                    if (type !== null) {

                        var title = data.title || notification.title || "";
                        if (angular.isString(title) === false && title.toString !== undefined) {
                            title = title.toString();
                        }
                        title = TranslationService.translate(title);

                        var content = data.text || notification.text || "";
                        if (angular.isString(content) === false && content.toString !== undefined) {
                            content = content.toString();
                        }
                        content = TranslationService.translate(content);

                        if (notification.actions !== undefined && notification.actions.length > 0) {
                            var ActionFactory = $injector.get("ActionFactory");
                            notification.options.onHidden = function (closedViaClick) {
                                if (closedViaClick === true) {
                                    ActionFactory.triggerEvent("click", notification.actions);
                                }
                            };
                        }

                        var options = angular.copy(notification.options);

                        // misunderstanding of what this property means; if enabled then remove timeouts for toastr notification
                        if (options.autoDismiss !== true) {
                            options.timeOut = 0;
                            options.extendedTimeOut = 0;
                        }

                        toastr[type](content, title, options);
                        deferred.resolve();
                    }
                }
            } else {
                deferred.reject("Notification with name '" + data.name + "' could not be found in app config.");
            }
        } else {
            deferred.reject("Notification name has not been specified.");
        }
        return deferred.promise;
    }

    return service;

}

angular.module("app.core").factory("IBeaconFactory", ["$injector", "Plugin", "$log", function ($injector, Plugin, $log) {
    var service = {
        "init": init,
        "addBeacon": addBeacon,
        "stopMonitoring": stopMonitoring,
        "stopRanging": stopRanging,
        "startMonitoring": startMonitoring,
        "startRanging": startRanging,
        "startListening": startListening,
        "stopListening": stopListening
    };

    var LocationManagerPlugin = false;

    var ActionFactory = null;
    var beaconsToMonitor = [];
    var beaconsToRange = [];
    var beaconRegions = [];

    var beaconsInRange = [];
    var initialised = false;

    function init() {
        if (!initialised) {

            LocationManagerPlugin = Plugin.getSource("locationManager");

            if (LocationManagerPlugin !== false) {

                try {

                    // Having to manually inject to avoid the Angular circular dependency error - THIS WILL COME BACK TO BITE US (Probably).
                    ActionFactory = $injector.get("ActionFactory");

                    // Request location always
                    LocationManagerPlugin.requestAlwaysAuthorization();

                    LocationManagerPlugin.isBluetoothEnabled()
                        .then(function (isEnabled) {
                            if (!isEnabled) {
                                LocationManagerPlugin.enableBluetooth();
                            }
                        })
                        .fail($log.error)
                        .done();
                } catch (e) {
                    $log.error("Error loading iBeacon plugin", e);
                }

                var delegate = new LocationManagerPlugin.Delegate();

                delegate.didExitRegion = function (pluginResult) {
                    onExitRegion(pluginResult);
                };

                delegate.didRangeBeaconsInRegion = function (pluginResult) {
                    onBeaconInRange(pluginResult);
                };
                // Set the delegate object to use.
                LocationManagerPlugin.setDelegate(delegate);

            } else {
                $log.error("Beacon plugin has not successfully initialised.");
            }
            initialised = true;
        }
    }

    function getSignalStrength(rssi) {
        return Math.round(((255 - Math.abs(rssi)) / 255) * 100);
    }

    function compare(a, b) {
        if (a.signalStrength < b.signalStrength) {
            return 1;
        }
        if (a.signalStrength > b.signalStrength) {
            return -1;
        }
        return 0;
    }

    function onBeaconInRange(pluginResult) {
        var beacon = pluginResult.beacons[0];

        if (beacon === undefined) {
            return;
        }

        var beaconUpdated = false;

        for (var beaconIterA in beaconsInRange) {
            var currentBeacon = beaconsInRange[beaconIterA];
            if (currentBeacon.uuid.toLowerCase() == beacon.uuid.toLowerCase()) {
                var event = beacon.proximity.toLowerCase().replace("proximity", "");
                if (currentBeacon.proximity != beacon.proximity) {
                    beaconsToMonitor.forEach(function (sBeacon) {
                        if (sBeacon.uuid !== undefined && currentBeacon.uuid !== undefined && sBeacon.uuid.toLowerCase() === currentBeacon.uuid.toLowerCase()) {
                            ActionFactory.triggerEvent(event, sBeacon.actions);
                        }
                    });
                }
                currentBeacon.proximity = beacon.proximity;
                currentBeacon.accuracy = beacon.accuracy;
                currentBeacon.signalStrength = getSignalStrength(beacon.rssi);
                beaconUpdated = true;
            }
        }

        if (!beaconUpdated) {
            for (var beaconIterB in beaconsToMonitor) {
                var region = beaconsToMonitor[beaconIterB];
                if (region.uuid.toLowerCase() == beacon.uuid.toLowerCase()) {
                    beaconsInRange.push({
                        title: region.name,
                        major: region.major,
                        minor: region.minor,
                        uuid: region.uuid,
                        accuracy: beacon.accuracy,
                        proximity: beacon.proximity,
                        signalStrength: getSignalStrength(beacon.rssi)
                    });
                    ActionFactory.triggerEvent("in-range", region.actions);
                }
            }
        }

        var firstUuid = beaconsInRange[0].uuid;

        beaconsInRange.sort(compare);
        var postSortFirstUuid = beaconsInRange[0].uuid;

        if (firstUuid.toLowerCase() != postSortFirstUuid.toLowerCase()) {
            var closestBeacon = beaconsInRange[0];

            for (var beaconIter in beaconsToMonitor) {
                var _region = beaconsToMonitor[beaconIter];
                if (_region.uuid.toLowerCase() == closestBeacon.uuid.toLowerCase()) {
                    ActionFactory.triggerEvent("closest", _region.actions);
                }
            }
        }
    }

    function onExitRegion(pluginResult) {
        var regionId = pluginResult.region.uuid;

        for (var beaconIter in beaconsInRange) {
            var currentBeacon = beaconsInRange[beaconIter];
            if (currentBeacon.uuid.toLowerCase() == regionId.toLowerCase()) {
                beaconsInRange.splice(beaconIter, 1);
                for (var monitorBeaconIter in beaconsToMonitor) {
                    var monitoredBeacon = beaconsToMonitor[monitorBeaconIter];
                    if (monitoredBeacon.uuid.toLowerCase() == regionId.toLowerCase()) {
                        ActionFactory.triggerEvent("out-of-range", monitoredBeacon.actions);
                    }
                }
            }
        }
    }

    function addBeacon(beacon) {
        beaconsToMonitor.push(beacon);
        if (window.cordova !== undefined) {

            var beaconRegion = getBeaconRegion(beacon);

            if (beacon.rangingEnabled) {
                beaconsToRange.push(beacon);
                // Start ranging.
                LocationManagerPlugin.startRangingBeaconsInRegion(beaconRegion)
                    .fail($log.error)
                    .done();
                beacon.ranging = true;
            }

            // Start monitoring.
            LocationManagerPlugin.startMonitoringForRegion(beaconRegion)
                .fail($log.error)
                .done();
            beacon.monitoring = true;
        }
    }

    function stopMonitoring() {
        angular.forEach(beaconsToMonitor, function (beacon) {
            if (beacon.monitoring) {
                var beaconRegion = getBeaconRegion(beacon);
                LocationManagerPlugin.stopMonitoringForRegion(beaconRegion)
                    .fail($log.error)
                    .done();
                beacon.monitoring = false;
            }
        });
    }

    function stopRanging() {
        angular.forEach(beaconsToRange, function (beacon) {
            if (beacon.ranging) {
                var beaconRegion = getBeaconRegion(beacon);
                LocationManagerPlugin.stopRangingBeaconsInRegion(beaconRegion)
                    .fail($log.error)
                    .done();
            }
            beacon.ranging = false;
        });
    }

    function stopListening() {
        stopMonitoring();
        stopRanging();
    }

    function startListening() {
        startMonitoring();
        startRanging();
    }

    function startMonitoring() {
        angular.forEach(beaconsToMonitor, function (beacon) {
            if (!beacon.monitoring) {
                var beaconRegion = getBeaconRegion(beacon);
                LocationManagerPlugin.startMonitoringForRegion(beaconRegion)
                    .fail($log.error)
                    .done();
                beacon.monitoring = true;
            }
        });
    }

    function startRanging() {
        angular.forEach(beaconsToRange, function (beacon) {
            if (!beacon.ranging) {
                var beaconRegion = getBeaconRegion(beacon);
                LocationManagerPlugin.startRangingBeaconsInRegion(beaconRegion)
                    .fail($log.error)
                    .done();
            }
            beacon.ranging = true;
        });
    }

    function getBeaconRegion(beacon) {
        var beaconRegion = null;
        angular.forEach(beaconRegions, function (region) {
            if (region.uuid.toLowerCase() == beacon.uuid.toLowerCase()) {
                beaconRegion = region;
                return;
            }
        });
        if (beaconRegion === null) {
            beaconRegion = new LocationManagerPlugin.BeaconRegion(beacon.name, beacon.uuid, beacon.major, beacon.minor);
            beaconRegions.push(beaconRegion);
        }
        return beaconRegion;
    }

    return service;
}]);
angular
    .module("app.core")
    .factory("GeofenceFactory", ["$rootScope", "$q", "$injector", "Plugin", "StoreFactory", "$log", function ($rootScope, $q, $injector, Plugin, StoreFactory, $log) {

        // === Constants === //

        var DEBUG_MODE = false; // Set to true to output verbose debug logging
        var USE_MOCK_PLUGIN = false; // Set to true to use locally mocked "geofence" plugin for testing and debugging purposes

        var GEOFENCE_STATE_STORE_KEY = "geofences";

        var GEOFENCE_TRANSITION_ENTER = 1;
        var GEOFENCE_TRANSITION_EXIT = 2;

        // === Fields === //

        var _plugin = null;

        var _applicationName = "";
        var _uniqueNamespace = "";
        var _updateTimeout = null;

        var _initialised = false;
        var _actionFactory = null;
        var _pluginReady = false;

        var _queuedGeofences = [];
        var _geofences = [];
        var _dynamicGeofences = [];

        // === Service functions === //

        function isValidGeofenceObject(obj) {

            return (
                obj.hasOwnProperty("name")
                && obj.hasOwnProperty("lat")
                && obj.hasOwnProperty("lng")
                && obj.hasOwnProperty("radius")
            );
        }

        function init(appName, namespace) {

            if (_initialised) return $q.when(); // immediately resolve if already initialised

            _applicationName = appName;
            _uniqueNamespace = namespace;

            _plugin = (USE_MOCK_PLUGIN === true)
                ? generateMockGeofencePlugin()
                : Plugin.getSource("geofence");

            var deferred = $q.defer();

            if (_plugin === false) {

                deferred.reject("Unable to initialise 'geofence' plugin");

            } else {

                // manual injection to avoid angular circular dependency
                _actionFactory = $injector.get("ActionFactory");

                debug("Retrieving saved geofence state:", StoreFactory.get(GEOFENCE_STATE_STORE_KEY));

                debug("Initializing 'geofence' plugin...");
                _plugin
                    .initialize()
                    .then(function () {
                        handlePluginLoaded(deferred);
                    })
                    .catch(function (error) {
                        handlePluginError(error);
                    });
            }

            $rootScope.$on("StoreChanged", onStoreChanged);

            _initialised = true;

            return deferred.promise;
        }

        function register(geofence) {

            // Ensure that plugin is ready, and queue geofence if not
            if (!_pluginReady) {

                _queuedGeofences.push(geofence);

                var notReadyMessage = "Plugin not ready, adding geofence to queue:";
                debug(notReadyMessage, geofence);
                return $q.reject(notReadyMessage);
            }

            var deferred = $q.defer();

            registerIfDynamicGeofence(geofence);

            geofence.fullyQualifiedName = getFullyQualifiedName(geofence.name);

            // If we don't know the state of the geofence
            if (geofence.listening === undefined) {

                // then check the store to see if it has state for this geofence
                var geofenceState = getState(geofence.name);
                geofence.listening = (geofenceState !== undefined)
                    ? geofenceState.listening
                    : true; // listening by default
            }

            if (geofence.listening === false) {

                // If the geofence state is that it is not listening, do not register the geofence
                debug("Skipping geofence '" + geofence.name + "', was previously stopped");

                // Save geofence to local array (_geofences)
                saveGeofence(geofence);

                deferred.resolve();

            } else {

                var geofenceRegistration = buildGeofenceRegistrationObject(geofence);
                if (typeof (geofenceRegistration) === "string") {

                    deferred.reject(geofenceRegistration);

                } else {

                    _plugin
                        .addOrUpdate(geofenceRegistration)
                        .then(function () {

                            debug("Registered geofence '" + geofenceRegistration.id + "' (" + geofenceRegistration.latitude + ", " + geofenceRegistration.longitude + " @ " + geofenceRegistration.radius + "m)");

                            // Save geofence to local array (_geofences)
                            saveGeofence(geofence);
                            saveState();

                            deferred.resolve();

                        })
                        .catch(function (error) {

                            var failedAddMessage = "Unable to register geofence '" + geofence.name + "'";
                            logError(failedAddMessage, error);
                            deferred.reject(failedAddMessage);
                        });
                }
            }

            return deferred.promise;
        }

        function update(geofence) {

            if (!_pluginReady) return $q.reject("Geofence plugin not initialised");

            var deferred = $q.defer();

            var fullyQualifiedName = getFullyQualifiedName(geofence.name);
            var foundGeofence = findByFullyQualifiedName(fullyQualifiedName);
            if (foundGeofence !== null) {

                var updatedGeofence = angular.extend({}, foundGeofence, geofence);
                var updatedGeofenceRegistration = buildGeofenceRegistrationObject(updatedGeofence);

                if (updatedGeofence.listening === false) {

                    // Save geofence to local array (_geofences) so that future enabling uses new values
                    saveGeofence(updatedGeofence);
                    saveState();

                    deferred.resolve();

                } else {

                    _plugin
                        .remove(fullyQualifiedName)
                        .then(function () {

                            return _plugin.addOrUpdate(updatedGeofenceRegistration);
                        })
                        .then(function () {

                            debug("Updated geofence '" + updatedGeofenceRegistration.id + "' (" + updatedGeofenceRegistration.latitude + ", " + updatedGeofenceRegistration.longitude + " @ " + updatedGeofenceRegistration.radius + "m)");

                            // Save geofence to local array (_geofences)
                            saveGeofence(updatedGeofence);
                            saveState();

                            deferred.resolve();

                        })
                        .catch(function (error) {

                            var failedUpdateMessage = "Unable to update geofence '" + updatedGeofence.name + "'";
                            logError(failedUpdateMessage, error);
                            deferred.reject(failedUpdateMessage);
                        });
                }

            } else {

                debug("Unable to find and update geofence '" + geofence.name + "'");
                deferred.resolve();
            }

            return deferred.promise;
        }

        function start(name) {

            if (!_pluginReady) return $q.reject("Geofence plugin not initialised");
            if (name === "|all|") return startAll(); // special case for all geofences

            var deferred = $q.defer();

            var fullyQualifiedName = getFullyQualifiedName(name);
            var geofence = findByFullyQualifiedName(fullyQualifiedName);
            if (geofence !== null) {

                if (geofence.listening === false) {

                    geofence.listening = true;

                    register(geofence)
                        .then(function () {

                            deferred.resolve();
                        });

                } else {

                    debug("Geofence '" + name + "' already registered");
                    deferred.resolve();
                }

            } else {

                deferred.reject("Unable to find and start geofence '" + name + "'");
            }

            return deferred.promise;
        }

        function stop(name) {

            if (!_pluginReady) return $q.reject("Geofence plugin not initialised");
            if (name === "|all|") return stopAll(); // special case for all geofences

            var deferred = $q.defer();

            var fullyQualifiedName = getFullyQualifiedName(name);
            var geofence = findByFullyQualifiedName(fullyQualifiedName);
            if (geofence !== null) {

                _plugin
                    .remove(geofence.fullyQualifiedName)
                    .then(function () {

                        debug("Geofence '" + name + "' stopped");

                        geofence.listening = false;

                        saveGeofence(geofence);
                        saveState();

                        deferred.resolve();

                    })
                    .catch(function (error) {

                        var errorMessage = "Unable to stop geofence '" + name + "'";
                        error(errorMessage, error);
                        deferred.reject(errorMessage);
                    });

            } else {

                deferred.reject("Unable to find and stop geofence '" + name + "'");
            }

            return deferred.promise;
        }

        // === Event handlers === //

        function handlePluginLoaded(deferred) {

            _pluginReady = true;
            _plugin.onTransitionReceived = handleGeofenceTransition;

            debug("Initialized 'geofence' plugin");

            _plugin
                .removeAll()
                .then(function () {

                    debug("Existing geofence registrations purged");

                    if (_queuedGeofences.length > 0) {

                        debug("Registering " + _queuedGeofences.length + " queued geofences...");
                        angular.forEach(_queuedGeofences, function (geofence) {

                            register(geofence);
                        });
                        _queuedGeofences = [];
                    }

                    deferred.resolve();
                });
        }

        function handlePluginError(error) {

            error("Geofence plugin not initialised", error);
        }

        function handleGeofenceTransition(registeredGeofences) {

            angular.forEach(registeredGeofences, function (registeredGeofence) {

                var geofence = findByFullyQualifiedName(registeredGeofence.id);
                if (geofence !== null && geofence.listening === true) {

                    switch (registeredGeofence.transitionType) {

                        case GEOFENCE_TRANSITION_ENTER:
                            handleEnterGeofence(geofence);
                            break;

                        case GEOFENCE_TRANSITION_EXIT:
                            handleExitGeofence(geofence);
                            break;
                    }
                }
            });
        }

        function handleEnterGeofence(geofence) {

            if (geofence !== null && geofence.listening === true && geofence.actions.length) {

                debug("Triggering 'enter' event for '" + geofence.name + "'");
                _actionFactory.triggerEvent("enter", geofence.actions);
            }
        }

        function handleExitGeofence(geofence) {

            if (geofence !== null && geofence.listening === true && geofence.actions.length) {

                debug("Triggering 'exit' event for '" + geofence.name + "'");
                _actionFactory.triggerEvent("exit", geofence.actions);
            }
        }

        // === Utility functions === //

        function startAll() {

            var deferred = $q.defer();

            var promises = [];
            angular.forEach(_geofences, function (geofence) {

                geofence.listening = true;
                promises.push(register(geofence));
            });

            $q.all(promises)
                .then(function () {

                    debug("All geofences registered");

                    deferred.resolve();
                });

            return deferred.promise;
        }

        function stopAll() {

            var deferred = $q.defer();

            _plugin
                .removeAll()
                .then(function () {

                    debug("All geofences stopped");

                    angular.forEach(_geofences, function (geofence) {

                        geofence.listening = false;
                        saveGeofence(geofence);
                    });

                    saveState();

                    deferred.resolve();

                })
                .catch(function (error) {

                    var errorMessage = "Unable to stop all geofences";
                    error(errorMessage, error);
                    deferred.reject(errorMessage);
                });

            return deferred.promise;
        }

        function registerIfDynamicGeofence(geofence) {

            var dynamicProperties = [];
            angular.forEach(["lat", "lng", "radius", "notificationText"], function (prop) {

                if (("" + geofence[prop]).trim().indexOf("{{") === 0) {
                    dynamicProperties.push(prop);
                }
            });

            if (dynamicProperties.length > 0 && _dynamicGeofences.indexOf(geofence.name) === -1) {

                _dynamicGeofences.push(geofence.name);
            }
        }

        function onStoreChanged() {

            clearTimeout(_updateTimeout);

            _updateTimeout = setTimeout(function () {

                angular.forEach(_dynamicGeofences, function (dynamicGeofenceName) {

                    var geofenceState = getState(dynamicGeofenceName);
                    var fullyQualifiedName = getFullyQualifiedName(dynamicGeofenceName);
                    var foundGeofence = findByFullyQualifiedName(fullyQualifiedName);
                    if (geofenceState && foundGeofence) {

                        var previousLat = geofenceState.lat;
                        var previousLng = geofenceState.lng;
                        var previousRadius = geofenceState.radius;
                        var previousNotificationText = geofenceState.notificationText;

                        var currentLat = getPropertyValue(foundGeofence.lat, true);
                        var currentLng = getPropertyValue(foundGeofence.lng, true);
                        var currentRadius = getPropertyValue(foundGeofence.radius, true);
                        var currentNotificationText = getPropertyValue(foundGeofence.notificationText, false);

                        if ((currentLat !== previousLat)
                            || (currentLng !== previousLng)
                            || (currentRadius !== previousRadius)
                            || (currentNotificationText !== previousNotificationText)) {

                            update(foundGeofence);
                        }
                    }
                });
            }, 100);
        }

        function getFullyQualifiedName(name) {

            return _uniqueNamespace + "__" + name;
        }

        function getPropertyValue(value, expectNumerical) {

            if (value === undefined || value === null) return null;

            if (angular.isString(value) && value.trim().indexOf("{{") === 0) {

                var modelValue = StoreFactory.parse(value);
                if (!modelValue) return null;

                return expectNumerical
                    ? parseFloat(modelValue)
                    : modelValue;

            } else {

                return expectNumerical
                    ? parseFloat(value)
                    : value;
            }
        }

        function buildGeofenceRegistrationObject(geofence) {

            // Check that geofence has transition action(s) defined
            var hasEnter = hasAction(geofence, "enter") ? GEOFENCE_TRANSITION_ENTER : 0;
            var hasExit = hasAction(geofence, "exit") ? GEOFENCE_TRANSITION_EXIT : 0;
            var transitionType = hasEnter | hasExit;

            var permittedTransitionTypes = [
                GEOFENCE_TRANSITION_ENTER,
                GEOFENCE_TRANSITION_EXIT,
                GEOFENCE_TRANSITION_ENTER | GEOFENCE_TRANSITION_EXIT // both enter and exit
            ];
            if (permittedTransitionTypes.indexOf(transitionType) === -1) {

                // Not a supported transition type
                var invalidTransitionTypeMessage = "Geofence '" + geofence.name + "' being ignored - has no transition actions defined";
                debug(invalidTransitionTypeMessage);
                return invalidTransitionTypeMessage;
            }

            var lat = getPropertyValue(geofence.lat, true) || 0;
            var lng = getPropertyValue(geofence.lng, true) || 0;
            var radius = getPropertyValue(geofence.radius, true) || 0;
            var notificationText = getPropertyValue(geofence.notificationText, false) || "You have passed a geofence boundary";

            return {
                id: geofence.fullyQualifiedName, // use fully qualified name to prevent other apps from interfering with this geofence
                latitude: lat,
                longitude: lng,
                radius: radius,
                transitionType: transitionType,
                notification: {
                    id: 1,
                    title: _applicationName,
                    text: notificationText,
                    openAppOnClick: true
                }
            };
        }

        function hasAction(geofence, eventType) {

            if (geofence.actions && geofence.actions.length) {

                return geofence.actions.some(function (action) {

                    return (action.event || "").toLowerCase() === eventType.toLowerCase();
                });
            }

            return false;
        }

        function findIndexByFullyQualifiedName(fullyQualifiedName) {

            for (var i = 0; i < _geofences.length; i++) {
                var geofence = _geofences[i];
                if (geofence.fullyQualifiedName === fullyQualifiedName) {
                    return i;
                }
            }
            return -1;
        }

        function findByFullyQualifiedName(fullyQualifiedName) {

            var idx = findIndexByFullyQualifiedName(fullyQualifiedName);
            return (idx !== -1)
                ? _geofences[idx]
                : null;
        }

        function saveGeofence(geofence) {

            var idx = findIndexByFullyQualifiedName(geofence.fullyQualifiedName);
            if (idx === -1) {

                _geofences.push(geofence);

            } else {

                _geofences[idx] = geofence;
            }
        }

        function saveState() {

            var stateData = {};

            // Create state objects for all known geofences
            angular.forEach(_geofences, function (geofence) {

                stateData[geofence.name] = {
                    listening: geofence.listening,
                    lat: getPropertyValue(geofence.lat),
                    lng: getPropertyValue(geofence.lng),
                    radius: getPropertyValue(geofence.radius),
                    notificationText: getPropertyValue(geofence.notificationText)
                };
            });

            StoreFactory.set(GEOFENCE_STATE_STORE_KEY, stateData);

            debug("Geofence state saved:", stateData);
        }

        function getState(geofenceName) {

            return angular.copy(StoreFactory.get(GEOFENCE_STATE_STORE_KEY + "." + geofenceName));
        }

        function debug() {

            if (DEBUG_MODE !== true) return;

            var params = Array.prototype.slice.call(arguments);
            if (params.length > 0 && typeof (params[0]) === "string") {
                params[0] = "[geofence.fct.js] " + params[0];
            }
            $log.log.apply($log, params);
        }

        function logError() {

            var params = Array.prototype.slice.call(arguments);
            if (params.length > 0 && typeof (params[0]) === "string") {
                params[0] = "[geofence.fct.js] " + params[0];
            }
            $log.error.apply($log, params);
        }

        // === Mock Geofence Plugin (for local development/testing) === //

        function generateMockGeofencePlugin() {

            $log.info("*** USING MOCK GEOFENCE PLUGIN: Turn this off in geofence.fct.js if you expect to use the real plugin ***");

            var FAKE_DELAY = 500; // 500ms

            function deferredResponse() {

                var deferred = $q.defer();

                setTimeout(function () {

                    deferred.resolve();

                }, FAKE_DELAY);

                return deferred.promise;
            }

            return {

                initialize: function () {
                    return deferredResponse();
                },
                addOrUpdate: function () {
                    return deferredResponse();
                },
                remove: function () {
                    return deferredResponse();
                },
                removeAll: function () {
                    return deferredResponse();
                },
                onTransitionReceived: function () {
                }
            };
        }

        // === Service object === //

        return {

            /**
             * Returns true if the supplied object has valid geofence data
             * @param {object} obj - The object to test
             */
            "isValidGeofenceObject": isValidGeofenceObject,

            /**
             * Initialised the Geofence plugin
             * @param {string} appName - The name of the application
             * @param {string} namespace - A unique namespace for geofences for this application
             */
            "init": init,

            /**
             * @typedef {object} Geofence
             * @property {string} name - Name of geofence
             * @property {number} lat - Latitudinal coordinates
             * @property {number} lng - Longitudinal coordinates
             * @property {number} radius - Radius in meters
             * @property {string} notificationText - The text to display in the notification
             *
             * Register a new geofence
             * @param {Geofence} geofence - The geofence to register
             */
            "register": register,

            /**
             * Start listening for geofence transitions for a specified geofence
             * @param {string} name - Name of geofence
             */
            "start": start,

            /**
             * Stop listening for geofence transitions for a specified geofence
             * @param {string} name - Name of geofence
             */
            "stop": stop
        };
    }]);

angular.module("app.core").factory("Xmpp", ["LoadingStatus", "$log", "StoreFactory", "$injector", "$rootScope", "$q", "Camera", "Plugin", "FileSystem", "$sce", "MimeTypes", "$filter", "SchemaHelper", function (LoadingStatus, $log, StoreFactory, $injector, $rootScope, $q, Camera, Plugin, FileSystem, $sce, MimeTypes, $filter, SchemaHelper) {

    function Xmpp(id, endpoint, actions, uploadJid, readReceipts, stayConnected, multicastJid, pingTime, pingTimeout, sendTimeout, enableOutbox, reconnectTime) {

        // === Uncomment this to output logging messages from Strophe === //

        // Strophe.log = function (level, msg) {
        //     var levelName = "INFO";
        //     var levelColor = "#999999";
        //     var levelBgColor = "transparent";
        //     switch (level) {
        //         case 0: levelName = "DEBUG"; break;
        //         case 1: levelName = "INFO"; break;
        //         case 2: levelName = "WARN"; levelColor = "#999900"; break;
        //         case 3: levelName = "ERROR"; levelColor = "#990000"; break;
        //         case 4: levelName = "FATAL"; levelColor = "#ffffff"; levelBgColor = "#990000"; break;
        //     }
        //     console.log("%c [" + levelName + "] " + msg, "color: " + levelColor + "; background: " + levelBgColor + "; font-style: italic;");
        // };
        // Strophe.Connection.xmlInput = function (data) {
        //     console.log("%c  IN ==>" +  + data, "color: #009900; font-style: italic;");
        // };
        // Strophe.Connection.xmlOutput = function (data) {
        //     console.log("%c OUT <==" +  + data, "color: #990000; font-style: italic;");
        // };

        // === End strophe logging === //

        var ActionFactory = $injector.get("ActionFactory");
        var $scope = this;
        $scope.id = id;
        $scope.endpoint = endpoint;
        $scope.uploadJid = uploadJid;
        $scope.readReceipts = readReceipts;
        $scope.stayConnected = stayConnected;
        $scope.multicastJid = multicastJid;
        $scope.pingTime = pingTime;
        $scope.pingTo = pingTimeout;
        $scope.sendtimeout = sendTimeout;
        $scope.enableOutbox = enableOutbox;
        $scope.reconnectTime = reconnectTime;
        if ($scope.stayConnected === true) {
            $scope.reconnect();
        }
        $scope.actions = actions;
        if ($scope.id !== undefined && $scope.endpoint !== undefined) {
            // Setup the initial data structure
            // Can"t use the usual StoreFactory.set() here because the AngularJS $parse service doesn"t like @ :(
            if (window.cti.store.xmpp[this.id] === undefined) {
                window.cti.store.xmpp[this.id] = {
                    "connection_status": null,
                    "user_status": null,
                    "history": {},
                    "contacts": [],
                    "groups": []
                };
            }
            // Any messages left as "sending" should be assumed as failed on start-up
            $scope.cleanQueue();
            // eslint-disable-next-line camelcase
            window.cti.api.xmpp_connection = new window.Strophe.Connection($scope.endpoint);
            window.cti.api.xmpp_connection.reset();

            // If a send timeout has been specified make sure this makes it through to the outbox plugin
            if ($scope.sendtimeout) window.cti.api.xmpp_connection.outbox.sendTimeoutDuration = $scope.sendtimeout;
            if ($scope.enableOutbox === true) {
                // If the user has enabled the outbox then we need to enable it via the outbox plugin
                window.cti.api.xmpp_connection.outbox.addEventListener(window.cti.api.xmpp_connection.outbox.eventTypes.MESSAGE_QUEUED, function (data) {
                    ActionFactory.triggerEvent("message-queued", $scope.actions, {"$message": data});
                });
                window.cti.api.xmpp_connection.outbox.addEventListener(window.cti.api.xmpp_connection.outbox.eventTypes.MESSAGE_RESEND_SUCCESS, function (data) {
                    ActionFactory.triggerEvent("message-resend-success", $scope.actions, {"$message": data});
                });
                window.cti.api.xmpp_connection.outbox.addEventListener(window.cti.api.xmpp_connection.outbox.eventTypes.MESSAGE_RESEND_FAILED, function (data) {
                    ActionFactory.triggerEvent("message-resend-failed", $scope.actions, {"$message": data});
                });
                window.cti.api.xmpp_connection.outbox.addEventListener(window.cti.api.xmpp_connection.outbox.eventTypes.QUEUE_CLEANED, function (data) {
                    ActionFactory.triggerEvent("queue-cleaned", $scope.actions, {"$result": data});
                });
                window.cti.api.xmpp_connection.outbox.addEventListener(window.cti.api.xmpp_connection.outbox.eventTypes.QUEUE_PROCESSED, function (data) {
                    ActionFactory.triggerEvent("queue-processed", $scope.actions, {"$result": data});
                });
                var encrypt = SchemaHelper.getSchemaSettingByName("encryption");
                if (encrypt === true) {
                    $log.debug("[xmpp.fct.js] (" + $scope.id + ") GETTING KEY TO SECURE OUTBOX DB...");
                    StoreFactory.getEncryptionKey(SchemaHelper.getAppName()).then(function (key) {
                        $log.debug("[xmpp.fct.js] (" + $scope.id + ") ENABLING XMPP OUTBOX...");
                        window.cti.api.xmpp_connection.outbox.enable($scope.id, key);
                    });
                } else {
                    $log.debug("[xmpp.fct.js] (" + $scope.id + ") ENABLING XMPP OUTBOX...");
                    window.cti.api.xmpp_connection.outbox.enable($scope.id);
                }
            }
            $scope.setConnectionStatus(null);
            $scope.onMessage = function ($message) {
                $log.debug("[xmpp.fct.js] (" + $scope.id + ") MESSAGE RECEIVED:", $message);
                // Use a try catch here otherwise Strophe steals our errors
                try {
                    // Enable ping on no activity
                    $scope.enablePing();
                    var type = $message.getAttribute("type");
                    var messageId = $message.getAttribute("id");
                    var to = $scope.getBareJid($message.getAttribute("to"));
                    var from = $scope.getBareJid($message.getAttribute("from"));
                    switch (type) {
                        case "chat":
                            var $body = $message.getElementsByTagName("body")[0];
                            var $url = $message.getElementsByTagName("url")[0];
                            if ($body !== undefined) {
                                var body = window.Strophe.getText($body);
                            }
                            var $metadata = $message.getElementsByTagName("metadata")[0];
                            if ($metadata !== undefined) {
                                var metadata = {};
                                var items = $metadata.childNodes;
                                if (items !== undefined && items.length > 0) {
                                    for (var i = 0; i < items.length; i++) {
                                        var $item = items[i];
                                        metadata[$item.tagName] = window.Strophe.getText($item);
                                    }
                                }
                            }
                            if ($body !== undefined || $url !== undefined) {
                                // Add message to history right away because downloading of media could take a while
                                var message = $scope.createMessageObject(to, from, body, null, messageId, null, metadata);
                                var $markable = $message.getElementsByTagName("markable")[0];
                                if ($markable !== undefined && $scope.readReceipts !== false) {
                                    // We need to acknowledge the receipt of this message
                                    $scope.sendMarker(message.id, $scope.MESSAGE_STATUS.RECEIVED);
                                }
                                if ($url !== undefined) {
                                    message.media.remote = encodeURI(window.Strophe.getText($url));
                                    message.media.status = $scope.MEDIA_STATUS.DOWNLOADING;
                                    $scope.saveAndUpdate();

                                    var fileName = FileSystem.getFileNameFromPath(message.media.remote);
                                    FileSystem
                                        .download(message.media.remote, fileName)
                                        .then(function (result) {

                                            message.media.local = result.filePath;
                                            message.media.type = result.mimeType;
                                            message.media.status = $scope.MEDIA_STATUS.DOWNLOADED;
                                            $scope.saveAndUpdate();
                                        })
                                        .catch(function (error) {

                                            $log.error(error);
                                        });
                                }
                                if ($scope.actions !== undefined && $scope.actions.length > 0) {
                                    ActionFactory.triggerEvent("message-received", $scope.actions, {"$message": message});
                                }
                                $scope.saveAndUpdate();
                            }
                            break;
                        case "error":
                            $log.error("XMPP ERROR!", $message);
                            var id = $message.getAttribute("id");
                            if (id !== undefined) {
                                var _message = $scope.getMessageFromHistory(from, id);
                                if (_message !== null) {
                                    _message.sent = false;
                                    ActionFactory.triggerEvent("error", $scope.actions, {"$message": _message});
                                    StoreFactory.save().then(function () {
                                        $rootScope.$emit("StoreHasChanged");
                                    });
                                }
                            }
                            break;
                        default:
                            var $received = $message.getElementsByTagName("received")[0];
                            if ($received !== undefined && $scope.readReceipts !== false) {
                                // This is an acknowledgement that a previous message we sent has been received by the client
                                // Update the message status
                                var prevId = $received.getAttribute("id");
                                if (prevId !== null) {
                                    // It could be null if its not been added to the UI this side
                                    var previousMessage = $scope.getMessageFromHistory(from, prevId);
                                    if (previousMessage !== null) {
                                        previousMessage.status = $scope.MESSAGE_STATUS.RECEIVED;
                                        $scope.saveAndUpdate();
                                    }
                                }
                            }
                            var $displayed = $message.getElementsByTagName("displayed")[0];
                            if ($displayed !== undefined && $scope.readReceipts !== false) {
                                // This is an acknowledgement that a previous message we sent has been displayed (i.e. read) by the client
                                // Update the message status
                                var _prevId = $displayed.getAttribute("id");
                                if (_prevId !== null) {
                                    var _previousMessage = $scope.getMessageFromHistory(from, _prevId);
                                    // It could be null if its not been added to the UI this side
                                    if (_previousMessage !== null) {
                                        _previousMessage.status = $scope.MESSAGE_STATUS.DISPLAYED;
                                        $scope.saveAndUpdate();
                                    }
                                }
                            }
                            var $acknowledged = $message.getElementsByTagName("acknowledged")[0];
                            if ($acknowledged !== undefined && $scope.readReceipts !== false) {
                                // This is an acknowledgement that a previous message we sent has been displayed (i.e. read) by the client
                                // Update the message status
                                var __prevId = $acknowledged.getAttribute("id");
                                if (__prevId !== null) {
                                    var __previousMessage = $scope.getMessageFromHistory(from, __prevId);
                                    // It could be null if its not been added to the UI this side
                                    if (__previousMessage !== null) {
                                        __previousMessage.status = $scope.MESSAGE_STATUS.ACKNOWLEDGED;
                                        $scope.saveAndUpdate();
                                    }
                                }
                            }
                    }
                } catch (e) {
                    $log.error("XMPP Error:", e);
                }
                return true;
            };
            $scope.updateMessageStatus = function (messageId) {
                // Is it still waiting for an acknowledgement?
                var changed = false;
                $scope.queue.forEach(function (id) {
                    // If it is then it never got one (probably) so mark it as failed
                    if (id === messageId) {
                        var message = $scope.getMessageFromAllHistory(messageId);
                        if (message !== null) {
                            message.status = $scope.MESSAGE_STATUS.FAILED;
                            ActionFactory.triggerEvent("send-failed", $scope.actions, {"$message": message});
                            changed = true;
                        }
                    }
                });
                if (changed === true) {
                    $scope.saveAndUpdate();
                }
            };
            $scope.send = function (data, addresses) {
                var deferred = $q.defer();
                if (window.cti.api.xmpp_connection.connected === true || window.cti.api.xmpp_connection.outbox.enabled === true) {
                    // Enable ping on no activity
                    $scope.enablePing();
                    var message = null;
                    if (data.id !== undefined) {
                        message = $scope.getMessageFromAllHistory(data.id);
                    } else {
                        message = $scope.createMessageObject(data.to, window.cti.api.xmpp_connection.authzid, data.message, null, null, data.ttl, data.metadata, addresses);
                    }
                    if (message !== null) {
                        var _sendIt = function () {
                            var $message = $scope.createMessageXml(message.id);
                            window.cti.api.xmpp_connection.sendMessage($message, function (result) {
                                // result will be null if message sent successfully and therefore has not been added to the queue
                                if (result === null && [$scope.MESSAGE_STATUS.RECEIVED, $scope.MESSAGE_STATUS.ACKNOWLEDGED, $scope.MESSAGE_STATUS.DISPLAYED].indexOf(message.status) === -1) {
                                    message.sent = true;
                                    message.status = $scope.MESSAGE_STATUS.SENT;
                                }
                                $scope.saveAndUpdate();
                                deferred.resolve();
                            }, function (error) {
                                message.sent = false;
                                message.status = $scope.MESSAGE_STATUS.FAILED;
                                ActionFactory.triggerEvent("send-failed", $scope.actions, {"$message": message, "$error": error});
                                $scope.saveAndUpdate();
                                deferred.reject(error);
                            });
                        };
                        // If we have a filePath then we are dealing with media upload
                        var filePath = data["file-path"];
                        if (filePath !== undefined && angular.isString(filePath) && filePath.length > 0) {
                            if ($scope.uploadJid !== undefined) {

                                var fileName = FileSystem.getFileNameFromPath(filePath);
                                FileSystem
                                    .getFile(fileName)
                                    .then(function (file) {
                                        message.media.local = file.filePath;
                                        message.media.type = file.mimeType;
                                        message.media.status = $scope.MEDIA_STATUS.UPLOADING;
                                        $scope.saveAndUpdate();

                                        window.cti.api.xmpp_connection.httpFileUpload.slot($scope.uploadJid, file.name, file.size, message.media.type, function (slot) {

                                            if (slot.put !== null) {

                                                var uploadSource = filePath;
                                                var uploadTarget = encodeURI(slot.put);
                                                var uploadOptions = {
                                                    httpMethod: "PUT",
                                                    fileName: file.name,
                                                    headers: {
                                                        "Content-Type": message.media.type
                                                    }
                                                };

                                                $log.debug("[xmpp.fct.js] uploading file '" + uploadSource + "' to '" + uploadTarget + "' with options", uploadOptions);
                                                FileSystem
                                                    .upload(uploadSource, uploadTarget, uploadOptions)
                                                    .then(function () {
                                                        message.media.remote = slot.get;
                                                        message.media.status = $scope.MEDIA_STATUS.UPLOADED;
                                                        _sendIt();
                                                    })
                                                    .catch(function (error) {

                                                        deferred.reject(error);
                                                    });

                                            } else {

                                                deferred.reject("No upload slot was provided.");
                                            }
                                        }, function (error) {

                                            deferred.reject(error);
                                        });

                                    }).catch(function (error) {
                                        deferred.reject(error);
                                    });

                            } else {
                                deferred.reject("Upload jid has not been configured.");
                            }
                        } else {
                            _sendIt();
                        }
                    } else {
                        deferred.reject("Unable to send message.");
                    }
                } else {
                    deferred.reject("No connection available.");
                }
                return deferred.promise;
            };
            $scope.sendToGroup = function (data) {
                var deferred = $q.defer();
                if (!data.groups) {
                    deferred.reject("No group(s) specified for group message.");
                } else if ($scope.multicastJid === undefined) {
                    deferred.reject("Multicast JID is required for group messages, please configure this on the \"" + $scope.id + "\" XMPP instance.");
                } else {
                    data.to = $scope.multicastJid;
                    var _statuses = (data.statuses !== undefined) ? data.statuses : [];
                    var _groups = (data.groups !== undefined) ? data.groups : [];
                    var contacts = StoreFactory.get("xmpp." + $scope.id + ".contacts");
                    var _contacts = contacts.filter(function (contact) {
                        return (contact.groups !== undefined && contact.groups.filter(function (group) {
                            return _groups.indexOf(group) > -1;
                        }).length > 0 && _statuses.indexOf(contact.status) === -1);
                    });
                    var addresses = _contacts.map(function (contact) {
                        return contact.username;
                    });
                    $scope.send(data, addresses).then(function () {
                        deferred.resolve();
                    }).catch(function (error) {
                        deferred.reject(error);
                    });
                }
                return deferred.promise;
            };
            $scope.markRead = function (data) {
                var deferred = $q.defer();
                if (window.cti.api.xmpp_connection.connected === true) {
                    if (data.id !== undefined) {
                        $log.debug("Marking message with ID \"" + data.id + "\" as displayed.");
                        $scope.sendMarker(data.id, "displayed");
                        deferred.resolve(true);
                    } else if (data.recipient !== undefined) {
                        if (window.cti.store.xmpp[$scope.id].history !== undefined && window.cti.store.xmpp[$scope.id].history[data.recipient] !== undefined) {
                            var messages = angular.copy(window.cti.store.xmpp[$scope.id].history[data.recipient].messages);
                            if (messages !== undefined && messages.length > 0) {
                                messages = messages.reverse();
                                messages.every(function (message) {
                                    // Keep going until we hit a message which has already been "read"
                                    if (message.status === $scope.MESSAGE_STATUS.DISPLAYED || message.status === $scope.MESSAGE_STATUS.ACKNOWLEDGED) {
                                        // We"ve finished so resolve
                                        return false;
                                    }
                                    // Only deal with received messages
                                    if (message.from !== window.cti.api.xmpp_connection.authzid) {
                                        if (message.id !== undefined) {
                                            $scope.sendMarker(message.id, $scope.MESSAGE_STATUS.DISPLAYED);
                                        }
                                    }
                                    return true;
                                });
                                deferred.resolve(true);
                            } else {
                                deferred.resolve(true);
                            }
                        } else {
                            deferred.resolve(true);
                        }
                    } else {
                        deferred.reject("No message ID provided.");
                    }
                } else {
                    // Fail silently
                    deferred.resolve();
                }
                return deferred.promise;
            };
            $scope.onIq = function ($iqPacket) {
                $log.debug("[xmpp.fct.js] (" + $scope.id + ") IQ RECEIVED:", $iqPacket);
                var type = $iqPacket.getAttribute("type");
                switch (type) {
                    case "set":
                        var $query = $iqPacket.getElementsByTagName("query")[0];
                        if ($query !== undefined) {
                            var ns = $query.getAttribute("xmlns");
                            switch (ns) {
                                case "jabber:iq:roster":
                                    $scope.processContacts($query.childNodes);
                                    // When we get a contact update, trigger the contacts update event
                                    ActionFactory.triggerEvent("contacts-update", $scope.actions);
                                    break;
                            }
                        }
                        break;
                }
                return true;
            };
            $scope.onPresence = function ($presPacket) {
                $log.debug("[xmpp.fct.js] (" + $scope.id + ") PRESENCE RECEIVED:", $presPacket);
                // Enable ping on no activity
                $scope.enablePing();
                var type = $presPacket.getAttribute("type");
                var status = (type === "unavailable") ? "offline" : "chat";
                var friendlyStatus = (type === "unavailable") ? "Offline" : "Available";
                var $show = $presPacket.getElementsByTagName("show")[0];
                if ($show !== undefined) {
                    status = window.Strophe.getText($show);
                }
                var $status = $presPacket.getElementsByTagName("status")[0];
                if ($status !== undefined) {
                    friendlyStatus = window.Strophe.getText($status);
                }
                var from = $scope.getBareJid($presPacket.getAttribute("from"));
                var contacts = StoreFactory.get("xmpp." + $scope.id + ".contacts");
                var changed = false;
                if (contacts.length > 0) {
                    var contact = contacts.filter(function (contact) {
                        return (contact.username === from);
                    })[0];
                    if (contact !== undefined && contact.status !== status) {
                        contact.status = status;
                        // eslint-disable-next-line camelcase
                        contact.friendly_status = friendlyStatus;
                        ActionFactory.triggerEvent("status-update", $scope.actions, {"$contact": contact});
                        changed = true;
                    }
                }
                if (changed) $scope.saveAndUpdate();
                return true;
            };
            $scope.login = function (username, password) {

                // If we have already connected just move on.
                if (window.cti.api.xmpp_connection.connected === true) {

                    return $q.when();
                }

                var deferred = $q.defer();

                window.cti.api.xmpp_connection.reset();
                $scope.setLastAuthStatus("pending");

                // Ensure we have a username and password to connect with
                if (username !== undefined && password !== undefined) {

                    // We need to ensure that the password is always a string
                    if (angular.isNumber(password)) {
                        password = password.toString();
                    }

                    window.cti.api.xmpp_connection.connect(username, password, function (code) {

                        var status = $scope.statusCodeToTxt(code);

                        if ($scope.finished === true && status !== $scope.CONNECTION_STATUS.CONNECTING) return;
                        $scope.finished = false;

                        $scope.setConnectionStatus(status);

                        ActionFactory.triggerEvent(status, $scope.actions);
                        $log.debug("[xmpp.fct.js] (" + $scope.id + ") STATUS CHANGE:", status);

                        switch (status) {

                            case $scope.CONNECTION_STATUS.CONNFAIL:
                            case $scope.CONNECTION_STATUS.ERROR:
                                // Any messages left in the queue need to be marked as failed
                                if ($scope.stayConnected === true && $scope.loggedOut !== true) {
                                    $scope.startReconnection();
                                } else {
                                    window.cti.api.xmpp_connection.disconnect();
                                    $scope.disablePing();
                                }
                                break;

                            case $scope.CONNECTION_STATUS.AUTHFAIL:
                                $scope.setLastAuthStatus("failed");
                                window.cti.api.xmpp_connection.disconnect();
                                $scope.disablePing();
                                break;

                            case $scope.CONNECTION_STATUS.DISCONNECTED:
                                if ($scope.stayConnected === true && $scope.loggedOut !== true) {
                                    $scope.startReconnection();
                                }
                                $scope.finished = true;
                                $scope.disablePing();
                                deferred.reject("disconnected");
                                break;

                            case $scope.CONNECTION_STATUS.CONNECTED:

                                $scope.loggedOut = false;

                                $scope.setLastAuthStatus("success");

                                // Setup the required handlers to act on different types of messages
                                window.cti.api.xmpp_connection.addHandler($scope.onMessage, null, "message", null, null, null);
                                window.cti.api.xmpp_connection.addHandler($scope.onIq, null, "iq", null, null, null);
                                window.cti.api.xmpp_connection.addHandler($scope.onPresence, null, "presence", null, null, null);

                                // Enable stream management and wait for a response from the server before we continue
                                window.cti.api.xmpp_connection.streamManagement.requestResponseInterval = 0; // Disable this because we manually send a request when we send a message using "sendMessage"
                                window.cti.api.xmpp_connection.streamManagement.enable(function () {

                                    var rosterRequest = window.$iq({
                                        from: window.cti.api.xmpp_connection.jid,
                                        id: window.cti.api.xmpp_connection.getUniqueId(),
                                        type: "get"
                                    });
                                    rosterRequest.c("query", {xmlns: "jabber:iq:roster"});
                                    // Clear out the contacts to ensure we get an updated list
                                    StoreFactory.set("xmpp." + $scope.id + ".contacts", []);
                                    window.cti.api.xmpp_connection.sendIQ(rosterRequest, function ($response) {
                                        $log.debug("[xmpp.fct.js] (" + $scope.id + ") GOT CONTACTS:", $response);
                                        $scope.processContacts($response.querySelector("query").childNodes);
                                        var status = StoreFactory.get("xmpp." + $scope.id + ".user_status") || $scope.USER_STATUS.CHAT;
                                        var _resolve = function () {
                                            // We"ve finished everything so trigger the connected event
                                            ActionFactory.triggerEvent("connected", $scope.actions);
                                            $scope.enablePing();
                                            if ($scope.enableOutbox === true) {
                                                window.cti.api.xmpp_connection.outbox.processQueue(function (response) {
                                                    $log.debug("[xmpp.fct.js] (" + $scope.id + ") PROCESSED OUTBOX QUEUE:", response);
                                                }, function (e) {
                                                    $log.error("[xmpp.fct.js] (" + $scope.id + ") ERROR PROCESSING OUTBOX QUEUE:", e);
                                                });
                                            }
                                            deferred.resolve();
                                        };
                                        $scope.setStatus(status).then(function () {
                                            // If stay connected is set then we need to stash the username and password in a secure DB
                                            if ($scope.stayConnected === true) {
                                                $scope.getSecureDb().then(function (db) {
                                                    $log.debug("[xmpp.fct.js] (" + $scope.id + ") Storing credentials for auto-login.");
                                                    db.put({
                                                        _id: $scope.DB.ID + "_data",
                                                        _rev: $scope.DB.REVISION,
                                                        data: username + ":" + password
                                                    }).then(function (result) {
                                                        // Update the revision so we don"t get any conflicts
                                                        $scope.DB.REVISION = result.rev;
                                                        _resolve();
                                                    }).catch(function (error) {
                                                        $log.error(error);
                                                        deferred.reject(error);
                                                    });
                                                }).catch(function (error) {
                                                    $log.error(error);
                                                    deferred.reject(error);
                                                });
                                            } else {
                                                _resolve();
                                            }
                                        }).catch(function (error) {
                                            deferred.reject(error);
                                        });
                                    });
                                }, function (error) {
                                    deferred.reject(error);
                                });

                                break;
                        }
                    });

                } else {

                    $scope.setLastAuthStatus("failed");
                    window.cti.api.xmpp_connection.disconnect();
                }

                return deferred.promise;
            };
            $scope.logout = function () {
                var deferred = $q.defer();
                $scope.loggedOut = true;
                // If stay connected has been enabled then we need to remove the credentials from the DB
                if ($scope.stayConnected === true) {
                    $scope.getSecureDb().then(function (db) {
                        db.destroy().then(function () {
                            $scope.DB.REVISION = null;
                            window.cti.api.xmpp_connection.disconnect();
                            deferred.resolve();
                        }).catch(function (error) {
                            deferred.reject(error);
                        });
                    }).catch(function (error) {
                        deferred.reject(error);
                    });
                } else {
                    window.cti.api.xmpp_connection.disconnect();
                    deferred.resolve();
                }
                return deferred.promise;
            };
            $scope.pingTimeout = null;
            $scope.disablePing = function () {
                if ($scope.pingTimeout !== null) {
                    clearTimeout($scope.pingTimeout);
                    $scope.pingTimeout = null;
                }
            };
            $scope.enablePing = function () {
                $scope.disablePing();
                if (window.cti.api.xmpp_connection !== null && window.cti.api.xmpp_connection.connected === true) {
                    // Wait 5 seconds to see if there has been some form of inactivity
                    $scope.pingTimeout = setTimeout(function () {
                        // 5 seconds has passed and this timeout hasn't been cancelled, so lets start pinging.
                        // Do an initial ping, we"ve already waited 5 seconds
                        $scope.ping();
                    }, $scope.pingTime || 5000);
                }
            };
            $scope.ping = function () {
                var pingIq = window.$iq({
                    from: window.cti.api.xmpp_connection.jid,
                    id: window.cti.api.xmpp_connection.getUniqueId(),
                    type: "get"
                });
                pingIq.c("ping", {xmlns: "urn:xmpp:ping"});
                window.cti.api.xmpp_connection.sendIQ(pingIq, function () {
                    // Still connected so lets send another ping
                    $scope.enablePing();
                }, function () {
                    // Error, no connection
                    $scope.disablePing();
                    $log.debug("[xmpp.fct.js] (" + $scope.id + ") Ping failed...");
                    $log.debug("[xmpp.fct.js] (" + $scope.id + ") No response from ping, disconnecting.");
                    window.cti.api.xmpp_connection.disconnect();
                    if ($scope.stayConnected === true) {
                        $log.debug("[xmpp.fct.js] (" + $scope.id + ") Stay connected enabled, reconnecting...");
                        $scope.startReconnection();
                    }
                }, $scope.pingTo || 5000);
            };
        } else {
            $log.error("Missing data for XMPP instance.");
        }

        $rootScope.$on("device-resume", function () {
            if ($scope.stayConnected === true && (window.cti.api.xmpp_connection === null || window.cti.api.xmpp_connection.connected === false)) {
                $scope.reconnect();
            }
        });
    }

    Xmpp.prototype.calcGroups = function () {
        var contacts = StoreFactory.get("xmpp." + this.id + ".contacts");
        var groups = [];
        contacts.forEach(function (contact) {
            if (contact.groups !== undefined) {
                contact.groups.forEach(function (group) {
                    var res = $filter("filter")(groups, {"name": group}, true);
                    if (res.length === 0) {
                        groups.push({
                            "name": group,
                            "count": 1
                        });
                    } else {
                        groups = groups.map(function (group) {
                            group.count++;
                            return group;
                        });
                    }
                });
            }
        });
        StoreFactory.set("xmpp." + this.id + ".groups", groups);
    };

    Xmpp.prototype.processContacts = function ($items) {
        if ($items !== undefined && $items.length > 0) {
            // Get the current contacts from the model
            var contacts = StoreFactory.get("xmpp." + this.id + ".contacts") || [];
            // Loop through each roster item
            for (var i = 0; i < $items.length; i++) {
                // Make it easy to get at the item
                var $item = $items[i];
                // Used as the unique identifier
                var jid = $item.getAttribute("jid");
                // If the subscription is set to remove we just simply want to remove it
                if ($item.getAttribute("subscription") === "remove") {
                    // Filter out this item
                    contacts = contacts.filter(function (contact) {
                        return (contact.username !== jid);
                    });
                } else {
                    // Otherwise we need to construct the contact object
                    // Save an array of the groups which the contact is in
                    var groups = [];
                    var $groups = $item.querySelectorAll("group");
                    if ($groups.length > 0) {
                        for (var j = 0; j < $groups.length; j++) {
                            var $group = $groups[j];
                            groups.push(window.Strophe.getText($group));
                        }
                    }

                    // Create the up to date contact object
                    var contactObj = {
                        "name": $item.getAttribute("name"),
                        "username": jid,
                        "groups": groups,
                        "status": null,
                        "friendly_status": null
                    };
                    // Does the contact already exist?
                    var contact = contacts.filter(function (cContact) {
                        return (cContact.username === jid);
                    })[0];
                    // If not we need to add it
                    if (contact === undefined) {
                        contacts.push(contactObj);
                    } else {
                        // Otherwise we need to update the current one
                        contact = contactObj;
                    }
                }
            }
            // Update the model and persist to the DB
            StoreFactory.set("xmpp." + this.id + ".contacts", contacts);
            this.calcGroups();
        }
    };

    Xmpp.prototype.getSecureDb = function () {
        var deferred = $q.defer();

        this.DB.ID = StoreFactory.getId() + "_" + this.id + "_xmpp_db";
        var db = new PouchDB(this.DB.ID, {
            // eslint-disable-next-line camelcase
            revs_limit: 10
        });
        StoreFactory.getEncryptionKey(this.DB.ID).then(function (encryptionKey) {
            db.crypto({"key": encryptionKey});
            return deferred.resolve(db);
        }).catch(function (error) {
            deferred.reject(error);
        });

        return deferred.promise;
    };

    Xmpp.prototype.reconnectInterval = null;
    Xmpp.prototype.startReconnection = function () {
        var $scope = this;
        if ($scope.reconnectInterval === null) {
            $scope.reconnectInterval = setInterval(function () {
                if (window.cti.api.xmpp_connection.connected === false) {
                    $log.debug("[xmpp.fct.js] (" + $scope.id + ") Trying to reconnect...");
                    $scope.reconnect().then(function () {
                        $log.debug("[xmpp.fct.js] (" + $scope.id + ") Successfully reconnected!");
                        clearInterval($scope.reconnectInterval);
                        $scope.reconnectInterval = null;
                    });
                } else if ($scope.reconnectInterval !== null) {
                    clearInterval($scope.reconnectInterval);
                    $scope.reconnectInterval = null;
                }
            }, $scope.reconnectTime || 5000);
        }
    };

    Xmpp.prototype.reconnect = function () {
        var deferred = $q.defer();
        var $scope = this;
        this.getSecureDb().then(function (db) {
            db.get($scope.DB.ID + "_data").then(function (result) {
                $scope.DB.REVISION = result._rev;
                var credentials = result.data.split(":");
                if (credentials[0] !== undefined && credentials[1] !== undefined) {
                    var username = credentials[0];
                    var password = credentials[1];
                    $log.debug("[xmpp.fct.js] (" + $scope.id + ") Auto-Logging in as \"" + username + "\".");
                    $scope.login(username, password).then(function () {
                        var ActionFactory = $injector.get("ActionFactory");
                        ActionFactory.triggerEvent("reconnected", $scope.actions);
                        deferred.resolve();
                    }).catch(function (error) {
                        deferred.reject(error);
                    });
                } else {
                    deferred.reject("Could not extract the saved credentials from the encrypted database.");
                }
            }).catch(function () {
                $log.debug("[xmpp.fct.js] (" + $scope.id + ") Stored credentials could not be found to auto-login.");
                // If its not found, that"s fine. Continue.
                deferred.resolve();
            });
        }).catch(function (error) {
            deferred.reject(error);
        });
        return deferred.promise;
    };

    Xmpp.prototype.DB = {
        ID: null,
        KEY: "2%^%123$^#_##}{P21$@#Dd}23fs#!@|#213@4",
        REVISION: null
    };

    // Xmpp.prototype.queue = [];

    Xmpp.prototype.USER_STATUS = {
        AWAY: "away",
        CHAT: "chat",
        DO_NOT_DISTURB: "dnd",
        EXTENDED_AWAY: "xa"
    };

    Xmpp.prototype.MESSAGE_STATUS = {
        SENDING: "sending",
        SENT: "sent",
        FAILED: "failed",
        RECEIVED: "received",
        DISPLAYED: "displayed",
        ACKNOWLEDGED: "acknowledged"
    };

    Xmpp.prototype.MEDIA_STATUS = {
        DOWNLOADING: "downloading",
        DOWNLOADED: "downloaded",
        FAILED: "failed",
        UPLOADING: "uploading",
        UPLOADED: "uploaded"
    };

    Xmpp.prototype.CONNECTION_STATUS = {
        ERROR: "error", // 0
        CONNECTING: "connecting", // 1
        CONNFAIL: "connection-failed", // 2
        AUTHENTICATING: "authenticating", // 3
        AUTHFAIL: "authentication-failed", // 4
        CONNECTED: "connected", // 5
        DISCONNECTED: "disconnected", // 6
        DISCONNECTING: "disconnecting", // 7
        ATTACHED: "attached" // 8
    };

    Xmpp.prototype.setStatus = function (status) {
        var deferred = $q.defer();
        var txt = null;
        switch (status) {
            case this.USER_STATUS.AWAY:
                txt = "Away";
                break;
            case this.USER_STATUS.CHAT:
                txt = "Available";
                break;
            case this.USER_STATUS.DO_NOT_DISTURB:
                txt = "Do Not Disturb";
                break;
            case this.USER_STATUS.EXTENDED_AWAY:
                txt = "Extended Away";
                break;
        }
        if (txt !== null) {
            var pres = window.$pres({from: window.cti.api.xmpp_connection.jid})
                .c("show", null, status)
                .c("status", null, txt);
            StoreFactory.set("xmpp." + this.id + ".user_status", status);
            window.cti.api.xmpp_connection.send(pres.tree());
            deferred.resolve();
        } else {
            deferred.reject("Invalid status provided.");
        }

        return deferred.promise;
    };

    Xmpp.prototype.setConnectionStatus = function (status) {
        StoreFactory.set("xmpp." + this.id + ".connection_status", status);
    };

    Xmpp.prototype.setLastAuthStatus = function (value) {
        StoreFactory.set("xmpp." + this.id + ".last_auth_status", value);
    };

    Xmpp.prototype.statusCodeToTxt = function (code) {
        var txt = null;
        switch (code) {
            case window.Strophe.Status.ERROR:
                txt = this.CONNECTION_STATUS.ERROR;
                break;
            case window.Strophe.Status.CONNECTING:
                txt = this.CONNECTION_STATUS.CONNECTING;
                break;
            case window.Strophe.Status.CONNFAIL:
                txt = this.CONNECTION_STATUS.CONNFAIL;
                break;
            case window.Strophe.Status.AUTHENTICATING:
                txt = this.CONNECTION_STATUS.AUTHENTICATING;
                break;
            case window.Strophe.Status.AUTHFAIL:
                txt = this.CONNECTION_STATUS.AUTHFAIL;
                break;
            case window.Strophe.Status.CONNECTED:
                txt = this.CONNECTION_STATUS.CONNECTED;
                break;
            case window.Strophe.Status.DISCONNECTED:
                txt = this.CONNECTION_STATUS.DISCONNECTED;
                break;
            case window.Strophe.Status.DISCONNECTING:
                txt = this.CONNECTION_STATUS.DISCONNECTING;
                break;
            case window.Strophe.Status.ATTACHED:
                txt = this.CONNECTION_STATUS.ATTACHED;
                break;
        }
        return txt;
    };

    Xmpp.prototype.createMessageXml = function (id) {
        var message = this.getMessageFromAllHistory(id);
        var $message = window.$msg({"to": message.to, "from": message.from, "id": id, "type": "chat"}).tree();
        if (message.addresses !== null) {
            var $addresses = new window.Strophe.Builder("addresses", {xmlns: "http://jabber.org/protocol/address"}).tree();
            message.addresses.forEach(function (address) {
                var $address = new window.Strophe.Builder("address", {type: "to", jid: address}).tree();
                $addresses.appendChild($address);
            });
            $message.appendChild($addresses);
        }
        if (message.body !== undefined) {
            var $body = new window.Strophe.Builder("body").t(message.body).tree();
            $message.appendChild($body);
        }
        if (message.media.remote !== null) {
            var $x = new window.Strophe.Builder("x", {xmlns: "jabber:x:oob"}).tree();
            var $url = new window.Strophe.Builder("url").t(message.media.remote).tree();
            $x.appendChild($url);
            $message.appendChild($x);
        }
        if (this.readReceipts !== false) {
            var $markable = new window.Strophe.Builder("markable", {xmlns: "urn:xmpp:chat-markers:0"}).tree();
            $message.appendChild($markable);
        }
        if (message.ttl !== null) {
            var $xpire = new window.Strophe.Builder("x", {xmlns: "jabber:x:expire", seconds: message.ttl}).tree();
            $message.appendChild($xpire);
        }
        if (message.metadata !== null && Object.keys(message.metadata).length > 0) {
            var $metadata = new window.Strophe.Builder("metadata", {xmlns: "urn:commontime:mdesign:metadata"}).tree();
            for (var key in message.metadata) {
                if (message.metadata[key] !== undefined) {
                    var $data = new window.Strophe.Builder(key).t(message.metadata[key]).tree();
                    $metadata.appendChild($data);
                }
            }
            $message.appendChild($metadata);
        }
        return $message;
    };

    Xmpp.prototype.sendMarker = function (messageId, markerType) {
        var message = this.getMessageFromAllHistory(messageId);
        var $message = window.$msg({
            "to": message.from,
            "from": message.to,
            "id": window.cti.api.xmpp_connection.getUniqueId(),
            "type": "marker"
        });
        $message.c(markerType, {xmlns: "urn:xmpp:chat-markers:0", id: messageId});
        message.status = markerType;
        this.calcReadCount(message.from);
        window.cti.api.xmpp_connection.send($message.tree());
    };

    Xmpp.prototype.calcReadCount = function (recipient) {
        if (window.cti.store.xmpp[this.id] !== undefined &&
            window.cti.store.xmpp[this.id].history !== undefined &&
            window.cti.store.xmpp[this.id].history[recipient] !== undefined
        ) {
            var history = window.cti.store.xmpp[this.id].history[recipient].messages;
            var read = 0;
            var unread = 0;
            var $scope = this;
            history.forEach(function (message) {
                if (message.from == recipient) {
                    if (message.status === $scope.MESSAGE_STATUS.DISPLAYED || message.status === $scope.MESSAGE_STATUS.ACKNOWLEDGED) {
                        read = (read + 1);
                    } else {
                        unread = (unread + 1);
                    }
                }
            });
            window.cti.store.xmpp[this.id].history[recipient].read = read;
            window.cti.store.xmpp[this.id].history[recipient].unread = unread;
            this.saveAndUpdate();
        }
    };

    Xmpp.prototype.createMessageObject = function (to, from, body, media, messageId, ttl, metadata, addresses) {
        // authzid
        var recipient = (from === window.cti.api.xmpp_connection.authzid) ? to : from;
        if (recipient !== undefined) {
            // Construct the basic message object
            var message = {
                "id": (messageId !== undefined && messageId !== null) ? messageId : window.cti.api.xmpp_connection.getUniqueId(),
                "from": from,
                "ttl": (ttl !== undefined) ? ttl : null,
                "to": to,
                "body": body,
                "sent": false,
                "status": (from === window.cti.api.xmpp_connection.authzid) ? this.MESSAGE_STATUS.SENDING : null,
                "ts": new Date().getTime(),
                "media": {
                    "local": null,
                    "remote": null,
                    "status": null
                },
                "metadata": (metadata !== undefined && metadata !== null) ? metadata : null,
                "addresses": (addresses !== undefined) ? addresses : null
            };
            if (media !== undefined && media !== null) {
                if (media.local !== undefined) {
                    message.media.local = media.local;
                }
                if (media.remote !== undefined) {
                    message.media.remote = media.remote;
                }
                if (media.status !== undefined) {
                    message.media.status = media.status;
                }
            }
            // Add the message to the message history
            this.addHistory(recipient, message);
            // Get the message with reference to the history so we can update it
            return this.getMessageFromHistory(recipient, message.id);
        } else {
            $log.error("Recipient required for a message.");
            return null;
        }
    };

    Xmpp.prototype.getMessageFromHistory = function (recipient, messageId) {
        var message = null;
        if (window.cti.store.xmpp[this.id].history[recipient] !== undefined) {
            var history = window.cti.store.xmpp[this.id].history[recipient].messages;
            if (history !== undefined && history.length > 0) {
                history.forEach(function (item) {
                    if (item.id == messageId) {
                        message = item;
                    }
                });
            }
        }
        return message;
    };

    Xmpp.prototype.getMessageFromAllHistory = function (messageId) {
        var history = window.cti.store.xmpp[this.id].history;
        var message = null;
        if (history !== undefined) {
            for (var key in history) {
                if (message === null) {
                    message = this.getMessageFromHistory(key, messageId);
                }
            }
        }
        return message;
    };

    Xmpp.prototype.addHistory = function (recipient, message) {
        if (window.cti.store.xmpp[this.id].history[recipient] === undefined) {
            window.cti.store.xmpp[this.id].history[recipient] = {
                "messages": [],
                "read": 0,
                "unread": 0
            };
        }
        message.ts = new Date().getTime();
        window.cti.store.xmpp[this.id].history[recipient].messages.push(message);
    };

    Xmpp.prototype.saveAndUpdate = function () {
        StoreFactory.save().then(function () {
            $rootScope.$emit("StoreHasChanged");
        });
    };

    Xmpp.prototype.cleanQueue = function () {
        if (window.cti.store.xmpp[this.id] !== undefined) {
            var history = window.cti.store.xmpp[this.id].history;
            var changed = false;
            if (history !== undefined) {
                var self = this;
                for (var key in history) {
                    var messages = history[key].messages;
                    if (messages !== undefined) {
                        messages.forEach(function (message) {
                            if (message.status === self.MESSAGE_STATUS.SENDING) {
                                message.status = self.MESSAGE_STATUS.FAILED;
                                changed = true;
                            }
                        });
                    }
                }
            }
            if (changed === true) {
                this.saveAndUpdate();
            }
        }
    };

    Xmpp.prototype.getBareJid = function (jid) {
        return window.Strophe.getBareJidFromJid(jid);
    };

    return Xmpp;

}]);

angular.module("app.core").factory("XmppFactory", ["Xmpp", "$q", function (Xmpp, $q) {

    var _instances = {};

    var service = {
        "init": init,
        "send": send,
        "login": login,
        "logout": logout,
        "markRead": markRead,
        "setStatus": setStatus,
        "sendToGroup": sendToGroup,
        "markAcknowledged": markAcknowledged
    };

    function init(item) {
        _instances[item.name] = new Xmpp(item.name, item.endpoint, item.actions, item["upload-jid"], item["read-receipts"], item["stay-connected"], item["multicast-jid"], item["ping-time"], item["ping-timeout"], item["send-timeout"], item["outbox"], item["reconnect-time"]);
    }

    function send(data) {
        var deferred = $q.defer();
        var name = data.name;
        if (name !== undefined) {
            if (_instances[name] !== undefined) {
                _instances[name].send(data).then(function () {
                    deferred.resolve(true);
                }).catch(function (error) {
                    deferred.reject(error);
                });
            } else {
                deferred.reject("XMPP instance with name \"" + name + "\" does not exist.");
            }
        } else {
            deferred.reject("XMPP instance name not specified.");
        }
        return deferred.promise;
    }

    function sendToGroup(data) {
        var deferred = $q.defer();
        var name = data.name;
        if (name !== undefined) {
            if (_instances[name] !== undefined) {
                _instances[name].sendToGroup(data).then(function () {
                    deferred.resolve(true);
                }).catch(function (error) {
                    deferred.reject(error);
                });
            } else {
                deferred.reject("XMPP instance with name \"" + name + "\" does not exist.");
            }
        } else {
            deferred.reject("XMPP instance name not specified.");
        }
        return deferred.promise;
    }

    function markRead(data) {
        var deferred = $q.defer();
        var name = data.name;
        if (name !== undefined) {
            if (_instances[name] !== undefined) {
                _instances[name].markRead(data).then(function () {
                    deferred.resolve(true);
                }).catch(function (error) {
                    deferred.reject(error);
                });
            } else {
                deferred.reject("XMPP instance with name \"" + name + "\" does not exist.");
            }
        } else {
            deferred.reject("XMPP instance name not specified.");
        }
        return deferred.promise;
    }

    function markAcknowledged(data) {
        var deferred = $q.defer();
        var name = data.name;
        if (name !== undefined) {
            if (_instances[name] !== undefined) {
                if (data.id !== undefined) {
                    _instances[name].sendMarker(data.id, "acknowledged");
                    deferred.resolve();
                } else {
                    deferred.reject("Message ID must be provided.");
                }
            } else {
                deferred.reject("XMPP instance with name \"" + name + "\" does not exist.");
            }
        } else {
            deferred.reject("XMPP instance name not specified.");
        }
        return deferred.promise;
    }

    function setStatus(data) {
        var deferred = $q.defer();
        var name = data.name;
        var status = (data.custom || data.status);
        if (name !== undefined && status !== undefined) {
            if (_instances[name] !== undefined) {
                _instances[name].setStatus(status).then(function () {
                    deferred.resolve(true);
                }).catch(function (error) {
                    deferred.reject(error);
                });
            } else {
                deferred.reject("XMPP instance with name \"" + name + "\" does not exist.");
            }
        } else {
            deferred.reject("XMPP instance name not specified.");
        }
        return deferred.promise;
    }

    function login(data) {
        var deferred = $q.defer();
        var name = data.name;
        if (name !== undefined) {
            if (_instances[name] !== undefined) {
                _instances[name].login(data.username, data.password).then(function () {
                    deferred.resolve();
                }).catch(function (error) {
                    deferred.reject(error);
                });
            } else {
                deferred.reject("XMPP instance with name \"" + name + "\" does not exist.");
            }
        } else {
            deferred.reject("XMPP instance name not specified.");
        }
        return deferred.promise;
    }

    function logout(data) {
        var deferred = $q.defer();
        var name = data.name;
        if (name !== undefined) {
            if (_instances[name] !== undefined) {
                _instances[name].logout().then(function () {
                    deferred.resolve();
                }).catch(function (error) {
                    deferred.reject(error);
                });
            } else {
                deferred.reject("XMPP instance with name \"" + name + "\" does not exist.");
            }
        } else {
            deferred.reject("XMPP instance name not specified.");
        }
        return deferred.promise;
    }

    return service;

}]);

angular
    .module("app.core")
    .factory("FileSystem", ["Plugin", "$q", "Platform", "electron", "MimeTypes", "$log", function (Plugin, $q, Platform, electron, MimeTypes, $log) {
    
        function _isElectron() {
        
            return (electron.app !== undefined);
        }
    
        function _isDevice() {
        
            return (window.resolveLocalFileSystemURL !== undefined);
        }

        /**
         * Obtains the path to the default storage location for the current platform
         * @returns {Promise} - A promise to resolve with the path of the default storage platform
         */
        function getStorageLocation() {

            if (_isElectron()) {

                var pathSeparator = electron.path.sep;
                var applicationDataPath = electron.app.getPath("userData");
                var location = applicationDataPath + pathSeparator;

                return $q.when(location);
            }

            if (Platform.getName() == "winphone") {

                return $q.resolve("");
            }

            var file = Plugin.getSource("file");
            if (!file) {

                return $q.reject("File System unavailable on this platform: " + navigator.userAgent);
            }

            var deferred = $q.defer();

            switch (Platform.getName()) {

                case "ios":
                    deferred.resolve(file.documentsDirectory);
                    break;

                case "android":
                    deferred.resolve(file.externalDataDirectory);
                    break;

                default:
                    deferred.resolve(file.dataDirectory);
                    break;
            }

            return deferred.promise;
        }

        /**
         * Obtains directory metadata for the current platform.
         * NOTE: Currently only available to devices and not to desktop.
         * @returns {Promise} - A promise to resolve with the DirectoryEntry cordova-plugin-file object representing the default storage location
         */
        function getStorage() {

            var deferred = $q.defer();

            getStorageLocation()
                .then(function (location) {

                    if (_isDevice()) {

                        // Fix for cameras -- needs a path, otherwise the camera crashes
                        if (Platform.getName() == "winphone" && location === "") {
                            location += ".\\";
                        }

                        window.resolveLocalFileSystemURL(location, function (directory) {
                            deferred.resolve(directory);
                        }, function (error) {
                            deferred.reject(error);
                        });

                    } else {

                        deferred.reject("Local file system unavailable on this platform.");
                    }

                })
                .catch(function (error) {

                    deferred.reject(error);
                });

            return deferred.promise;
        }

        /**
         * Obtains file metadata for a file given a file name.
         * @param {string} fileName - The name of the file which should be located in default device storage
         * @returns {Promise} - A promise to resolve with a file object containing file name, file path, mime type and size
         */
        function getFile(fileName) {

            var deferred = $q.defer();

            getStorageLocation()
                .then(function (location) {

                    if (_isElectron()) {

                        electron.fsplus.stat(location + fileName, function (error, stats) {

                            if (error) {

                                deferred.reject({
                                    message: "Error obtaining file '" + fileName + "'",
                                    innerError: error
                                });

                            } else {

                                deferred.resolve({
                                    name: fileName,
                                    filePath: location + fileName,
                                    mimeType: MimeTypes.mimeTypeFromExtension(fileName),
                                    size: stats.size
                                });
                            }
                        });

                    } else if (_isDevice()) {

                        window.resolveLocalFileSystemURL(location + fileName, function (fileEntry) {

                            fileEntry.file(function (file) {

                                deferred.resolve({
                                    name: file.name || file.localURL,
                                    filePath: file.localURL,
                                    mimeType: MimeTypes.mimeTypeFromExtension(file.name || file.localURL),
                                    size: file.size
                                });

                            });

                        }, function (error) {
                            deferred.reject({
                                message: "Error obtaining file '" + fileName + "'",
                                innerError: error
                            });
                        });

                    } else {

                        deferred.reject("Local file system unavailable on this platform: " + navigator.userAgent);
                    }
                })
                .catch(function (error) {

                    deferred.reject({
                        message: "Error obtaining file '" + fileName + "'",
                        innerError: error
                    });
                });

            return deferred.promise;
        }

        /**
         * Obtains a Blob object for the file given a file name
         * @param {string} fileName - The name of the file which should be located in default device storage
         * @returns {Blob} - A blob of the file data
         */
        function getFileBlob(fileName) {

            var deferred = $q.defer();

            getStorageLocation()
                .then(function (location) {

                    if (_isElectron()) {

                        electron.fsplus.readFile(location + fileName, function (error, data) {

                            if (error) {

                                deferred.reject({
                                    message: "Error obtaining file blob for file '" + fileName + "'",
                                    innerError: error
                                });

                            } else {

                                var blob = new Blob([data], {type: MimeTypes.mimeTypeFromExtension(fileName)});
                                deferred.resolve(blob);
                            }
                        });

                    } else if (_isDevice()) {

                        window.resolveLocalFileSystemURL(location + fileName, function (file) {

                            file.file(function (fileObject) {

                                var fileReader = new FileReader();
                                fileReader.onloadend = function (event) {
                                    var blob = new Blob([event.target.result], {type: MimeTypes.mimeTypeFromExtension(fileName)});
                                    deferred.resolve(blob);
                                };
                                fileReader.readAsArrayBuffer(fileObject);
                            });

                        }, function (error) {

                            deferred.reject({
                                message: "Error obtaining file blob for file '" + fileName + "'",
                                innerError: error
                            });
                        });

                    } else {

                        deferred.reject("Unable to read file on this platform: " + navigator.userAgent);
                    }

                })
                .catch(function (error) {

                    deferred.reject({
                        message: "Error obtaining file blob for file '" + fileName + "'",
                        innerError: error
                    });
                });

            return deferred.promise;
        }

        /**
         * Obtains just the file name part given a file path
         * @param {string} filePath - The full file path
         * @returns {string} - The file name portion of the file path (including file extension)
         */
        function getFileNameFromPath(filePath) {

            return filePath.replace(/\\/g, "/").split("/").pop();

        }

        /**
         * Obtains the path to the folder that the file resides in given a file path
         * @param {string} filePath - The full file path
         * @returns {string} - The folder name portion of the file path
         */
        function getFolderFromPath(filePath) {

            if (filePath.indexOf("/") == -1) { // windows
                return filePath.substring(0, filePath.lastIndexOf("\\") + 1);
            } else { // unix
                return filePath.substring(0, filePath.lastIndexOf("/") + 1);
            }

        }

        /**
         * Save a file to the device storage given the supplied file name and file data
         * @param {string} fileName - The name to save the file as
         * @param {object} fileData - The file data
         * @returns {Promise} - A promise to resolve once the file is saved to device storage
         */
        function saveFile(fileName, fileData) {

            var deferred = $q.defer();

            getStorageLocation()
                .then(function (location) {

                    var filePath = location + fileName;
                    var mimeType = MimeTypes.mimeTypeFromExtension(fileName);

                    if (_isElectron()) {

                        var arrayBuffer = new Uint8Array(fileData);
                        var fileBuffer = new window.Buffer(arrayBuffer);

                        electron.fsplus.writeFile(filePath, fileBuffer, function (error) {

                            if (error) {

                                deferred.reject({
                                    message: "Error saving file '" + fileName + "'",
                                    innerError: error
                                });

                            } else {

                                deferred.resolve(filePath);
                            }
                        });

                    } else if (_isDevice()) {

                        getStorage()
                            .then(function (directoryEntry) {

                                directoryEntry.getFile(fileName, {
                                    create: true,
                                    exclusive: false
                                }, function (fileEntry) {

                                    fileEntry.createWriter(function (fileWriter) {

                                        fileWriter.onwriteend = function () {
                                            fileEntry.file(function (file) {
                                                deferred.resolve(file.localURL);
                                            });
                                        };

                                        fileWriter.onerror = function (error) {
                                            deferred.reject({
                                                message: "Error saving file '" + fileName + "'",
                                                innerError: error
                                            });
                                        };

                                        var blob = new Blob([fileData], {type: mimeType});
                                        fileWriter.write(blob);
                                    });
                                });
                            });

                    } else {

                        deferred.reject("Unable to save file on this platform: " + navigator.userAgent);
                    }

                })
                .catch(function (error) {

                    deferred.reject({
                        message: "Error saving file '" + fileName + "'",
                        innerError: error
                    });
                });

            return deferred.promise;
        }

        /**
         * Rename a file in device storage given the supplied current file name and new file name
         * @param {string} currentFileName - The current name of the file
         * @param {string} newFileName - The new name for the file
         * @returns {Promise} - A promise to resolve once the file is renamed
         */
        function renameFile(currentFileName, newFileName) {

            var deferred = $q.defer();

            getStorageLocation()
                .then(function (location) {

                    if (_isElectron()) {

                        var currentFilePath = location + currentFileName;
                        var newFilePath = location + newFileName;

                        electron.fsplus.rename(currentFilePath, newFilePath, function (error) {

                            if (error) {
                                deferred.reject({
                                    message: "Error renaming file '" + currentFileName + "'",
                                    innerError: error
                                });
                            } else {
                                deferred.resolve(newFilePath);
                            }
                        });

                    } else if (_isDevice()) {

                        getStorage()
                            .then(function (directoryEntry) {

                                directoryEntry.getFile(currentFileName, {
                                    create: false,
                                    exclusive: true
                                }, function (fileEntry) {

                                    fileEntry.moveTo(directoryEntry, newFileName, function (movedFileEntry) {
                                        movedFileEntry.file(function (file) {
                                            deferred.resolve(file.localURL);
                                        });
                                    }, function (error) {
                                        deferred.reject({
                                            message: "Error renaming file '" + currentFileName + "'",
                                            innerError: error
                                        });
                                    });
                                }, function (error) {
                                    deferred.reject({
                                        message: "Error renaming file '" + currentFileName + "'",
                                        innerError: error
                                    });
                                });
                            });

                    } else {

                        deferred.reject("Unable to rename file on this platform: " + navigator.userAgent);
                    }
                })
                .catch(function (error) {

                    deferred.reject({
                        message: "Error renaming file '" + currentFileName + "'",
                        innerError: error
                    });
                });

            return deferred.promise;
        }

        /**
         * Move a file to the device storage given the supplied file path and new file name
         * @param {string} filePath - The current path of the file
         * @param {string} newFileName - The new name in storage for the file
         * @returns {Promise} - A promise to resolve once the file is moved
         */
        function moveFileToStorage(filePath, newFileName) {

            var deferred = $q.defer();

            getStorageLocation()
                .then(function (location) {

                    if (_isElectron()) {

                        var newFilePath = location + newFileName;

                        electron.fsplus.rename(filePath, newFilePath, function (error) {

                            if (error) {
                                deferred.reject({
                                    message: "Error moving file at '" + filePath + "'",
                                    innerError: error
                                });
                            } else {
                                deferred.resolve(newFilePath);
                            }
                        });

                    } else if (_isDevice()) {

                        if (Platform.getName() === "ios" || Platform.getName() === "android") {
                            if (filePath.indexOf("file://") == -1) {
                                filePath = "file://" + filePath;
                            }
                        }

                        var folder = getFolderFromPath(filePath);
                        var fileName = getFileNameFromPath(filePath);
                        window.resolveLocalFileSystemURL(folder, function (directoryEntry) {
                            directoryEntry.getFile(fileName, {create: false, exclusive: true}, function (fileEntry) {

                                fileEntry.moveTo(directoryEntry, newFileName, function (movedFileEntry) {
                                    movedFileEntry.file(function (file) {
                                        deferred.resolve(file.localURL);
                                    });
                                }, function (error) {
                                    deferred.reject({
                                        message: "Error moving file '" + filePath + "'",
                                        innerError: error
                                    });
                                });
                            }, function (error) {
                                deferred.reject({
                                    message: "Error moving file '" + filePath + "'",
                                    innerError: error
                                });
                            });
                        });

                    } else {

                        deferred.reject("Unable to move file on this platform: " + navigator.userAgent);
                    }
                })
                .catch(function (error) {

                    deferred.reject({
                        message: "Error moving file '" + filePath + "'",
                        innerError: error
                    });
                });

            return deferred.promise;
        }

        /**
         * Upload a file to a URL from the specified file path
         * @param {string} filePath - The path to the file on the device
         * @param {string} url - The URL to upload the file to
         * @param {object} options - The file upload options: httpMethod (POST or PUT), fileName (name of file), fileKey (the parameter name of the file to upload) and headers (object of headers to send)
         * @returns {Promise} - Promise to resolve when the file is uploaded
         */
        function upload(filePath, url, options) {
            var FileTransfer = (_isElectron())
                ? Plugin.getSource("@commontimeltd/com.commontime.filetransfer") // should come from node module
                : Plugin.getSource("FileTransfer"); // should come from cordova plugin

            if (!FileTransfer) {

                return $q.reject("File transfer plugin not available");
            }

            var deferred = $q.defer();

            var uploadOptions = {
                httpMethod: options.httpMethod,
                fileName: options.fileName || getFileNameFromPath(filePath),
                fileKey: options.fileKey,
                headers: options.headers
            };

            var ft = new FileTransfer();
            ft.upload(filePath, url, function (result) {

                deferred.resolve({
                    source: filePath,
                    target: url,
                    response: result.response
                });

            }, function (error) {

                deferred.reject({
                    message: "Error uploading file '" + filePath + "' to '" + url + "'",
                    innerError: error
                });

            }, uploadOptions);

            return deferred.promise;
        }

        /**
         * Download a file from a URL to the device storage as the supplied filename
         * @param {string} url - The URL to download the file from
         * @param {string} fileName - The file name to save as
         * @returns {Promise} - Promise to resolve with the full file path and mime type of the downloaded file
         */
        function download(url, fileName) {

            var FileTransfer = (_isElectron())
                ? Plugin.getSource("@commontimeltd/com.commontime.filetransfer") // should come from node module
                : Plugin.getSource("FileTransfer"); // should come from cordova plugin

            if (!FileTransfer) {

                return $q.reject("File transfer plugin not available");
            }

            if (_isElectron()) {

                getStorageLocation()
                    .then(function (location) {
                        doDownload(location);
                    });

            } else {

                getStorage()
                    .then(function (directory) {
                        doDownload(directory.nativeURL);
                    });
            }

            var deferred = $q.defer();

            function doDownload(location) {

                var filePath = location + fileName;

                var ft = new FileTransfer();
                ft.download(url, filePath, function (result) {

                    if (_isElectron()) {

                        deferred.resolve({
                            filePath: result.filePath,
                            mimeType: MimeTypes.mimeTypeFromExtension(result.filePath)
                        });

                    } else {

                        result.file(function (file) {

                            deferred.resolve({
                                filePath: file.localURL,
                                mimeType: MimeTypes.mimeTypeFromExtension(file.localURL)
                            });

                        }, function (error) {

                            deferred.reject({
                                message: "Error download file from '" + url + "' to '" + filePath + "'",
                                innerError: error
                            });
                        });
                    }

                }, function (error) {

                    deferred.reject({
                        message: "Error download file from '" + url + "' to '" + filePath + "'",
                        innerError: error
                    });
                });
            }

            return deferred.promise;
        }

        /**
         * Generates a filename inside the Storage Location path.
         * @returns {Promise} - Promise to resolve with the full file path
         */
        function generateFileName() {
            var deferred = $q.defer();

            var d = new Date();
            var n = d.getTime();

            var fileName = n + ".m4a";

            getStorageLocation().then(function (location) {
                if (location.indexOf("file://") === 0) {
                    location = location.replace("file://", "");
                }
                var recordPath = location + fileName;
                deferred.resolve(recordPath);
            }).catch(function (error) {
                $log.error(error);
            });

            return deferred.promise;
        }

        /**
         * Deletes a media item at a given file URI
         * @param {string} uri - The file URI to delete the file from
         * @returns {Promise} - Promise to resolve if the file has been deleted successfully
         */
        function deleteMediaItem(uri) {
            var deferred = $q.defer();

            var onError = function () {
                $log.error(arguments);
                deferred.reject(arguments);
            };

            if (uri === undefined || uri === null) {
                onError("Could not delete media item - no uri specified");
            } else if (!_isElectron() && !_isDevice()) {
                onError("resolveLocalFileSystemURL is not available - platform could not be detected");
            } else if (_isElectron()) {
                try {
                    // Check the filepath exists and it"s a file
                    if (electron.fsplus.existsSync(uri) === false) {
                        onError("Error deleting file - file does not exist");
                    } else if (electron.fsplus.isFileSync(uri) === false) {
                        onError("Error deleting file - path was not a file");
                    } else {
                        electron.fsplus.removeSync(uri);
                        deferred.resolve();
                    }
                } catch (e) {
                    onError("Error deleting file", e);
                }
            } else {
                try {
                    var prefixNotFound = uri.indexOf("file://") == -1;
                    if (Platform.getName() != "winphone" && prefixNotFound) {
                        uri = "file://" + uri;
                    }
                    window.resolveLocalFileSystemURL(uri, function (fileEntry) {
                        // Assuming it"s a fileEntry isn't good enough
                        // This function returns a FileEntry or a DirectoryEntry, both have the following flag correctly set
                        if (fileEntry.isDirectory) {
                            onError("Error getting file to delete - file uri resolved to a directory: ", uri);
                        } else {
                            fileEntry.remove(function () {
                                deferred.resolve();
                            }, function (error) {
                                onError("Error deleting the file: ", error);
                            });
                        }
                    }, function (error) {
                        onError("Error getting file entry", error);
                    });
                } catch (e) {
                    onError("Error deleting file: ", e);
                }
            }

            return deferred.promise;
        }

        function selectFile(mimes) {
            var deferred = $q.defer();
            var fileFilters = [];
            if (mimes !== undefined && mimes.length > 0) {
                var exts = [];
                mimes.forEach(function (mime) {
                    var ext = MimeTypes.extensionFromMimeType(mime);
                    if (ext !== null) {
                        exts.push(ext);
                    }
                });
                if (exts.length > 0) {
                    fileFilters.push({name: "Mimes", extensions: exts});
                }
            }
            electron.dialog.showOpenDialog({
                properties: ["openFile", "singleSelection"],
                filters: fileFilters
            }, function (paths) {
                if (paths == undefined || (paths != undefined && paths.length == 0)) {
                    return;
                }
                getStorageLocation().then(function (location) {
                    var path = paths[0];
                    var fileName = getFileNameFromPath(path);
                    var destination = location + fileName;
                    // eslint-disable-next-line consistent-return
                    electron.fsplus.copy(paths[0], destination, function (error) {
                        if (error) return $log.error(error);
                        deferred.resolve(destination);
                    });
                });
            });
            return deferred.promise;
        }

        return {
            "getStorageLocation": getStorageLocation,
            "getStorage": getStorage,
            "getFile": getFile,
            "getFileBlob": getFileBlob,
            "getFileNameFromPath": getFileNameFromPath,
            "saveFile": saveFile,
            "renameFile": renameFile,
            "moveFileToStorage": moveFileToStorage,
            "upload": upload,
            "download": download,
            "generateFileName": generateFileName,
            "deleteMediaItem": deleteMediaItem,
            "selectFile": selectFile
        };
    }]);

angular.module("app.core").factory("Platform", ["StoreFactory", function (StoreFactory) {

    var service = {
        "init": init,
        "getType": getType,
        "getName": getName
    };

    var _ieRegexp = (navigator.userAgent.indexOf("MSIE") != -1) ? /MSIE (\d+\.\d+);/ : /Trident.*rv[ :]*(\d+\.\d+)/;

    function init() {
        StoreFactory.set("env.platform.type", getType());
        StoreFactory.set("env.platform.name", getName());
    }

    function getType() {
        if ((window.cordova !== false) && /iPhone|iPad|iPod|IEMobile|Android/i.test(navigator.userAgent)) {
            return "device";
        } else if (/Electron/i.test(navigator.userAgent)) {
            return "desktop";
        } else if (/Chrome/i.test(navigator.userAgent) || /Firefox/i.test(navigator.userAgent) || _ieRegexp.test(navigator.userAgent)) {
            return "browser";
        } else {
            return null;
        }
    }

    function getName() {
        if (/IEMobile/i.test(navigator.userAgent) || /Windows Phone 8\.1/i.test(navigator.userAgent)) {
            return "winphone";
        }  else if (/Android/i.test(navigator.userAgent)) {
            return "android";
        } else if (/iPhone|iPad|iPod/i.test(navigator.userAgent)) {
            return "ios";
        } else if (/Electron/i.test(navigator.userAgent)) {
            return "electron";
        } else if (/Chrome/i.test(navigator.userAgent)) {
            return "chrome";
        } else if (/Firefox/i.test(navigator.userAgent)) {
            return "firefox";
        } else if (_ieRegexp.test(navigator.userAgent)) {
            return "internet_explorer";
        } else {
            return null;
        }
    }

    return service;
}]);
angular
    .module("app.core")
    .factory("InboxOutboxFactory", ["$q", "$log", "$injector", "Plugin", "Utilities", "electron", function ($q, $log, $injector, Plugin, Utilities, electron) {

        // === Constants === //

        var USE_MOCK_PLUGIN = false; // Set to true to use locally mocked plugins for testing and debugging purposes

        var RECEIVER_NAME = "com.commontime.inboxOutbox"; // fixed receiver name for now

        var PROVIDER_AZURESERVICEBUS = "azure.servicebus";
        var PROVIDER_AZUREAPPSERVICES = "azure.appservices";
        var PROVIDER_REST = "rest";
        var PROVIDER_UNKNOWN = null;

        // === Fields === //

        var _isDebugMode = false;
        var _isElectron = (electron.app !== undefined);
        var _initialised = false;
        var _pluginReady = false;
        var _providerConfigs = {};
        var _plugin = null;
        var _schemaService = null;
        var _actionFactory = null;
        
        var _actionCache = {};

        // === Service functions === //

        function init() {

            var debugData = sessionStorage.getItem("debug");
            if (debugData) {
                var items = debugData.split("|");
                _isDebugMode = ((items.indexOf("*") !== -1) || (items.indexOf("inboxoutbox") !== -1));
            }

            debug("Ensuring \"InboxOutbox\" factory is initialised...");

            if (_initialised) return $q.when();

            var deferred = $q.defer();

            // manual injection to avoid angular circular dependency
            _schemaService = $injector.get("SchemaService");
            _actionFactory = $injector.get("ActionFactory");

            preparePlugin()
                .then(function () {

                    if (_plugin === false) {

                        deferred.reject("Unable to initialise \"notify\" plugin");

                    } else {

                        setTimeout(function () {

                            debug("Registering global outbox and inbox change handlers");
                            _plugin.receiveInboxChanges(RECEIVER_NAME, handleInboxChange);
                            _plugin.receiveOutboxChanges(RECEIVER_NAME, handleOutboxChange);

                            _pluginReady = true;

                            deferred.resolve();
                        }, 0);
                    }
                })
                .catch(function (error) {

                    logError(error);
                });

            _initialised = true;

            return deferred.promise;
        }

        function setOptions(options) {

            if (!_pluginReady) return $q.reject("Notfiy plugin not initialised");

            var deferred = $q.defer();

            debug("Setting \"notify\" options:", options);

            _plugin.setOptions(function () {
                deferred.resolve();
            }, function () {
                deferred.reject("Error setting message queue options");
            }, options);

            return deferred.promise;
        }

        function getProviderPlugin(pluginName) {

            return _isElectron
                ? Plugin.getSource("@commontimeltd/com.commontime." + pluginName)
                : Plugin.getSource(pluginName);
        }

        function registerProvider(providerConfig) {

            debug("Registering provider with InboxOutboxFactory:", providerConfig);

            _providerConfigs[providerConfig.name] = {
                outboxChangeCallback: providerConfig.outboxChangeCallback,
                inboxChangeCallback: providerConfig.inboxChangeCallback
            };

            return $q.when(_providerConfigs[providerConfig.name]);
        }

        function isFromStudio() {

            return (_schemaService.isPreview() || _schemaService.isLivePreview());
        }

        function generateRequestId(providerName) {

            return "REQUEST_" + providerName.toUpperCase() + "_" + Utilities.uuid();
        }

        function addChannel(channelName) {

            if (!_pluginReady) return $q.reject("Notfiy plugin not initialised");

            return callPluginMethod("addChannel", [channelName]);
        }

        function removeChannel(channelName) {

            if (!_pluginReady) return $q.reject("Notfiy plugin not initialised");

            return callPluginMethod("removeChannel", [channelName]);
        }

        function sendMessage(message) {

            if (!_pluginReady) return $q.reject("Notfiy plugin not initialised");

            debug("Sending message...", message);

            return callPluginMethod("sendMessage", [message]);
        }

        function acknowledgeMessage(receiver, messageId) {

            if (!_pluginReady) return $q.reject("Notfiy plugin not initialised");

            debug("Acknowledging message id \"" + messageId + "\" for receiver \"" + receiver + "\"");

            return callPluginMethod("messageReceivedAck", [receiver, messageId]);
        }

        function deleteMessage(messageId) {

            if (!_pluginReady) return $q.reject("Notfiy plugin not initialised");

            debug("Deleting message \"" + messageId + "\"");

            return callPluginMethod("deleteMessage", [messageId]);
        }

        function getActionId(action) {
            
            if (action.hasOwnProperty(_schemaService.ITEM_AUTO_ID_PROPERTY)) {
                
                var id = action[_schemaService.ITEM_AUTO_ID_PROPERTY];
    
                // cache the action into the action cache for speedy retrieval in the same session
                _actionCache[id] = action;
                
                return id;
            }

            return null;
        }

        function getActionById(actionId) {

            if (_actionCache.hasOwnProperty(actionId)) {
                
                // obtain from the cache
                debug("Found invoking action in action cache:", _actionCache[actionId]);
                return _actionCache[actionId];
            }
    
            debug("Invoking action not found in action cache, searching in app schema...");
            var action = _schemaService.findItemById(actionId);
            
            if (action) {
    
                debug("Found in app schema:", action);
                
            } else {
                
                debug("No action found with action id:", actionId);
            }
            
            return action;
        }

        function callActions(actionsCollection, actionsType, model) {

            debug("Calling \"" + actionsType + "\" actions from", actionsCollection, "with model", model);

            return _actionFactory.triggerEvent(actionsType, actionsCollection, model);
        }

        function callChildActions(action, actionsType, model) {

            debug("Looking for child actions of:", action);

            if (action === null || (!action.actions instanceof Array)) {

                return $q.when();
            }

            return callActions(action.actions, actionsType, model);
        }

        function isDebugMode() {

            return (_isDebugMode === true);
        }

        // === Event handlers === //

        function handleOutboxChange(error, result) {

            setTimeout(function () {

                debug("Outbox change received:", result);

                var providerId = getProviderId(result);
                var providerConfig = getProviderConfig(providerId);
                if (providerConfig !== null && typeof (providerConfig.outboxChangeCallback) === "function") {

                    debug("Routing outbox change to provider \"" + providerId + "\"");
                    providerConfig.outboxChangeCallback(error, result);
                }
            }, 0);
        }

        function handleInboxChange(error, result) {

            setTimeout(function () {

                debug("Inbox change received:", result);

                var providerId = getProviderId(result);
                var providerConfig = getProviderConfig(providerId);
                if (providerConfig !== null && typeof (providerConfig.inboxChangeCallback) === "function") {

                    debug("Routing inbox change to provider \"" + providerId + "\"");
                    providerConfig.inboxChangeCallback(error, result);
                }
            }, 100);
        }

        // === Utility functions === //

        function preparePlugin() {

            var deferred = $q.defer();

            debug("Obtaining \"nofity\" plugin...");

            _plugin = (USE_MOCK_PLUGIN === true)
                ? generateMockNotifyPlugin()
                : _isElectron
                ? Plugin.getSource("@commontimeltd/com.commontime.notify")
                : Plugin.getSource("notify");

            deferred.resolve(_plugin);

            return deferred.promise;
        }

        function callPluginMethod(methodName, args) {

            var deferred = $q.defer();

            args.push(function (error, response) {

                if (error) {
                    deferred.reject(error);
                } else {
                    deferred.resolve(response);
                }
            });

            _plugin[methodName].apply(_plugin, args);

            return deferred.promise;
        }

        function getProviderId(result) {

            var providerId = result.message.provider;
            if (!providerId) {

                // Legacy use-case where ASB messages do not have their provider specified
                providerId = PROVIDER_AZURESERVICEBUS;
            }

            return providerId;
        }

        function getProviderConfig(providerId) {

            if (_providerConfigs.hasOwnProperty(providerId)) {

                return _providerConfigs[providerId];
            }

            return null;
        }

        function debug() {

            if (_isDebugMode !== true) return;
            if (arguments === undefined) return;

            var params = Array.prototype.slice.call(arguments);
            if (params.length > 0 && typeof (params[0]) === "string") {
                params[0] = "[inboxOutbox.fct.js] " + params[0];
            }
            $log.log.apply($log, params);
        }

        function logError() {

            if (arguments === undefined) return;

            var params = Array.prototype.slice.call(arguments);
            if (params.length > 0 && typeof (params[0]) === "string") {
                params[0] = "[inboxOutbox.fct.js] " + params[0];
            }
            $log.error.apply($log, params);
        }

        // === Mock Message Queue Plugins (for local development/testing) === //

        function generateMockNotifyPlugin() {

            $log.info("*** USING MOCK NOTIFY PLUGIN: Turn this off in inboxOutbox.fct.js if you expect to use the real plugin ***");

            var FAKE_DELAY = 500; // 500ms

            function deferredResponse(callback, data) {

                setTimeout(function () {
                    callback(undefined, data);
                }, FAKE_DELAY);
            }

            return {

                ___queues: {},
                ___localChannels: [],
                ___onInboxChange: null,
                ___onOutboxChange: null,

                addChannel: function (channelName, callback) {

                    debug("addChannel called with arguments:", arguments);

                    if (this.___localChannels.indexOf(channelName) === -1) {
                        this.___localChannels.push(channelName);
                    }

                    deferredResponse(callback, channelName);
                },

                removeChannel: function (channelName, callback) {

                    debug("removeChannel called with arguments:", arguments);

                    var idx = this.___localChannels.indexOf(channelName);
                    if (idx !== -1) {
                        this.___localChannels.splice(idx, 1);
                    }

                    deferredResponse(callback, channelName);
                },

                sendMessage: function (message, callback) {

                    debug("sendMessage called with arguments:", arguments);

                    if (!this.___queues[message.channel]) {
                        this.___queues[message.channel] = [];
                    }

                    var messageId = "Message_" + Utilities.uuid();
                    message.id = messageId;
                    message.date = new Date().getTime();

                    this.___queues[message.channel].push(message);

                    if (this.___localChannels.indexOf(message.channel) !== -1) {

                        if (typeof (this.___onOutboxChange) === "function") {

                            var outboxAction1 = {action: "SENDING", message: message};
                            var outboxAction2 = {action: "SENT", message: message};
                            this.___onOutboxChange(undefined, outboxAction1);
                            this.___onOutboxChange(undefined, outboxAction2);
                        }

                        if (typeof (this.___onInboxChange) === "function") {

                            var inboxAction = {action: "create", message: message};
                            this.___onInboxChange(undefined, inboxAction);
                        }
                    }

                    deferredResponse(callback, messageId);
                },

                deleteMessage: function (messageId, callback) {

                    debug("deleteMessage called with arguments:", arguments);

                    for (var q in this.___queues) {
                        if (this.___queues.hasOwnProperty(q)) {
                            for (var i = this.___queues[q].length - 1; i >= 0; i--) {
                                if (this.___queues[q][i].id === messageId) {
                                    this.___queues[q].splice(i, 1);
                                }
                            }
                        }
                    }

                    deferredResponse(callback, messageId);
                },

                messageReceivedAck: function (receiver, messageId, callback) {

                    debug("messageReceivedAck called with arguments:", arguments);

                    deferredResponse(callback, null);
                },

                receiveInboxChanges: function (receiver, callback) {

                    debug("receiveInboxChanges called with arguments:", arguments);

                    this.___onInboxChange = callback;
                },

                receiveOutboxChanges: function (receiver, callback) {

                    debug("receiveOutboxChanges called with arguments:", arguments);

                    this.___onOutboxChange = callback;
                }
            };
        }

        return {

            /**
             * Initialises the factory to allow it to manage message transmission and delegation
             */
            "init": init,

            /**
             * Set options on the "Notify" plugin
             * @param {object} options - The options to set
             */
            "setOptions": setOptions,

            /**
             * Obtain the provider plugin by name
             * @param {string} pluginName - The name of the plugin
             * @returns {object|null} - The plugin instance, or null if not found
             */
            "getProviderPlugin": getProviderPlugin,

            /**
             * Register a provider with this factory
             * @param {object} providerConfig - The provider configuration
             * @returns {Promise} - A promise to resolve once registered
             */
            "registerProvider": registerProvider,

            /**
             * Returns true if this context is previewing the app from the studio or in live preview
             * @returns {boolean} - True if this context is previewing the app from the studio or in live preview
             */
            "isFromStudio": isFromStudio,

            /**
             * Generates a new unique ID for a request
             * @param {string} providerName - The provider name to include in the ID
             * @returns {string} - A unique ID for the request
             */
            "generateRequestId": generateRequestId,

            /**
             * Adds a channel to the inbox listener
             * @param {string} channelName - The name of the channel to add
             * @returns {Promise} - A promise to resolve once done
             */
            "addChannel": addChannel,

            /**
             * Removes a channel from the inbox listener
             * @param {string} channelName - The name of the channel to remove
             * @returns {Promise} - A promise to resolve once done
             */
            "removeChannel": removeChannel,

            /**
             * Send a message to the plugin
             * @oaram {object} message - The message to send
             * @returns {Promise} - A promise to resolve once done
             */
            "sendMessage": sendMessage,

            /**
             * Acknowledges a message in the inbox
             * @param {string} receiver - The name of the receiver who wishes to acknowledge the message
             * @param {string} messageId - The ID of the message to acknowledge
             * @returns {Promise} - A promise to resolve once done
             */
            "acknowledgeMessage": acknowledgeMessage,

            /**
             * Deletes a message from the inbox
             * @param {string} messageId - The ID of the message to delete
             * @returns {Promise} - A promise to resolve once done
             */
            "deleteMessage": deleteMessage,

            /**
             * Gets the automatically generated unique ID of the supplied action
             * @param {object} action - The action to obtain the ID from
             * @returns {string|null} - The ID of the action, or null if the action has no ID
             */
            "getActionId": getActionId,

            /**
             * Gets an action from the schema by the specified ID
             * @oaram {string} actionId - The ID of the action to get
             * @returns {object|null} - The action with the supplied ID, or null if one not found
             */
            "getActionById": getActionById,

            /**
             * Call the specified type of a collection of actions
             * @param {Array<object>} actionsCollection - The collection of actions
             * @param {string} actionsType - The event type of the actions to invoke
             * @param {object} model - The model data to pass into the action invocation
             * @returns {Promise} - A promise to resolve once done
             */
            "callActions": callActions,

            /**
             * Call the specified type of child actions of an action
             * @param {object} action - The action to call child actions of
             * @param {string} actionsType - The event type of the actions to invoke
             * @param {object} model - The model data to pass into the action invocation
             * @returns {Promise} - A promise to resolve once done
             */
            "callChildActions": callChildActions,

            /**
             * Returns whether debug mode is enabled
             * @returns {boolean} - True if debug mode is enabled, otherwise fales
             */
            "isDebugMode": isDebugMode,

            USE_MOCK_PLUGIN: USE_MOCK_PLUGIN,
            PROVIDER_AZURESERVICEBUS: PROVIDER_AZURESERVICEBUS,
            PROVIDER_AZUREAPPSERVICES: PROVIDER_AZUREAPPSERVICES,
            PROVIDER_REST: PROVIDER_REST,
            PROVIDER_UNKNOWN: PROVIDER_UNKNOWN
        };
    }]);
angular
    .module("app.core")
    .factory("MessageQueueFactory", ["$q", "$log", "InboxOutboxFactory", "StoreFactory", function ($q, $log, InboxOutboxFactory, StoreFactory) {

        // Author note:
        // The cordova plugin uses the term "channel" for message queue, and so you might find the
        // terminology in this file varies between "queue" (for outward facing functions) and "channel"
        // (for internal implementation).  For all intents and purposes; queue === channel

        // === Constants === //

        var MESSAGE_QUEUES_STORE_KEY = "messageQueues";

        var RECEIVER_NAME = "com.commontime.infinity.messageQueue"; // fixed receiver name for now
        var MESSAGE_SUB_CHANNEL = "default"; // fixed sub-channel for now

        // === Fields === //

        var _initialised = false;
        var _pluginReady = false;
        var _actions = {
            onReady: [],
            onReceived: [],
            onSent: []
        };
        var _defaultProvider = null;

        // === Service functions === //

        function init(schema) {

            if (_initialised) return $q.when(); // immediately resolve if already initialised

            var deferred = $q.defer();

            InboxOutboxFactory
                .init()
                .then(function () {

                    debug("Initialising message queue providers with schema...", schema);

                    var messageQueueConfig = schema.settings["message-queue"];

                    // determine which message queue providers to initialise; more may be added in future releases
                    var providers = getEnabledProviders(messageQueueConfig);

                    if (providers.length === 0) {

                        debug("No message queue providers enabled");
                        deferred.resolve(); // no message queue implementations enabled, immediately resolve
                    }

                    _defaultProvider = getDefaultProvider(providers);

                    // when all enabled providers have loaded
                    setInboxOutboxOptions()
                        .then(function () {
                            return startAllProviders(providers);
                        })
                        .then(function () {
                            return registerEventHandlers(schema);
                        })
                        .then(function () {
                            return restorePreviousQueues();
                        })
                        .then(function () {

                            _pluginReady = true;

                            deferred.resolve();
                        })
                        .catch(function (error) {

                            logError(error);
                            deferred.reject(error);
                        });

                })
                .catch(function (error) {

                    logError(error);
                    deferred.reject(error);
                });

            _initialised = true;

            return deferred.promise;
        }

        function startListening(queueName) {

            if (!_pluginReady) return $q.reject("Message Queue plugin not initialised");
            if (!queueName) return $q.reject("Missing queue name");
            
            // force queue names to be lowercase to ensure case insensitivity (CTI-574)
            queueName = queueName.toLowerCase();

            debug("Listening to queue \"" + queueName + "\"...");

            var promise = InboxOutboxFactory.addChannel(queueName);

            promise.then(function () {

                debug("Adding \"" + queueName + "\" to store");
                addStoredQueue(queueName);
            });

            return promise;
        }

        function stopListening(queueName) {

            if (!_pluginReady) return $q.reject("Message Queue plugin not initialised");
            if (!queueName) return $q.reject("Missing queue name");
    
            // force queue names to be lowercase to ensure case insensitivity (CTI-574)
            queueName = queueName.toLowerCase();

            debug("Stopped listening to queue \"" + queueName + "\"...");

            var promise = InboxOutboxFactory.removeChannel(queueName);

            promise.then(function () {

                debug("Removing \"" + queueName + "\" from store");
                removeStoredQueue(queueName);
            });

            return promise;
        }

        function sendMessage(queueName, messageContent) {

            if (!_pluginReady) return $q.reject("Message Queue plugin not initialised");
            if (!queueName) return $q.reject("Missing queue name");
            if (!messageContent) return $q.reject("Invalid message content \"" + messageContent + "\"");
    
            // force queue names to be lowercase to ensure case insensitivity (CTI-574)
            queueName = queueName.toLowerCase();

            var now = new Date();
            var expirationYear = now.getUTCFullYear() + 1; // expire one year from now
            var expirationEpoch = Date.UTC(expirationYear, now.getUTCMonth(), now.getUTCDate(), now.getUTCHours(), now.getUTCMinutes(), now.getUTCSeconds());

            var message = {
                channel: queueName,
                subchannel: MESSAGE_SUB_CHANNEL,
                expiry: expirationEpoch,
                provider: _defaultProvider.name, // always send to default message queue provider, until we have a way to allow one to be specified
                notification: "", // no notifications at this time
                content: {data: messageContent}
            };

            return InboxOutboxFactory.sendMessage(message);
        }

        // === Event handlers === //

        function handleOutboxChange(error, result) {

            if (error) {

                logError(error);
                return;
            }

            if (result.action.toLowerCase() === "sent" && _actions.onSent.length) {

                debug("Triggering \"message sent\" event");
                InboxOutboxFactory.callActions(_actions.onSent, "click", {$messageId: result.message.id}); // "click" event seems to be the default, so they will all be this
            }
        }

        function handleInboxChange(error, result) {

            if (error) {

                logError(error);

            } else {

                if (result.action.toLowerCase() === "create" && _actions.onReceived.length) {

                    // We have to stringify and then int-parse epoch dates as they were being hydrated
                    // as "[object Object]" strings when passed into actions, for some reason
                    var model = {
                        $message: {
                            id: result.message.id,
                            queue: result.message.channel,
                            body: result.message.content.data,
                            sent: parseInt((result.message.date || 0).toString()),
                            received: parseInt(new Date().getTime().toString())
                        }
                    };

                    debug("Triggering \"message received\" event");
                    InboxOutboxFactory
                        .callActions(_actions.onReceived, "click", model) // "click" event seems to be the default, so they will all be this
                        .then(function () {

                            // acknowledge receipt of message and then delete the message from the plugin
                            InboxOutboxFactory.acknowledgeMessage(RECEIVER_NAME, result.message.id);
                            InboxOutboxFactory.deleteMessage(result.message.id);
                        });
                }
            }
        }

        // === Utility functions === //

        function getEnabledProviders(messageQueueConfig) {

            var providers = [];

            var asbConfig = messageQueueConfig.asb || {};
            if (asbConfig.enabled === true) {

                debug("Obtaining provider \"" + InboxOutboxFactory.PROVIDER_AZURESERVICEBUS + "\"...");

                var optionsToInject = {
                    sbHostName: asbConfig.hostName,
                    serviceNamespace: asbConfig.serviceNamespace,
                    sasKeyName: asbConfig.keyName,
                    sasKey: asbConfig.key,
                    brokerType: asbConfig.brokerType,
                    brokerAutoCreate: asbConfig.autoCreate || false
                };

                providers.push({
                    name: InboxOutboxFactory.PROVIDER_AZURESERVICEBUS,
                    loadProviderPromise: loadProvider("asb", optionsToInject)
                });
            }

            return providers;
        }

        function loadProvider(providerPluginName, optionsToInject) {

            var deferred = $q.defer();

            debug("Initialising \"" + providerPluginName + "\" message queue provider...");

            var providerPlugin = (InboxOutboxFactory.USE_MOCK_PLUGIN === true)
                ? generateMockProviderPlugin(providerPluginName)
                : InboxOutboxFactory.getProviderPlugin(providerPluginName);

            if (providerPlugin === false) {

                deferred.reject("Unable to initialise \"" + providerPluginName + "\" plugin");

            } else {

                if (InboxOutboxFactory.isFromStudio()) {

                    debug("...running from Studio - injecting \"" + providerPluginName + "\" message queue preferences:", optionsToInject);
                    providerPlugin.start(deferred.resolve, deferred.reject, optionsToInject);

                } else {

                    debug("...using \"" + providerPluginName + "\" message queue preferences from configuration file");
                    providerPlugin.start(deferred.resolve, deferred.reject);
                }
            }

            return deferred.promise;
        }

        function getDefaultProvider(providers) {

            // Assume first provider is the default push system for now,
            // if more are added in the future there may be some logic or configuration around this
            return (providers.length > 0)
                ? providers[0]
                : null;
        }

        function setInboxOutboxOptions() {

            var deferred = $q.defer();

            if (InboxOutboxFactory.isFromStudio()) {

                if (_defaultProvider !== null) {

                    // Assume first provider is the default push system for now,
                    // if more are added in the future there may be some logic or configuration around this
                    var options = {
                        defaultPushSystem: _defaultProvider.name
                    };

                    InboxOutboxFactory
                        .setOptions(options)
                        .then(function () {
                            deferred.resolve();
                        })
                        .catch(function (error) {
                            deferred.reject(error);
                        });

                } else {

                    deferred.reject("No default push system was specified");
                }

            } else {

                debug("Options being obtained from config.xml / package.json");
                deferred.resolve(); // options read from config.xml or package.json; continue immediately
            }

            return deferred.promise;
        }

        function startAllProviders(providers) {

            var providerPromises = [];
            angular.forEach(providers, function (provider) {

                var providerPromise = $q.defer();

                provider
                    .loadProviderPromise
                    .then(function () {

                        debug("Registering message queue provider \"" + provider.name + "\"");

                        var providerRegistration = {
                            name: provider.name,
                            outboxChangeCallback: handleOutboxChange,
                            inboxChangeCallback: handleInboxChange
                        };

                        InboxOutboxFactory
                            .registerProvider(providerRegistration)
                            .then(function () {
                                providerPromise.resolve();
                            });
                    });

                providerPromises.push(providerPromise);
            });

            return $q.all(providerPromises);
        }

        function registerEventHandlers(schema) {

            var deferred = $q.defer();

            if (schema && schema.config && schema.config.length) {

                angular.forEach(schema.config, function (config) {

                    if (config["item-type"] === "message-queue-event") {

                        switch ((config.eventType || "").toLowerCase()) {

                            case "ready":
                                _actions.onReady = _actions.onReady.concat(config.actions);
                                break;

                            case "received":
                                _actions.onReceived = _actions.onReceived.concat(config.actions);
                                break;

                            case "sent":
                                _actions.onSent = _actions.onSent.concat(config.actions);
                                break;

                            default:
                                logError("Unknown message queue event type \"" + config.eventType + "\"");
                                break;
                        }
                    }
                });
            }

            debug("Registered actions:", _actions);

            deferred.resolve();

            return deferred.promise;
        }

        function restorePreviousQueues() {

            var deferred = $q.defer();

            setTimeout(function () {

                // Automatically register any channels set the last time the app was used
                var listeningTo = getStoredQueues();
                if (listeningTo.length) {

                    debug("Re-adding queues:", listeningTo);
                    angular.forEach(listeningTo, function (queueName) {

                        InboxOutboxFactory.addChannel(queueName.toLowerCase());
                    });
                }

                debug("Triggering \"ready\" event");
                InboxOutboxFactory.callActions(_actions.onReady, "click");

                deferred.resolve();

            }, 0);

            return deferred.promise;
        }

        function debug() {

            if (!InboxOutboxFactory.isDebugMode()) return;
            if (arguments === undefined) return;

            var params = Array.prototype.slice.call(arguments);
            if (params.length > 0 && typeof (params[0]) === "string") {
                params[0] = "[messageQueue.fct.js] " + params[0];
            }
            $log.log.apply($log, params);
        }

        function logError() {

            if (arguments === undefined) return;

            var params = Array.prototype.slice.call(arguments);
            if (params.length > 0 && typeof (params[0]) === "string") {
                params[0] = "[messageQueue.fct.js] " + params[0];
            }
            $log.error.apply($log, params);
        }

        // === Store function === //

        function getStoredQueues() {

            var messageQueueData = (StoreFactory.get(MESSAGE_QUEUES_STORE_KEY) || {});
            return messageQueueData.listeningTo || [];
        }

        function addStoredQueue(queueName) {

            var queues = getStoredQueues();
            queues.push(queueName);
            StoreFactory.set(MESSAGE_QUEUES_STORE_KEY, {listeningTo: queues});
        }

        function removeStoredQueue(queueName) {

            var queues = getStoredQueues();
            var idx = queues.indexOf(queueName);
            if (idx !== -1) {
                queues.splice(idx, 1);
                StoreFactory.set(MESSAGE_QUEUES_STORE_KEY, {listeningTo: queues});
            }
        }

        // === Mock Message Queue Plugins (for local development/testing) === //

        function generateMockProviderPlugin(pluginName) {

            function deferredResponse(callback, data) {

                $log.info("*** USING MOCK " + pluginName.toUpperCase() + " PLUGIN: Set USE_MOCK_PLUGIN to false in inboxOutbox.fct.js if you expect to use the real plugin ***");

                var FAKE_DELAY = 500; // 500ms

                setTimeout(function () {
                    callback(undefined, data);
                }, FAKE_DELAY);
            }

            return {

                start: function (onSuccess) {

                    debug("start called with arguments:", arguments);

                    deferredResponse(onSuccess, "ok");
                }
            };
        }

        // === Service object === //

        return {

            /**
             * Initialises the message queue plugin
             * @param {object} schema - The application schema to obtain configuration from
             */
            "init": init,

            /**
             * Start listening to a message queue
             * @param {string} queueName - The name of the queue to listen to
             * @returns {Promise} - A promise to resolve once done
             */
            "startListening": startListening,

            /**
             * Stop listening to a message queue
             * @param {string} queueName - The name of the queue to stop listening to
             * @returns {Promise} - A promise to resolve once done
             */
            "stopListening": stopListening,

            /**
             * Sends a message to a nominated message queue
             * @param {string} queueName - The name of the queue to send the message to
             * @param {object} messageContent - The message payload to send to the queue
             * @returns {Promise} - A promise to resolve once done
             */
            "sendMessage": sendMessage
        };
    }]);

angular
    .module("app.core")
    .factory("RestFactory", ["$q", "$log", "InboxOutboxFactory", "Api", "StoreFactory", "Utilities", "FileSystem", "MimeTypes", function ($q, $log, InboxOutboxFactory, Api, StoreFactory, Utilities, FileSystem, MimeTypes) {

        // === Constants === //

        var CHANNEL_NAME = "inboxoutbox." + InboxOutboxFactory.PROVIDER_REST;
        var PLUGIN_NAME = "rest";

        // === Fields === //

        var _initialised = false;
        var _pluginReady = false;
        var _offlineApis = [];

        function init() {

            if (_initialised) return $q.when(); // immediately resolve if already initialised

            var deferred = $q.defer();

            InboxOutboxFactory
                .init()
                .then(function () {

                    return preparePlugin();
                })
                .then(function () {

                    var providerRegistration = {
                        name: InboxOutboxFactory.PROVIDER_REST,
                        outboxChangeCallback: handleOutboxChange,
                        inboxChangeCallback: handleInboxChange
                    };

                    return InboxOutboxFactory.registerProvider(providerRegistration);
                })
                .then(function () {

                    _pluginReady = true;

                    deferred.resolve();
                })
                .catch(function (error) {

                    logError(error);
                    deferred.reject(error);
                });

            _initialised = true;

            return deferred.promise;
        }

        function registerOfflineApi(offlineApiItem) {

            debug("Registering Offline API item:", offlineApiItem);
            _offlineApis.push(offlineApiItem);
        }

        function makeRequest(action) {

            if (!_pluginReady) return $q.reject(PLUGIN_NAME + " plugin not initialised");

            debug("Making request for action:", action);

            var invokingActionId = InboxOutboxFactory.getActionId(action);
            var offlineApiName = action.data.name;
            var operationName = action.data.operation;
            var offlineApi = findOfflineApi(offlineApiName);
            var operation = findOperation(offlineApi, operationName);

            if (operation === null) {
                return $q.reject("Unknown operation \"" + operationName + "\"");
            }

            debug("Invoking operation \"" + operationName + "\" with config:", operation);

            var api = new Api(offlineApi.name, offlineApi.url, offlineApi.params, offlineApi.headers, offlineApi.operations);
            api.buildRequestObject(operation, action.data.params, fileDataParameterBuilder)
                .then(function (request) {

                    if (operation.downloadAsFile === true) {
                        request.downloadAsFile = operation.downloadAsFile;
                        request.downloadFileName = operation.downloadFileName;
                    }

                    request.invokingActionId = invokingActionId;

                    var ttlMinutes = operation.ttlMinutes;
                    if (ttlMinutes === undefined) {
                        ttlMinutes = 60; // default to 1 hour if not defined
                    }

                    var expirationEpoch = 0;
                    if (ttlMinutes === 0) {
                        expirationEpoch = 0;
                    } else {
                        var now = new Date();
                        expirationEpoch = Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate(), now.getUTCHours(), now.getUTCMinutes(), now.getUTCSeconds());
                        expirationEpoch += (ttlMinutes * 60 * 1000); // milliseconds since 01/01/1970
                    }

                    var requestId = InboxOutboxFactory.generateRequestId(InboxOutboxFactory.PROVIDER_REST);
                    var message = {
                        channel: CHANNEL_NAME,
                        subchannel: requestId,
                        provider: InboxOutboxFactory.PROVIDER_REST,
                        expiry: expirationEpoch,
                        content: request
                    };

                    InboxOutboxFactory
                        .sendMessage(message)
                        .catch(function (error) {

                            logError(error);
                            InboxOutboxFactory.callChildActions(action, "fail", {$response: error});
                        });
                })
                .catch(function (error) {
                    
                    logError(error);
                });

            return $q.when(true);
        }

        // === Event handlers === //

        function handleOutboxChange(error) {

            if (error !== undefined) {

                logError(error);
            }
        }

        function handleInboxChange(error, result) {

            if (error !== undefined) {

                logError(error);

            } else if (result.action.toLowerCase() === "create") {

                var requestData = getMessageRequestData(result);
                if (requestData === null) {

                    debug("Unable to handle inbox change - no message request data found in result:", result);

                } else {

                    var invokingActionId = requestData.invokingActionId;
                    var invokingAction = InboxOutboxFactory.getActionById(invokingActionId);
                    if (invokingAction !== null) {

                        getMessageResponse(result)
                            .then(function (response) {

                                debug("Parsed response for " + invokingAction.data.name + "." + invokingAction.data.operation + ": ", response);

                                if (response.isSuccess) {
                                    StoreFactory.set("offlineApi." + invokingAction.data.name + "." + invokingAction.data.operation, response.responseData);
                                }

                                var actionsType = (response.isSuccess)
                                    ? "success"
                                    : "fail";

                                debug("Calling child \"" + actionsType + "\" actions of action id \"" + invokingActionId + "\" with model:", response.responseData);
                                InboxOutboxFactory.callChildActions(invokingAction, actionsType, {$response: response.responseData});
                                InboxOutboxFactory.deleteMessage(result.message.id);
                            });
                    }
                }
            }
        }

        // === Utility functions === //

        function preparePlugin() {

            var deferred = $q.defer();

            debug("Initialising \"" + PLUGIN_NAME + "\" plugin...");

            var providerPlugin = (InboxOutboxFactory.USE_MOCK_PLUGIN === true)
                ? generateMockPlugin()
                : InboxOutboxFactory.getProviderPlugin(PLUGIN_NAME);

            if (providerPlugin === false) {

                deferred.reject("Unable to initialise \"" + PLUGIN_NAME + "\" plugin");

            } else {

                providerPlugin.start(deferred.resolve, deferred.reject);
            }

            deferred.resolve();

            return deferred.promise;
        }

        function findOfflineApi(offlineApiName) {

            var found = _offlineApis.filter(function (x) {
                return (x.name === offlineApiName);
            });

            if (!found.length) return null;

            return found[0];
        }

        function findOperation(offlineApi, operationName) {

            if (!offlineApi || !offlineApi.operations || !offlineApi.operations.length) return null;

            var found = offlineApi.operations.filter(function (x) {
                return (x.name === operationName);
            });

            if (!found.length) return null;

            return found[0];
        }

        function fileDataParameterBuilder(request, parameter, value) {

            var deferred = $q.defer();

            if (parameter.in === "formData" && parameter.type === "file") {

                var filePath = value;
                var fileName = FileSystem.getFileNameFromPath(filePath);

                var base64Encode = parameter.typeConfig.base64encode;
                if (base64Encode) {

                    FileSystem
                        .getFileBlob(fileName)
                        .then(function (blob) {

                            var fileReader = new FileReader();
                            fileReader.onloadend = function (event) {

                                request.headers["Content-Type"] = "application/json";
                                request.data[parameter.name] = event.target.result; // base64 data

                                if (parameter.typeConfig.fileNameParameterName) {

                                    request.data[parameter.typeConfig.fileNameParameterName] = fileName;
                                }

                                deferred.resolve(true);
                            };
                            fileReader.readAsDataURL(blob);
                        })
                        .catch(function (error) {

                            $log.error(error);
                            deferred.resolve(false);
                        });

                } else {

                    request.headers["Content-Type"] = MimeTypes.mimeTypeFromExtension(filePath);
                    request.data = value;
                    request.uploadAsFile = true;
                    request.uploadAsMultipartForm = true;
                    request.formPartName = parameter.name;
                    request.formPartFilename = fileName;

                    deferred.resolve(true);
                }

            } else {

                // do not build parameter here; return false
                deferred.resolve(false);
            }

            return deferred.promise;
        }

        function getMessageRequestData(result) {

            if (!result.message) return null;
            if (!result.message.content) return null;

            return result.message.content.config;
        }

        function getMessageResponse(result) {

            if (!result.message || !result.message.content) {

                return $q.when({
                    isSuccess: false,
                    responseData: "Invalid response message"
                });
            }

            var statusCode = parseInt(result.message.content.status || -1);
            var isErrorResponse = (statusCode <= 0 || statusCode >= 400); // status code lte 0 or gte 400 or above indicates an error type response
            if (isErrorResponse) {

                return $q.when({
                    isSuccess: false,
                    responseData: {
                        status: result.message.content.status,
                        statusText: result.message.content.statusText,
                        message: result.message.content.data
                    }
                });
            }

            var deferred = $q.defer();

            var requestData = getMessageRequestData(result);
            var responseData = result.message.content.data;
            var responseHeaders = result.message.content.headers;

            if (requestData && requestData.downloadAsFile === true && responseHeaders) {

                debug("Response is downloaded file; file path:", responseData);

                var filePath = responseData;
                var newFileName = "";

                if ((requestData.downloadFileName || "").trim().length > 0) {

                    newFileName = requestData.downloadFileName;

                } else {

                    newFileName = Utilities.uuid();

                    var contentType = (responseHeaders["Content-Type"] || "").split(";")[0].trim();
                    var fileExtension = MimeTypes.extensionFromMimeType(contentType);
                    if (fileExtension !== null) {
                        newFileName += "." + fileExtension;
                    }
                }

                FileSystem
                    .moveFileToStorage(filePath, newFileName)
                    .then(function (newFilePath) {

                        deferred.resolve({
                            isSuccess: true,
                            responseData: newFilePath
                        });
                    })
                    .catch(function (error) {

                        deferred.resolve({
                            isSuccess: false,
                            responseData: error
                        });
                    });

            } else {

                deferred.resolve({
                    isSuccess: true,
                    responseData: responseData
                });
            }

            return deferred.promise;
        }

        function debug() {

            if (!InboxOutboxFactory.isDebugMode()) return;
            if (arguments === undefined) return;

            var params = Array.prototype.slice.call(arguments);
            if (params.length > 0 && typeof (params[0]) === "string") {
                params[0] = "[rest.fct.js] " + params[0];
            }
            $log.log.apply($log, params);
        }

        function logError() {

            if (arguments === undefined) return;

            var params = Array.prototype.slice.call(arguments);
            if (params.length > 0 && typeof (params[0]) === "string") {
                params[0] = "[rest.fct.js] " + params[0];
            }
            $log.error.apply($log, params);
        }

        // === Mock Plugins (for local development/testing) === //

        function generateMockPlugin() {

            function deferredResponse(callback, data) {

                $log.info("*** USING MOCK " + PLUGIN_NAME.toUpperCase() + " PLUGIN: Set USE_MOCK_PLUGIN to false in inboxOutbox.fct.js if you expect to use the real plugin ***");

                var FAKE_DELAY = 500; // 500ms

                setTimeout(function () {
                    callback(undefined, data);
                }, FAKE_DELAY);
            }

            return {

                start: function (onSuccess) {

                    debug("start called with arguments:", arguments);

                    deferredResponse(onSuccess, "ok");
                }
            };
        }

        return {

            /**
             * Initialises the REST plugin
             */
            "init": init,

            /**
             * Register an offline API item with the factory
             * @param {object} offlineApiItem - An offline API item
             */
            "registerOfflineApi": registerOfflineApi,

            /**
             * Make a request to REST
             * @param {object} action - the action which is invoking the request
             * @returns {Promise} - A promise to resolve immediately (we do not wait for message response)
             */
            "makeRequest": makeRequest
        };
    }]);
angular
    .module("app.core")
    .factory("AzureAppServicesFactory", ["$q", "$log", "InboxOutboxFactory", "StoreFactory", function ($q, $log, InboxOutboxFactory, StoreFactory) {

        // === Constants === //

        var CHANNEL_NAME = "inboxoutbox." + InboxOutboxFactory.PROVIDER_AZUREAPPSERVICES;
        var PLUGIN_NAME = "zumo";

        // === Fields === //

        var _initialised = false;
        var _pluginReady = false;
        var _configuration = null;

        function init(configurationItem) {

            if (_initialised) return $q.when(); // immediately resolve if already initialised

            var deferred = $q.defer();

            _configuration = configurationItem;

            InboxOutboxFactory
                .init()
                .then(function () {

                    return preparePlugin(configurationItem);
                })
                .then(function () {

                    var providerRegistration = {
                        name: InboxOutboxFactory.PROVIDER_AZUREAPPSERVICES,
                        outboxChangeCallback: handleOutboxChange,
                        inboxChangeCallback: handleInboxChange
                    };

                    return InboxOutboxFactory.registerProvider(providerRegistration);
                })
                .then(function () {

                    _pluginReady = true;

                    deferred.resolve();
                })
                .catch(function (error) {

                    logError(error);
                    deferred.reject(error);
                });

            _initialised = true;

            return deferred.promise;
        }

        function makeRequest(action) {

            if (!_pluginReady) return $q.reject(PLUGIN_NAME + " plugin not initialised");

            debug("Making request for action:", action);

            var invokingActionId = InboxOutboxFactory.getActionId(action);
            var operationName = action.data.operation;
            var operation = findOperation(operationName);

            if (operation === null) {
                return $q.reject("Unknown operation '" + operationName + "'");
            }

            var operationPath = operation.path;

            debug("Invoking operation '" + operationPath + "' with config:", operation);

            var content = {
                transport: {
                    type: "zumoDirect",
                    httpMethod: operation.method,
                    api: operationPath
                },
                invokingActionId: invokingActionId
            };

            if (action.data.params) {

                content.data = {};

                for (var paramName in action.data.params) {

                    if (action.data.params.hasOwnProperty(paramName)) {

                        var parameter = findParameter(operation, paramName);
                        if (parameter !== null) {

                            switch (parameter.type) {

                                case "fileref":
                                    content.data[paramName] = "#fileref:" + action.data.params[paramName];
                                    break;

                                default:
                                    content.data[paramName] = action.data.params[paramName];
                                    break;
                            }
                        }
                    }
                }
            }

            var ttlMinutes = operation.ttlMinutes;
            if (ttlMinutes === undefined) {
                ttlMinutes = 60; // default to 1 hour if not defined
            }

            var expirationEpoch = 0;
            if (ttlMinutes === 0) {
                expirationEpoch = 0;
            } else {
                var now = new Date();
                expirationEpoch = Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate(), now.getUTCHours(), now.getUTCMinutes(), now.getUTCSeconds());
                expirationEpoch += (ttlMinutes * 60 * 1000); // milliseconds since 01/01/1970
            }

            var requestId = InboxOutboxFactory.generateRequestId(InboxOutboxFactory.PROVIDER_AZUREAPPSERVICES);
            var message = {
                channel: CHANNEL_NAME,
                subchannel: requestId,
                provider: InboxOutboxFactory.PROVIDER_AZUREAPPSERVICES,
                expiry: expirationEpoch,
                content: content
            };

            InboxOutboxFactory
                .sendMessage(message)
                .catch(function (error) {

                    logError(error);
                    InboxOutboxFactory.callChildActions(action, "fail", {$response: error});
                });

            return $q.when(true);
        }

        function logout() {

            if (!_pluginReady) return $q.reject(PLUGIN_NAME + " plugin not initialised");

            var deferred = $q.defer();

            debug("Attempting logout");

            var providerPlugin = (InboxOutboxFactory.USE_MOCK_PLUGIN === true)
                ? generateMockPlugin()
                : InboxOutboxFactory.getProviderPlugin(PLUGIN_NAME);

            if (providerPlugin === false) {

                deferred.reject("Unable to initialise '" + PLUGIN_NAME + "' plugin");

            } else {

                providerPlugin.logout(deferred.resolve, deferred.reject);
            }

            return deferred.promise;
        }

        // === Event handlers === //

        function handleOutboxChange(error) {

            if (error !== undefined) {

                logError(error);
            }
        }

        function handleInboxChange(error, result) {

            if (error !== undefined) {

                logError(error);

            } else if (result.action.toLowerCase() === "create") {

                var requestData = getMessageRequestData(result);
                if (requestData === null) {

                    debug("Unable to handle inbox change - no message request data found in result:", result);

                } else {

                    var invokingActionId = requestData.invokingActionId;
                    var invokingAction = InboxOutboxFactory.getActionById(invokingActionId);
                    if (invokingAction !== null) {

                        getMessageResponse(result)
                            .then(function (response) {

                                debug("Parsed response:", response);

                                if (response.isSuccess) {
                                    StoreFactory.set("azureAppServices." + invokingAction.data.name + "." + invokingAction.data.operation, response.responseData);
                                }

                                var actionsType = (response.isSuccess)
                                    ? "success"
                                    : "fail";

                                debug("Calling child '" + actionsType + "' actions of action id '" + invokingActionId + "' with model:", response.responseData);
                                InboxOutboxFactory.callChildActions(invokingAction, actionsType, {$response: response.responseData});
                                InboxOutboxFactory.deleteMessage(result.message.id);
                            });
                    }
                }
            }
        }

        // === Utility functions === //

        function preparePlugin(configurationItem) {

            var deferred = $q.defer();

            debug("Initialising '" + PLUGIN_NAME + "' plugin...");

            var providerPlugin = (InboxOutboxFactory.USE_MOCK_PLUGIN === true)
                ? generateMockPlugin()
                : InboxOutboxFactory.getProviderPlugin(PLUGIN_NAME);

            if (providerPlugin === false) {

                deferred.reject("Unable to initialise '" + PLUGIN_NAME + "' plugin");

            } else {

                if (InboxOutboxFactory.isFromStudio()) {

                    var options = {
                        url: configurationItem.aasUrl,
                        authenticationMethod: configurationItem.aasAuthenticationMethod,
                        useBlobStorage: configurationItem.aasUseBlobStorage
                    };

                    debug("...running from Studio - injecting '" + PLUGIN_NAME + "' preferences:", options);
                    providerPlugin.start(deferred.resolve, deferred.reject, options);

                } else {

                    debug("...using '" + PLUGIN_NAME + "' preferences from configuration file");
                    providerPlugin.start(deferred.resolve, deferred.reject);
                }
            }

            deferred.resolve();

            return deferred.promise;
        }

        function findOperation(operationName) {

            if (!_configuration.operations || !_configuration.operations.length) return null;

            var found = _configuration.operations.filter(function (x) {
                return (x.name === operationName);
            });

            if (!found.length) return null;
            return found[0];
        }

        function findParameter(operation, parameterName) {

            if (!operation || !operation.params.length) return null;

            var found = operation.params.filter(function (x) {
                return (x.name === parameterName);
            });

            if (!found.length) return null;
            return found[0];
        }

        function getMessageRequestData(result) {

            if (!result.message) return null;
            if (!result.message.content) return null;

            return result.message.content.config;
        }

        function getMessageResponse(result) {

            if (!result.message || !result.message.content) {

                return $q.when({
                    isSuccess: false,
                    responseData: "Invalid response message"
                });
            }

            var deferred = $q.defer();

            var isErrorResponse = result.message.content.errorType && result.message.content.errorMessage; // if an errorType and errorMessage is specified, it"s an error
            if (isErrorResponse) {

                deferred.resolve({
                    isSuccess: false,
                    responseData: result.message.content.errorMessage
                });

            } else {

                deferred.resolve({
                    isSuccess: true,
                    responseData: result.message.content.response
                });
            }

            return deferred.promise;
        }

        function debug() {

            if (!InboxOutboxFactory.isDebugMode()) return;
            if (arguments === undefined) return;

            var params = Array.prototype.slice.call(arguments);
            if (params.length > 0 && typeof (params[0]) === "string") {
                params[0] = "[azureAppServices.fct.js] " + params[0];
            }
            $log.log.apply($log, params);
        }

        function logError() {

            if (arguments === undefined) return;

            var params = Array.prototype.slice.call(arguments);
            if (params.length > 0 && typeof (params[0]) === "string") {
                params[0] = "[azureAppServices.fct.js] " + params[0];
            }
            $log.error.apply($log, params);
        }

        // === Mock Plugins (for local development/testing) === //

        function generateMockPlugin() {

            function deferredResponse(callback, data) {

                $log.info("*** USING MOCK " + PLUGIN_NAME.toUpperCase() + " PLUGIN: Set USE_MOCK_PLUGIN to false in inboxOutbox.fct.js if you expect to use the real plugin ***");

                var FAKE_DELAY = 500; // 500ms

                setTimeout(function () {
                    callback(undefined, data);
                }, FAKE_DELAY);
            }

            return {

                start: function (onSuccess) {

                    debug("start called with arguments:", arguments);

                    deferredResponse(onSuccess, "ok");
                },

                logout: function (onSuccess) {

                    debug("logout called with arguments:", arguments);

                    deferredResponse(onSuccess, "ok");
                }
            };
        }

        return {

            /**
             * Initialises the Azure App Services plugin
             * @param {object} configurationItem - The configuation item for Azure App Service
             */
            "init": init,

            /**
             * Make a request to azure app services
             * @param {object} action - the action which is invoking the request
             * @returns {Promise} - A promise to resolve immediately (we do not wait for message response)
             */
            "makeRequest": makeRequest,

            /**
             * Logout of any authentication providers logged into
             * @returns {Promise} - A promise to resolve once logged out
             */
            "logout": logout
        };
    }]);

angular.module("app.core").factory("DataflowFactory", ["Dataflow", "$q", function (Dataflow, $q) {

    var _dataflows = {};

    var service = {
        "init": init,
        "execute": execute
    };

    function init(name, schema) {
        _dataflows[name] = new Dataflow(schema);
    }

    function execute(name, data) {
        var deferred = $q.defer();
        if (_dataflows[name] != undefined) {
            _dataflows[name].execute(data).then(function (result) {
                deferred.resolve(result);
            }).catch(function (error) {
                deferred.reject(error);
            });
        }
        return deferred.promise;
    }

    return service;

}]);

angular.module("app.core").factory("Dataflow", ["$log", "$q", "$injector", "StoreFactory", "localStorageService", function ($log, $q, $injector, StoreFactory, localStorageService) {

    /**
     * Represents a Dataflow
     * @param steps - The JSON schema representing all the steps in the workflow
     * @constructor
     */
    function Dataflow(steps) {
        this.steps = steps;
        this.debug = (localStorageService.get("debug") == "true");
    }

    Dataflow.prototype = {
        /**
         * Function to begin execution of the dataflow with provided data
         * @param data - Dataflow initial data (e.g. Input event, API results, etc.)
         * @returns {$q.defer().promise}
         */
        execute: function (data) {
            var deferred = $q.defer();
            var $scope = this;
            if ($scope.steps !== undefined) {
                var result = [];

                var _data = data;
                if (angular.isObject(data) && !angular.isArray(data)) {
                    _data = [data];
                }

                var source = window.Rx.Observable.from(_data);
                // Variable added to scope so that store data can be accessed within workflow
                var $store = window.cti.store;
                var ActionFactory = $injector.get("ActionFactory");
                if ($scope.debug) {
                    $log.log("========== WORKFLOW ==========");
                }
                this.steps.forEach(function (step) {
                    switch (step["item-type"]) {
                        // TRANSFORM
                        // https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/select.md
                        case "map":
                            step = StoreFactory.parse(angular.copy(step), {"$data": _data});
                            if (step.content !== undefined && step.content.length > 0) {
                                eval("var stepFunction = function($data){ " + step.content + " }");
                                // eslint-disable-next-line no-undef
                                source = source.map(stepFunction);
                            } else if (step.xpath !== undefined && step.xpath.length > 0) {
                                source = source.map(function ($data) {
                                    var res = JSON.search($data, step.xpath);
                                    if ($scope.debug) {
                                        $log.log("[MAP] - XPATH RESULT:", res[0]);
                                        $log.log("============  ============");
                                    }
                                    return (res.length === 1) ? res[0] : res;
                                });
                            } else {
                                $log.error("No xpath or code has been added for a 'map' step.");
                            }
                            break;
                        // https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/selectmany.md
                        case "flat-map":
                            step = StoreFactory.parse(angular.copy(step), {"$data": _data});
                            if (step.content !== undefined && step.content.length > 0) {
                                eval("var stepFunction = function($data, $index){ " + step.content + " }");
                                // eslint-disable-next-line no-undef
                                source = source.flatMap(stepFunction);
                            } else if (step.xpath !== undefined && step.xpath.length > 0) {
                                source = source.flatMap(function ($data) {
                                    var res = JSON.search($data, step.xpath);
                                    if ($scope.debug) {
                                        $log.log("[FLAT MAP] - XPATH RESULT:", res[0]);
                                        $log.log("============  ============");
                                    }
                                    return (res.length === 1) ? res[0] : res;
                                });
                            } else {
                                $log.error("No xpath or code has been added for a 'flat-map' step.");
                            }
                            break;
                        // https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/reduce.md
                        case "reduce":
                            step = StoreFactory.parse(angular.copy(step), {"$data": _data});
                            if (step.content !== undefined && step.content.length > 0) {
                                eval("var stepFunction = function($acc, $current, $index, $source){ " + step.content + "; }");
                                // eslint-disable-next-line no-undef
                                source = source.reduce(stepFunction);
                            } else if (step.xpath !== undefined && step.xpath.length > 0) {
                                source = source.reduce(function ($acc) {
                                    var res = JSON.search($acc, step.xpath);
                                    if ($scope.debug) {
                                        $log.log("[REDUCE] - XPATH RESULT:", res[0]);
                                        $log.log("============  ============");
                                    }
                                    return (res.length === 1) ? res[0] : res;
                                });
                            } else {
                                $log.error("No xpath or code has been added for a 'reduce' step.");
                            }
                            break;
                        // https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/some.md
                        case "some":
                            step = StoreFactory.parse(angular.copy(step), {"$data": _data});
                            if (step.content !== undefined && step.content.length > 0) {
                                eval("var stepFunction = function($data){ " + step.content + "; }");
                                // eslint-disable-next-line no-undef
                                source = source.some(stepFunction);
                            } else if (step.xpath !== undefined && step.xpath.length > 0) {
                                source = source.some(function ($data) {
                                    var res = JSON.search($data, step.xpath);
                                    if ($scope.debug) {
                                        $log.log("[SOME] - XPATH RESULT:", res[0]);
                                        $log.log("============  ============");
                                    }
                                    return (res.length === 1) ? res[0] : res;
                                });
                            } else {
                                $log.error("No xpath or code has been added for a 'some' step.");
                            }
                            break;
                        // Custom step created using jsonapter
                        case "convert":
                            step = StoreFactory.parse(angular.copy(step), {"$data": _data}, false);
                            if (step.content !== undefined) {
                                source = source.map(function (stepData) {
                                    var template = null;
                                    try {
                                        eval("template = " + step.content);
                                    } catch (e) {
                                        $log.error(e);
                                    }
                                    if (template !== null) {
                                        var res = window.jsonapter.instance().run(template, stepData);
                                        if ($scope.debug) {
                                            $log.log("[CONVERT] - TEMPLATE:", template);
                                            $log.log("[CONVERT] - JSONAPTER RESULT:", res);
                                            $log.log("============  ============");
                                        }
                                        return res;
                                    }
                                    return undefined;
                                });
                            } else {
                                $log.error("No template has been added for a 'convert' step.");
                            }
                            break;
                        case "take":
                            step = StoreFactory.parse(angular.copy(step), {"$data": _data});
                            if (step.content !== undefined) {
                                source = source.take(step.content);
                            } else {
                                $log.error("No value has been added for a 'take' step.");
                            }
                            break;
                        // SEARCH
                        // https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/every.md
                        case "every":
                            if (step.content !== undefined && step.content.length > 0) {
                                step = StoreFactory.parse(angular.copy(step), {"$data": _data});
                                eval("var stepFunction = function($data){ " + step.content + "; }");
                                // eslint-disable-next-line no-undef
                                source = source.every(stepFunction);
                            } else if (step.operations !== undefined && step.operations.length > 0) {
                                source = source.every(function ($data) {
                                    return ActionFactory.evalOperations(__copy(step.operations), {
                                        "$data": $data,
                                        "$store": $store
                                    });
                                });
                            } else {
                                $log.error("No expression or code has been added for an 'every' step.");
                            }
                            break;
                        // https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/where.md
                        case "filter":
                            if (step.content !== undefined && step.content.length > 0) {
                                step = StoreFactory.parse(angular.copy(step), {"$data": _data});
                                eval("var stepFunction = function($current, $index, $source){ " + step.content + " }");
                                // eslint-disable-next-line no-undef
                                source = source.filter(stepFunction);
                            } else if (step.operations !== undefined && step.operations.length > 0) {
                                source = source.filter(function ($current, $index, $source) {
                                    return ActionFactory.evalOperations(__copy(step.operations), {
                                        "$current": $current,
                                        "$index": $index,
                                        "$source": $source,
                                        "$store": $store
                                    });
                                });
                            } else {
                                $log.error("No expression or code has been added for a 'filter' step.");
                            }
                            break;
                        case "find":
                            if (step.content !== undefined && step.content.length > 0) {
                                step = StoreFactory.parse(angular.copy(step), {"$data": _data});
                                eval("var stepFunction = function($current, $index, $source){ " + step.content + "; }");
                                // eslint-disable-next-line no-undef
                                source = source.find(stepFunction);
                            } else if (step.operations !== undefined && step.operations.length > 0) {
                                source = source.find(function ($current, $index, $source) {
                                    return ActionFactory.evalOperations(__copy(step.operations), {
                                        "$current": $current,
                                        "$index": $index,
                                        "$source": $source,
                                        "$store": $store
                                    });
                                });
                            } else {
                                $log.error("No expression or code has been added for a 'find' step.");
                            }
                            break;
                        // https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/toarray.md
                        case "to-array":
                            source = source.toArray();
                            break;
                        // MATHEMATICAL STEPS
                        // https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/max.md
                        case "max":
                            if (step.content !== undefined) {
                                step = StoreFactory.parse(angular.copy(step), {"$data": _data});
                                eval("var stepFunction = function($current, $next){ " + step.content + "; }");
                                // eslint-disable-next-line no-undef
                                source = source.average(stepFunction);
                            } else {
                                source = source.max();
                            }
                            break;
                        // https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/min.md
                        case "min":
                            if (step.content !== undefined) {
                                step = StoreFactory.parse(angular.copy(step), {"$data": _data});
                                eval("var stepFunction = function($current, $next){ " + step.content + "; }");
                                // eslint-disable-next-line no-undef
                                source = source.average(stepFunction);
                            } else {
                                source = source.min();
                            }
                            break;
                        // https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/sum.md
                        case "sum":
                            if (step.content !== undefined) {
                                step = StoreFactory.parse(angular.copy(step), {"$data": _data});
                                eval("var stepFunction = function($current, $index, $source){ " + step.content + "; }");
                                // eslint-disable-next-line no-undef
                                source = source.average(stepFunction);
                            } else {
                                source = source.sum();
                            }
                            break;
                        // https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/count.md
                        case "count":
                            if (step.content !== undefined) {
                                step = StoreFactory.parse(angular.copy(step), {"$data": _data});
                                eval("var stepFunction = function($current){ " + step.content + "; }");
                                // eslint-disable-next-line no-undef
                                source = source.average(stepFunction);
                            } else {
                                source = source.count();
                            }
                            break;
                        // https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/average.md
                        case "average":
                            if (step.content !== undefined) {
                                step = StoreFactory.parse(angular.copy(step), {"$data": _data});
                                eval("var stepFunction = function($data){ " + step.content + "; }");
                                // eslint-disable-next-line no-undef
                                source = source.average(stepFunction);
                            } else {
                                source = source.average();
                            }
                            break;
                    }
                });
                source.subscribe(function (data) {
                    if ($scope.debug) {
                        $log.log("ON NEXT:", data);
                        $log.log("============  ============");
                    }
                    result.push(data);
                }, function (error) {
                    $log.error(error);
                    deferred.reject(error);
                }, function () {
                    var output = (result.length === 1) ? result[0] : result;
                    if ($scope.debug) {
                        $log.log("COMPLETED:", output);
                        $log.log("===========================");
                    }
                    deferred.resolve(output);
                });
            }
            return deferred.promise;
        }
    };

    /**
     * This is used because the angular.copy method fiddles with the scope of data breaking the RxJS flow
     * @param value
     * @private
     */
    function __copy(value) {
        return JSON.parse(JSON.stringify(value));
    }

    return Dataflow;
}]);

angular.module("app.core").factory("ActionflowFactory", ["Actionflow", "$q", function (Actionflow, $q) {

    var _actionflows = {};

    var service = {
        "init": init,
        "execute": execute
    };

    function init(name, schema) {
        _actionflows[name] = new Actionflow(schema);
    }

    function execute(name, data) {
        var deferred = $q.defer();
        if (_actionflows[name] != undefined) {
            _actionflows[name].execute(data).then(function (result) {
                deferred.resolve(result);
            }).catch(function (error) {
                deferred.reject(error);
            });
        }
        return deferred.promise;
    }

    return service;

}]);

angular.module("app.core").factory("Actionflow", ["$log", "$q", "$injector", "localStorageService", function ($log, $q, $injector, localStorageService) {

    /**
     * Represents a Actionflow
     * @param steps - The JSON schema representing all the actions in the actionflow
     * @constructor
     */
    function Actionflow(actions) {
        this.actions = actions;
        this.debug = (localStorageService.get("debug") == "true");
    }

    Actionflow.prototype = {
        /**
         * Function to begin execution of the actionflow with provided data
         * @param data - Actionflow initial data (e.g. Input event, API results, etc.)
         * @returns {$q.defer().promise}
         */
        execute: function (data) {
            var ActionFactory = $injector.get("ActionFactory");
            return ActionFactory.triggerEvent(null, this.actions, data);
        }
    };

    return Actionflow;
}]);

/* eslint-disable no-console*/

angular.module("app.core").factory("LoggingFactory", ["$injector", "electron", "SchemaHelper", function ($injector, electron, SchemaHelper) {

    var service = {
        "init": init,
        "emailLogs": emailLogs,
        "setRootLogLevel": setRootLogLevel,
        "flushBuffer": flushBuffer,
        "setBufferFrequency": setBufferFrequency,
        "configure": configure,
        "zipLogs": zipLogs,
        "enableDisableLogging": enableDisableLogging,
        "enableDisableDestination": enableDisableDestination,
        "getLogFilePaths": getLogFilePaths,
        "getArchivedLogFilePaths": getArchivedLogFilePaths,
        "isLoggingEnabled": isLoggingEnabled,
        "isDestinationEnabled": isDestinationEnabled,
        "getRootLogLevel": getRootLogLevel,
        "makeFilesPublic": makeFilesPublic,
        "removePublicFiles": removePublicFiles,
        "process$log": process$log
    };

    var LOG_LEVEL_DEBUG = "debug";
    var LOG_LEVEL_INFO = "info";
    var LOG_LEVEL_WARNING = "warn";
    var LOG_LEVEL_ERROR = "error";
    var LOG_LEVEL_OFF = "off";
    var CLIENT_DESTINATION_IDENTIFIER = "_cti_log_";
    var CLIENT_DESTINATION = "client";
    var APP_DESTINATION = "app";
    var NATIVE_DESTINATION = "native";
    var MIN_BUFFER_FREQUENCY = 1;
    var MAX_BUFFER_FREQUENCY = 500;

    var ENV_LOGGING_ENABLED = "env.logging.enabled";
    var ENV_APP_DESTINATION_ENABLED = "env.logging.appDestinationEnabled";
    var ENV_CLIENT_DESTINATION_ENABLED = "env.logging.clientDestinationEnabled";
    var ENV_NATIVE_DESTINATION_ENABLED = "env.logging.nativeDestinationEnabled";
    var ENV_APP_ROOT_LOG_LEVEL = "env.logging.currentAppLogRootLevel";
    var ENV_CLIENT_ROOT_LOG_LEVEL = "env.logging.currentClientLogRootLevel";
    var ENV_NATIVE_ROOT_LOG_LEVEL = "env.logging.currentNativeLogRootLevel";
    var ENV_BUFFER_SIZE = "env.logging.currentBufferSize";
    var ENV_APP_LOG_FILE_PATH = "env.logging.appLogFilePath";
    var ENV_CLIENT_LOG_FILE_PATH = "env.logging.clientLogFilePath";
    var ENV_NATIVE_LOG_FILE_PATH = "env.logging.nativeLogFilePath";

    var ACTIVE_DB_NAME_KEY = "activeDbName";
    var REQUIRES_FLUSH_DB_NAMES_KEY = "requiresFlushDbNames";

    var bufferFrequency = 1;

    var db;
    var dbsToFlush = [];
    var activeDbName;

    var appName;

    var loggingEnabled = false;
    var appLoggingEnabled = false;
    var clientLoggingEnabled = false;
    var appLogRootLevel = LOG_LEVEL_ERROR;
    var clientLogRootLevel = LOG_LEVEL_ERROR;

    var dbNameFlushing = "x";

    var fmt = new DateFmt("%y-%m-%d %H:%M:%S:%s");

    if (window.console && console.log) {
        var oldLog = console.log;
        console.log = function () {
            handleLog(arguments);
            oldLog.apply(this, arguments);
        };
    }

    if (window.console && console.info) {
        var oldInfo = console.info;
        console.info = function () {
            handleInfo(arguments);
            oldInfo.apply(this, arguments);
        };
    }

    if (window.console && console.debug) {
        var oldDebug = console.debug;
        console.debug = function () {
            handleDebug(arguments);
            oldDebug.apply(this, arguments);
        };
    }

    if (window.console && console.error) {
        var oldError = console.error;
        console.error = function () {
            handleError(arguments);
            oldError.apply(this, arguments);
        };
    }

    if (window.console && console.warn) {
        var oldWarn = console.warn;
        console.warn = function () {
            handleWarn(arguments);
            oldWarn.apply(this, arguments);
        };
    }

    function process$log($delegate) {
        return {
            log: function () {
                handleLog(arguments, true);
                // Pass original arguments to $log method so we don't include the client identifier in the console
                $delegate.log.apply(null, arguments);
            },
            debug: function () {
                handleDebug(arguments, true);
                $delegate.debug.apply(null, arguments);
            },
            info: function () {
                handleInfo(arguments, true);
                $delegate.info.apply(null, arguments);
            },
            error: function () {
                handleError(arguments, true);
                $delegate.error.apply(null,  arguments);
            },
            warn: function () {
                handleWarn(arguments, true);
                $delegate.warn.apply(null, arguments);
            }
        };
    }

    function init(appNameIn) {
        var StoreFactory = $injector.get("StoreFactory");
        appName = appNameIn;
        if (SchemaHelper.schema.hostContext != 0) { // In live preview or preview mode so inject values in.
            enableDisableLogging(SchemaHelper.schema.settings.logging.enabled || false);
            enableDisableDestination(SchemaHelper.schema.settings.logging.appEnabled || false, APP_DESTINATION);
            enableDisableDestination(SchemaHelper.schema.settings.logging.clientEnabled || false, CLIENT_DESTINATION);
            enableDisableDestination(SchemaHelper.schema.settings.logging.nativeEnabled || false, NATIVE_DESTINATION);
            setRootLogLevel(SchemaHelper.schema.settings.logging.appUseDefault ? SchemaHelper.schema.settings.logging.defaultRootLogLevel : SchemaHelper.schema.settings.logging.appRootLogLevel, APP_DESTINATION);
            setRootLogLevel(SchemaHelper.schema.settings.logging.clientUseDefault ? SchemaHelper.schema.settings.logging.defaultRootLogLevel : SchemaHelper.schema.settings.logging.clientRootLogLevel, CLIENT_DESTINATION);
            setRootLogLevel(SchemaHelper.schema.settings.logging.nativeUseDefault ? SchemaHelper.schema.settings.logging.defaultRootLogLevel : SchemaHelper.schema.settings.logging.nativeRootLogLevel, NATIVE_DESTINATION);
            setBufferFrequency(SchemaHelper.schema.settings.logging.bufferFrequency);
        } else {
            isLoggingEnabled()
                .then(function (result) {
                    loggingEnabled = result;
                    StoreFactory.set(ENV_LOGGING_ENABLED, result);
                });
            isDestinationEnabled(APP_DESTINATION)
                .then(function (result) {
                    appLoggingEnabled = result;
                    StoreFactory.set(ENV_APP_DESTINATION_ENABLED, result);
                });
            isDestinationEnabled(CLIENT_DESTINATION)
                .then(function (result) {
                    clientLoggingEnabled = result;
                    StoreFactory.set(ENV_CLIENT_DESTINATION_ENABLED, result);
                });
            isDestinationEnabled(NATIVE_DESTINATION)
                .then(function (result) {
                    StoreFactory.set(ENV_NATIVE_DESTINATION_ENABLED, result);
                });
            getRootLogLevel(APP_DESTINATION)
                .then(function (result) {
                    appLogRootLevel = result;
                    StoreFactory.set(ENV_APP_ROOT_LOG_LEVEL, result);
                });
            getRootLogLevel(CLIENT_DESTINATION)
                .then(function (result) {
                    clientLogRootLevel = result;
                    StoreFactory.set(ENV_CLIENT_ROOT_LOG_LEVEL, result);
                });
            getRootLogLevel(NATIVE_DESTINATION)
                .then(function (result) {
                    StoreFactory.set(ENV_NATIVE_ROOT_LOG_LEVEL, result);
                });
        }

        var savedBufferFrequency = StoreFactory.get(ENV_BUFFER_SIZE);
        if (savedBufferFrequency === undefined) {
            setBufferFrequency(SchemaHelper.schema.settings.logging.bufferFrequency);
        } else {
            bufferFrequency = savedBufferFrequency;
        }
        var savedActiveDbName = StoreFactory.get(ACTIVE_DB_NAME_KEY);
        if (savedActiveDbName === undefined) {
            createDb();
        } else {
            createDb(savedActiveDbName);
        }
        var savedRequiresFlushDbNames = StoreFactory.get(REQUIRES_FLUSH_DB_NAMES_KEY);
        if (savedRequiresFlushDbNames !== undefined) {
            dbsToFlush = savedRequiresFlushDbNames;
        }
    }

    function createDb(name) {
        var storeFactory = $injector.get("StoreFactory");
        if (name === undefined) {
            if (activeDbName) {
                dbsToFlush.unshift(activeDbName);
                storeFactory.set(REQUIRES_FLUSH_DB_NAMES_KEY, dbsToFlush);
            }
            name = appName + "_logs_" + new Date().getTime().toString();
        }
        db = new PouchDB(name, {
            // eslint-disable-next-line camelcase
            revs_limit: 1
        });
        db.changes({
            since: "now",
            live: true,
            // eslint-disable-next-line camelcase
            include_docs: true
        }).on("change", function () {
            flushBuffer(true);
        });
        activeDbName = name;
        storeFactory.set(ACTIVE_DB_NAME_KEY, name);
    }

    function getDb(name) {
        return new PouchDB(name, {
            // eslint-disable-next-line camelcase
            revs_limit: 1
        });
    }

    function destroyDb(db) {
        var $q = $injector.get("$q");
        var deferred = $q.defer();
        db.destroy().then(function () {
            deferred.resolve();
        }).catch(function (err) {
            deferred.reject(err);
        });
        return deferred.promise;
    }

    function flushBuffer(considerBufferFrequency) {
        var $q = $injector.get("$q");
        var deferred = $q.defer();
        var outerArguments = arguments;
        db.info()
            .then(function (infoResult) {
                var result = ((outerArguments.length == 0 && infoResult.doc_count > 0) || (considerBufferFrequency === false && infoResult.doc_count > 0) || (considerBufferFrequency && infoResult.doc_count >= bufferFrequency));
                if (result && (considerBufferFrequency === undefined || !considerBufferFrequency || infoResult.db_name != dbNameFlushing)) {
                    dbNameFlushing = infoResult.db_name;
                    createDb();
                    flushDbs()
                        .then(function (dbsFlushed) {
                            var StoreFactory = $injector.get("StoreFactory");
                            dbsFlushed.forEach(function (dbName) {
                                var dbNameIndex = dbsToFlush.indexOf(dbName);
                                dbsToFlush.splice(dbNameIndex, 1);
                            });
                            StoreFactory.set(REQUIRES_FLUSH_DB_NAMES_KEY, dbsToFlush);
                            getLogFilePaths()
                                .then(function (paths) {
                                    if (paths[CLIENT_DESTINATION] != null) {
                                        StoreFactory.set(ENV_CLIENT_LOG_FILE_PATH, paths[CLIENT_DESTINATION]);
                                    }
                                    if (paths[APP_DESTINATION] != null) {
                                        StoreFactory.set(ENV_APP_LOG_FILE_PATH, paths[APP_DESTINATION]);
                                    }
                                    if (paths[NATIVE_DESTINATION] != null) {
                                        StoreFactory.set(ENV_NATIVE_LOG_FILE_PATH, paths[NATIVE_DESTINATION]);
                                    }
                                });
                            deferred.resolve();
                        });
                } else {
                    deferred.resolve();
                }
            });
        return deferred.promise;
    }

    function flushDbs() {
        var $q = $injector.get("$q");
        var deferred = $q.defer();
        var dbsFlushed = [];
        var dbsToFlushCount = dbsToFlush.length;
        dbsToFlush.forEach(function (dbName) {
            var dbToFlush = getDb(dbName);
            dbToFlush.allDocs({
                // eslint-disable-next-line camelcase
                include_docs: true
            }, function (err, allDocsResult) {
                if (!err) {
                    var logsFromDb = [];
                    for (var i = 0; i < allDocsResult.rows.length; i++) {
                        var doc = allDocsResult.rows[i].doc;
                        logsFromDb.push(doc.data);
                    }
                    var Plugin = $injector.get("Plugin");
                    var Platform = $injector.get("Platform");
                    var logging = Plugin.getSource("logging");
                    if (logging) {
                        var isDesktop = Platform.getType() === "desktop";
                        if (isDesktop) {
                            logging.logMessages(logsFromDb);
                            destroyDb(dbToFlush)
                                .then(function () {
                                    dbsFlushed.push(dbName);
                                    dbsToFlushCount--;
                                    if (dbsToFlushCount == 0) {
                                        deferred.resolve(dbsFlushed);
                                    }
                                })
                                .catch(function () {
                                    dbsToFlushCount--;
                                    if (dbsToFlushCount == 0) {
                                        deferred.resolve(dbsFlushed);
                                    }
                                });
                        } else {
                            logging.logMessages(function () {
                                destroyDb(dbToFlush)
                                    .then(function () {
                                        dbsFlushed.push(dbName);
                                        dbsToFlushCount--;
                                        if (dbsToFlushCount == 0) {
                                            deferred.resolve(dbsFlushed);
                                        }
                                    })
                                    .catch(function () {
                                        dbsToFlushCount--;
                                        if (dbsToFlushCount == 0) {
                                            deferred.resolve(dbsFlushed);
                                        }
                                    });
                            }, function () {
                                dbsToFlushCount--;
                                if (dbsToFlushCount == 0) {
                                    deferred.resolve(dbsFlushed);
                                }
                            }, logsFromDb);
                        }
                    }
                }
            });
        });
        return deferred.promise;
    }

    function handleLog(arguments, isClient) {
        if (_isClient(isClient, arguments)) {
            if (clientLoggingEnabled) {
                if (shouldBuffer(LOG_LEVEL_INFO, clientLogRootLevel)) {
                    arguments = processArguments(arguments);
                    addToBuffer("[" + getTimeStamp() + "] [DEBUG] " + arguments, LOG_LEVEL_DEBUG, CLIENT_DESTINATION);
                }
            }
        } else {
            if (appLoggingEnabled) {
                if (shouldBuffer(LOG_LEVEL_INFO, appLogRootLevel)) {
                    arguments = processArguments(arguments);
                    addToBuffer("[" + getTimeStamp() + "] [DEBUG] " + arguments, LOG_LEVEL_DEBUG, APP_DESTINATION);
                }
            }
        }
    }

    function handleDebug(arguments, isClient) {
        if (_isClient(isClient, arguments)) {
            if (clientLoggingEnabled) {
                if (shouldBuffer(LOG_LEVEL_DEBUG, clientLogRootLevel)) {
                    arguments = processArguments(arguments);
                    addToBuffer("[" + getTimeStamp() + "] [DEBUG] " + arguments, LOG_LEVEL_DEBUG, CLIENT_DESTINATION);
                }
            }
        } else {
            if (appLoggingEnabled) {
                if (shouldBuffer(LOG_LEVEL_DEBUG, appLogRootLevel)) {
                    arguments = processArguments(arguments);
                    addToBuffer("[" + getTimeStamp() + "] [DEBUG] " + arguments, LOG_LEVEL_DEBUG, APP_DESTINATION);
                }
            }
        }
    }

    function handleInfo(arguments, isClient) {
        if (_isClient(isClient, arguments)) {
            if (clientLoggingEnabled) {
                if (shouldBuffer(LOG_LEVEL_INFO, clientLogRootLevel)) {
                    arguments = processArguments(arguments);
                    addToBuffer("[" + getTimeStamp() + "] [INFO] " + arguments, LOG_LEVEL_INFO, CLIENT_DESTINATION);
                }
            }
        } else {
            if (appLoggingEnabled) {
                if (shouldBuffer(LOG_LEVEL_INFO, appLogRootLevel)) {
                    arguments = processArguments(arguments);
                    addToBuffer("[" + getTimeStamp() + "] [INFO] " + arguments, LOG_LEVEL_INFO, APP_DESTINATION);
                }
            }
        }
    }

    function handleError(arguments, isClient) {
        if (_isClient(isClient, arguments)) {
            if (clientLoggingEnabled) {
                if (shouldBuffer(LOG_LEVEL_ERROR, clientLogRootLevel)) {
                    arguments = processArguments(arguments);
                    addToBuffer("[" + getTimeStamp() + "] [ERROR] " + arguments, LOG_LEVEL_ERROR, CLIENT_DESTINATION);
                }
            }
        } else {
            if (appLoggingEnabled) {
                if (shouldBuffer(LOG_LEVEL_ERROR, appLogRootLevel)) {
                    arguments = processArguments(arguments);
                    addToBuffer("[" + getTimeStamp() + "] [ERROR] " + arguments, LOG_LEVEL_ERROR, APP_DESTINATION);
                }
            }
        }
    }

    function handleWarn(arguments, isClient) {
        if (_isClient(isClient, arguments)) {
            if (clientLoggingEnabled) {
                if (shouldBuffer(LOG_LEVEL_WARNING, clientLogRootLevel)) {
                    arguments = processArguments(arguments);
                    addToBuffer("[" + getTimeStamp() + "] [WARN] " + arguments, LOG_LEVEL_WARNING, CLIENT_DESTINATION);
                }
            }
        } else {
            if (appLoggingEnabled) {
                if (shouldBuffer(LOG_LEVEL_WARNING, appLogRootLevel)) {
                    arguments = processArguments(arguments);
                    addToBuffer("[" + getTimeStamp() + "] [WARN] " + arguments, LOG_LEVEL_WARNING, APP_DESTINATION);
                }
            }
        }
    }

    function _isClient(isClient, arguments) {
        return isClient === true || (arguments.length >= 2 && arguments[0] === CLIENT_DESTINATION_IDENTIFIER);
    }

    function processArguments(arguments) {
        var processedArguments = [];
        var args = Array.prototype.slice.call(arguments);
        if (arguments.length >= 2 && arguments[0] === CLIENT_DESTINATION_IDENTIFIER) {
            args.shift();
        }
        for (var index = 0; index < args.length; index++) {
            var argument = args[index];
            if (angular.isObject(argument) || angular.isArray(argument)) {
                try {
                    processedArguments.push(JSON.stringify(argument));
                } catch (err) {
                    processedArguments.push(argument);
                }
            } else if (typeof argument === "function") {
                processedArguments.push(argument.toString());
            } else {
                processedArguments.push(argument);
            }
        }
        if (args.length > 0) {
            processedArguments = sprintf.apply(null, processedArguments);
        }
        return processedArguments;
    }

    function addToBuffer(message, level, destination) {
        if (db == null) return;
        var msgObj = {
            "logLevel": level,
            "message": message,
            "destination": destination
        };
        db.put({
            _id: new Date().getTime().toString() + window.performance.now(),
            data: msgObj
        }, function () {
        });
    }

    function enableDisableLogging(enabled) {
        loggingEnabled = enabled;
        var StoreFactory = $injector.get("StoreFactory");
        var Plugin = $injector.get("Plugin");
        var Platform = $injector.get("Platform");
        var logging = Plugin.getSource("logging");
        if (logging) {
            var isDesktop = Platform.getType() === "desktop";
            if (isDesktop) {
                if (enabled) {
                    logging.enableLogging();
                } else if (!enabled) {
                    logging.disableLogging();
                }
                StoreFactory.set(ENV_LOGGING_ENABLED, enabled);
            } else {
                if (enabled) {
                    logging.enableLogging(function () {
                        StoreFactory.set(ENV_LOGGING_ENABLED, enabled);
                    }, function () {
                    });
                } else if (!enabled) {
                    logging.disableLogging(function () {
                        StoreFactory.set(ENV_LOGGING_ENABLED, enabled);
                    }, function () {
                    });
                }
            }
        }
    }

    function isLoggingEnabled() {
        var $q = $injector.get("$q");
        var deferred = $q.defer();
        var Plugin = $injector.get("Plugin");
        var Platform = $injector.get("Platform");
        var logging = Plugin.getSource("logging");
        if (logging) {
            var isDesktop = Platform.getType() === "desktop";
            if (isDesktop) {
                deferred.resolve(logging.isLoggingEnabled());
            } else {
                logging.isLoggingEnabled(function (result) {
                    deferred.resolve(result);
                }, function (err) {
                    deferred.reject(err);
                });
            }
        }
        return deferred.promise;
    }

    function enableDisableDestination(enabled, destination) {
        var StoreFactory = $injector.get("StoreFactory");
        var Plugin = $injector.get("Plugin");
        var Platform = $injector.get("Platform");
        var logging = Plugin.getSource("logging");
        if (logging) {
            var isDesktop = Platform.getType() === "desktop";
            if (isDesktop) {
                if (enabled) {
                    logging.enableDestination(destination);
                } else if (!enabled) {
                    logging.disableDestination(destination);
                }
                if (destination === APP_DESTINATION) {
                    appLoggingEnabled = enabled;
                    StoreFactory.set(ENV_APP_DESTINATION_ENABLED, enabled);
                } else if (destination === CLIENT_DESTINATION) {
                    clientLoggingEnabled = enabled;
                    StoreFactory.set(ENV_CLIENT_DESTINATION_ENABLED, enabled);
                } else if (destination === NATIVE_DESTINATION) {
                    StoreFactory.set(ENV_NATIVE_DESTINATION_ENABLED, enabled);
                }
            } else {
                if (enabled) {
                    logging.enableDestination(function () {
                        if (destination === APP_DESTINATION) {
                            appLoggingEnabled = enabled;
                            StoreFactory.set(ENV_APP_DESTINATION_ENABLED, enabled);
                        } else if (destination === CLIENT_DESTINATION) {
                            clientLoggingEnabled = enabled;
                            StoreFactory.set(ENV_CLIENT_DESTINATION_ENABLED, enabled);
                        } else if (destination === NATIVE_DESTINATION) {
                            StoreFactory.set(ENV_NATIVE_DESTINATION_ENABLED, enabled);
                        }
                    }, function () {
                    }, destination);
                } else if (!enabled) {
                    logging.disableDestination(function () {
                        if (destination === APP_DESTINATION) {
                            appLoggingEnabled = false;
                            StoreFactory.set(ENV_APP_DESTINATION_ENABLED, false);
                        } else if (destination === CLIENT_DESTINATION) {
                            clientLoggingEnabled = false;
                            StoreFactory.set(ENV_CLIENT_DESTINATION_ENABLED, false);
                        } else if (destination === NATIVE_DESTINATION) {
                            StoreFactory.set(ENV_NATIVE_DESTINATION_ENABLED, false);
                        }
                    }, function () {
                    }, destination);
                }
            }
        }
    }

    function isDestinationEnabled(destination) {
        var $q = $injector.get("$q");
        var deferred = $q.defer();
        var Plugin = $injector.get("Plugin");
        var Platform = $injector.get("Platform");
        var logging = Plugin.getSource("logging");
        if (logging) {
            var isDesktop = Platform.getType() === "desktop";
            if (isDesktop) {
                deferred.resolve(logging.isDestinationEnabled(destination));
            } else {
                logging.isDestinationEnabled(function (result) {
                    deferred.resolve(result);
                }, function (err) {
                    deferred.reject(err);
                }, destination);
            }
        }
        return deferred.promise;
    }

    function setRootLogLevel(level, destination) {
        if (level === undefined) {
            return;
        }
        level = level.toLowerCase();
        if (level === LOG_LEVEL_INFO || level === LOG_LEVEL_DEBUG || level === LOG_LEVEL_WARNING || level === LOG_LEVEL_ERROR) {
            var StoreFactory = $injector.get("StoreFactory");
            var Plugin = $injector.get("Plugin");
            var Platform = $injector.get("Platform");
            var logging = Plugin.getSource("logging");
            if (logging) {
                var isDesktop = Platform.getType() === "desktop";
                if (destination) {
                    if (isDesktop) {
                        logging.setRootLogLevel(level, destination);
                    } else {
                        logging.setRootLogLevel(function () {
                        }, function () {
                        }, level, destination);
                    }
                    if (destination === APP_DESTINATION) {
                        appLogRootLevel = level;
                        StoreFactory.set(ENV_APP_ROOT_LOG_LEVEL, level);
                    } else if (destination === CLIENT_DESTINATION) {
                        clientLogRootLevel = level;
                        StoreFactory.set(ENV_CLIENT_ROOT_LOG_LEVEL, level);
                    } else if (destination === NATIVE_DESTINATION) {
                        StoreFactory.set(ENV_NATIVE_ROOT_LOG_LEVEL, level);
                    }
                } else {
                    if (isDesktop) {
                        logging.setRootLogLevel(level, CLIENT_DESTINATION);
                        logging.setRootLogLevel(level, APP_DESTINATION);
                        logging.setRootLogLevel(level, NATIVE_DESTINATION);
                    } else {
                        logging.setRootLogLevel(function () {
                        }, function () {
                        }, level, CLIENT_DESTINATION);
                        logging.setRootLogLevel(function () {
                        }, function () {
                        }, level, APP_DESTINATION);
                        logging.setRootLogLevel(function () {
                        }, function () {
                        }, level, NATIVE_DESTINATION);
                    }
                    StoreFactory.set(ENV_APP_ROOT_LOG_LEVEL, level);
                    StoreFactory.set(ENV_CLIENT_ROOT_LOG_LEVEL, level);
                    StoreFactory.set(ENV_NATIVE_ROOT_LOG_LEVEL, level);
                }
            }
        }
    }

    function getRootLogLevel(destination) {
        var $q = $injector.get("$q");
        var deferred = $q.defer();
        var Plugin = $injector.get("Plugin");
        var Platform = $injector.get("Platform");
        var logging = Plugin.getSource("logging");
        if (logging) {
            var isDesktop = Platform.getType() === "desktop";
            if (isDesktop) {
                deferred.resolve(logging.getRootLogLevel(destination));
            } else {
                logging.getRootLogLevel(function (result) {
                    deferred.resolve(result);
                }, function (err) {
                    deferred.reject(err);
                }, destination);
            }
        }
        return deferred.promise;
    }

    function setBufferFrequency(frequency) {
        if (frequency === undefined) {
            frequency = MIN_BUFFER_FREQUENCY;
        } else if (frequency < MIN_BUFFER_FREQUENCY) {
            frequency = MIN_BUFFER_FREQUENCY;
        } else if (frequency > MAX_BUFFER_FREQUENCY) {
            frequency = MAX_BUFFER_FREQUENCY;
        }
        bufferFrequency = frequency;
        var StoreFactory = $injector.get("StoreFactory");
        StoreFactory.set(ENV_BUFFER_SIZE, frequency);
    }

    function configure(settings, destination) {
        var Plugin = $injector.get("Plugin");
        var Platform = $injector.get("Platform");
        var logging = Plugin.getSource("logging");
        if (logging) {
            var isDesktop = Platform.getType() === "desktop";
            if (destination) {
                if (isDesktop) {
                    logging.configure(settings, destination);
                } else {
                    logging.configure(function () {
                    }, function () {
                    }, settings, destination);
                }
            } else {
                if (isDesktop) {
                    logging.configure(settings, CLIENT_DESTINATION);
                    logging.configure(settings, APP_DESTINATION);
                    logging.configure(settings, NATIVE_DESTINATION);
                } else {
                    logging.configure(function () {
                    }, function () {
                    }, settings, CLIENT_DESTINATION);
                    logging.configure(function () {
                    }, function () {
                    }, settings, APP_DESTINATION);
                    logging.configure(function () {
                    }, function () {
                    }, settings, NATIVE_DESTINATION);
                }
            }
        }
    }

    function zipLogs(includeArchivedLogs) {
        var $q = $injector.get("$q");
        var deferred = $q.defer();
        var Plugin = $injector.get("Plugin");
        var Platform = $injector.get("Platform");
        var logging = Plugin.getSource("logging");
        if (logging) {
            flushBuffer()
                .then(function () {
                    var isDesktop = Platform.getType() === "desktop";
                    if (isDesktop) {
                        logging.zipLogFiles(includeArchivedLogs, function (path) {
                            deferred.resolve(path);
                        });
                    } else {
                        logging.zipLogFiles(function (path) {
                            deferred.resolve(path);
                        }, function () {
                            deferred.reject();
                        }, includeArchivedLogs);
                    }
                });
        } else {
            deferred.reject();
        }
        return deferred.promise;
    }

    function shouldBuffer(messageLogLevel, rootLogLevel) {
        if (!loggingEnabled) {
            return false;
        }
        if (rootLogLevel === LOG_LEVEL_OFF) {
            return false;
        }
        if (rootLogLevel === LOG_LEVEL_DEBUG) {
            if (messageLogLevel === LOG_LEVEL_DEBUG || messageLogLevel === LOG_LEVEL_INFO || messageLogLevel === LOG_LEVEL_WARNING || messageLogLevel === LOG_LEVEL_ERROR) {
                return true;
            } else {
                return false;
            }
        } else if (rootLogLevel  === LOG_LEVEL_INFO) {
            if (messageLogLevel === LOG_LEVEL_INFO || messageLogLevel === LOG_LEVEL_WARNING || messageLogLevel === LOG_LEVEL_ERROR) {
                return true;
            } else {
                return false;
            }
        } else if (rootLogLevel === LOG_LEVEL_WARNING) {
            if (messageLogLevel === LOG_LEVEL_WARNING || messageLogLevel === LOG_LEVEL_ERROR) {
                return true;
            } else {
                return false;
            }
        } else if (rootLogLevel === LOG_LEVEL_ERROR) {
            if (messageLogLevel === LOG_LEVEL_ERROR) {
                return true;
            } else {
                return false;
            }
        }
        return true;
    }

    function emailLogs(to, subject, body, includeArchivedLogs) {
        var Plugin = $injector.get("Plugin");
        var Platform = $injector.get("Platform");
        var logging = Plugin.getSource("logging");
        if (logging) {
            zipLogs(includeArchivedLogs)
                .then(function (zipPath) {
                    var isDesktop = Platform.getType() === "desktop";
                    if (isDesktop) {
                        location.href= "mailto:" + to + "?subject=" + subject + "&body=" + body;
                        logging.getRootLogFolder(function (path) {
                            electron.shell.openItem(path);
                        });
                    } else {
                        logging.makeFilesPublic(function (zipPath) {
                            openEmailClient(to, subject, body, zipPath, function () {});
                        }, function () {
                        }, zipPath);
                    }
                });
        }
    }

    function openEmailClient(to, subject, body, attachmentPaths, callback) {
        var Plugin = $injector.get("Plugin");
        var emailPlugin = Plugin.getSource("email");
        emailPlugin.open({
            to: to,
            subject: subject,
            body: body,
            attachments: attachmentPaths
        }, function () {
            callback();
        });
    }

    function getLogFilePaths() {
        var $q = $injector.get("$q");
        var deferred = $q.defer();
        var Plugin = $injector.get("Plugin");
        var Platform = $injector.get("Platform");
        var logging = Plugin.getSource("logging");
        if (logging) {
            var isDesktop = Platform.getType() === "desktop";
            if (isDesktop) {
                logging.getLogFilePaths(function (paths) {
                    deferred.resolve(paths);
                });
            } else {
                logging.getLogFilePaths(function (paths) {
                    deferred.resolve(paths);
                }, function (err) {
                    deferred.reject(err);
                });
            }
        }
        return deferred.promise;
    }

    function getArchivedLogFilePaths() {
        var $q = $injector.get("$q");
        var deferred = $q.defer();
        var Plugin = $injector.get("Plugin");
        var Platform = $injector.get("Platform");
        var logging = Plugin.getSource("logging");
        if (logging) {
            var isDesktop = Platform.getType() === "desktop";
            if (isDesktop) {
                logging.getArchivedLogFilePaths(function (paths) {
                    deferred.resolve(paths);
                });
            } else {
                logging.getArchivedLogFilePaths(function (paths) {
                    deferred.resolve(paths);
                }, function (err) {
                    deferred.reject(err);
                });
            }
        }
        return deferred.promise;
    }

    function makeFilesPublic(paths) {
        var $q = $injector.get("$q");
        var deferred = $q.defer();
        var Plugin = $injector.get("Plugin");
        var Platform = $injector.get("Platform");
        var logging = Plugin.getSource("logging");
        if (logging) {
            var isDesktop = Platform.getType() === "desktop";
            if (isDesktop) {
                deferred.resolve(paths);
            } else {
                logging.makeFilesPublic (function (paths) {
                    deferred.resolve(paths);
                }, function (err) {
                    deferred.reject(err);
                }, paths);
            }
        }
        return deferred.promise;
    }

    function removePublicFiles() {
        var Plugin = $injector.get("Plugin");
        var Platform = $injector.get("Platform");
        var logging = Plugin.getSource("logging");
        if (logging) {
            var isDesktop = Platform.getType() === "desktop";
            if (isDesktop) {
                logging.removePublicFiles();
            } else {
                logging.removePublicFiles(function () {}, function () {});
            }
        }
    }

    function getTimeStamp() {
        return fmt.format(new Date());
    }

    function DateFmt(fstr) {
        this.formatString = fstr;

        var mthNames = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
        var dayNames = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
        var zeroPadPowerOf2 = function (number) {
            return ("0"+number).substr(-2, 2);
        };
        var zeroPadPowerOf3 = function (number) {
            return ("00"+number).substr(-3, 3);
        };
        var dateMarkers = {
            d: ["getDate", function (v) {
                return zeroPadPowerOf2(v);
            }],
            m: ["getMonth", function (v) {
                return zeroPadPowerOf2(v+1);
            }],
            n: ["getMonth", function (v) {
                return mthNames[v];
            }],
            w: ["getDay", function (v) {
                return dayNames[v];
            }],
            y: ["getFullYear"],
            H: ["getHours", function (v) {
                return zeroPadPowerOf2(v);
            }],
            M: ["getMinutes", function (v) {
                return zeroPadPowerOf2(v);
            }],
            S: ["getSeconds", function (v) {
                return zeroPadPowerOf2(v);
            }],
            s: ["getMilliseconds", function (v) {
                return zeroPadPowerOf3(v);
            }],
            i: ["toISOString"]
        };

        this.format = function (date) {
            var dateTxt = this.formatString.replace(/%(.)/g, function (m, p) {
                var rv = date[(dateMarkers[p])[0]]();
                if (dateMarkers[p][1] != null) rv = dateMarkers[p][1](rv);
                return rv;
            });
            return dateTxt;
        };
    }

    function sprintf() {
        var toBase = function (value, base) {
            // converts to the required bases
            return (parseInt(value, 10) || 0).toString(base);
        };
        var map = {
            s: function (value) {
                return value.toString();
            },
            d: function (value) {
                return toBase(value, 10);
            },
            i: function (value) {
                return this.d(value);
            },
            b: function (value) {
                // binary conversion
                return toBase(value, 2);
            },
            o: function (value) {
                // octal conversion
                return toBase(value, 8);
            },
            x: function (value) {
                // hexadecimal conversion
                return toBase(value, 16);
            },
            X: function (value) {
                // HEXADECIMAL CONVERSION IN CAPITALS
                return toBase(value, 16).toUpperCase();
            },
            e: function (value) {
                // scientific notation
                return (parseFloat(value, 10) || 0).toExponential();
            },
            E: function (value) {
                return this.e(value, 10).toUpperCase();
            },
            f: function (value) {
                // floating point
                return (parseFloat(value, 10) || "0.0").toString();
            }
        };

        // crude way to extract the keys
        var keys = "";
        for (var k in map) {
            keys += k;
        }
        var args = Array.prototype.slice.call(arguments).slice();

        var stringToReturn = args.shift().toString().replace(new RegExp("%([" + keys + "])", "g"), function (_, type) {
            if (!args.length) {
                throw new Error("Too few elements");
            }
            return map[type](args.shift());
        });

        for (var index = 0; index < args.length; index++) {
            var arg = args[index];
            stringToReturn += " " + arg;
        }

        return stringToReturn;
    }

    return service;
}]);

/* eslint-enable no-console */

angular.module("app.core").factory("AudioPlayer", ["$q", "Plugin", "electron", "$interval", "$log", "$timeout", "VibrateFactory", function ($q, Plugin, electron, $interval, $log, $timeout, VibrateFactory) {

    var LOOP_FOREVER = -999999;

    var Media = Plugin.getSource("Media");

    var _callbacks = {};
    var _loopOptions = undefined;
    var _vibrate = undefined;
    var _loopTimer = undefined;
    var _interval = null;

    // Thanks to Windows Phone we are only able to have once instance of Media at any one time
    var __audio = null;
    // For Electron we can use the HTML audio player
    var $audio = document.createElement("audio");
    $audio.setAttribute("preload", "auto");

    function _formatTime(number) {
        var seconds = 0;
        var minutes = 0;
        if (number > 0) {
            seconds = Math.floor(number % 60);
            minutes = Math.floor(number / 60);
        }
        return "" + minutes + ":" + (seconds < 10 ? "0" : "") + seconds;
    }

    function _info(callback, state) {
        if (__audio === null) {
            $log.error("Audio has not been initialised yet, cannot continue.");
            return;
        }
        __audio.getCurrentPosition(function (position) {
            callback({
                "state": state,
                "position": (position > -1) ? position : 0,
                "currentTime": _formatTime(position)
            });
        });
    }

    function _initialise(src, options, callback) {

        _vibrate = {};
        _vibrate.vibrate = options.vibrate;
        _vibrate.vibratePattern = options.vibratePattern;
        _vibrate.vibrateCustomPattern = options.vibrateCustomPattern;
        _vibrate.forceVibrate = options.forceVibrate;

        function vibrate(_options) {

            if (!_options || !_options.vibrate) return;

            if (_options.vibratePattern !== "none") {
                var patternArray;
                if (_options.vibratePattern === "custom") {
                    if (_options.vibrateCustomPattern !== "") {
                        patternArray = _options.vibrateCustomPattern.split(",");
                    }
                } else {
                    patternArray = _options.vibratePattern.split(",");
                }
                if (patternArray) {
                    VibrateFactory.vibratePattern(patternArray, 0, true, _options.forceVibrate);
                }
            } else {
                VibrateFactory.vibrate(0, true, _options.forceVibrate);
            }
        }

        function stopVibrate() {
            if (_vibrate && _vibrate.vibrate) {
                VibrateFactory.stopVibration();
            }
        }

        // If we currently have an audio object then we need to release it
        if (__audio !== null) {
            __audio.release();
            for (var key in _callbacks) {
                if (_callbacks[key] !== undefined) {
                    $interval.cancel(_interval);
                    _info(_callbacks[key], "stopped");
                    _callbacks[key] = undefined;
                }
            }
        }

        _callbacks[src] = callback;

        function _stateChange(state) {
            switch (state) {
                case Media.MEDIA_NONE: // 0
                    $interval.cancel(_interval);
                    $timeout(function () {
                        _info(callback, "released");
                    }, 60);
                    break;
                case Media.MEDIA_STARTING: // 1
                    $timeout(function () {
                        _info(callback, "starting");
                    }, 50);
                    break;
                case Media.MEDIA_RUNNING: // 2
                    $timeout(function () {
                        _info(callback, "playing");
                    }, 50);
                    _interval = $interval(function () {
                        _info(callback, "running");
                    }, 50);
                    vibrate(_loopOptions);
                    break;
                case Media.MEDIA_PAUSED: // 3
                    $interval.cancel(_interval);
                    $timeout(function () {
                        _info(callback, "paused");
                    }, 60);
                    stopVibrate();
                    break;
                case Media.MEDIA_STOPPED: // 4
                    $interval.cancel(_interval);
                    $timeout(function () {
                        _info(callback, "stopped");
                    }, 60);
                    stopVibrate();
                    break;
            }
        }

        if (electron.app !== undefined) {
            __audio = {
                "change": function (state) {
                    _stateChange(state);
                },
                "play": function () {
                    $audio.play();
                    __audio.change(Media.MEDIA_RUNNING);
                },
                "pause": function () {
                    $audio.pause();
                    __audio.change(Media.MEDIA_PAUSED);
                },
                "stop": function () {
                    $audio.pause();
                    $audio.currentTime = 0;
                    __audio.change(Media.MEDIA_STOPPED);
                },
                "getCurrentPosition": function (cb) {
                    if ($audio.ended === true) {
                        __audio.stop();
                    }
                    cb($audio.currentTime);
                },
                "getDuration": function () {
                    return $audio.duration;
                },
                "release": function () {
                    // We do not need to do anything here
                    $audio.currentTime = 0;
                    __audio.change(Media.MEDIA_NONE);
                }
            };
            $audio.onloadeddata = function () {
                __audio.play();
            };
            $audio.onended = function () {
                checkLoop(_loopOptions);
            };
            $audio.setAttribute("src", src);
        } else {
            __audio = new Media(src, function () {
                checkLoop(_loopOptions);
            }, function (error) {
                if (error && error.code === 0) {
                    // Probably just stopping a stream that isn't running.
                    $log.info("No media player active");
                } else {
                    $log.error("Audio Error:", error);
                }
            }, function (state) {
                _stateChange (state);
            });
            __audio.setStreamId(function () {
                __audio.play();
            }, options.streamId);
        }

        function checkLoop() {

            function playLoop() {
                if (_loopOptions) {
                    _initialise(src, _loopOptions, _callbacks[src]);
                }
            }

            if (_loopOptions && _loopOptions.loop && (_loopOptions.loopCount > 0 || _loopOptions.loopCount <= LOOP_FOREVER)) {
                var interval = _loopOptions.loopInterval;
                _loopTimer = setTimeout(playLoop, interval * 1000);
                if (_loopOptions.loopCount != LOOP_FOREVER) {
                    _loopOptions.loopCount--;
                }
            } else {
                _loopOptions = undefined;
            }
        }
    }

    return {
        "getDuration": function (src, callback) {
            if (src === undefined || src.length === 0) {
                return;
            }
            if (electron.app !== undefined) {
                var $info = document.createElement("audio");
                $info.setAttribute("preload", "auto");
                $info.onloadeddata = function (e) {
                    callback(e.currentTarget.duration, _formatTime(e.currentTarget.duration));
                };
                $info.setAttribute("src", src);
            } else {
                var MediaProperties = Plugin.getSource("mediaproperties");
                if (MediaProperties === false) {
                    return;
                }
                MediaProperties.getProperties(function (props) {
                    callback(props.duration, _formatTime(props.duration));
                }, function (error) {
                    $log.error("Audio Error, could not get media properties:", error);
                }, src);
            }
        },
        "play": function (src, options, callback) {
            if (options.loop) {
                if (options.loopCount == 0) {
                    options.loopCount = LOOP_FOREVER;
                }
                _loopOptions = options;
            }
            _initialise(src, options, callback);
        },
        "stop": function (callback) {
            _loopOptions = undefined;
            clearTimeout(_loopTimer);
            if (__audio !== null) {
                __audio.stop(callback);
            } else {
                callback();
            }
        },
        "pause": function () {
            if (__audio !== null) {
                __audio.pause();
            }
        },
        "unpause": function () {
            if (__audio !== null) {
                __audio.play();
            }
        }
    };
}]);

angular
    .module("app.core")
    .factory("GoogleMapService", ["$q", "$rootScope", function ($q, $rootScope) {

        var scriptDeferred;
        var maps = [];

        function requestGoogleMapsScript(apiKey) {

            if (!scriptDeferred) {

                scriptDeferred = $q.defer();

                var s = document.createElement("script");
                s.onload = function () {
                    scriptDeferred.resolve();
                };
                s.onerror = function (e) {
                    scriptDeferred.resolve(e);
                    scriptDeferred = undefined;
                };

                var lang = getLanguage($rootScope.currentLanguage);
                if (apiKey && apiKey.length > 0) {
                    s.src = "https://maps.googleapis.com/maps/api/js?key=" + apiKey + "&libraries=visualization&language=" + lang;
                } else {
                    s.src = "https://maps.googleapis.com/maps/api/js?libraries=visualization&language=" + lang;
                }
                document.head.appendChild(s);
            }

            return scriptDeferred.promise;
        }

        function getLanguage(studioLang) {
            var supportedLanguages = {
                "ar": "ARABIC",
                "eu": "BASQUE",
                "bg": "BULGARIAN",
                "bn": "BENGALI",
                "ca": "CATALAN",
                "cs": "CZECH",
                "da": "DANISH",
                "de": "GERMAN",
                "el": "GREEK",
                "en": "ENGLISH",
                "en-AU": "ENGLISH (AUSTRALIAN)",
                "en-GB": "ENGLISH (GREAT BRITAIN)",
                "es": "SPANISH",
                "fa": "FARSI",
                "fi": "FINNISH",
                "fil": "FILIPINO",
                "fr": "FRENCH",
                "gl": "GALICIAN",
                "gu": "GUJARATI",
                "hi": "HINDI",
                "hr": "CROATIAN",
                "hu": "HUNGARIAN",
                "id": "INDONESIAN",
                "it": "ITALIAN",
                "iw": "HEBREW",
                "ja": "JAPANESE",
                "kn": "KANNADA",
                "ko": "KOREAN",
                "lt": "LITHUANIAN",
                "lv": "LATVIAN",
                "ml": "MALAYALAM",
                "mr": "MARATHI",
                "nl": "DUTCH",
                "no": "NORWEGIAN",
                "pl": "POLISH",
                "pt": "PORTUGUESE",
                "pt-BR": "PORTUGUESE (BRAZIL)",
                "pt-PT": "PORTUGUESE (PORTUGAL)",
                "ro": "ROMANIAN",
                "ru": "RUSSIAN",
                "sk": "SLOVAK",
                "sl": "SLOVENIAN",
                "sr": "SERBIAN",
                "sv": "SWEDISH",
                "tl": "TAGALOG",
                "ta": "TAMIL",
                "te": "TELUGU",
                "th": "THAI",
                "tr": "TURKISH",
                "uk": "UKRAINIAN",
                "vi": "VIETNAMESE",
                "zh-CN": "CHINESE (SIMPLIFIED)",
                "zh-TW": "CHINESE (TRADITIONAL)"
            };

            var lang = studioLang.replace("_", "-");
            if (supportedLanguages[lang]) {
                return lang;
            }

            lang = studioLang.substr(0, 2);
            if (supportedLanguages[lang]) {
                return lang;
            }

            return "en-GB";
        }

        function registerResize(map) {
            maps.push(map);
        }

        function unregisterResize(map) {
            maps.splice(maps.indexOf(map), 1);
        }

        window.addEventListener("resize", function () {
            var i = maps.length;
            while (i--) {
                if (maps[i]) {
                    google.maps.event.trigger(maps[i], "resize");
                } else {
                    maps.splice(i, 1);
                }
            }
        }, true);

        return {
            "requestGoogleMapsScript": requestGoogleMapsScript,
            "registerResize": registerResize,
            "unregisterResize": unregisterResize
        };
    }]);

angular
    .module("app.core")
    .factory("ListFactory", ["$rootScope", "SchemaHelper", "StoreFactory", function ($rootScope, SchemaHelper, StoreFactory) {
    
        function initializeListsForApp(schema) {
        
            var pages = schema.pages;
            pages.forEach(function (page) {
            
                var pageName = page.name;
                var lists = SchemaHelper.getItems(page.content, "content", "list");
                lists.forEach(function (list) {
                
                    var listName = list.name;
                    resetListState(pageName, listName, true, true, true);
                });
            });
        }
        
        function calculateNumberOfPages(totalItems, itemsPerPage) {
    
            return Math.ceil(totalItems / (itemsPerPage || 1));
        }
        
        function calculateVisiblePages(currentPage, totalPages, maxVisiblePages) {
    
            var visiblePages = [];
            var firstPageNumber = 1;
            var lastPageNumber = totalPages;
    
            if (maxVisiblePages && maxVisiblePages > 0) {
        
                var pagesToDisplay = Math.min(maxVisiblePages, totalPages);
                var pagesToLeft = Math.floor(pagesToDisplay / 2);
                if (pagesToDisplay % 2 === 0) {
                    pagesToLeft = pagesToLeft - 1;
                }
                var pagesToRight = pagesToDisplay - pagesToLeft - 1;
        
                firstPageNumber = currentPage - pagesToLeft;
                lastPageNumber = currentPage + pagesToRight;
        
                if (firstPageNumber < 1) {
                    var leftDiff = (1 - firstPageNumber);
                    firstPageNumber = 1;
                    lastPageNumber = lastPageNumber + leftDiff;
                }
        
                if (lastPageNumber > totalPages) {
                    var rightDiff = (lastPageNumber - totalPages);
                    lastPageNumber = totalPages;
                    firstPageNumber = firstPageNumber - rightDiff;
                }
            }
    
            for (var p = firstPageNumber; p <= lastPageNumber; p++) visiblePages.push(p);
            
            return visiblePages;
        }
        
        function getListState(pageName, listName) {
    
            var storeLocation = "$store.pages." + pageName + "." + listName;
            return StoreFactory.get(storeLocation);
        }
        
        function setListStateFromListScope(pageName, listName, $listScope) {
    
            var listState = {
                numberOfItems: $listScope.listData.length
            };
    
            // === Search === //
            
            if ($listScope.search && $listScope.search.enabled) {
    
                var searchMode = "";
                if ($listScope.search.internal) {
                    searchMode = "internal";
                } else if ($listScope.search.allowExternal) {
                    if ($listScope.search.external) {
                        searchMode = $listScope.search.external.simple
                            ? "simple"
                            : "advanced";
                    }
                }
                
                var searchCriteria = $listScope.search.internal
                    ? $listScope.search.term
                    : $listScope.search.external && $listScope.search.external.criteria || null;
                
                var mode = searchMode;
                var criteria = searchCriteria;
                var totalSearchResults = $listScope.filteredListData.length;
                _applyListSearchState(listState, mode, criteria, totalSearchResults);
            }
    
            // === Order === //
            
            var orderProperty = $listScope.order.property;
            var orderDirection = $listScope.order.reverse ? "desc" : "asc";
            _applyListOrderState(listState, orderProperty, orderDirection);
    
            // === Pagination === //
            
            if ($listScope.pagination && $listScope.pagination.enabled) {
        
                var currentPage = $listScope.pagination.currentPage;
                var totalPages = $listScope.pagination.totalPages;
                var pageSize = $listScope.pagination.limit;
                var hasPreviousPage = $listScope.pagination.currentPage > 1;
                var hasNextPage = $listScope.pagination.currentPage < $listScope.pagination.totalPages;
                
                _applyListPaginationState(listState, currentPage, totalPages, pageSize, hasPreviousPage, hasNextPage);
            }
            
            return _setListState(pageName, listName, listState);
        }
        
        function setListSearchState(pageName, listName, mode, criteria, fromInternalSearch) {
    
            var listSchema = _getListSchema(pageName, listName);
            if (!listSchema) throw "Could not obtain list \"" + listName + "\" on page \"" + pageName + "\"";
            
            if (fromInternalSearch !== true && listSchema.search !== "external") throw "Search actions not allowed for list \"" + listName + "\" on page \"" + pageName + "\"";
    
            var listState = getListState(pageName, listName);
            
            _applyListSearchState(listState, mode, criteria, undefined);
    
            triggerListRefresh(pageName, listName, listState);
        }
        
        function setListOrderState(pageName, listName, orderProperty, orderDirection) {
    
            var listSchema = _getListSchema(pageName, listName);
            if (!listSchema) throw "Could not obtain list \"" + listName + "\" on page \"" + pageName + "\"";
    
            var listState = getListState(pageName, listName);
    
            if (orderDirection === "switch") {
    
                orderDirection = (listState && listState.order)
                    ? (listState.order.property === orderProperty)
                        ? listState.order.direction === "asc"
                            ? "desc"
                            : "asc"
                        : "asc"
                    : "asc";
            }
    
            _applyListOrderState(listState, orderProperty, orderDirection);
    
            triggerListRefresh(pageName, listName, listState);
        }
        
        function setListPaginationState(pageName, listName, pageChange) {
    
            var listSchema = _getListSchema(pageName, listName);
            if (!listSchema) throw "Could not obtain list \"" + listName + "\" on page \"" + pageName + "\"";
            
            if (!listSchema.pagination) throw "Pagination not enabled for list \"" + listName + "\" on page \"" + pageName + "\"";
    
            var listState = getListState(pageName, listName);
            
            var newPageNumber = 1;
            var totalPages = 1;
            var pageSize = undefined;
            
            if (listState && listState.pagination) {
                totalPages = listState.pagination.totalPages || 1;
                pageSize = listState.pagination.pageSize || undefined;
            }
            
            if (!isNaN(pageChange)) {
        
                newPageNumber = pageChange;
        
            } else if (listState && listState.pagination) {
        
                var currentPageNumber = listState.pagination.currentPage || 1;
        
                switch (pageChange) {
            
                    case "first":
                        newPageNumber = 1;
                        break;
            
                    case "prev":
                        newPageNumber = currentPageNumber - 1;
                        break;
            
                    case "next":
                        newPageNumber = currentPageNumber + 1;
                        break;
            
                    case "last":
                        newPageNumber = totalPages;
                        break;
                }
            }
            
            if (newPageNumber < 1) newPageNumber = 1;
            if (newPageNumber > totalPages) newPageNumber = totalPages;
            
            var hasPreviousPage = newPageNumber > 1;
            var hasNextPage = newPageNumber < totalPages;
            
            _applyListPaginationState(listState, newPageNumber, totalPages, pageSize, hasPreviousPage, hasNextPage);
            
            triggerListRefresh(pageName, listName, listState);
        }
        
        function resetListState(pageName, listName, resetSearch, resetOrder, resetPagination) {
    
            var listSchema = _getListSchema(pageName, listName);
            if (!listSchema) throw "Could not obtain list \"" + listName + "\" on page \"" + pageName + "\"";
    
            var listState = getListState(pageName, listName);
            if (!listState) return;
            
            if (resetSearch) {
                delete listState.search;
            }
            if (resetOrder) {
                delete listState.order;
            }
            if (resetPagination) {
                delete listState.pagination;
            }
    
            triggerListRefresh(pageName, listName, listState);
        }
        
        function triggerListRefresh(pageName, listName, listState) {
    
            _setListState(pageName, listName, listState);
            $rootScope.$emit("UpdateList_" + pageName + "_" + listName);
        }
        
        // === Private functions === //
    
        function _getListSchema(pageName, listName) {
            
            if (!pageName || !listName) return null;
            
            var schema = SchemaHelper.schema;
            var page = schema.pages.filter(function (x) {
                return x.name === pageName;
            })[0];
            if (!page) return null;
            var jsonPath = "//content//*[name=\"" + listName + "\"]";
            return JSON.search(page, jsonPath, true)[0];
        }
        
        function _applyListSearchState(listState, mode, criteria, totalSearchResults) {
            
            listState = listState || {};
            
            angular.extend(listState, {
                search: {
                    mode: mode,
                    criteria: criteria,
                    totalSearchResults: totalSearchResults
                }
            });
        }
        
        function _applyListOrderState(listState, orderProperty, orderDirection) {
    
            listState = listState || {};
            
            angular.extend(listState, {
                order: {
                    property: orderProperty,
                    direction: orderDirection
                }
            });
        }
        
        function _applyListPaginationState(listState, currentPage, totalPages, pageSize, hasPreviousPage, hasNextPage) {
    
            listState = listState || {};
            
            angular.extend(listState, {
                pagination: {
                    currentPage: currentPage,
                    totalPages: totalPages,
                    pageSize: pageSize,
                    hasPreviousPage: hasPreviousPage,
                    hasNextPage: hasNextPage
                }
            });
        }
    
        function _setListState(pageName, listName, state) {
        
            var storeLocation = "$store.pages." + pageName + "." + listName;
            return StoreFactory.set(storeLocation, state);
        }
        
        return {
    
            "initializeListsForApp": initializeListsForApp,
            "calculateNumberOfPages": calculateNumberOfPages,
            "calculateVisiblePages": calculateVisiblePages,
            "getListState": getListState,
            "setListStateFromListScope": setListStateFromListScope,
            "setListSearchState": setListSearchState,
            "setListOrderState": setListOrderState,
            "setListPaginationState": setListPaginationState,
            "resetListState": resetListState,
            "triggerListRefresh": triggerListRefresh
        };
    }]);
angular.module("app.core").factory("VibrateFactory", ["Platform", "$timeout", function (Platform, $timeout) {

    var service = {
        "vibrate": vibrate,
        "vibratePattern": vibratePattern,
        "stopVibration": stopVibration
    };

    var stopVibrationCalled = false;

    function vibrate(vibrateDuration, continuous, force) {
        stopVibrationCalled = false;
        if (continuous === false) {
            if (vibrateDuration < 100) {
                vibrateDuration = 100;
            }
            vibrateFunc(vibrateDuration, force);
        } else {
            var isAndroid = Platform.getName() === "android";
            var isiOS = Platform.getName() === "ios";
            if (isiOS) {
                vibrateFunc(1, force);
                $timeout(function () {
                    if (stopVibrationCalled === false) {
                        vibrate(1, continuous, force);
                    }
                }, 400);
            } else if (isAndroid) {
                vibrateFunc(86400000, force);
            }
        }
    }

    function vibratePattern(patternArray, iterations, continuous, force) {
        if (continuous === false) {
            if (iterations < 0) {
                iterations = 0;
            }
            if (iterations === 0) {
                return;
            }
            runPattern(patternArray, 0, iterations, continuous, force);
            stopVibrationCalled = false;
        } else {
            runPattern(patternArray, 0, 0, continuous, force);
            stopVibrationCalled = false;
        }
    }

    function stopVibration() {
        navigator.vibrate(0);
        stopVibrationCalled = true;
    }

    function vibrateFunc(duration, force) {
        navigator.vibrate(duration, force);
    }

    function runPattern(patternArray, timesRun, iterations, continuous, force) {
        var isAndroid = Platform.getName() === "android";
        var isiOS = Platform.getName() === "ios";
        if (isiOS) {
            var patternArrayIterator = makeIterator(patternArray);
            loopThroughPatternIterator(patternArrayIterator, function () {
                timesRun++;
                $timeout(function () {
                    if ((continuous === true && stopVibrationCalled === false) || (continuous === false && timesRun < iterations) && stopVibrationCalled === false) {
                        runPattern(patternArray, timesRun, iterations, continuous, force);
                    }
                }, 1000);
            });
        } else if (isAndroid) {
            var patternDuration = 0;
            patternArray.forEach (function (currentValue) {
                patternDuration += parseInt(currentValue);
            });
            vibrateFunc(patternArray, force);
            $timeout(function () {
                timesRun++;
                $timeout(function () {
                    if ((continuous === true && stopVibrationCalled === false) || (continuous === false && timesRun < iterations) && stopVibrationCalled === false) {
                        runPattern(patternArray, timesRun, iterations, continuous, force);
                    }
                }, 1000);
            }, patternDuration);
        }
    }

    function makeIterator(array) {
        var nextIndex = 0;
        return {
            next: function () {
                if (nextIndex < array.length) {
                    var currentIndex = nextIndex;
                    nextIndex++;
                    return {value: array[currentIndex], done: false, index: currentIndex};
                } else {
                    return {done: true};
                }
            }
        };
    }

    function loopThroughPatternIterator(itrArray, callback) {
        var item = itrArray.next();
        if (item.done === false) {
            var isDurationOff = (item.index + 1) % 2 === 0 ? true : false;
            if (isDurationOff === true) {
                $timeout(function () {
                    loopThroughPatternIterator(itrArray, callback);
                }, parseInt(item.value));
            } else {
                vibrateFunc(parseInt(item.value));
                var isiOS = Platform.getName() === "ios";
                if (isiOS) {
                    $timeout(function () {
                        loopThroughPatternIterator(itrArray, callback);
                    }, 590);
                } else {
                    loopThroughPatternIterator(itrArray, callback);
                }
            }
        } else {
            callback();
        }
    }

    return service;
}]);

angular.module("mobile-router", ["LocalStorageModule"]);

angular.module("mobile-router").provider("RouterConfig", function () {
    this.options = {};
    this.set = function (option, value) {
        switch (option) {
            case "id":
                this.options.id = value;
                break;
            case "startPage":
                this.options.startPage = value;
                break;
            case "mode":
                switch (value) {
                    case "allin":
                    case "intelligent":
                    case "single":
                        this.options[option] = value;
                        break;
                    default:
                        // eslint-disable-next-line no-console
                        console.log("Invalid Value: An invalid value for option 'mode' was specified.");
                }
                break;
            case "animation":
                switch (value) {
                    case "off":
                    case "slide-in":
                    case "slide-out":
                    case "flip-in":
                    case "fade-in":
                    case "rotate-in-left":
                        this.options[option] = value;
                        break;
                    default:
                        // eslint-disable-next-line no-console
                        console.log("Invalid Value: An invalid value for option 'animation' was specified.");
                }
                break;
            default:
                // eslint-disable-next-line no-console
                console.log("Invalid Option: An invalid option was specified.");
        }
    };
    var self = this;
    this.$get = function () {
        return {
            options: self.options,
            set: self.set
        };
    };
});

angular.module("mobile-router").factory("RouteStack", ["localStorageService", function (localStorageService) {
    
    var MAX_STACK_LENGTH = 25;
    
    var _stackId = null;
    var _stack = [];
    
    function init(stackId) {
        
        _stackId = stackId;
        
        var storedStack = localStorageService.get(_stackId + "_stack");
        _stack = angular.fromJson(storedStack) || [];
    }
    
    function add(location) {
        
        var currentLocation = getCurrent();
        
        // don't add to the stack if it's the same page as the current one
        if (!location || location === currentLocation) return;
        
        if (location) {

            // Graham removed this line when adding one in _go in router.fct.js
            // window.cti.store.state.currentPage = location.replace("/", "");
            
            if (_stack.length >= MAX_STACK_LENGTH) {
                
                _stack.shift(); // remove earliest element in stack
            }
            
            _stack.push(location);
        }
        
        _save();
    }
    
    function remove(location) {
        
        var idx = -1;
        
        // iterate in reverse to match only the most recent instance of the location
        for (var i = _stack.length -1; i >= 0 && idx === -1; i++) {
            if (_stack[i] === location) idx = i;
        }
        
        if (idx > -1) {
            _stack.splice(idx, 1);
            _save();
        }
    }
    
    function clear() {
        
        if (_stackId) {
            
            _stack = [];
            localStorageService.remove(_stackId + "_stack");
        }
    }
    
    function getCurrent() {
        
        return _stack[_stack.length - 1]; // will return undefined if index out of bounds
    }
    
    function getPrevious() {
        
        return _stack[_stack.length - 2]; // will return undefined if index out of bounds
    }
    
    // === private functions === //
    
    function _save() {
        
        if (_stackId) {
            
            localStorageService.set(_stackId + "_stack", _stack);
        }
    }
    
    return {
        "init": init,
        "add": add,
        "remove": remove,
        "clear": clear,
        "getCurrent": getCurrent,
        "getPrevious": getPrevious
    };
    
}]);

angular.module("mobile-router").factory("Router", ["RouterConfig", "$templateCache", "$log", "$filter", "RouteStack", "$rootScope", "$timeout", "$q", "$injector", "$location", "Auth", function (RouterConfig, $templateCache, $log, $filter, RouteStack, $rootScope, $timeout, $q, $injector, $location, Auth) {

    var service = {
        routes: [],
        views: [],
        isInitialized: false,
        animate: false,
        currentPath: null,
        getCurrent: getCurrent,
        init: init,
        addRoute: addRoute,
        go: go,
        lastRoute: lastRoute,
        goPrevious: goPrevious,
        setFirstPage: setFirstPage
    };
    
    var explicitFirstPage = null;

    function clearSlashes(path) {
        return path.toString().replace(/\/$/, "").replace(/^\//, "");
    }

    function lastRoute() {
        return RouteStack.getPrevious();
    }
    
    function goPrevious() {
        
        var current = RouteStack.getCurrent();
        var previous = RouteStack.getPrevious();
        if (current && previous) {
            RouteStack.remove(current);
            go(previous);
        }
    }

    function routeExists(path) {
        for (var i = 0; i < service.routes.length; i++) {
            if (service.routes[i].path == path) {
                return true;
            }
        }
        return false;
    }

    function getCurrent() {
        return $filter("filter")(service.routes, {"path": service.currentPath}, true)[0];
    }
    
    function setFirstPage(location) {
    
        explicitFirstPage = location;
    }

    function init() {
        var path = null;
        if (RouterConfig.options.id !== undefined) {
            RouteStack.init(RouterConfig.options.id);
            var currentPath = RouteStack.getCurrent();
            if (RouterConfig.options.startPage !== undefined) {
                path = RouterConfig.options.startPage;
                executeActions(getRouteFromPath(path).actions);
            } else if (explicitFirstPage !== null) {
                path = explicitFirstPage;
                executeActions(getRouteFromPath(path).actions);
            } else if (getRouteFromPath(currentPath) !== undefined) {
                path = currentPath;
                var route = getRouteFromPath(currentPath);
                executeActions(route.actions);
            } else {
                var start = service.routes[0];
                angular.forEach(service.routes, function (route) {
                    if (route.start === true) {
                        start = route;
                    }
                });
                if (start != undefined) {
                    path = start.path;
                    executeActions(start.actions);
                } else {
                    $log.error("No first page available");
                }
            }
            if (path !== null) {
                window.location.hash = "#" + path;
                window.cti.store.state.currentPage = path.replace("/", "");
                window.dispatchEvent(new CustomEvent("hashchange"));
            }
        }
        service.isInitialized = true;
    }

    function addRoute(path, config) {
        if (path != undefined) {
            if (routeExists(path) === false) {
                var id = clearSlashes(path);
                var templateUrl = config.templateUrl ? config.templateUrl : id + ".tpl.html";
                if (config.template != undefined) {
                    $templateCache.put(templateUrl, config.template);
                }
                service.routes.push({
                    "path": path,
                    "id": id,
                    "templateUrl": templateUrl,
                    "possibilities": config.possibilities,
                    "actions": config.actions,
                    "start": config.start,
                    "auth": config.auth
                });
            } else {
                $log.error("Duplicate route names are not allowed.");
            }
        }
    }

    function getPathFromUrl() {
        var result = window.location.href.match(/#(.*)$/);
        if (result !== null) {
            return result[1];
        }
        return undefined;
    }

    function executeActions(actions) {
        if (actions !== undefined && actions.length > 0) {
            // Having to manually inject to avoid the Angular circular dependency error - THIS WILL COME BACK TO BITE US (Probably).
            var ActionFactory = $injector.get("ActionFactory");
            return ActionFactory.triggerEvent("onpageload", actions);
        } else {
            var deferred = $q.defer();
            deferred.resolve();
            return deferred.promise;
        }
    }

    function authenticate(route) {
        var deferred = $q.defer();
        if (route.auth === true) {
            Auth.authenticate().then(function () {
                deferred.resolve();
            }).catch(function (error) {
                deferred.reject(error);
            });
        } else {
            deferred.resolve();
        }
        return deferred.promise;
    }

    function go(path) {
    
        if (!$rootScope.$$phase) {
            $rootScope.$apply(_go);
        } else {
            _go();
        }
        
        function _go() {
            
            path = path || "";
    
            var route = getRouteFromPath(path);
            if (route !== undefined) {
                authenticate(route).then(function () {
                    executeActions(route.actions).then(function () {
                        window.cti.store.state.currentPage = path.replace("/", "");
                        $location.path(path);
                    });
                }).catch(function (error) {
                    $rootScope.errorMessage = error.message || error;
                    $location.path("/error");
                });
            }
        }
    }

    function getRoute(id) {
        var result = undefined;
        angular.forEach(service.routes, function (route) {
            if (result === undefined) {
                if (route.id == id) {
                    result = route;
                }
            }
        });
        return result;
    }

    function getRouteFromPath(path) {
        var result = undefined;
        angular.forEach(service.routes, function (route) {
            if (result === undefined) {
                if (route.path == path) {
                    result = route;
                }
            }
        });
        return result;
    }

    function viewExists(path) {
        var result = false;
        angular.forEach(service.views, function (view) {
            if (view.path == path) {
                result = true;
            }
        });
        return result;
    }

    function calcViews() {
        var current = getCurrent();
        if (current != undefined) {
            switch (RouterConfig.options.mode) {
                case "allin":
                    angular.forEach(service.routes, function (route) {
                        if (viewExists(route.path) === false) {
                            service.views.push(route);
                        }
                    });
                    $timeout(function () {
                        service.animate = true;
                    }, 1500);
                    break;
                case "single":
                    service.views = [current];
                    $timeout(function () {
                        service.animate = true;
                    }, 1500);
                    break;
                case "intelligent":
                default:
                    if (viewExists(current.path) === false) {
                        service.views.push(current);
                    }
                    $timeout(function () {
                        angular.forEach(current.possibilities, function (id) {
                            var route = getRoute(id);
                            if (route != undefined) {
                                if (viewExists(route.path) === false) {
                                    service.views.push(route);
                                }
                            }
                        });
                    }, 500);
                    $timeout(function () {
                        service.animate = true;
                    }, 1500);
            }
        }
    }

    function apply(path) {
        if (service.currentPath != path) {
            service.currentPath = path;
            if (path != "/error") {
                RouteStack.add(path);
            }
            calcViews();
        }
    }

    window.onhashchange = function (event) {
        if (event.newURL != event.oldURL || (event.newURL === undefined && event.oldURL === undefined)) {
            var path = getPathFromUrl();
            if (path != undefined && path != "") {
                if (!$rootScope.$$phase) {
                    $rootScope.$apply(function () {
                        apply(path);
                    });
                } else {
                    apply(path);
                }
            }
        }
    };

    return service;

}]);

angular.module("mobile-router").directive("mobileView", ["Router", "RouterConfig", "StoreFactory", "localStorageService", "$rootScope", "LoadingStatus", "$timeout", "Platform", function (Router, RouterConfig, StoreFactory, localStorageService, $rootScope, LoadingStatus, $timeout, Platform) {
    return {
        restrict: "A",
        template: [
            "<div class=\"grace-warning\" ng-if=\"$root.grace\">",
            "   This app will expire on <strong>{{$root.grace | date:'short'}}</strong></strong>",
            "</div>",
            "<div class=\"preview-bar\" ng-if=\"::$root.cancelable\">",
            "   <a href=\"javascript:void(0)\" ng-click=\"view.exit()\">",
            "       <span class=\"fa fa-arrow-circle-left\"></span> BACK",
            "   </a>",
            "   <a href=\"javascript:void(0)\" ng-click=\"view.toggle()\" class=\"drop-menu\">",
            "       <span class=\"fa fa-ellipsis-h\"></span>",
            "   </a>",
            "</div>",
            "<nav class=\"drop-menu-nav\" ng-class=\"{'open': (view.open && $root.cancelable)}\">",
            "   <a href=\"javascript:void(0)\" ng-click=\"view.reset()\">",
            "       <span class=\"fa fa-trash\"></span> Reset",
            "   </a>",
            "</nav>",
            "<div class=\"app-container\" ng-class=\"{'loading': (view.load.loading), 'cancelable': ($root.cancelable), 'grace': ($root.grace)}\">",
            "   <div class=\"loader-container alert alert-primary\">",
            "       <span ng-if=\"view.load.loading\" class=\"fa fa-spinner fa-spin\"></span> {{view.load.message | translate}}",
            "   </div>",
            "   <div ng-repeat=\"route in view.router.views\" id=\"{{::route.id}}\" page-info ng-controller=\"PageController as page\" class=\"page-container {{::view.config.options.animation}}\" ng-class=\"{'current': (view.router.currentPath == route.path), 'animate': (view.router.animate == true)}\">",
            "       <div class=\"flexbox-container\" ng-form name=\"pageForm\" md-form ng-include=\"route.templateUrl\"></div>",
            "       <div md-dom-ready=\"view.onDomReady(route)\" ng-if=\"view.router.currentPath == route.path\"></div>",
            "   </div>",
            "</div>"
        ].join(""),
        controller: function () {
            var vm = this;
            vm.router = Router;
            vm.config = RouterConfig;
            vm.load = LoadingStatus;
            vm.exit = function () {
                if ($rootScope.cancelable) {
                    var url = (localStorageService.get("cancelUrl") !== null) ? localStorageService.get("cancelUrl") : localStorageService.get("backUrl");
                    if (url !== null) {

                        // Remove temporary data introduced by the studio for preview mode
                        localStorageService.remove("backUrl");
                        localStorageService.remove("appName");

                        StoreFactory.set("env.exit", "cancel");
                        window.location.href = url;
                    }
                }
            };
            vm.open = false;
            vm.toggle = function () {
                vm.open = !vm.open;
            };
            vm.reset = function () {
                if ($rootScope.cancelable) {
                    StoreFactory.destroyAllData();
                    window.location.reload();
                }
            };
            vm.onDomReady = function (route) {

                $timeout(function () {

                    $rootScope.$emit("onPageContentLoaded", route);

                    if (Platform.getName() === "ios") {

                        // iOS hack to ensure that scrollable areas work correctly after dynamic content has been added and rendered
                        var thisViewElement = document.querySelector("#" + route.id);
                        var scrollableAreas = Array.prototype.slice.call(thisViewElement.querySelectorAll(".scrollable-item"), 0); // turn NodeList into JS array
                        scrollableAreas.forEach(function (scrollableArea) {

                            scrollableArea.classList.remove("scrollable-item-ios");
                            setTimeout(function () {
                                scrollableArea.classList.add("scrollable-item-ios");
                            }, 100);
                        });
                    }
                }, 0);
            };
        },
        controllerAs: "view"
    };
}]);

angular.module("mobile-router").directive("endOfRender", ["Router", "$log", function (Router, $log) {
    return {
        restrict: "E",
        link: function ($scope) {
            $log.log("END OF RENDER: ", $scope.route.id);
            Router.rendered = true;
        }
    };
}]);

angular
    .module("app.core")
    .factory("BaseLayerFactory", function () {
        
        function getByName(name) {
            
            if (!window.CtLayerRegistration) return null;
            
            return window.CtLayerRegistration.getInstance(name) || null;
        }
        
        return {
            "getByName": getByName
        };
    });

angular
    .module("app.core")
    .factory("IncidentLayerFactory", ["$q", "$rootScope", "$parse", "StoreFactory", "ActionFactory", function ($q, $rootScope, $parse, StoreFactory, ActionFactory) {

        var scriptDeferred;

        function load() {

            if (!scriptDeferred) {

                scriptDeferred = $q.defer();

                var s = document.createElement("script");
                s.onload = function () {
                    scriptDeferred.resolve();
                };
                s.onerror = function (e) {
                    scriptDeferred.resolve(e);
                    scriptDeferred = undefined;
                };

                if (window.___supportsNativeWebComponents) {
                    s.src = $rootScope.basedir + "web_components/collections/incident.es6.js";
                    document.head.appendChild(s);
                } else {
                    scriptDeferred.reject("Incident layer not supported on older platforms (for now)");
                }
            }

            return scriptDeferred.promise;
        }

        function init(settings) {
            
            var id = settings.name;
            var actions = settings.actions;
            var ilConfig = settings.ilConfig;
            
            var parsedConfig = StoreFactory.parse(ilConfig);
            var processedConfig = ensureValidDataTypes(parsedConfig);

            var incidentLayer = new window.CtIncidentLayer(id, processedConfig);
            if (actions && actions.length) {

                bindEventHandlers(id, incidentLayer, actions);
            }
        }
        
        function ensureValidDataTypes(config) {
            
            var integerTypes = [
                "xmpp.bot.timeout",
                "xmpp.pingInterval",
                "xmpp.pingTimeout",
                "xmpp.initTimeout",
                "xmpp.loginTimeout",
                "xmpp.maxMessageAge",
                "behaviour.incidentExpiration"
            ];
            
            integerTypes.forEach(function (x) {
                
                var getter = $parse(x);
                var setter = getter.assign;
                var currentValue = getter(config);
                if (currentValue && typeof (currentValue) !== "number") {
                    var numberValue = ~~parseInt(currentValue.toString(), 10);
                    setter(config, numberValue);
                }
            });
            
            return config;
        }

        function getByName(name) {

            return window.CtIncidentLayer.getInstance(name) || null;
        }

        function bindEventHandlers(id, incidentLayer, actions) {

            document.addEventListener("base-layer-ready:" + id, function () {

                ActionFactory.triggerEvent("incident-layer-ready", actions, {});
            });

            incidentLayer.on("login-result", function (e) {

                if (e.success) {
                    
                    var currentUser = incidentLayer.getCurrentUser();
                    var role = currentUser && currentUser.role;
                    
                    ActionFactory.triggerEvent("login", actions, {
                        
                        user: currentUser && currentUser.jid || null,
                        role: role && role.id || null
                    });
                }
            });

            incidentLayer.on("logout-result", function (e) {

                if (e.success) {
                    
                    ActionFactory.triggerEvent("logout", actions);
                }
            });

            incidentLayer.on("connection-status-change", function (e) {
                
                ActionFactory.triggerEvent("connection-status-change", actions, {
                    status: e.status
                });
            });

            incidentLayer.on("new-incident", function (e) {
                    
                ActionFactory.triggerEvent("new-incident", actions, {
                    incident: e.incident
                });
            });

            incidentLayer.on("incident-updated", function (e) {

                ActionFactory.triggerEvent("incident-updated", actions, {
                    incident: e.incident
                });
            });

            incidentLayer.on("incident-response", function (e) {

                ActionFactory.triggerEvent("incident-response", actions, {
                    incident: e.incident,
                    response: e.response
                });
            });

            incidentLayer.on("incident-severity-change", function (e) {

                ActionFactory.triggerEvent("incident-severity-change", actions, {
                    oldIncident: e.oldIncident,
                    newIncident: e.newIncident
                });
            });

            incidentLayer.on("incident-closed", function (e) {

                ActionFactory.triggerEvent("incident-closed", actions, {
                    incident: e.incident
                });
            });

            incidentLayer.on("incident-alert", function (e) {

                ActionFactory.triggerEvent("incident-alert", actions, {
                    incident: e.incident,
                    response: e.response
                });
            }, false, true); // this event should not be handled if raised during suppressed mode

            incidentLayer.on("incident-alert-dismissed", function () {

                ActionFactory.triggerEvent("incident-alert-dismissed", actions);
            }, false, true); // this event should not be handled if raised during suppressed mode
            
            incidentLayer.on("report-downloaded", function (e) {

                ActionFactory.triggerEvent("report-downloaded", actions, {
                    filePath: e.filePath,
                    report: e.report
                });
            });
        }

        return {
            "load": load,
            "init": init,
            "getByName": getByName
        };
    }]);

angular
    .module("app.core")
    .factory("PagerLayerFactory", ["$q", "$rootScope", "ActionFactory", function ($q, $rootScope, ActionFactory) {

        var scriptDeferred;

        function load() {

            if (!scriptDeferred) {

                scriptDeferred = $q.defer();

                var s = document.createElement("script");
                s.onload = function () {
                    scriptDeferred.resolve();
                };
                s.onerror = function (e) {
                    scriptDeferred.resolve(e);
                    scriptDeferred = undefined;
                };

                if (window.___supportsNativeWebComponents) {
                    s.src = $rootScope.basedir + "web_components/collections/pager.es6.js";
                    document.head.appendChild(s);
                } else {
                    scriptDeferred.reject("Pager layer not supported on older platforms (for now)");
                }
            }

            return scriptDeferred.promise;
        }

        function init(settings) {

            var copyOfSettings = angular.extend({}, settings);

            var id = copyOfSettings.name;
            var actions = copyOfSettings.actions;

            // delete properties which are not for the Incident Layer
            delete copyOfSettings["_auto_id_"];
            delete copyOfSettings["item-type"];
            delete copyOfSettings["name"];
            delete copyOfSettings["type"];
            delete copyOfSettings["str"];
            delete copyOfSettings["actions"];

            var pagerLayer = new window.CtPagerLayer(id, copyOfSettings);
            if (actions && actions.length) {

                bindEventHandlers(id, pagerLayer, actions);
            }
        }

        function getByName(name) {

            return window.CtPagerLayer.getInstance(name) || null;
        }

        function bindEventHandlers(id, pagerLayer, actions) {

            document.addEventListener("base-layer-ready:" + id, function () {

                ActionFactory.triggerEvent("pager-layer-ready", actions, {});
            });

            pagerLayer.on("connection-status-change", function (status) {

                ActionFactory.triggerEvent("connection-status-change", actions, { status: status });
            });

            pagerLayer.on("new-page-received", function (message) {

                ActionFactory.triggerEvent("new-page-received", actions, { $message: message });
            });

            pagerLayer.on("responded-to-page", function (id) {

                ActionFactory.triggerEvent("responded-to-page", actions, { id: id });
            });

            pagerLayer.on("responded-to-all-pages", function () {

                ActionFactory.triggerEvent("responded-to-all-pages", actions);
            });

            pagerLayer.on("logout-request-confirmed", function () {

                ActionFactory.triggerEvent("pager-logout-request-confirmed", actions, {});
            });

            pagerLayer.on("mute", function () {

                ActionFactory.triggerEvent("pager-mute", actions, {});
            });

            pagerLayer.on("login-result", function (e) {

                if (e.success) {

                    ActionFactory.triggerEvent("login-success", actions, e);

                } else {

                    ActionFactory.triggerEvent("login-fail", actions, e);

                }

            });

            pagerLayer.on("databases-auto-destroyed", function () {

                ActionFactory.triggerEvent("databases-auto-destroyed", actions, {});
            });

            pagerLayer.on("request-make-audio-notification", function () {

                ActionFactory.triggerEvent("request-make-audio-notification", actions, {});
            });

        }

        return {
            "load": load,
            "init": init,
            "getByName": getByName
        };
    }]);

angular
.module("app.core")
.factory("UserManagementLayerFactory", ["$q", "$rootScope", "ActionFactory", function ($q, $rootScope, ActionFactory) {

    var scriptDeferred;

    function load() {

        if (!scriptDeferred) {

            scriptDeferred = $q.defer();

            var s = document.createElement("script");
            s.onload = function () {
                scriptDeferred.resolve();
            };
            s.onerror = function (e) {
                scriptDeferred.resolve(e);
                scriptDeferred = undefined;
            };

            if (window.___supportsNativeWebComponents) {
                s.src = $rootScope.basedir + "web_components/collections/user-management.es6.js";
                document.head.appendChild(s);
            } else {
                scriptDeferred.reject("User Management layer not supported on older platforms (for now)");
            }
        }

        return scriptDeferred.promise;
    }

    function init(settings) {

        var copyOfSettings = angular.extend({}, settings);

        var id = copyOfSettings.name;
        var actions = copyOfSettings.actions;

        // delete properties which are not for the Incident Layer
        delete copyOfSettings["_auto_id_"];
        delete copyOfSettings["item-type"];
        delete copyOfSettings["name"];
        delete copyOfSettings["type"];
        delete copyOfSettings["str"];
        delete copyOfSettings["actions"];

        var userManagementLayer = new window.CtUMLayer(id, copyOfSettings);
        if (actions && actions.length) {

            bindEventHandlers(id, userManagementLayer, actions);
        }
    }

    function getByName(name) {

        return window.CtUMLayer.getInstance(name) || null;
    }

    function bindEventHandlers(id, umLayer, actions) {

        document.addEventListener("base-layer-ready:" + id, function () {

            ActionFactory.triggerEvent("user-management-layer-ready", actions, {});
        });

        umLayer.on("connection-status-change", function (status) {

            ActionFactory.triggerEvent("connection-status-change", actions, {status: status});
        });

        umLayer.on("user-authorised", function () {

            ActionFactory.triggerEvent("user-management-user-authorised", actions, {});
        });

        umLayer.on("logout-request-confirmed", function () {

            ActionFactory.triggerEvent("user-management-logout-request-confirmed", actions, {});
        });

    }

    return {
        "load": load,
        "init": init,
        "getByName": getByName
    };
}]);

angular.module("app.core").factory("ForegroundBackground", ["$log", "SchemaHelper", "ActionFactory", "StoreFactory", "LoggingFactory", function ($log, SchemaHelper, ActionFactory, StoreFactory, LoggingFactory) {

    function init() {

        StoreFactory.set("env.foreground", true);

        document.addEventListener("deviceready", function () {
            document.addEventListener("pause", onPause, false);
            document.addEventListener("resume", onResume, false);

            window.removeEventListener("blur", onPause, false);
            window.removeEventListener("focus", onResume, false);
        });

        window.addEventListener("blur", onPause, false);
        window.addEventListener("focus", onResume, false);

        function onResume() {
            LoggingFactory
                .isLoggingEnabled()
                .then(function (enabled) {
                    if (enabled === true) {
                        $log.info("App has gone foreground");
                    }
                });
            window.cti.store.state.foreground = true;
            StoreFactory.save();
            var item = SchemaHelper.getSchemaConfigItemsByItemType("onforeground");
            if (item && item.length > 0) {
                ActionFactory.triggerEvent("onforeground", item[0].actions);
            }
        }

        function onPause() {
            LoggingFactory
                .isLoggingEnabled()
                .then(function (enabled) {
                    if (enabled === true) {
                        $log.info("App has gone background");
                    }
                });
            window.cti.store.state.foreground = false;
            StoreFactory.save();
            var item = SchemaHelper.getSchemaConfigItemsByItemType("onbackground");
            if (item && item.length > 0) {
                ActionFactory.triggerEvent("onbackground", item[0].actions);
            }
        }
    }

    return {
        "init": init
    };
}]);
angular.module("app.core").factory("WcUtils", ["StoreFactory", function (StoreFactory) {
    
    /**
     * Apply attributes to the item
     * @param $element - The DOM item
     * @param attributes - An object containing attributes names and values
     * @param [applyDynamicAttributesOnly] - If true, only dyanmic (expression based) and null attribute values will be processed
     */
    function applyAttributes($element, attributes, applyDynamicAttributesOnly) {
        
        if (!$element || !$element[0]) return;
        
        if (angular.isObject(attributes) && Object.keys(attributes).length > 0) {
            
            for (var key in attributes) {
                
                if (attributes.hasOwnProperty(key) && key.indexOf("$") !== 0) {
    
                    var value = attributes[key];
                    var isDynamic = false;
                    
                    if (value === null) {
                        isDynamic = true;
                    }
                    if (typeof (value) === "string" && value.indexOf("{{") !== -1) {
                        isDynamic = true;
                        value = StoreFactory.parse(value);
                    }
                    
                    if (isDynamic || !applyDynamicAttributesOnly) {
                        
                        if (value !== "" && value !== undefined && value !== null) {
                            $element[0].setAttribute(key, value);
                        } else {
                            $element[0].removeAttribute(key);
                        }
                    }
                }
            }
        }
        
        $element[0].$$attrsHandled = true;
    }
    
    /**
     * Apply expressions to th eitem
     * @param $element - The DOM item
     * @param expressions - An object containing expressions to apply
     */
    function applyExpressions($element, expressions) {
        
        if (!$element || !$element[0]) return;
        
        if (angular.isObject(expressions) && Object.keys(expressions).length > 0) {
            
            $element[0].setAttribute("md-expressions", JSON.stringify(expressions));
        }
    }
    
    /**
     * Apply action event handlers to the item
     * @param $element - The DOM item
     * @param [includeEventDetailOnly] - true if the event should be raised passing the event detail only
     */
    function applyActionsFromSchema($element, includeEventDetailOnly) {
    
        if (!$element || !$element[0]) return;
        
        $element[0].setAttribute("md-actions", "from-schema");
        
        if (includeEventDetailOnly) {
            $element[0].setAttribute("md-actions-event-detail-only", "true");
        }
    }
    
    /**
     * Apply action event handlers via a callback to be invoked when the item is added to the dom
     * @param $element - The DOM item
     * @param callbackFactory - the name of the factory to call back into to apply actions
     */
    function applyActionsFromCallback($element, callbackFactory) {
    
        if (!$element || !$element[0]) return;
        
        $element[0].setAttribute("md-actions", "from-callback");
        $element[0].setAttribute("md-actions-callback-factory", callbackFactory);
    }
    
    return {
        applyAttributes: applyAttributes,
        applyExpressions: applyExpressions,
        applyActionsFromSchema: applyActionsFromSchema,
        applyActionsFromCallback: applyActionsFromCallback
    };
    
}]);

angular
    .module("app.core")
    .factory("ctDataGrid", ["$rootScope", "WcUtils", "SchemaHelper", "StoreFactory", "TranslationService", "DirectiveBridge", function ($rootScope, WcUtils, SchemaHelper, StoreFactory, TranslationService, DirectiveBridge) {
    
        // === DOM-based functions === //
        function buildDom(gridOrColumn, itemSchema) {
        
            switch (gridOrColumn) {
            
                case "grid":
                    return (function () {
                    
                        var $element = angular.element("<ct-data-grid id=\"" + itemSchema.name + "\" schema-source=\"" + itemSchema._auto_id_ + "\" ct-data-grid-bridge></ct-data-grid>");
                        var attributes = getAttributes($element, gridOrColumn, itemSchema);
                        WcUtils.applyAttributes($element, attributes);
                        WcUtils.applyExpressions($element, itemSchema.expressons);
                        WcUtils.applyActionsFromSchema($element, true);
                        return $element;
                    })();
            
                case "column":
                case "edit-actions-column":
                    return (function () {
                    
                        var heading = TranslationService.translate(itemSchema.heading) || "";
                        var $element = angular.element("<ct-data-col>" + heading + "</ct-data-col>");
                        var attributes = getAttributes($element, gridOrColumn, itemSchema);
                        WcUtils.applyAttributes($element, attributes);
                        return $element;
                    })();
            }
        
            return false;
        }
        
        function getAttributes($element, gridOrColumn, itemSchema) {
            
            var attributes = {};
            
            function addAttribute(key, value) {
                
                if (value === "" || value === undefined) return;
                
                attributes[key] = value;
            }
            
            switch (gridOrColumn) {
                
                case "grid":
                    (function () {
                        
                        if (itemSchema.sourceType === "remote") {
                            
                            // these attributes only apply if the data source is remote
                            addAttribute("data-source", itemSchema.dataSource);
                            addAttribute("data-source-method", itemSchema.dataSourceMethod);
                            addAttribute("data-source-page-param", itemSchema.dataSourcePageParam);
                            addAttribute("data-source-page-size-param", itemSchema.dataSourcePageSizeParam);
                            addAttribute("data-source-search-param", itemSchema.dataSourceSearchParam);
                            addAttribute("data-source-sort-column-param", itemSchema.dataSourceSortColumnParam);
                            addAttribute("data-source-sort-direction-param", itemSchema.dataSourceSortDirectionParam);
                            addAttribute("data-results-property", itemSchema.dataResultsProperty);
                            addAttribute("data-results-total-property", itemSchema.dataResultsTotalProperty);
                            addAttribute("use-local-interaction", itemSchema.useLocalInteraction);
                        }
                        
                        addAttribute("show-search", itemSchema.showSearch);
                        addAttribute("fixed-headers", itemSchema.fixedHeaders);
                        
                        var usePagination = false;
                        if (itemSchema.usePagination.indexOf("{{") === 0) {
                            var expression = itemSchema.usePagination.replace("{{", "").replace("}}", "");
                            usePagination = StoreFactory.getForElement(expression, $element);
                        } else {
                            usePagination = itemSchema.usePagination === "true";
                        }
                        
                        if (usePagination) {
                            addAttribute("page-size", itemSchema.pageSize);
                            addAttribute("show-pagination", itemSchema.showPagination);
                        } else {
                            addAttribute("page-size", null);
                            addAttribute("show-pagination", null);
                        }
                        
                        addAttribute("row-css-key", itemSchema.rowCssKey);
                        addAttribute("selection-mode", itemSchema.selectionMode);
    
                        addAttribute("class", itemSchema.classes);
                    })();
                    break;
                
                case "column":
                    (function () {
                        
                        addAttribute("key", itemSchema.key);
                        addAttribute("data-type", itemSchema.dataType);
                        
                        if (itemSchema.useDisplayKey && itemSchema.displayKey) {
                            addAttribute("display-key", itemSchema.displayKey);
                        }
                        
                        addAttribute("css-key", itemSchema.cssKey);
                        addAttribute("sortable", itemSchema.sortable);
                        addAttribute("sort", itemSchema.sort);
                        addAttribute("editable", itemSchema.editable);
                        addAttribute("width", itemSchema.width);
                        
                        addAttribute("class", itemSchema.classes);
                    })();
                    break;
                
                case "edit-actions-column":
                    (function () {
                        
                        addAttribute("data-type", "controls");
                        addAttribute("edit-button-label", TranslationService.translate(itemSchema.editButtonLabel) || "");
                        addAttribute("save-button-label", TranslationService.translate(itemSchema.saveButtonLabel) || "");
                        addAttribute("cancel-button-label", TranslationService.translate(itemSchema.cancelButtonLabel) || "");
                        addAttribute("width", itemSchema.width);
                        
                        addAttribute("class", itemSchema.classes);
                    })();
                    break;
            }
            
            return attributes;
        }
        
        // === State-based functions === //
        
        function initializeDataGridsForApp(schema) {
        
            var pages = schema.pages;
            pages.forEach(function (page) {

                var pageName = page.name;
                var dataGrids = SchemaHelper.getItems(page.content, "content", "data-grid");
                dataGrids.forEach(function (dataGrid) {

                    var dataGridName = dataGrid.name;
                    clearDataGridState(pageName, dataGridName);
                });
            });
        }
    
        function getDataGridState(pageName, dataGridName) {
        
            var storeLocation = "$store.pages." + pageName + "." + dataGridName;
            return StoreFactory.get(storeLocation);
        }
    
        function clearDataGridState(pageName, dataGridName) {
        
            var storeLocation = "$store.pages." + pageName + "." + dataGridName;
            return StoreFactory.set(storeLocation, undefined);
        }
    
        function setDataGridStateFromComponent(pageName, dataGridName, dataGridSchema, $component) {
    
            var visibleData = $component.getVisibleData();
            var searchInfo = $component.getSearch();
            var sortInfo = $component.getSort();
            var pageInfo = $component.getPage();
            
            var dataGridState = {
                numberOfItems: searchInfo.unfilteredTotalResults,
                visibleData: visibleData
            };
        
            // === Search === //
            
            var query = (searchInfo && searchInfo.query) || "";
            var totalSearchResults = (searchInfo)
                ? searchInfo.totalResults
                : undefined;
            
            _applyDataGridSearchState(dataGridState, query, totalSearchResults);
        
            // === Order === //
            
            var orderColumn = (sortInfo && sortInfo.column) || "";
            var orderDirection = (sortInfo && sortInfo.direction) || "";
            _applyDataGridOrderState(dataGridState, orderColumn, orderDirection);
        
            // === Pagination === //
            
            if (dataGridSchema.usePagination !== "false" && pageInfo) {
                
                var currentPage = pageInfo.number;
                var totalPages = pageInfo.total;
                var pageSize = pageInfo.pageSize;
                var hasPreviousPage = pageInfo.hasPrevious;
                var hasNextPage = pageInfo.hasNext;
                
                _applyDataGridPaginationState(dataGridState, currentPage, totalPages, pageSize, hasPreviousPage, hasNextPage);
            }
        
            return _setDataGridState(pageName, dataGridName, dataGridState);
        }
    
        function setDataGridSearchState(pageName, dataGridName, query) {
        
            var dataGridSchema = _getDataGridSchema(pageName, dataGridName);
            if (!dataGridSchema) throw "Could not obtain dataGrid \"" + dataGridName + "\" on page \"" + pageName + "\"";
        
            var dataGridState = getDataGridState(pageName, dataGridName);
        
            _applyDataGridSearchState(dataGridState, query, undefined);
        
            triggerDataGridRefresh(pageName, dataGridName, dataGridState);
        }
    
        function setDataGridOrderState(pageName, dataGridName, orderColumn, orderDirection) {
        
            var dataGridSchema = _getDataGridSchema(pageName, dataGridName);
            if (!dataGridSchema) throw "Could not obtain dataGrid \"" + dataGridName + "\" on page \"" + pageName + "\"";
        
            var dataGridState = getDataGridState(pageName, dataGridName);
            
            if (orderDirection === "switch") {
            
                orderDirection = (dataGridState && dataGridState.order)
                    ? (dataGridState.order.column === orderColumn)
                        ? dataGridState.order.direction === "asc"
                            ? "desc"
                            : "asc"
                        : "asc"
                    : "asc";
            }
        
            _applyDataGridOrderState(dataGridState, orderColumn, orderDirection);
        
            triggerDataGridRefresh(pageName, dataGridName, dataGridState);
        }
    
        function setDataGridPaginationState(pageName, dataGridName, pageChange) {
        
            var dataGridSchema = _getDataGridSchema(pageName, dataGridName);
            if (!dataGridSchema) throw "Could not obtain dataGrid \"" + dataGridName + "\" on page \"" + pageName + "\"";
        
            if (dataGridSchema.usePagination === "false") throw "Pagination not enabled for dataGrid \"" + dataGridName + "\" on page \"" + pageName + "\"";
        
            var dataGridState = getDataGridState(pageName, dataGridName);
        
            var newPageNumber = 1;
            var totalPages = 1;
            var pageSize = undefined;
        
            if (dataGridState && dataGridState.pagination) {
                totalPages = dataGridState.pagination.totalPages || 1;
                pageSize = dataGridState.pagination.pageSize || undefined;
            }
        
            if (!isNaN(pageChange)) {
            
                newPageNumber = pageChange;
            
            } else if (dataGridState && dataGridState.pagination) {
            
                var currentPageNumber = dataGridState.pagination.currentPage || 1;
            
                switch (pageChange) {
                
                    case "first":
                        newPageNumber = 1;
                        break;
                
                    case "prev":
                        newPageNumber = currentPageNumber - 1;
                        break;
                
                    case "next":
                        newPageNumber = currentPageNumber + 1;
                        break;
                
                    case "last":
                        newPageNumber = totalPages;
                        break;
                }
            }
        
            if (newPageNumber < 1) newPageNumber = 1;
            if (newPageNumber > totalPages) newPageNumber = totalPages;
        
            var hasPreviousPage = newPageNumber > 1;
            var hasNextPage = newPageNumber < totalPages;
        
            _applyDataGridPaginationState(dataGridState, newPageNumber, totalPages, pageSize, hasPreviousPage, hasNextPage);
        
            triggerDataGridRefresh(pageName, dataGridName, dataGridState);
        }
    
        function resetDataGridState(pageName, dataGridName, resetSearch, resetOrder, resetPagination) {
        
            var dataGridSchema = _getDataGridSchema(pageName, dataGridName);
            if (!dataGridSchema) throw "Could not obtain dataGrid \"" + dataGridName + "\" on page \"" + pageName + "\"";
        
            var dataGridState = getDataGridState(pageName, dataGridName);
            if (!dataGridState) return;
        
            if (resetSearch) {
                delete dataGridState.search;
            }
            if (resetOrder) {
                delete dataGridState.order;
            }
            if (resetPagination) {
                delete dataGridState.pagination;
            }
        
            triggerDataGridRefresh(pageName, dataGridName, dataGridState);
        }
    
        function triggerDataGridRefresh(pageName, dataGridName, dataGridState) {
        
            _setDataGridState(pageName, dataGridName, dataGridState);
            $rootScope.$emit("UpdateDataGrid_" + pageName + "_" + dataGridName);
        }
    
        function startEditMode(pageName, dataGridName, items, indexes) {
    
            var dataGridSchema = _getDataGridSchema(pageName, dataGridName);
            if (!dataGridSchema) throw "Could not obtain dataGrid \"" + dataGridName + "\" on page \"" + pageName + "\"";
            
            var api = DirectiveBridge.getItemApi(pageName, dataGridName);
            if (api) {
                
                switch (items) {
                    
                    case "selected":
                        var editIndexes = angular.copy(indexes);
                        if (!angular.isArray(editIndexes)) {
                            editIndexes = [editIndexes];
                        }
                        if (_allItemsAreNumbers(editIndexes)) {
                            api.editIndexes(editIndexes);
                        } else {
                            throw "Invalid value of indexes: " + indexes;
                        }
                        break;
                        
                    case "all":
                        api.editAll();
                        break;
                        
                    default:
                        throw "Unknown items selection: " + items;
                }
            }
        }
        
        function finishEditMode(pageName, dataGridName) {
    
            var dataGridSchema = _getDataGridSchema(pageName, dataGridName);
            if (!dataGridSchema) throw "Could not obtain dataGrid \"" + dataGridName + "\" on page \"" + pageName + "\"";
            
            var api = DirectiveBridge.getItemApi(pageName, dataGridName);
            if (api) {
        
                return api.finishedEdit();
            }
            
            return [];
        }
    
        // === Private functions === //
    
        function _getDataGridSchema(pageName, dataGridName) {
        
            if (!pageName || !dataGridName) return null;
        
            var schema = SchemaHelper.schema;
            var page = schema.pages.filter(function (x) {
                return x.name === pageName;
            })[0];
            if (!page) return null;
            var jsonPath = "//content//*[name=\"" + dataGridName + "\"]";
            return JSON.search(page, jsonPath, true)[0];
        }
    
        function _applyDataGridSearchState(dataGridState, query, totalSearchResults) {
        
            angular.extend(dataGridState, {
                search: {
                    query: query,
                    totalSearchResults: totalSearchResults
                }
            });
        }
    
        function _applyDataGridOrderState(dataGridState, orderProperty, orderDirection) {
        
            angular.extend(dataGridState, {
                order: {
                    column: orderProperty,
                    direction: orderDirection
                }
            });
        }
    
        function _applyDataGridPaginationState(dataGridState, currentPage, totalPages, pageSize, hasPreviousPage, hasNextPage) {
            
            angular.extend(dataGridState, {
                pagination: {
                    currentPage: currentPage,
                    totalPages: totalPages,
                    pageSize: pageSize,
                    hasPreviousPage: hasPreviousPage,
                    hasNextPage: hasNextPage
                }
            });
        }
    
        function _setDataGridState(pageName, dataGridName, state) {
    
            var storeLocation = "$store.pages." + pageName + "." + dataGridName;
            return StoreFactory.set(storeLocation, state);
        }
        
        function _allItemsAreNumbers(array) {
            
            var includesNonNumbers = array.some(function (x) {
                return (typeof (x) !== "number");
            });
            
            return !includesNonNumbers;
        }
        
        return {
            "buildDom": buildDom,
            "getAttributes": getAttributes,
            "initializeDataGridsForApp": initializeDataGridsForApp,
            "getDataGridState": getDataGridState,
            "setDataGridStateFromComponent": setDataGridStateFromComponent,
            "setDataGridSearchState": setDataGridSearchState,
            "setDataGridOrderState": setDataGridOrderState,
            "setDataGridPaginationState": setDataGridPaginationState,
            "resetDataGridState": resetDataGridState,
            "triggerDataGridRefresh": triggerDataGridRefresh,
            "startEditMode": startEditMode,
            "finishEditMode": finishEditMode
        };
    }]);
angular.module("app.core").directive("ctDataGridBridge", ["$rootScope", "$log", "StoreFactory", "ActionFactory", "WcUtils", "DirectiveBridge", "ctDataGrid", function ($rootScope, $log, StoreFactory, ActionFactory, WcUtils, DirectiveBridge, ctDataGrid) {
    return {
        "restrict": "A",
        "scope": true,
        "require": ["?^mdContextProvider", "^pageInfo"],
        "link": function ($scope, $element, $attrs, $ctrls) {
            
            var $instance = $element[0];
            
            var mdContextProviderCtrl = $ctrls[0];
            var pageInfoCtrl = $ctrls[1];
    
            var pageName = pageInfoCtrl.name;
            var dataGridName = $scope._schema.name;
            
            var initialStateApplied = false;
            
            if ($scope._schema.sourceType === "static" && $scope._schema.data) {
                
                $instance.addEventListener("ready", function () {
                    
                    var dataObject = null;
                    try {
                        dataObject = JSON.parse($scope._schema.data);
                    } catch (e) {
                        $log.error("Couldn't parse static data for grid:", e);
                    }
                    
                    if (dataObject !== null) {
    
                        applyInitialDataGridState();
                        $instance.setData(dataObject);
                    }
                });
                
            } else if ($scope._schema.sourceType === "dynamic" && $scope._schema.model) {
                
                $scope.$watch(function () {
                    return StoreFactory.getForElement($scope._schema.model, $element);
                }, function (data) {
                    if ($instance.isReady === true) {
    
                        applyInitialDataGridState();
                        $instance.setData(data);
                    }
                }, true);
                
            } else if ($scope._schema.sourceType === "remote") {
    
                applyInitialDataGridState();
            }
    
            function getStateFromStore() {
        
                return ctDataGrid.getDataGridState(pageName, dataGridName);
            }
    
            function applyInitialDataGridState() {
             
                if (!initialStateApplied) {
                    applyDataGridState();
                    initialStateApplied = true;
                }
            }
    
            function applyDataGridState() {
    
                var storedState = getStateFromStore();
                if (storedState) {
        
                    // search
                    var currentSearchInfo = $instance.getSearch();
                    if (currentSearchInfo && storedState.search) {
                        if (currentSearchInfo.query !== storedState.search.query) {
                            $instance.setSearch(storedState.search.query);
                        }
                    } else {
                        $instance.setSearch(null);
                    }
        
                    // sort
                    var currentSortInfo = $instance.getSort();
                    if (currentSortInfo && storedState.order) {
                        if (currentSortInfo.column !== storedState.order.column || currentSortInfo.direction !== storedState.order.direction) {
                            $instance.setSort(storedState.order.column, storedState.order.direction);
                        }
                    } else {
                        $instance.setSort(null);
                    }
        
                    // pagination
                    var currentPageInfo = $instance.getPage();
                    if (currentPageInfo && storedState.pagination) {
                        if (currentPageInfo.number !== storedState.pagination.currentPage) {
                            $instance.setPage(storedState.pagination.currentPage || 1);
                        }
                    } else if (currentPageInfo) {
                        $instance.setPage(null);
                    }
                }
            }
    
            function handleDataRendered() {
                
                // if this data grid is within a context provider that repeats, then do not write anything to the store
                if (mdContextProviderCtrl && mdContextProviderCtrl.isRepeaterContextProvider()) return;
        
                // write data grid state to the store
                ctDataGrid.setDataGridStateFromComponent(pageName, dataGridName, $scope._schema, $instance);
            }
    
            function handleDataChange(e) {
    
                autoSaveChangesIfApplicable(e.detail);
            }
            
            function autoSaveChangesIfApplicable(changes) {
                
                if ($scope._schema.sourceType === "dynamic" && $scope._schema.model && $scope._schema.autoSaveEdits === true) {
                    
                    if ((changes instanceof Array) === false) {
                        changes = [changes];
                    }
        
                    var dataInStore = StoreFactory.getForElement($scope._schema.model, $element);
                    changes.forEach(function (x) {
            
                        angular.extend(dataInStore[x.__idx], x.newValue);
                    });
                    StoreFactory.setForElement($scope._schema.model, dataInStore, $element, true);
                }
            }
            
            $rootScope.$on("StoreChanged", function () {
                
                var attributes = ctDataGrid.getAttributes($element, "grid", $scope._schema);
                WcUtils.applyAttributes($element, attributes, true);
            });
            
            var unsubscribe = $rootScope.$on("UpdateDataGrid_" + pageName + "_" + dataGridName, applyDataGridState);
            $instance.addEventListener("data-rendered", handleDataRendered);
            $instance.addEventListener("data-change", handleDataChange);
            
            $scope.$on("$destory", function () {
                
                unsubscribe();
                $instance.removeEventListener("data-rendered", handleDataRendered);
                $instance.removeEventListener("data-change", handleDataChange);
            });
    
            DirectiveBridge.registerItemApi(pageName, dataGridName, {
                
                editIndexes: function (indexes) {
                    
                    $instance.edit(indexes);
                },
    
                editAll: function () {
                    
                    var storedState = getStateFromStore();
                    if (storedState) {
                        var allIndexes = [];
                        for (var i = 0; i < storedState.numberOfItems || 0; i++) {
                            allIndexes.push(i);
                        }
                        $instance.edit(allIndexes);
                    }
                },
                
                finishedEdit: function () {
                    
                    var changes = $instance.finishedEdit();
    
                    autoSaveChangesIfApplicable(changes);
    
                    changes.forEach(function (x) {
    
                        ActionFactory.triggerEvent("data-change", $scope._schema.actions, x);
                    });
                    
                    return changes;
                }
            });
        }
    };
}]);

angular
    .module("app.core")
    .factory("ctCommonLoginFormFactory", ["$rootScope", "WcUtils", "ActionFactory", function ($rootScope, WcUtils, ActionFactory) {

        var TAG_NAME = "ct-login-form";

        function buildDom(itemSchema) {

            var $element = angular.element("<" + TAG_NAME + ">");
            $element.attr("id", itemSchema.name);
            $element.attr("schema-source", itemSchema._auto_id_);

            WcUtils.applyAttributes($element, getAttributes(itemSchema));
            WcUtils.applyExpressions($element, itemSchema.expressons);
            WcUtils.applyActionsFromCallback($element, "ctCommonLoginFormFactory#applyActions");

            return $element;
        }

        function getAttributes(itemSchema) {

            var attributes = {};

            function addAttribute(key, value) {

                if (value === "" || value === undefined) return;

                attributes[key] = value;
            }

            addAttribute("class", itemSchema.classes);
            addAttribute("owner", itemSchema.layer);

            addAttribute("auto-append-domain-name", itemSchema.autoAppendDomainName);
            addAttribute("username", itemSchema.username);
            addAttribute("hide-username", itemSchema.hideUsername);
            addAttribute("disable-username", itemSchema.disableUsername);

            return attributes;
        }

        function applyActions($element, actions) {

            $element[0].addEventListener("login-form-result", function (e) {

                var result = e.detail;
                if (result.success) {
                    ActionFactory.triggerEvent("login-success", actions, {});
                } else {
                    ActionFactory.triggerEvent("login-failure", actions, { exception: result.exception });
                }
            });
        }

        return {
            "buildDom": buildDom,
            "getAttributes": getAttributes,
            "applyActions": applyActions
        };
    }]);


angular
    .module("app.core")
    .factory("ctCommonOnlineIndicatorFactory", ["$rootScope", "WcUtils", function ($rootScope, WcUtils) {

        var TAG_NAME = "ct-online-indicator";

        function buildDom(itemSchema) {

            var $element = angular.element("<" + TAG_NAME + ">");
            $element.attr("id", itemSchema.name);
            $element.attr("schema-source", itemSchema._auto_id_);

            WcUtils.applyAttributes($element, getAttributes(itemSchema));
            WcUtils.applyExpressions($element, itemSchema.expressons);

            return $element;
        }

        function getAttributes(itemSchema) {

            var attributes = {};

            function addAttribute(key, value) {

                if (value === "" || value === undefined) return;

                attributes[key] = value;
            }

            addAttribute("class", itemSchema.classes);
            addAttribute("owner", itemSchema.layer);
            
            addAttribute("show-icon", itemSchema.showIcon);
            addAttribute("show-text", itemSchema.showText);

            return attributes;
        }

        return {
            "buildDom": buildDom,
            "getAttributes": getAttributes
        };
    }]);


angular
    .module("app.core")
    .factory("ctCommonUserDisplayFactory", ["$rootScope", "WcUtils", function ($rootScope, WcUtils) {

        var TAG_NAME = "ct-user-display";

        function buildDom(itemSchema) {
            
            var $element = angular.element("<" + TAG_NAME + ">");

            WcUtils.applyAttributes($element, getAttributes(itemSchema));
            WcUtils.applyExpressions($element, itemSchema.expressons);

            if (itemSchema.label) {
             
                var $labelContainer = angular.element("<div style=\"display: flex;\">");
                var $label = angular.element("<div class=\"user-display-label\"></div>");
                $label.text(itemSchema.label);
                
                $labelContainer.append($label);
                $labelContainer.append("&nbsp;");
                $labelContainer.append($element);
                
                $labelContainer.attr("id", itemSchema.name);
                $labelContainer.attr("schema-source", itemSchema._auto_id_);
                
                return $labelContainer;
                
            } else {
                
                $element.attr("id", itemSchema.name);
                $element.attr("schema-source", itemSchema._auto_id_);
            
                return $element;
            }
        }

        function getAttributes(itemSchema) {

            var attributes = {};

            function addAttribute(key, value) {

                if (value === "" || value === undefined) return;

                attributes[key] = value;
            }

            addAttribute("class", itemSchema.classes);
            addAttribute("owner", itemSchema.layer);
            
            addAttribute("show-icon", itemSchema.showIcon);

            return attributes;
        }

        return {
            "buildDom": buildDom,
            "getAttributes": getAttributes
        };
    }]);


angular
    .module("app.core")
    .factory("ctILRoleSelectionFactory", ["$rootScope", "WcUtils", "ActionFactory", function ($rootScope, WcUtils, ActionFactory) {

        var TAG_NAME = "ct-il-role-selection";

        function buildDom(itemSchema) {

            var $element = angular.element("<" + TAG_NAME + ">");
            $element.attr("id", itemSchema.name);
            $element.attr("schema-source", itemSchema._auto_id_);

            WcUtils.applyAttributes($element, getAttributes(itemSchema));
            WcUtils.applyExpressions($element, itemSchema.expressons);
            WcUtils.applyActionsFromCallback($element, "ctILRoleSelectionFactory#applyActions");

            return $element;
        }

        function getAttributes(itemSchema) {

            var attributes = {};

            function addAttribute(key, value) {

                if (value === "" || value === undefined) return;

                attributes[key] = value;
            }

            addAttribute("class", itemSchema.classes);
            addAttribute("owner", itemSchema.layer);

            return attributes;
        }

        function applyActions($element, actions) {

            $element[0].addEventListener("role-selection", function (e) {

                var result = e.detail;
                ActionFactory.triggerEvent("role-selection", actions, {
                    "role": result.role
                });
            });
        }

        return {
            "buildDom": buildDom,
            "getAttributes": getAttributes,
            "applyActions": applyActions
        };
    }]);


angular
    .module("app.core")
    .factory("ctILIncidentListFactory", ["$rootScope", "WcUtils", function ($rootScope, WcUtils) {

        var TAG_NAME = "ct-il-incident-list";

        function buildDom(itemSchema) {

            var $element = angular.element("<" + TAG_NAME + ">");
            $element.attr("id", itemSchema.name);
            $element.attr("schema-source", itemSchema._auto_id_);

            WcUtils.applyAttributes($element, getAttributes(itemSchema));
            WcUtils.applyExpressions($element, itemSchema.expressons);

            return $element;
        }

        function getAttributes(itemSchema) {

            var attributes = {};

            function addAttribute(key, value) {

                if (value === "" || value === undefined) return;

                attributes[key] = value;
            }

            addAttribute("class", itemSchema.classes);
            addAttribute("owner", itemSchema.layer);

            addAttribute("max-incidents", itemSchema.maxIncidents);
            addAttribute("max-incident-age", itemSchema.maxIncidentAge);
            addAttribute("status-filter", itemSchema.statusFilter);
            addAttribute("order-by", itemSchema.orderBy);
            addAttribute("order-by-reverse", itemSchema.orderByReverse);
            addAttribute("show-test-incidents", itemSchema.showTestIncidents);
            addAttribute("no-incidents-message", itemSchema.noIncidentsMessage);

            addAttribute("view", itemSchema.view);
            addAttribute("view-options", itemSchema.viewOptions);

            return attributes;
        }

        return {
            "buildDom": buildDom,
            "getAttributes": getAttributes
        };
    }]);


angular
    .module("app.core")
    .factory("ctILLastIncidentDisplayFactory", ["$rootScope", "WcUtils", function ($rootScope, WcUtils) {

        var TAG_NAME = "ct-il-last-incident-display";

        function buildDom(itemSchema) {

            var $element = angular.element("<" + TAG_NAME + ">");
            $element.attr("id", itemSchema.name);
            $element.attr("schema-source", itemSchema._auto_id_);

            WcUtils.applyAttributes($element, getAttributes(itemSchema));
            WcUtils.applyExpressions($element, itemSchema.expressons);

            return $element;
        }

        function getAttributes(itemSchema) {

            var attributes = {};

            function addAttribute(key, value) {

                if (value === "" || value === undefined) return;

                attributes[key] = value;
            }

            addAttribute("class", itemSchema.classes);
            addAttribute("owner", itemSchema.layer);

            addAttribute("view", itemSchema.view);
            addAttribute("view-options", itemSchema.viewOptions);

            return attributes;
        }

        return {
            "buildDom": buildDom,
            "getAttributes": getAttributes
        };
    }]);


angular
    .module("app.core")
    .factory("ctILNewIncidentButtonFactory", ["$rootScope", "WcUtils", function ($rootScope, WcUtils) {

        var TAG_NAME = "ct-il-new-incident-button";

        function buildDom(itemSchema) {

            var $element = angular.element("<" + TAG_NAME + ">");
            $element.attr("id", itemSchema.name);
            $element.attr("schema-source", itemSchema._auto_id_);
            
            if (itemSchema.labelOverride) {
                $element.text(itemSchema.labelOverride);
            }

            WcUtils.applyAttributes($element, getAttributes(itemSchema));
            WcUtils.applyExpressions($element, itemSchema.expressons);

            return $element;
        }

        function getAttributes(itemSchema) {

            var attributes = {};

            function addAttribute(key, value) {

                if (value === "" || value === undefined) return;

                attributes[key] = value;
            }

            addAttribute("class", itemSchema.classes);
            addAttribute("owner", itemSchema.layer);

            if (itemSchema.raisePredefinedIncident === true) {
                addAttribute("predefined-incident-id", itemSchema.predefinedIncidentId);
            }

            return attributes;
        }

        return {
            "buildDom": buildDom,
            "getAttributes": getAttributes
        };
    }]);


angular
    .module("app.core")
    .factory("ctILUserListFactory", ["$rootScope", "WcUtils", function ($rootScope, WcUtils) {

        var TAG_NAME = "ct-il-user-list";

        function buildDom(itemSchema) {

            var $element = angular.element("<" + TAG_NAME + ">");
            $element.attr("id", itemSchema.name);
            $element.attr("schema-source", itemSchema._auto_id_);

            WcUtils.applyAttributes($element, getAttributes(itemSchema));
            WcUtils.applyExpressions($element, itemSchema.expressons);

            return $element;
        }

        function getAttributes(itemSchema) {

            var attributes = {};

            function addAttribute(key, value) {

                if (value === "" || value === undefined) return;

                attributes[key] = value;
            }

            addAttribute("class", itemSchema.classes);
            addAttribute("owner", itemSchema.layer);

            addAttribute("view", itemSchema.view);
            addAttribute("view-options", itemSchema.viewOptions);

            return attributes;
        }

        return {
            "buildDom": buildDom,
            "getAttributes": getAttributes
        };
    }]);


angular
    .module("app.core")
    .factory("ctILReportListFactory", ["$rootScope", "WcUtils", function ($rootScope, WcUtils) {

        var TAG_NAME = "ct-il-report-list";

        function buildDom(itemSchema) {

            var $element = angular.element("<" + TAG_NAME + ">");
            $element.attr("id", itemSchema.name);
            $element.attr("schema-source", itemSchema._auto_id_);

            WcUtils.applyAttributes($element, getAttributes(itemSchema));
            WcUtils.applyExpressions($element, itemSchema.expressons);

            return $element;
        }

        function getAttributes(itemSchema) {

            var attributes = {};

            function addAttribute(key, value) {

                if (value === "" || value === undefined) return;

                attributes[key] = value;
            }

            addAttribute("class", itemSchema.classes);
            addAttribute("owner", itemSchema.layer);
            
            addAttribute("max-reports", itemSchema.maxReports);
            addAttribute("max-report-age", itemSchema.maxReportAge);
            addAttribute("own-reports-only", itemSchema.ownReportsOnly);
            addAttribute("no-reports-message", itemSchema.noReportsMessage);

            addAttribute("view", itemSchema.view);
            addAttribute("view-options", itemSchema.viewOptions);

            return attributes;
        }

        return {
            "buildDom": buildDom,
            "getAttributes": getAttributes
        };
    }]);


angular
    .module("app.core")
    .factory("ctPGListFactory", ["$rootScope", "WcUtils", function ($rootScope, WcUtils) {

        var TAG_NAME = "ct-pg-list";

        function buildDom(itemSchema) {

            var $element = angular.element("<" + TAG_NAME + ">");
            $element.attr("id", itemSchema.name);
            $element.attr("schema-source", itemSchema._auto_id_);

            WcUtils.applyAttributes($element, getAttributes(itemSchema));
            WcUtils.applyExpressions($element, itemSchema.expressons);

            return $element;
        }

        function getAttributes(itemSchema) {

            var attributes = {};

            function addAttribute(key, value) {

                if (value === "" || value === undefined) return;

                attributes[key] = value;
            }

            addAttribute("class", itemSchema.classes);
            addAttribute("owner", itemSchema.layer);
            addAttribute("enable-touch-features", itemSchema.enableTouchFeatures);

            return attributes;
        }

        return {
            "buildDom": buildDom,
            "getAttributes": getAttributes
        };
    }]);


angular
.module("app.core")
.factory("ctUMListFactory", ["$rootScope", "WcUtils", function ($rootScope, WcUtils) {

    var TAG_NAME = "ct-um-list";

    function buildDom(itemSchema) {

        var $element = angular.element("<" + TAG_NAME + ">");
        $element.attr("id", itemSchema.name);
        $element.attr("schema-source", itemSchema._auto_id_);

        WcUtils.applyAttributes($element, getAttributes(itemSchema));
        WcUtils.applyExpressions($element, itemSchema.expressons);

        return $element;
    }

    function getAttributes(itemSchema) {

        var attributes = {};

        function addAttribute(key, value) {

            if (value === "" || value === undefined) return;

            attributes[key] = value;
        }

        addAttribute("class", itemSchema.classes);
        addAttribute("owner", itemSchema.layer);
        addAttribute("type", itemSchema.listType);

        return attributes;
    }

    return {
        "buildDom": buildDom,
        "getAttributes": getAttributes
    };
}]);


(function () {
    
    // May need to change these
    var _deviceReadyTimeout = 5000;
    var _provisioning = null;
    var _isFromStudio = false;
    var _isDevice = window.cordova !== false;
    var _deviceReady = false;
    var _popupActive = false;
    
    var $q = angular.injector(["ng"]).get("$q");
    var basePath = "./";
    
    function prepareBootstrapping() {
        
        if (document.head.getAttribute("data-is-client") === "true" && document.URL.indexOf("file://") !== -1) {
            
            basePath = "./client/";
        }
        
        var appName = localStorage.getItem("appName");
        _isFromStudio = (appName !== undefined && appName !== null);
        
        if (_isDevice) {
            
            document.addEventListener("deviceready", bootstrapProvisioningPlugin, false);
            
            setTimeout(function () {
                // if deviceready was never called, force the app to load
                if (!_deviceReady) {
                    // eslint-disable-next-line no-console
                    console.error("deviceready was not fired");
                    bootstrapApp();
                }
            }, _deviceReadyTimeout);
            
        } else {
            
            bootstrapApp();
        }
    }
    
    // === Provisioning === //
    
    function bootstrapProvisioningPlugin() {
        
        _deviceReady = true;
        
        // if not from the studio and
        // the plugins object is available and the plugin we want is available
        if (!_isFromStudio && window.plugins !== undefined && window.plugins !== null && window.plugins.provisioning !== undefined && window.plugins.provisioning !== null) {
            
            _provisioning = window.plugins.provisioning;
            document.addEventListener("updateavailable", onProvisioningUpdateAvailable, false);
            bootstrapApp();
            
        } else {
            
            bootstrapApp();
        }
    }
    
    function onProvisioningUpdateAvailable(event) {
        
        function install() {
            
            _provisioning.installVersion(function () {
                
                _provisioning.restartApplication(function () {
                
                }, function () {
                    // eslint-disable-next-line no-console
                    console.error("Provisioning failed to restart and install new version");
                });
                
            }, function () {
                
                // eslint-disable-next-line no-console
                console.error("Provisioning failed to update");
                
            }, { "version": event.detail.version });
        }
        
        function postpone() {
            
            // eslint-disable-next-line no-console
            console.info("Update postponed.");
        }
        
        popupConfirmation(event, install, postpone);
    }
    
    function popupConfirmation(event, successCallback, dismissCallback) {
        
        if (!_popupActive) {
            
            _popupActive = true;
            
            document.querySelectorAll("#version-modal .version-number")[0].innerText = event.detail.version;
            var versionModal = document.getElementById("version-modal");
            versionModal.style.display = "block";
            
            document.querySelectorAll("#version-modal .confirm-button")[0].addEventListener("click", function () {
                _popupActive = false;
                versionModal.style.display = "none";
                if (successCallback !== undefined) {
                    successCallback();
                }
            });
            
            document.querySelectorAll("#version-modal .dismiss-button")[0].addEventListener("click", function () {
                _popupActive = false;
                versionModal.style.display = "none";
                if (dismissCallback !== undefined) {
                    dismissCallback();
                }
            });
        }
    }
    
    // === Bootstrapping === //
    
    function bootstrapApp() {
        
        $q.when()
            .then(function () {
                
                return loadPolyfills();
            })
            .then(function () {
                
                return loadWebComponents();
            })
            .then(function () {
                
                addMdAppDirective();
            });
    }
    
    // === Polyfills === //
    
    function loadPolyfills() {
        
        var deferred = $q.defer();
        
        $q.when()
            .then(function () {
                
                return loadScript("assets/js/polyfills/custom-events.js");
            })
            .then(function () {
                
                deferred.resolve();
            });
        
        return deferred.promise;
    }
    
    // === Web Components === //
    
    function loadWebComponents() {
    
        window.___supportsNativeWebComponents = (!!window.customElements && !!HTMLElement.prototype.attachShadow);
    
        var deferred = $q.defer();
    
        $q.when()
            .then(function () {
    
                return loadScriptIf(!window.___supportsNativeWebComponents, "assets/js/polyfills/web-component-polyfills.js");
            })
            .then(function () {
                
                return loadScriptIf(window.___supportsNativeWebComponents, "assets/js/skatejs/skate.es6.js");
            })
            .then(function () {
            
                return loadScriptIfElse(window.___supportsNativeWebComponents, "web_components/dist/web-components.es6.js", "web_components/dist/web-components.es5.js");
            })
            .then(function () {
            
                deferred.resolve();
            });
    
        return deferred.promise;
    }
    
    // === mdApp === //
    
    function addMdAppDirective() {
        
        var schemaFile = document.body.getAttribute("data-schema");
        var appElement = window.document.querySelectorAll("body div.view-frame")[0];
        appElement.setAttribute("md-app", "" + (_isFromStudio ? "" : (!schemaFile ? "config.json" : schemaFile)));
        /* in your js file */
        angular.element(document).ready(function () {
            angular.bootstrap(document, ["app"]);
        });
    }
    
    // === Utility functions === //
    
    // eslint-disable-next-line no-unused-vars
    function loadScript(url) {
        
        var deferred = $q.defer();
        
        var script = document.createElement("script");
        script.onload = function () {
            deferred.resolve();
        };
        script.src = basePath + url;
        document.head.appendChild(script);
        
        return deferred.promise;
    }
    
    // eslint-disable-next-line no-unused-vars
    function loadScriptIf(condition, url) {
        
        if (condition) return loadScript(url);
        
        return $q.when();
    }
    
    // eslint-disable-next-line no-unused-vars
    function loadScriptIfElse(condition, url, elseUrl) {
        
        if (condition) return loadScript(url);
        
        return loadScript(elseUrl);
    }
    
    // === Kick it all off === //
    
    document.addEventListener("DOMContentLoaded", prepareBootstrapping, false);
})();
(function(module) {
try {
  module = angular.module('app.templates');
} catch (e) {
  module = angular.module('app.templates', []);
}
module.run(['$templateCache', function($templateCache) {
  $templateCache.put('components/mdDynamicForm/mediaPlayer/audioPlayer.tpl.html',
    '<div class="audio-player" ng-class="{\'play-active\': (ap.info.state === \'running\'), \'play-idle\': (ap.info.state !== \'running\'), \'disabled\': (ap.info.state === null)}">\n' +
    '    <a class="play-button" ng-click="ap.button()" ng-disabled="ap.info.state === null">\n' +
    '        <span class="fa fa-stack fa-2x">\n' +
    '            <i id="play-background" class="fa fa-stack-2x" ng-class="{\'fa-square\': (ap.info.state === \'running\'), \'fa-circle\': (ap.info.state !== \'running\')}"></i>\n' +
    '            <i id="play-foreground" class="fa fa-stack-1x" ng-class="{\'fa-pause\': (ap.info.state === \'running\'), \'fa-play\': (ap.info.state !== \'running\')}"></i>\n' +
    '        </span>\n' +
    '    </a>\n' +
    '    <span class="current-time">{{ap.info.currentTime}}</span>\n' +
    '    <div class="timeline">\n' +
    '        <div class="filler"></div>\n' +
    '    </div>\n' +
    '    <span class="total-time">{{ap.info.totalTime}}</span>\n' +
    '    <!--<div class="loader" ng-if="ap.load === true">Loading...</div>-->\n' +
    '</div>');
}]);
})();

(function(module) {
try {
  module = angular.module('app.templates');
} catch (e) {
  module = angular.module('app.templates', []);
}
module.run(['$templateCache', function($templateCache) {
  $templateCache.put('components/mdDynamicForm/mediaPlayer/mediaPlayer.tpl.html',
    '<div class="media-player-container {{classes}}" ng-class="{\'dynamic\': (model)}">\n' +
    '    <div ng-if="itemType == \'audio\'">\n' +
    '        <audio-player name="{{name}}_player" src="{{src | trusted}}" actions="actions"></audio-player>\n' +
    '    </div>\n' +
    '    <div ng-if="itemType == \'video\'">\n' +
    '        <video type="video/mp4" ng-src="{{src | trusted}}" width="100%" controls></video>\n' +
    '    </div>\n' +
    '</div>');
}]);
})();

(function(module) {
try {
  module = angular.module('app.templates');
} catch (e) {
  module = angular.module('app.templates', []);
}
module.run(['$templateCache', function($templateCache) {
  $templateCache.put('components/mdDynamicForm/imageViewer/imageViewer.tpl.html',
    '<div class="image-viewer-container {{classes}}" ng-class="{\'dynamic\': (multiple || (image === undefined))}">\n' +
    '    <div class="image-frame" ng-if="multiple" ng-repeat="fileURI in files track by $index" ng-switch="getFileType(fileURI)">\n' +
    '        <img ng-switch-when="image" md-thumbnail="{{fileURI}}" md-thumbnail-maxwidth="200" md-thumbnail-maxheight="200" ng-click="open($index)"/>\n' +
    '        <div ng-switch-when="audio" class="media-player text-center" ng-click="open($index)"><span class="fa fa-file-audio-o fa-3x"></span><br><br><span>{{getViewableFilePath(fileURI)}}</span></div>\n' +
    '    </div>\n' +
    '    <div class="image-frame no-data" ng-if="(multiple && files.length === 0) || (!multiple && image === undefined)">\n' +
    '        <span class="fa fa-picture-o"></span>\n' +
    '        {{ \'No sources have been added.\' | translate }}\n' +
    '    </div>\n' +
    '    <img md-thumbnail="{{image | trusted}}" md-thumbnail-maxwidth="{{maxWidth}}" md-thumbnail-maxheight="{{maxHeight}}" ng-if="!multiple && image !== undefined && scaleImage" ng-click="open($index)"/>\n' +
    '    <img ng-src="{{image | trusted}}" ng-if="!multiple && image !== undefined && !scaleImage"/>\n' +
    '</div>\n' +
    '');
}]);
})();

(function(module) {
try {
  module = angular.module('app.templates');
} catch (e) {
  module = angular.module('app.templates', []);
}
module.run(['$templateCache', function($templateCache) {
  $templateCache.put('components/mdDynamicForm/imageViewer/imageViewerDisplay.tpl.html',
    '<div class="image-viewer-display-container"><div class="image-frame"><img ng-src="{{src}}" /></div><div class="image-footer"><a href="javascript:void(0)" class="danger" ng-click="delete()"><span class="fa fa-trash"></span> Delete</a><a href="javascript:void(0)" class="warning"><span class="fa fa-camera"></span> Retake</a><a href="javascript:void(0)" ng-click="close()" class="primary"><span class="fa fa-close"></span> Close</a></div></div>');
}]);
})();

(function(module) {
try {
  module = angular.module('app.templates');
} catch (e) {
  module = angular.module('app.templates', []);
}
module.run(['$templateCache', function($templateCache) {
  $templateCache.put('components/mdDynamicForm/fields/md-barcode.tpl.html',
    '<div class="barcode-group" md-actions="{{actions}}">\n' +
    '\n' +
    '    <div class="code-display" ng-if="displayValue !== false" ng-class="{\'placeholder\': (!inputModel)}">{{inputModel || \'--\'}}</div>\n' +
    '\n' +
    '    <button class="btn btn-primary btn-lg" type="button">\n' +
    '        <span ng-if="codeType === \'bar\'">\n' +
    '            <span class="fa fa-barcode"></span> {{ \'Capture Barcode\' | translate }}\n' +
    '        </span>\n' +
    '        <span ng-if="codeType === \'qr\'">\n' +
    '            <span class="fa fa-qrcode"></span> {{ \'Capture QR Code\' | translate }}\n' +
    '        </span>\n' +
    '    </button>\n' +
    '\n' +
    '    <input type="hidden" validation="{{validators}}" name="{{::name}}" id="{{::name}}" ng-model="inputModel" ng-required="required" class="form-control" />\n' +
    '</div>');
}]);
})();

(function(module) {
try {
  module = angular.module('app.templates');
} catch (e) {
  module = angular.module('app.templates', []);
}
module.run(['$templateCache', function($templateCache) {
  $templateCache.put('components/mdDynamicForm/fields/md-checkbox.tpl.html',
    '<div class="container md-checkbox-container">\n' +
    '    <div class="checkbox-element" ng-repeat="option in options track by $index" ng-class="{\'vertical\': ($parent.$parent.vertical == true)}">\n' +
    '        <div class="md-checkbox" ng-class="{ \'no-label\': !option.label, selected: (model[option.id] == true), \'md-checkbox-disabled\': disabled }"\n' +
    '             md-actions="{{ actions }}"\n' +
    '             ng-click="makeSelection(option.id)">\n' +
    '            <span class="fa" ng-class="getClasses(option)"></span>\n' +
    '            <span>{{option.label | translate}}</span>\n' +
    '        </div>\n' +
    '    </div>\n' +
    '    <input type="hidden" name="{{name}}" validation="{{validators}}" ng-required="{{required}}" ng-model="model" />\n' +
    '</div>\n' +
    '');
}]);
})();

(function(module) {
try {
  module = angular.module('app.templates');
} catch (e) {
  module = angular.module('app.templates', []);
}
module.run(['$templateCache', function($templateCache) {
  $templateCache.put('components/mdDynamicForm/fields/md-radio.tpl.html',
    '<div class="container md-checkbox-container">\n' +
    '    <div class="checkbox-element" ng-repeat="option in options track by $index">\n' +
    '        <div class="md-checkbox" ng-class="{ \'no-label\': !option.label, selected: (model == option.value), \'md-radio-disabled\': (disabled) }"\n' +
    '             md-actions="{{ actions }}"\n' +
    '             ng-click="makeSelection(option.value)">\n' +
    '            <span class="fa" ng-class="getClasses(option)"></span>\n' +
    '            <span>{{option.label | translate}}</span>\n' +
    '        </div>\n' +
    '    </div>\n' +
    '    <input type="hidden" name="{{name}}" validation="{{validators}}" ng-required="{{required}}" ng-model="model" />\n' +
    '</div>\n' +
    '');
}]);
})();

(function(module) {
try {
  module = angular.module('app.templates');
} catch (e) {
  module = angular.module('app.templates', []);
}
module.run(['$templateCache', function($templateCache) {
  $templateCache.put('components/mdDynamicForm/fields/record-audio.tpl.html',
    '<div class="{{classes}}" ng-class="{ \'audio-recorder-small\': smallrecorder, \'audio-recorder\': !smallrecorder }">\n' +
    '    <a class="record-button" ng-click="recordButton()" ng-class="{ \'record-active\': state == 2, \'record-populated\': (isPopulated && !multiple) }">\n' +
    '        <span class="fa fa-stack fa-2x">\n' +
    '            <i id="mic-background" class="fa fa-stack-2x" ng-class="multiple ? (state == 2 ? \'fa-circle\' : \'fa-circle-thin\') : (state == 2 || isPopulated ? \'fa-circle\' : \'fa-circle-thin\')"></i>\n' +
    '            <i id="mic-foreground" class="fa fa-microphone fa-stack-1x"></i>\n' +
    '        </span>\n' +
    '    </a>\n' +
    '    <div ng-if="!smallrecorder" class="current-time">\n' +
    '        {{currentTime}}\n' +
    '    </div>\n' +
    '</div>');
}]);
})();

(function(module) {
try {
  module = angular.module('app.templates');
} catch (e) {
  module = angular.module('app.templates', []);
}
module.run(['$templateCache', function($templateCache) {
  $templateCache.put('components/area/mdList/mdList.tpl.html',
    '<div id="{{:: name }}"\n' +
    '     class="md-list {{:: classes }}">\n' +
    '\n' +
    '    <div ng-if="::(search.internal || pagination.showAbove)"\n' +
    '         class="top">\n' +
    '\n' +
    '        <div ng-if="::search.internal" class="search-area">\n' +
    '\n' +
    '            <div class="search-box" ng-class="::{ \'input-group\': search.showButton }">\n' +
    '                <input type="text" class="form-control" ng-model="search.inputValue" ng-model-options="::{ debounce: { default: search.debounce, blur: 0 } }" md-on-enter="performSearch()" placeholder="{{ \'Search...\' | translate }}"/>\n' +
    '                <span ng-if="::search.showButton" class="input-group-btn">\n' +
    '                    <button class="btn btn-default" ng-click="performSearch()">\n' +
    '                        {{:: search.buttonLabel }}\n' +
    '                        <span ng-if="::search.buttonIcon" class="fa {{:: search.buttonIcon }}"></span>\n' +
    '                    </button>\n' +
    '                </span>\n' +
    '            </div>\n' +
    '\n' +
    '        </div>\n' +
    '\n' +
    '        <div ng-if="::pagination.showAbove"\n' +
    '             ng-show="pagination.visible"\n' +
    '             class="pagination-container"\n' +
    '             ng-include="\'components/area/mdList/mdListPagination.tpl.html\'">\n' +
    '        </div>\n' +
    '\n' +
    '    </div>\n' +
    '\n' +
    '    <div class="main scrollable">\n' +
    '        <ul class="md-list-items">\n' +
    '            <li md-list-item\n' +
    '                ng-repeat="$item in (filteredListData = (listData | filter:filter | orderBy:listOrder:order.reverse)) | limitTo:pagination.limit:pagination.start track by itemTrackFn($item, $index)"\n' +
    '                md-context-provider="::$item"\n' +
    '                md-context-item-collection="::listData"\n' +
    '                ng-class="itemCssClass($item, $index)">\n' +
    '            </li>\n' +
    '        </ul>\n' +
    '    </div>\n' +
    '\n' +
    '    <div ng-if="::pagination.showBelow"\n' +
    '         class="bottom">\n' +
    '\n' +
    '        <div ng-show="pagination.visible"\n' +
    '             class="pagination-container"\n' +
    '             ng-include="\'components/area/mdList/mdListPagination.tpl.html\'">\n' +
    '        </div>\n' +
    '\n' +
    '    </div>\n' +
    '\n' +
    '</div>');
}]);
})();

(function(module) {
try {
  module = angular.module('app.templates');
} catch (e) {
  module = angular.module('app.templates', []);
}
module.run(['$templateCache', function($templateCache) {
  $templateCache.put('components/area/mdList/mdListPagination.tpl.html',
    '<nav>\n' +
    '    <ul class="pagination pagination-sm">\n' +
    '        <li ng-if="::pagination.showFirstLast"\n' +
    '            class="page-first"\n' +
    '            ng-class="{ \'disabled\': pagination.currentPage === 1 }">\n' +
    '            <a ng-click="goToPage(\'first\')">\n' +
    '                <span ng-if="::pagination.firstPageIcon" class="fa {{:: pagination.firstPageIcon }}"></span>\n' +
    '                {{ pagination.firstPageLabel | translate }}\n' +
    '            </a>\n' +
    '        </li>\n' +
    '        <li ng-if="::pagination.showPrevNext"\n' +
    '            class="page-prev"\n' +
    '            ng-class="{ \'disabled\': pagination.currentPage === 1 }">\n' +
    '            <a ng-click="goToPage(\'prev\')">\n' +
    '                <span ng-if="::pagination.prevPageIcon" class="fa {{:: pagination.prevPageIcon }}"></span>\n' +
    '                {{ pagination.prevPageLabel | translate }}\n' +
    '            </a>\n' +
    '        </li>\n' +
    '        <li ng-repeat="pageNumber in pagination.visiblePages"\n' +
    '            class="numbered-page"\n' +
    '            ng-class="{ \'active\': pageNumber === pagination.currentPage }">\n' +
    '            <a ng-click="goToPage(pageNumber)">\n' +
    '                {{ pageNumber }}\n' +
    '            </a>\n' +
    '        </li>\n' +
    '        <li ng-if="::pagination.showPrevNext"\n' +
    '            class="page-next"\n' +
    '            ng-class="{ \'disabled\': pagination.currentPage === pagination.totalPages }">\n' +
    '            <a ng-click="goToPage(\'next\')">\n' +
    '                {{ pagination.nextPageLabel | translate }}\n' +
    '                <span ng-if="::pagination.nextPageIcon" class="fa {{:: pagination.nextPageIcon }}"></span>\n' +
    '            </a>\n' +
    '        </li>\n' +
    '        <li ng-if="::pagination.showFirstLast"\n' +
    '            class="page-last"\n' +
    '            ng-class="{ \'disabled\': pagination.currentPage === pagination.totalPages }">\n' +
    '            <a ng-click="goToPage(\'last\')">\n' +
    '                {{ pagination.lastPageLabel | translate }}\n' +
    '                <span ng-if="::pagination.lastPageIcon" class="fa {{:: pagination.lastPageIcon }}"></span>\n' +
    '            </a>\n' +
    '        </li>\n' +
    '    </ul>\n' +
    '</nav>');
}]);
})();

(function(module) {
try {
  module = angular.module('app.templates');
} catch (e) {
  module = angular.module('app.templates', []);
}
module.run(['$templateCache', function($templateCache) {
  $templateCache.put('bower_components/angular-strap/src/aside/aside.tpl.html',
    '<div class="aside" tabindex="-1" role="dialog">\n' +
    '  <div class="aside-dialog">\n' +
    '    <div class="aside-content">\n' +
    '      <div class="aside-header" ng-show="title">\n' +
    '        <button type="button" class="close" ng-click="$hide()">&times;</button>\n' +
    '        <h4 class="aside-title" ng-bind="title"></h4>\n' +
    '      </div>\n' +
    '      <div class="aside-body" ng-bind="content"></div>\n' +
    '      <div class="aside-footer">\n' +
    '        <button type="button" class="btn btn-default" ng-click="$hide()">Close</button>\n' +
    '      </div>\n' +
    '    </div>\n' +
    '  </div>\n' +
    '</div>\n' +
    '');
}]);
})();

(function(module) {
try {
  module = angular.module('app.templates');
} catch (e) {
  module = angular.module('app.templates', []);
}
module.run(['$templateCache', function($templateCache) {
  $templateCache.put('bower_components/angular-strap/src/alert/alert.tpl.html',
    '<div class="alert" ng-class="[type ? \'alert-\' + type : null]">\n' +
    '  <button type="button" class="close" ng-if="dismissable" ng-click="$hide()">&times;</button>\n' +
    '  <strong ng-bind="title"></strong>&nbsp;<span ng-bind-html="content"></span>\n' +
    '</div>\n' +
    '');
}]);
})();

(function(module) {
try {
  module = angular.module('app.templates');
} catch (e) {
  module = angular.module('app.templates', []);
}
module.run(['$templateCache', function($templateCache) {
  $templateCache.put('bower_components/angular-strap/src/datepicker/datepicker.tpl.html',
    '<div class="dropdown-menu datepicker" ng-class="\'datepicker-mode-\' + $mode" style="max-width: 320px;">\n' +
    '<table style="table-layout: fixed; height: 100%; width: 100%;">\n' +
    '  <thead>\n' +
    '    <tr class="text-center">\n' +
    '      <th>\n' +
    '        <button tabindex="-1" type="button" class="btn btn-default pull-left" ng-click="$selectPane(-1)">\n' +
    '          <i class="{{$iconLeft}}"></i>\n' +
    '        </button>\n' +
    '      </th>\n' +
    '      <th colspan="{{ rows[0].length - 2 }}">\n' +
    '        <button tabindex="-1" type="button" class="btn btn-default btn-block text-strong"  ng-click="$toggleMode()">\n' +
    '          <strong style="text-transform: capitalize;" ng-bind="title"></strong>\n' +
    '        </button>\n' +
    '      </th>\n' +
    '      <th>\n' +
    '        <button tabindex="-1" type="button" class="btn btn-default pull-right" ng-click="$selectPane(+1)">\n' +
    '          <i class="{{$iconRight}}"></i>\n' +
    '        </button>\n' +
    '      </th>\n' +
    '    </tr>\n' +
    '    <tr ng-show="showLabels" ng-bind-html="labels"></tr>\n' +
    '  </thead>\n' +
    '  <tbody>\n' +
    '    <tr ng-repeat="(i, row) in rows" height="{{ 100 / rows.length }}%">\n' +
    '      <td class="text-center" ng-repeat="(j, el) in row">\n' +
    '        <button tabindex="-1" type="button" class="btn btn-default" style="width: 100%" ng-class="{\'btn-primary\': el.selected, \'btn-info btn-today\': el.isToday && !el.selected}" ng-click="$select(el.date)" ng-disabled="el.disabled">\n' +
    '          <span ng-class="{\'text-muted\': el.muted}" ng-bind="el.label"></span>\n' +
    '        </button>\n' +
    '      </td>\n' +
    '    </tr>\n' +
    '  </tbody>\n' +
    '</table>\n' +
    '</div>\n' +
    '');
}]);
})();

(function(module) {
try {
  module = angular.module('app.templates');
} catch (e) {
  module = angular.module('app.templates', []);
}
module.run(['$templateCache', function($templateCache) {
  $templateCache.put('bower_components/angular-strap/src/dropdown/dropdown.tpl.html',
    '<ul tabindex="-1" class="dropdown-menu" role="menu">\n' +
    '  <li role="presentation" ng-class="{divider: item.divider}" ng-repeat="item in content" >\n' +
    '    <a role="menuitem" tabindex="-1" ng-href="{{item.href}}" ng-if="!item.divider && item.href" target="{{item.target || \'\'}}" ng-bind="item.text"></a>\n' +
    '    <a role="menuitem" tabindex="-1" href="javascript:void(0)" ng-if="!item.divider && item.click" ng-click="$eval(item.click);$hide()" ng-bind="item.text"></a>\n' +
    '  </li>\n' +
    '</ul>\n' +
    '');
}]);
})();

(function(module) {
try {
  module = angular.module('app.templates');
} catch (e) {
  module = angular.module('app.templates', []);
}
module.run(['$templateCache', function($templateCache) {
  $templateCache.put('bower_components/angular-strap/src/modal/modal.tpl.html',
    '<div class="modal" tabindex="-1" role="dialog">\n' +
    '  <div class="modal-dialog">\n' +
    '    <div class="modal-content">\n' +
    '      <div class="modal-header" ng-show="title">\n' +
    '        <button type="button" class="close" ng-click="$hide()">&times;</button>\n' +
    '        <h4 class="modal-title" ng-bind="title"></h4>\n' +
    '      </div>\n' +
    '      <div class="modal-body" ng-bind="content"></div>\n' +
    '      <div class="modal-footer">\n' +
    '        <button type="button" class="btn btn-default" ng-click="$hide()">Close</button>\n' +
    '      </div>\n' +
    '    </div>\n' +
    '  </div>\n' +
    '</div>\n' +
    '');
}]);
})();

(function(module) {
try {
  module = angular.module('app.templates');
} catch (e) {
  module = angular.module('app.templates', []);
}
module.run(['$templateCache', function($templateCache) {
  $templateCache.put('bower_components/angular-strap/src/popover/popover.tpl.html',
    '<div class="popover">\n' +
    '  <div class="arrow"></div>\n' +
    '  <h3 class="popover-title" ng-bind="title" ng-show="title"></h3>\n' +
    '  <div class="popover-content" ng-bind="content"></div>\n' +
    '</div>\n' +
    '');
}]);
})();

(function(module) {
try {
  module = angular.module('app.templates');
} catch (e) {
  module = angular.module('app.templates', []);
}
module.run(['$templateCache', function($templateCache) {
  $templateCache.put('bower_components/angular-strap/src/select/select.tpl.html',
    '<ul tabindex="-1" class="select dropdown-menu" ng-show="$isVisible()" role="select">\n' +
    '  <li ng-if="$showAllNoneButtons">\n' +
    '    <div class="btn-group" style="margin-bottom: 5px; margin-left: 5px">\n' +
    '      <button class="btn btn-default btn-xs" ng-click="$selectAll()">All</button>\n' +
    '      <button class="btn btn-default btn-xs" ng-click="$selectNone()">None</button>\n' +
    '    </div>\n' +
    '  </li>\n' +
    '  <li role="presentation" ng-repeat="match in $matches" ng-class="{active: $isActive($index)}">\n' +
    '    <a style="cursor: default;" role="menuitem" tabindex="-1" ng-click="$select($index, $event)">\n' +
    '      <i class="{{$iconCheckmark}} pull-right" ng-if="$isMultiple && $isActive($index)"></i>\n' +
    '      <span ng-bind="match.label"></span>\n' +
    '    </a>\n' +
    '  </li>\n' +
    '</ul>\n' +
    '');
}]);
})();

(function(module) {
try {
  module = angular.module('app.templates');
} catch (e) {
  module = angular.module('app.templates', []);
}
module.run(['$templateCache', function($templateCache) {
  $templateCache.put('bower_components/angular-strap/src/tab/tab.tpl.html',
    '<ul class="nav" ng-class="$navClass" role="tablist">\n' +
    '  <li ng-repeat="$pane in $panes track by $index" ng-class="$index == $panes.$active ? $activeClass : \'\'">\n' +
    '    <a role="tab" data-toggle="tab" ng-click="$setActive($index)" data-index="{{ $index }}" ng-bind-html="$pane.title"></a>\n' +
    '  </li>\n' +
    '</ul>\n' +
    '<div ng-transclude class="tab-content">\n' +
    '</div>\n' +
    '');
}]);
})();

(function(module) {
try {
  module = angular.module('app.templates');
} catch (e) {
  module = angular.module('app.templates', []);
}
module.run(['$templateCache', function($templateCache) {
  $templateCache.put('bower_components/angular-strap/src/timepicker/timepicker.tpl.html',
    '<div class="dropdown-menu timepicker" style="min-width: 0px;width: auto;">\n' +
    '<table height="100%">\n' +
    '  <thead>\n' +
    '    <tr class="text-center">\n' +
    '      <th>\n' +
    '        <button tabindex="-1" type="button" class="btn btn-default pull-left" ng-click="$arrowAction(-1, 0)">\n' +
    '          <i class="{{ $iconUp }}"></i>\n' +
    '        </button>\n' +
    '      </th>\n' +
    '      <th>\n' +
    '        &nbsp;\n' +
    '      </th>\n' +
    '      <th>\n' +
    '        <button tabindex="-1" type="button" class="btn btn-default pull-left" ng-click="$arrowAction(-1, 1)">\n' +
    '          <i class="{{ $iconUp }}"></i>\n' +
    '        </button>\n' +
    '      </th>\n' +
    '    </tr>\n' +
    '  </thead>\n' +
    '  <tbody>\n' +
    '    <tr ng-repeat="(i, row) in rows">\n' +
    '      <td class="text-center">\n' +
    '        <button tabindex="-1" style="width: 100%" type="button" class="btn btn-default" ng-class="{\'btn-primary\': row[0].selected}" ng-click="$select(row[0].date, 0)" ng-disabled="row[0].disabled">\n' +
    '          <span ng-class="{\'text-muted\': row[0].muted}" ng-bind="row[0].label"></span>\n' +
    '        </button>\n' +
    '      </td>\n' +
    '      <td>\n' +
    '        <span ng-bind="i == midIndex ? timeSeparator : \' \'"></span>\n' +
    '      </td>\n' +
    '      <td class="text-center">\n' +
    '        <button tabindex="-1" ng-if="row[1].date" style="width: 100%" type="button" class="btn btn-default" ng-class="{\'btn-primary\': row[1].selected}" ng-click="$select(row[1].date, 1)" ng-disabled="row[1].disabled">\n' +
    '          <span ng-class="{\'text-muted\': row[1].muted}" ng-bind="row[1].label"></span>\n' +
    '        </button>\n' +
    '      </td>\n' +
    '      <td ng-if="showAM">\n' +
    '        &nbsp;\n' +
    '      </td>\n' +
    '      <td ng-if="showAM">\n' +
    '        <button tabindex="-1" ng-show="i == midIndex - !isAM * 1" style="width: 100%" type="button" ng-class="{\'btn-primary\': !!isAM}" class="btn btn-default" ng-click="$switchMeridian()" ng-disabled="el.disabled">AM</button>\n' +
    '        <button tabindex="-1" ng-show="i == midIndex + 1 - !isAM * 1" style="width: 100%" type="button" ng-class="{\'btn-primary\': !isAM}" class="btn btn-default" ng-click="$switchMeridian()" ng-disabled="el.disabled">PM</button>\n' +
    '      </td>\n' +
    '    </tr>\n' +
    '  </tbody>\n' +
    '  <tfoot>\n' +
    '    <tr class="text-center">\n' +
    '      <th>\n' +
    '        <button tabindex="-1" type="button" class="btn btn-default pull-left" ng-click="$arrowAction(1, 0)">\n' +
    '          <i class="{{ $iconDown }}"></i>\n' +
    '        </button>\n' +
    '      </th>\n' +
    '      <th>\n' +
    '        &nbsp;\n' +
    '      </th>\n' +
    '      <th>\n' +
    '        <button tabindex="-1" type="button" class="btn btn-default pull-left" ng-click="$arrowAction(1, 1)">\n' +
    '          <i class="{{ $iconDown }}"></i>\n' +
    '        </button>\n' +
    '      </th>\n' +
    '    </tr>\n' +
    '  </tfoot>\n' +
    '</table>\n' +
    '</div>\n' +
    '');
}]);
})();

(function(module) {
try {
  module = angular.module('app.templates');
} catch (e) {
  module = angular.module('app.templates', []);
}
module.run(['$templateCache', function($templateCache) {
  $templateCache.put('bower_components/angular-strap/src/tooltip/tooltip.tpl.html',
    '<div class="tooltip in" ng-show="title">\n' +
    '  <div class="tooltip-arrow"></div>\n' +
    '  <div class="tooltip-inner" ng-bind="title"></div>\n' +
    '</div>\n' +
    '');
}]);
})();

(function(module) {
try {
  module = angular.module('app.templates');
} catch (e) {
  module = angular.module('app.templates', []);
}
module.run(['$templateCache', function($templateCache) {
  $templateCache.put('bower_components/angular-strap/src/typeahead/typeahead.tpl.html',
    '<ul tabindex="-1" class="typeahead dropdown-menu" ng-show="$isVisible()" role="select">\n' +
    '  <li role="presentation" ng-repeat="match in $matches" ng-class="{active: $index == $activeIndex}">\n' +
    '    <a role="menuitem" tabindex="-1" ng-click="$select($index, $event)" ng-bind="match.label"></a>\n' +
    '  </li>\n' +
    '</ul>\n' +
    '');
}]);
})();

(function(module) {
try {
  module = angular.module('app.templates');
} catch (e) {
  module = angular.module('app.templates', []);
}
module.run(['$templateCache', function($templateCache) {
  $templateCache.put('components/mdDynamicForm/fields/templates/barcode.tpl.html',
    '<take-barcode code-type="bar" ng-model="$parent.$parent.inputModel"></take-barcode>');
}]);
})();

(function(module) {
try {
  module = angular.module('app.templates');
} catch (e) {
  module = angular.module('app.templates', []);
}
module.run(['$templateCache', function($templateCache) {
  $templateCache.put('components/mdDynamicForm/fields/templates/checkbox.tpl.html',
    '<md-checkbox model="$parent.$parent.inputModel"\n' +
    '             name="name"\n' +
    '             required="required"\n' +
    '             options="options"\n' +
    '             disabled="disabled"\n' +
    '             icon-selected="{{iconSelected}}"\n' +
    '             validators="{{validators}}"\n' +
    '             actions="{{actions}}"\n' +
    '             icon-unselected="{{iconUnselected}}">\n' +
    '</md-checkbox>\n' +
    '');
}]);
})();

(function(module) {
try {
  module = angular.module('app.templates');
} catch (e) {
  module = angular.module('app.templates', []);
}
module.run(['$templateCache', function($templateCache) {
  $templateCache.put('components/mdDynamicForm/fields/templates/date.tpl.html',
    '<div ng-class="{\'input-group\': (leftIcon || rightIcon)}" >\n' +
    '    <div class="input-group-addon" ng-if="leftIcon"><span class="fa {{::leftIcon}}"></span></div>\n' +
    '    <input type="text" pick-a-date="$parent.$parent.inputModel" pick-a-date-options="options" md-actions="{{actions}}" placeholder="{{::placeholder || \'--\' | translate}}" class="form-control" ng-disabled="disabled" />\n' +
    '    <div class="input-group-addon" ng-if="rightIcon"><span class="fa {{::rightIcon}}"></span></div>\n' +
    '</div>\n' +
    '<input type="hidden" name="{{::name}}" validation="{{validators}}" ng-required="{{required}}" ng-model="$parent.$parent.inputModel" />\n' +
    '');
}]);
})();

(function(module) {
try {
  module = angular.module('app.templates');
} catch (e) {
  module = angular.module('app.templates', []);
}
module.run(['$templateCache', function($templateCache) {
  $templateCache.put('components/mdDynamicForm/fields/templates/datetime.tpl.html',
    '\n' +
    '<div class="row datetime-container">\n' +
    '    <div class="col-xs-6">\n' +
    '        <div class="input-group">\n' +
    '            <div class="input-group-addon">\n' +
    '                <span class="fa fa-calendar"></span>\n' +
    '            </div>\n' +
    '            <input type="text" validation="{{validators}}" pick-a-date date-value="$parent.$parent.inputModel" min="min" max="max" ng-model="dateModel" class="form-control" name="{{::name}}" id="{{::name}}" placeholder="{{::placeholder}}" ng-required="{{required}}" ng-disabled="disabled">\n' +
    '        </div>\n' +
    '    </div>\n' +
    '    <div class="col-xs-6">\n' +
    '        <div class="input-group">\n' +
    '            <div class="input-group-addon">\n' +
    '                <span class="fa fa-calendar"></span>\n' +
    '            </div>\n' +
    '            <input type="text" validation="{{validators}}" pick-a-time date-value="$parent.$parent.inputModel" tmin="tmin" tmax="tmax" ng-model="dateModel" class="form-control" name="{{::name}}" id="{{::name}}" placeholder="{{::placeholder}}" ng-required="{{required}}" ng-disabled="disabled">\n' +
    '        </div>\n' +
    '    </div>\n' +
    '</div>\n' +
    '\n' +
    '');
}]);
})();

(function(module) {
try {
  module = angular.module('app.templates');
} catch (e) {
  module = angular.module('app.templates', []);
}
module.run(['$templateCache', function($templateCache) {
  $templateCache.put('components/mdDynamicForm/fields/templates/email.tpl.html',
    '<div ng-class="{\'input-group\': (leftIcon || rightIcon)}">\n' +
    '    <div class="input-group-addon" ng-if="leftIcon"><span class="fa {{::leftIcon}}"></span></div>\n' +
    '    <input type="email" md-actions="{{actions}}" valid-email validation="{{validators}}" class="form-control" id="{{::name}}" name="{{::name}}" placeholder="{{::placeholder | translate}}" ng-required="{{required}}" ng-disabled="disabled" ng-model="$parent.$parent.inputModel" ng-model-options="{debounce: { \'default\': 500, \'blur\': 0 }}">\n' +
    '    <div class="input-group-addon" ng-if="rightIcon"><span class="fa {{::rightIcon}}"></span></div>\n' +
    '</div>');
}]);
})();

(function(module) {
try {
  module = angular.module('app.templates');
} catch (e) {
  module = angular.module('app.templates', []);
}
module.run(['$templateCache', function($templateCache) {
  $templateCache.put('components/mdDynamicForm/fields/templates/number.tpl.html',
    '<div ng-class="{\'input-group\': (leftIcon || rightIcon)}">\n' +
    '    <div class="input-group-addon" ng-if="leftIcon"><span class="fa {{::leftIcon}}"></span></div>\n' +
    '    <input type="number" validation="{{validators}}" md-actions="{{actions}}" min="{{min}}" max="{{max}}" class="form-control" id="{{::name}}" name="{{::name}}" placeholder="{{::placeholder | translate}}" ng-required="{{required}}" ng-disabled="disabled" ng-model="$parent.$parent.inputModel" ng-model-options="{debounce: { \'default\': 500, \'blur\': 0 }}" number-format decimal-places="{{::decimals}}" />\n' +
    '    <div class="input-group-addon" ng-if="rightIcon"><span class="fa {{::rightIcon}}"></span></div>\n' +
    '</div>\n' +
    '');
}]);
})();

(function(module) {
try {
  module = angular.module('app.templates');
} catch (e) {
  module = angular.module('app.templates', []);
}
module.run(['$templateCache', function($templateCache) {
  $templateCache.put('components/mdDynamicForm/fields/templates/password.tpl.html',
    '<div ng-class="{\'input-group\': (leftIcon || rightIcon)}">\n' +
    '    <div class="input-group-addon" ng-if="leftIcon"><span class="fa {{::leftIcon}}"></span></div>\n' +
    '    <input type="password" validation="{{validators}}" md-actions="{{actions}}" class="form-control" id="{{::name}}" name="{{::name}}" placeholder="{{::placeholder | translate}}" ng-required="{{required}}" ng-disabled="disabled" ng-model="$parent.$parent.inputModel" ng-model-options="{debounce: { \'default\': 500, \'blur\': 0 }}" />\n' +
    '    <div class="input-group-addon" ng-if="rightIcon"><span class="fa {{::rightIcon}}"></span></div>\n' +
    '</div>');
}]);
})();

(function(module) {
try {
  module = angular.module('app.templates');
} catch (e) {
  module = angular.module('app.templates', []);
}
module.run(['$templateCache', function($templateCache) {
  $templateCache.put('components/mdDynamicForm/fields/templates/photo.tpl.html',
    '<take-photo ng-model="$parent.$parent.inputModel" image-url="$parent.$parent.inputModel" quality="quality" source="source" disabled="disabled" destination="destination"></take-photo>');
}]);
})();

(function(module) {
try {
  module = angular.module('app.templates');
} catch (e) {
  module = angular.module('app.templates', []);
}
module.run(['$templateCache', function($templateCache) {
  $templateCache.put('components/mdDynamicForm/fields/templates/qrcode.tpl.html',
    '<take-barcode code-type="qr" ng-model="$parent.$parent.inputModel"></take-barcode>');
}]);
})();

(function(module) {
try {
  module = angular.module('app.templates');
} catch (e) {
  module = angular.module('app.templates', []);
}
module.run(['$templateCache', function($templateCache) {
  $templateCache.put('components/mdDynamicForm/fields/templates/radio.tpl.html',
    '<md-radio model="$parent.$parent.inputModel"\n' +
    '          name="name"\n' +
    '          required="required"\n' +
    '          options="options"\n' +
    '          disabled="disabled"\n' +
    '          icon-selected="{{iconSelected}}"\n' +
    '          validators="{{validators}}"\n' +
    '          actions="{{actions}}"\n' +
    '          icon-unselected="{{iconUnselected}}">\n' +
    '</md-radio>\n' +
    '');
}]);
})();

(function(module) {
try {
  module = angular.module('app.templates');
} catch (e) {
  module = angular.module('app.templates', []);
}
module.run(['$templateCache', function($templateCache) {
  $templateCache.put('components/mdDynamicForm/fields/templates/range-slider.tpl.html',
    '<md-range-slider name="name"\n' +
    '                 model="$parent.$parent.inputModel"\n' +
    '                 required="required"\n' +
    '                 disabled="disabled"\n' +
    '                 validators="{{validators}}"\n' +
    '                 min="{{min}}"\n' +
    '                 max="{{max}}"\n' +
    '                 step="{{step}}"\n' +
    '                 actions="actions">\n' +
    '</md-range-slider>');
}]);
})();

(function(module) {
try {
  module = angular.module('app.templates');
} catch (e) {
  module = angular.module('app.templates', []);
}
module.run(['$templateCache', function($templateCache) {
  $templateCache.put('components/mdDynamicForm/fields/templates/rating.tpl.html',
    '<div star-rating\n' +
    '     class="star-rating"\n' +
    '     rating-value="$parent.$parent.inputModel"\n' +
    '     max="max || 5"\n' +
    '     on-rating-selected="inputModel = rating; updateInputValue(rating);"\n' +
    '     actions="actions"\n' +
    '     disabled="disabled">\n' +
    '</div>\n' +
    '<input type="hidden" md-actions="{{actions}}" validation="{{validators}}" ng-model="$parent.$parent.inputModel" name="{{::name}}" ng-required="{{required}}" />\n' +
    '');
}]);
})();

(function(module) {
try {
  module = angular.module('app.templates');
} catch (e) {
  module = angular.module('app.templates', []);
}
module.run(['$templateCache', function($templateCache) {
  $templateCache.put('components/mdDynamicForm/fields/templates/recordAudio.tpl.html',
    '<record-audio name="{{name}}" model="{{key}}" label="{{label}}" small-player="smallplayer" actions="actions"></record-audio>');
}]);
})();

(function(module) {
try {
  module = angular.module('app.templates');
} catch (e) {
  module = angular.module('app.templates', []);
}
module.run(['$templateCache', function($templateCache) {
  $templateCache.put('components/mdDynamicForm/fields/templates/select.tpl.html',
    '<select ng-if="!searchable"\n' +
    '        md-select\n' +
    '        id="{{:: name }}"\n' +
    '        name="{{:: name }}"\n' +
    '        ng-model="$parent.$parent.$parent.inputModel"\n' +
    '        ng-options="option.label group by option.group for option in $parent.options track by option.value"\n' +
    '        ng-change="$parent.$parent.$parent.userInput()"\n' +
    '        ng-required="{{ required }}"\n' +
    '        ng-disabled="disabled"\n' +
    '        ng-class="{ disabled: disabled }"\n' +
    '        md-actions="{{ actions }}"\n' +
    '        validation="{{ validators }}"\n' +
    '        class="form-control">\n' +
    '    <option value="">{{ \'Please select...\' | translate }}</option>\n' +
    '</select>\n' +
    '\n' +
    '<div ng-if="searchable">\n' +
    '    <ol class="nya-bs-select"\n' +
    '        data-live-search="true"\n' +
    '        data-size="5"\n' +
    '        ng-model="$parent.$parent.$parent.inputModel"\n' +
    '        ng-disabled="disabled"\n' +
    '        md-actions="{{ actions }}">\n' +
    '        <li nya-bs-option="option in $parent.options group by option.group track by option.value">\n' +
    '            <span class="dropdown-header" ng-if="$group">{{ $group | translate }}</span>\n' +
    '            <a>{{ option.label | translate }}</a>\n' +
    '        </li>\n' +
    '    </ol>\n' +
    '    <input type="hidden" ng-model="$parent.$parent.inputModel" validation="{{validators}}" name="{{::name}}" ng-required="{{required}}"/>\n' +
    '</div>');
}]);
})();

(function(module) {
try {
  module = angular.module('app.templates');
} catch (e) {
  module = angular.module('app.templates', []);
}
module.run(['$templateCache', function($templateCache) {
  $templateCache.put('components/mdDynamicForm/fields/templates/signature.tpl.html',
    '<input type="hidden" validation="{{validators}}" name="{{::name}}" ng-model="$parent.$parent.inputModel" ng-required="{{required}}" />\n' +
    '<div class="signature-frame">\n' +
    '    <div class="canvas-frame">\n' +
    '        <canvas md-signature ng-model="$parent.$parent.inputModel" disabled="disabled" md-actions="{{actions}}"></canvas>\n' +
    '        <div class="sign-line"></div>\n' +
    '    </div>\n' +
    '    <div class="controls">\n' +
    '        <button class="btn btn-default" ng-click="$parent.$parent.inputModel = undefined;" ng-disabled="disabled">{{ \'Clear signature\' | translate }}</button>\n' +
    '    </div>\n' +
    '</div>');
}]);
})();

(function(module) {
try {
  module = angular.module('app.templates');
} catch (e) {
  module = angular.module('app.templates', []);
}
module.run(['$templateCache', function($templateCache) {
  $templateCache.put('components/mdDynamicForm/fields/templates/slider.tpl.html',
    '<md-slider name="name"\n' +
    '           model="$parent.$parent.inputModel"\n' +
    '           required="required"\n' +
    '           disabled="disabled"\n' +
    '           validators="{{validators}}"\n' +
    '           min="{{min}}"\n' +
    '           max="{{max}}"\n' +
    '           step="{{step}}"\n' +
    '           actions="actions">\n' +
    '</md-slider>');
}]);
})();

(function(module) {
try {
  module = angular.module('app.templates');
} catch (e) {
  module = angular.module('app.templates', []);
}
module.run(['$templateCache', function($templateCache) {
  $templateCache.put('components/mdDynamicForm/fields/templates/smiley.tpl.html',
    '\n' +
    '<div class="smiley-container">\n' +
    '    <a href="javascript:void(0)" class="smile" ng-class="{\'active\': ($parent.$parent.inputModel == true)}" ng-click="$parent.$parent.inputModel = true; $parent.$parent.updateStore(true)"><span class="icon icon-smile"></span></a>\n' +
    '    <a href="javascript:void(0)" class="frown" ng-class="{\'active\': ($parent.$parent.inputModel == false)}" ng-click="$parent.$parent.inputModel = false; $parent.$parent.updateStore(false)"><span class="icon icon-sad"></span></a>\n' +
    '</div>\n' +
    '<input type="hidden" validation="{{validators}}" name="{{::name}}" ng-model="$parent.$parent.inputModel" ng-required="{{required}}" />\n' +
    '');
}]);
})();

(function(module) {
try {
  module = angular.module('app.templates');
} catch (e) {
  module = angular.module('app.templates', []);
}
module.run(['$templateCache', function($templateCache) {
  $templateCache.put('components/mdDynamicForm/fields/templates/switch.tpl.html',
    '<div class="switch-container">\n' +
    '\n' +
    '    <span class="switch-text on">\n' +
    '        <span ng-show="$parent.$parent.inputModel === true">{{ onText | translate }}</span>\n' +
    '    </span>\n' +
    '\n' +
    '    <span class="switch"\n' +
    '          ng-class="{ checked: $parent.$parent.inputModel, disabled: disabled }"\n' +
    '          id="{{::name}}"\n' +
    '          name="{{::name}}">\n' +
    '\n' +
    '        <small></small>\n' +
    '\n' +
    '        <input type="checkbox"\n' +
    '               name="{{::name}}"\n' +
    '               ng-disabled="disabled"\n' +
    '               ng-model="$parent.$parent.inputModel"\n' +
    '               md-actions="{{actions}}"\n' +
    '               validation="{{validators}}"\n' +
    '               ng-required="{{required}}"\n' +
    '               style="width: 100%; height: 100%; margin: 0; opacity: 0; cursor: pointer;"\n' +
    '               class="ng-pristine ng-untouched ng-valid"\n' +
    '               ng-hide="disabled"\n' +
    '               ng-model-options="{ debounce: 0, allowInvalid: true }" />\n' +
    '\n' +
    '    </span>\n' +
    '\n' +
    '    <span class="switch-text off">\n' +
    '        <span ng-show="$parent.$parent.inputModel !== true">{{ offText | translate }}</span>\n' +
    '    </span>\n' +
    '\n' +
    '</div>');
}]);
})();

(function(module) {
try {
  module = angular.module('app.templates');
} catch (e) {
  module = angular.module('app.templates', []);
}
module.run(['$templateCache', function($templateCache) {
  $templateCache.put('components/mdDynamicForm/fields/templates/text.tpl.html',
    '<div ng-switch="multi">\n' +
    '    <div ng-switch-when="false" ng-class="{\'input-group\': (leftIcon || rightIcon)}">\n' +
    '        <div class="input-group-addon" ng-if="leftIcon"><span class="fa {{::leftIcon}}"></span></div>\n' +
    '        <input type="text" validation="{{validators}}" md-actions="{{actions}}" class="form-control" id="{{::name}}" name="{{::name}}" maxlength="{{::maxlength || undefined}}" placeholder="{{::placeholder | translate}}" ng-required="{{required}}" ng-disabled="disabled" ng-model="$parent.$parent.$parent.inputModel" ng-model-options="{debounce: { \'default\': debounce, \'blur\': 0 }}" />\n' +
    '        <div class="input-group-addon" ng-if="rightIcon"><span class="fa {{::rightIcon}}"></span></div>\n' +
    '    </div>\n' +
    '    <textarea ng-switch-when="true" class="form-control" validation="{{validators}}" md-actions="{{actions}}" id="{{::name}}" name="{{::name}}" maxlength="{{::maxlength || undefined}}" ng-attr-placeholder="{{::placeholder | translate}}" ng-required="{{required}}" ng-disabled="disabled" ng-model="$parent.$parent.$parent.inputModel" rows="3" ng-model-options="{debounce: { \'default\': debounce, \'blur\': 0 }}"></textarea>\n' +
    '</div>\n' +
    '');
}]);
})();

(function(module) {
try {
  module = angular.module('app.templates');
} catch (e) {
  module = angular.module('app.templates', []);
}
module.run(['$templateCache', function($templateCache) {
  $templateCache.put('components/mdDynamicForm/fields/templates/time.tpl.html',
    '<div ng-class="{\'input-group\': (leftIcon || rightIcon)}" id="{{::name}}">\n' +
    '    <div class="input-group-addon" ng-if="leftIcon"><span class="fa {{::leftIcon}}"></span></div>\n' +
    '    <input type="text" pick-a-time="$parent.$parent.inputModel" pick-a-time-options="options" md-actions="{{actions}}" placeholder="{{::placeholder || \'--\' | translate}}" class="form-control" ng-disabled="disabled" />\n' +
    '    <div class="input-group-addon" ng-if="rightIcon"><span class="fa {{::rightIcon}}"></span></div>\n' +
    '</div>\n' +
    '<input type="hidden" name="{{::name}}" validation="{{validators}}" ng-required="{{required}}" ng-model="$parent.$parent.inputModel" />\n' +
    '');
}]);
})();
