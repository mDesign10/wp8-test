/*! Copyright (c) 2018 CommonTime Ltd */
/*! Build date: Mon Sep 17 2018 08:41:57 GMT+0100 (BST) */
/*! ================================= */

/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 103);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var prop_1 = __webpack_require__(47);
exports.prop = prop_1.prop;
var customProps_1 = __webpack_require__(46);
exports.Stroolean = customProps_1.Stroolean;
exports.NullableNumber = customProps_1.NullableNumber;
var CTBaseComponent_1 = __webpack_require__(22);
exports.CTBaseComponent = CTBaseComponent_1.CTBaseComponent;
var CTLayerComponent_1 = __webpack_require__(44);
exports.CTLayerComponent = CTLayerComponent_1.CTLayerComponent;
var BaseLayer_1 = __webpack_require__(43);
exports.BaseLayer = BaseLayer_1.BaseLayer;
var Logger_1 = __webpack_require__(10);
exports.Logger = Logger_1.Logger;


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var ct_alert_modal_manager_1 = __webpack_require__(83);
exports.CTAlertModalManager = ct_alert_modal_manager_1.CTAlertModalManager;
var ct_alert_modal_1 = __webpack_require__(84);
exports.CTAlertModal = ct_alert_modal_1.CTAlertModal;
var ct_button_1 = __webpack_require__(28);
exports.CTButton = ct_button_1.CTButton;
var ct_file_picker_1 = __webpack_require__(86);
exports.CTFilePicker = ct_file_picker_1.CTFilePicker;
var ct_icon_1 = __webpack_require__(87);
exports.CTIcon = ct_icon_1.CTIcon;
var ct_login_form_1 = __webpack_require__(89);
exports.CTLoginForm = ct_login_form_1.CTLoginForm;
var ct_online_indicator_1 = __webpack_require__(90);
exports.CTOnlineIndicator = ct_online_indicator_1.CTOnlineIndicator;
var ct_selection_list_1 = __webpack_require__(91);
exports.CTSelectionList = ct_selection_list_1.CTSelectionList;
var ct_textbox_1 = __webpack_require__(92);
exports.CTTextbox = ct_textbox_1.CTTextbox;
var ct_user_display_1 = __webpack_require__(93);
exports.CTUserDisplay = ct_user_display_1.CTUserDisplay;
var ct_img_1 = __webpack_require__(88);
exports.CTImg = ct_img_1.CTImg;
var ct_audio_1 = __webpack_require__(85);
exports.CTAudio = ct_audio_1.CTAudio;


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var AppMode_1 = __webpack_require__(58);
exports.AppMode = AppMode_1.AppMode;
var Alert_1 = __webpack_require__(25);
exports.DefaultAlerts = Alert_1.DefaultAlerts;
var ConnectionStatus_1 = __webpack_require__(59);
exports.ConnectionStatus = ConnectionStatus_1.ConnectionStatus;
var DisconnectionStatus_1 = __webpack_require__(60);
exports.DisconnectionStatus = DisconnectionStatus_1.DisconnectionStatus;
var Icons_1 = __webpack_require__(26);
exports.Icons = Icons_1.Icons;
var RoomRole_1 = __webpack_require__(61);
exports.RoomRole = RoomRole_1.RoomRole;
var UserAdditionalDetailsType_1 = __webpack_require__(62);
exports.UserAdditionalDetailsType = UserAdditionalDetailsType_1.UserAdditionalDetailsType;


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const Moment = __webpack_require__(101);
const plugin_1 = __webpack_require__(15);
const environment_1 = __webpack_require__(14);
// tslint:disable no-any
function padLeft(value, length, char = " ") {
    let result = value;
    const lengthDiff = (length - value.length);
    if (lengthDiff > 0) {
        result = Array(lengthDiff + 1).join(char) + result;
    }
    return result;
}
exports.padLeft = padLeft;
function generateRandomSixString() {
    let firstPart = (Math.random() * 46656) | 0;
    let secondPart = (Math.random() * 46656) | 0;
    firstPart = ("000" + firstPart.toString(36)).slice(-3);
    secondPart = ("000" + secondPart.toString(36)).slice(-3);
    return firstPart + secondPart;
}
exports.generateRandomSixString = generateRandomSixString;
function tokenReplace(input, data) {
    if (!input)
        return "";
    if (data === undefined || data === null)
        return input;
    if (input.indexOf("${") === -1)
        return input;
    const getPropertyValue = (entity, propertyPath) => {
        const parts = propertyPath.split(".");
        do { } while (parts.length && (entity = entity[parts.shift()]));
        return entity;
    };
    return input.replace(/\${([^{}]*)}/g, (token, propertyPath) => {
        const replacement = getPropertyValue(data, propertyPath);
        return typeof replacement === "string" || typeof replacement === "number" ? replacement : token;
    });
}
exports.tokenReplace = tokenReplace;
function formatDate(date, format) {
    if (date === null || date === undefined)
        return "";
    return Moment(date).format(format);
}
exports.formatDate = formatDate;
function formatDateForTimeOrDate(date, includeTodayLabel = false, showSeconds = false) {
    if (date === null || date === undefined)
        return "";
    const now = Moment().date();
    const then = Moment(date).date();
    if (now !== then) {
        return formatDate(date, showSeconds ? "DD/MM/YYYY HH:mm:ss" : "DD/MM/YYYY HH:mm");
    }
    else {
        return (includeTodayLabel && "Today, " || "") + formatDate(date, showSeconds ? "HH:mm:ss" : "HH:mm");
    }
}
exports.formatDateForTimeOrDate = formatDateForTimeOrDate;
function prettyDuration(timespan) {
    // the ~~ operator here is used to floor the number, i.e. ~~24.7 === 24
    if (timespan < 1000)
        return "< 1s";
    const seconds = ~~(timespan / 1000);
    if (seconds < 60)
        return `${seconds}s`;
    const minutes = ~~(timespan / 1000 / 60);
    const remainingSeconds = ~~((timespan - (minutes * 60 * 1000)) / 1000);
    if (minutes < 60)
        return `${minutes}m` + (remainingSeconds && ` ${remainingSeconds}s` || "");
    const hours = ~~(timespan / 1000 / 60 / 60);
    const remainingMinutes = ~~((timespan - (hours * 60 * 60 * 1000)) / 1000 / 60);
    if (hours < 24)
        return `${hours}h` + (remainingMinutes && ` ${remainingMinutes}m` || "");
    const days = ~~(timespan / 1000 / 60 / 60 / 24);
    return `${days} days`;
}
exports.prettyDuration = prettyDuration;
function enumFromString(stringValue) {
    return stringValue || null;
}
exports.enumFromString = enumFromString;
function deepCloneArray(array) {
    return array.map(x => {
        if (x instanceof Array)
            return deepCloneArray(x);
        else if (typeof (x) === "object")
            return Object.assign({}, x);
        else
            return x;
    });
}
exports.deepCloneArray = deepCloneArray;
function deepCloneObject(obj) {
    return JSON.parse(JSON.stringify(obj));
}
exports.deepCloneObject = deepCloneObject;
function isObject(item) {
    return (item && typeof item === "object" && !Array.isArray(item));
}
exports.isObject = isObject;
function mergeDeep(target, ...sources) {
    if (!sources.length)
        return target;
    const source = sources.shift();
    if (isObject(target) && isObject(source)) {
        for (const key in source) {
            if (isObject(source[key])) {
                if (!target[key])
                    Object.assign(target, { [key]: {} });
                mergeDeep(target[key], source[key]);
            }
            else {
                Object.assign(target, { [key]: source[key] });
            }
        }
    }
    return mergeDeep(target, ...sources);
}
exports.mergeDeep = mergeDeep;
function getMessageType(data) {
    const messageKeys = Object.keys(data);
    return messageKeys[0] || null;
}
exports.getMessageType = getMessageType;
function getUsernameFromJid(jid) {
    if (jid.indexOf("@") > -1) {
        return jid.substring(0, jid.indexOf("@"));
    }
    else
        return jid;
}
exports.getUsernameFromJid = getUsernameFromJid;
function getVCardNameOrUsername(jid, contacts, isCurrentUser = false, vcard = null) {
    if (vcard && isCurrentUser) {
        if (vcard.name && vcard.name.given) {
            return `${vcard.name.given} ${vcard.name.family || ""}`.trim();
        }
    }
    else {
        const contact = contacts.find(x => x.jid === jid);
        if (contact) {
            if (contact.vCard &&
                contact.vCard.name &&
                contact.vCard.name.given) {
                return `${contact.vCard.name.given} ${contact.vCard.name.family || ""}`.trim();
            }
        }
    }
    return getUsernameFromJid(jid);
}
exports.getVCardNameOrUsername = getVCardNameOrUsername;
function validateVCardObject(obj) {
    return obj && Object.keys(obj).length > 0;
}
exports.validateVCardObject = validateVCardObject;
function randomNumberBetween(start, end) {
    return Math.floor(Math.random() * end) + start;
}
exports.randomNumberBetween = randomNumberBetween;
function sleep(ms) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise(resolve => {
            setTimeout(resolve, ms);
        });
    });
}
exports.sleep = sleep;
function displayImage(path) {
    return new Promise((resolve, reject) => {
        if (environment_1.isDevice()) {
            const fileEncryption = plugin_1.getSource("fileEncryption");
            if (fileEncryption) {
                fileEncryption.viewEncryptedImage(resolve, reject, path);
            }
            else {
                const fileOpener = plugin_1.getSource("fileopener");
                fileOpener.openFile(resolve, reject, path);
            }
        }
        else {
            resolve();
        }
    });
}
exports.displayImage = displayImage;
// tslint:enable no-any


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function renderIf(condition, contents) {
    return renderIfElse(condition, contents, null);
}
exports.renderIf = renderIf;
function renderIfElse(condition, contents, elseContents) {
    return (condition)
        ? contents
        : elseContents;
}
exports.renderIfElse = renderIfElse;
// tslint:disable-next-line no-any
function buildStyles(definitions) {
    const element = document.createElement("div");
    return Object.assign({}, element.style, definitions);
}
exports.buildStyles = buildStyles;
// Below has been nicely robbed from StackOverflow:
// https://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb
function hexToRgbParts(hex) {
    // Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
    const shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
    // tslint:disable-next-line no-any
    hex = hex.replace(shorthandRegex, function (m, r, g, b) {
        return r + r + g + g + b + b;
    });
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? {
        r: parseInt(result[1], 16),
        g: parseInt(result[2], 16),
        b: parseInt(result[3], 16)
    } : null;
}
function hexToRgbaString(hex) {
    const rgbParts = hexToRgbParts(hex);
    return `rgba(${rgbParts.r}, ${rgbParts.g}, ${rgbParts.b}, 1)`;
}
exports.hexToRgbaString = hexToRgbaString;
// Likwise, so has this:
// https://stackoverflow.com/questions/3942878/how-to-decide-font-color-in-white-or-black-depending-on-background-color
function decideTextColorFromBgColor(hex) {
    const rgb = hexToRgbParts(hex);
    if ((rgb.r * 0.299 + rgb.g * 0.587 + rgb.b * 0.114) > 186) {
        return "#000000";
    }
    else {
        return "#ffffff";
    }
}
exports.decideTextColorFromBgColor = decideTextColorFromBgColor;


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var BaseEventArgs_1 = __webpack_require__(12);
exports.BaseEventArgs = BaseEventArgs_1.BaseEventArgs;
var CommsEventArgs_1 = __webpack_require__(24);
exports.CommsEventArgs = CommsEventArgs_1.CommsEventArgs;
var UserActivityEventArgs_1 = __webpack_require__(51);
exports.UserActivityEventArgs = UserActivityEventArgs_1.UserActivityEventArgs;
var UserConnectionStatusEventArgs_1 = __webpack_require__(52);
exports.UserConnectionStatusEventArgs = UserConnectionStatusEventArgs_1.UserConnectionStatusEventArgs;
var RoomParticipantUpdateEventArgs_1 = __webpack_require__(50);
exports.RoomParticipantUpdateEventArgs = RoomParticipantUpdateEventArgs_1.RoomParticipantUpdateEventArgs;
var ConnectionStatusEventArgs_1 = __webpack_require__(48);
exports.ConnectionStatusEventArgs = ConnectionStatusEventArgs_1.ConnectionStatusEventArgs;
class BaseEvents {
}
// === Events to request actions to be invoked or messages to be sent === //
BaseEvents._Request_RaiseAlert = "request-raise-alert"; // raise a modal alert message
BaseEvents._Request_CloseAlert = "request-close-alert"; // close a modal alert message
BaseEvents._Request_UpdateUISuppression = "request-update-ui-suppression"; // indicate whether to suppress UI changes
BaseEvents._Request_RedrawAllUIs = "_request-redraw-all-uis"; // request that all components be redrawn
BaseEvents._Request_Logout = "request-logout"; // request that the current user be logged out
BaseEvents._Request_Component_Clear_Data = "request-component-clear-data"; // request that listening components clear their local data / state
BaseEvents._Request_ThemeChange = "request-theme-change"; // request to change the current ui colour theme
// === Events to be handled === //
BaseEvents.ConnectionStatusChange = "connection-status-change"; // raised after the current users connection status has changed
BaseEvents.OtherUserConnectionStatusChange = "other-user-connection-status-change"; // raised when another users connection status has changed
BaseEvents.CurrentUserVCardUpdate = "current-user-vcard-update";
BaseEvents.RoomParticipantUpdate = "room-participant-update"; // raised when the room participants have changed
BaseEvents.UserActivity = "user-activity"; // raised when there is any activity from the current user
BaseEvents.LoginResult = "login-result"; // raised when the user has logged in
BaseEvents.LogoutResult = "logout-result"; // raised when the user has logged out
BaseEvents.LoginFormResult = "login-form-result"; // raised when the user has logged in via the login form
exports.BaseEvents = BaseEvents;
// tslint:enable no-any


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = __webpack_require__(5);
var BasePageEventArgs_1 = __webpack_require__(65);
exports.BasePageEventArgs = BasePageEventArgs_1.BasePageEventArgs;
var ReadPageDetailEventArgs_1 = __webpack_require__(66);
exports.ReadPageDetailEventArgs = ReadPageDetailEventArgs_1.ReadPageDetailEventArgs;
var SendNewPageEventArgs_1 = __webpack_require__(67);
exports.SendNewPageEventArgs = SendNewPageEventArgs_1.SendNewPageEventArgs;
var SendPageResponseEventArgs_1 = __webpack_require__(68);
exports.SendPageResponseEventArgs = SendPageResponseEventArgs_1.SendPageResponseEventArgs;
class PagerEvents extends events_1.BaseEvents {
}
// === Events to request actions to be invoked or messages to be sent === //
PagerEvents._Request_SendNewPage = "request-send-new-page";
PagerEvents._Request_ReadPageDetail = "request-read-page-detail";
PagerEvents._Request_OpenClientReadModal = "request-open-client-read-modal";
PagerEvents._Request_OpenBroadcasterReadModal = "request-open-broadcaster-read-modal";
PagerEvents._Request_CheckForPendingPages = "request-check-for-pending-pages";
PagerEvents._Request_CloseSendNewPageModal = "request-close-send-new-page-modal";
// === Events to be handled === //
PagerEvents.NewPageReceived = "new-page-received";
PagerEvents.PageUpdate = "page-update";
PagerEvents.PageResponse = "page-response";
PagerEvents.SendingPageError = "sending-page-error";
PagerEvents.ProcessMamMessages = "process-mam-messages";
PagerEvents.ProcessMamPages = "process-mam-pages";
PagerEvents.RespondedToPage = "responded-to-page";
PagerEvents.RespondedToAllPages = "responded-to-all-pages";
PagerEvents.LogoutRequestConfirmed = "logout-request-confirmed";
PagerEvents.Mute = "mute"; // request to mute sound and stop vibration
PagerEvents.DatabasesAutoDestroyed = "databases-auto-destroyed"; // emitted when the auto destroyed database event is fired from the XMPP client
PagerEvents.RequestMakeAudioNotification = "request-make-audio-notification"; // request to infinity to make noise
exports.PagerEvents = PagerEvents;


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var DeviceType_1 = __webpack_require__(78);
exports.DeviceType = DeviceType_1.DeviceType;
var Icons_1 = __webpack_require__(27);
exports.Icons = Icons_1.Icons;
var ResponseStatus_1 = __webpack_require__(80);
exports.ResponseStatus = ResponseStatus_1.ResponseStatus;
var Contacts_1 = __webpack_require__(77);
exports.ContactResponseType = Contacts_1.ContactResponseType;
var FilterType_1 = __webpack_require__(79);
exports.FilterType = FilterType_1.FilterType;
// tslint:disable no-any
var TimerDirection;
(function (TimerDirection) {
    TimerDirection[TimerDirection["Up"] = "Up"] = "Up";
    TimerDirection[TimerDirection["Down"] = "Down"] = "Down";
})(TimerDirection = exports.TimerDirection || (exports.TimerDirection = {}));


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
// tslint:disable no-any
class BaseMessageType {
}
exports.BaseMessageType = BaseMessageType;
class BaseBotCommand {
}
exports.BaseBotCommand = BaseBotCommand;
function get(baseLayer) {
    return [];
}
exports.get = get;
var BaseHandler_1 = __webpack_require__(53);
exports.BaseHandler = BaseHandler_1.BaseHandler;
// tslint:enable no-any


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Models_1 = __webpack_require__(7);
const utils_1 = __webpack_require__(3);
const Handlers_1 = __webpack_require__(11);
const INCIDENT_RESPONSE_STATUS_ORDER = [
    Models_1.ResponseStatus.NotReceivedNotification,
    Models_1.ResponseStatus.Received,
    Models_1.ResponseStatus.Displayed,
    Models_1.ResponseStatus.Acknowledged,
    Models_1.ResponseStatus.Unable,
    Models_1.ResponseStatus.Attending
];
function getMessageType(data) {
    const messageKeys = Object.keys(data);
    if (messageKeys.length > 0) {
        const validMessageTypes = Object.values(Handlers_1.PagerMessageTypes).filter((x, idx) => idx % 2 === 0);
        // tslint:disable-next-line no-any
        return messageKeys.find(x => validMessageTypes.includes(x));
    }
    else {
        return null;
    }
}
exports.getMessageType = getMessageType;
function getResponse(contact, type) {
    const res = contact.responses.find(x => x.type === type);
    return res || null;
}
exports.getResponse = getResponse;
function convertContactsIntoAddressList(contacts) {
    const addresses = [];
    contacts.map(contact => {
        addresses.push({ type: "to", jid: contact.id });
    });
    return addresses;
}
exports.convertContactsIntoAddressList = convertContactsIntoAddressList;
function createAddressFromJid(jid) {
    return {
        type: "to",
        jid: jid
    };
}
exports.createAddressFromJid = createAddressFromJid;
function addAttachmentsToPage(message, page) {
    page.image = [];
    page.audio = [];
    page.attachmentsLoaded = true;
    message.attachments.map(x => {
        if (x.type && Object.keys(x.type).length > 1) {
            const path = (x.path || x.get);
            if (path.indexOf("http") === 0) {
                // If we've resorted to the get URL then we haven't downloaded the attachments yet
                page.attachmentsLoaded = false;
            }
            if (x.type && typeof x.type === "string" && x.type.includes("image")) {
                page.image.push(path);
            }
            else {
                page.audio.push(path);
            }
        }
    });
    return page;
}
exports.addAttachmentsToPage = addAttachmentsToPage;
function createNewPage(newPage, sender, pageType, replyTemplate) {
    return {
        _id: null,
        sender: sender,
        to: newPage.to,
        individuals: [],
        openedDate: new Date().getTime(),
        expirationDate: null,
        closedDate: null,
        pageType: pageType,
        replyTemplate: replyTemplate,
        subject: newPage.subject,
        message: newPage.message,
        messageSplit: [],
        image: newPage.image,
        audio: newPage.audio,
        attachments: (newPage.image.length > 0 || newPage.audio.length > 0),
        attachmentsLoaded: false,
        messageId: null,
        ts: null
    };
}
exports.createNewPage = createNewPage;
function convertContacts(groups, contacts, selectAll = false) {
    const selectedContacts = [];
    const selectedGroups = [];
    for (const g in groups) {
        if (groups[g].selected) {
            selectedGroups.push(groups[g]);
        }
    }
    selectedGroups.map(group => {
        const contacts = [];
        contacts.map(contact => {
            if (contact.groups.includes(group.id)) {
                if (!contact.alreadyAdded) {
                    contact.alreadyAdded = true;
                    contacts.push(contact);
                }
            }
        });
        if (contacts.length > 0) {
            selectedContacts.push({ name: group.id, contacts: contacts, displayName: group.id, isGroup: true });
        }
    });
    contacts.filter(x => x.selected === true || selectAll).map(contact => {
        if (!contact.alreadyAdded) {
            if (!contact.responses)
                contact.responses = [];
            selectedContacts.push({ name: contact.id, contacts: [contact], displayName: getNameFromContact(contact), isGroup: false });
        }
    });
    return selectedContacts;
}
exports.convertContacts = convertContacts;
function parseMessageContent(content) {
    const splitLines = content.split(/\r?\n/);
    const assembledLines = splitLines.filter(x => x !== "");
    return assembledLines;
}
exports.parseMessageContent = parseMessageContent;
function getNameFromContact(contact) {
    let name = utils_1.getUsernameFromJid(contact.id);
    if (utils_1.validateVCardObject(contact.vCard)) {
        if (utils_1.validateVCardObject(contact.vCard.name)) {
            if (contact.vCard.name.given) {
                name = `${contact.vCard.name.given || ""} ${contact.vCard.name.family || ""}`.trim();
            }
        }
    }
    return name;
}
exports.getNameFromContact = getNameFromContact;


/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = __webpack_require__(3);
// tslint:disable no-any
// tslint:disable no-console
var LoggerTypes;
(function (LoggerTypes) {
    LoggerTypes[LoggerTypes["Connectivity"] = "connectivity"] = "Connectivity";
    LoggerTypes[LoggerTypes["MessageSent"] = "message-sent"] = "MessageSent";
    LoggerTypes[LoggerTypes["MessageReceived"] = "message-received"] = "MessageReceived";
    LoggerTypes[LoggerTypes["MessageUpdated"] = "message-updated"] = "MessageUpdated";
    LoggerTypes[LoggerTypes["MessageChatMarker"] = "message-chat-marker"] = "MessageChatMarker";
    LoggerTypes[LoggerTypes["IQSent"] = "iq-sent"] = "IQSent";
    LoggerTypes[LoggerTypes["ProcessingReceived"] = "processing-received"] = "ProcessingReceived";
    LoggerTypes[LoggerTypes["ProcessingUpdated"] = "processing-updated"] = "ProcessingUpdated";
    LoggerTypes[LoggerTypes["ProcessingChatMarker"] = "processing-chat-marker"] = "ProcessingChatMarker";
    LoggerTypes[LoggerTypes["Status"] = "status"] = "Status";
    LoggerTypes[LoggerTypes["Presence"] = "presence"] = "Presence";
    LoggerTypes[LoggerTypes["Participation"] = "participation"] = "Participation";
    LoggerTypes[LoggerTypes["Mam"] = "mam"] = "Mam";
    LoggerTypes[LoggerTypes["CleanUp"] = "clean-up"] = "CleanUp";
    LoggerTypes[LoggerTypes["XmppClient"] = "xmpp-client"] = "XmppClient";
    LoggerTypes[LoggerTypes["Events"] = "events"] = "Events";
    LoggerTypes[LoggerTypes["DataStorage"] = "data-storage"] = "DataStorage";
    LoggerTypes[LoggerTypes["Other"] = "other"] = "Other";
})(LoggerTypes = exports.LoggerTypes || (exports.LoggerTypes = {}));
class Logger {
    constructor(types = null) {
        this._types = types;
    }
    log(type, ...logArgs) {
        if (this.shouldLog(type)) {
            console.log.call(null, ...logArgs);
        }
    }
    info(type, ...logArgs) {
        if (this.shouldLog(type)) {
            console.info.call(null, ...logArgs);
        }
    }
    debug(type, ...logArgs) {
        if (this.shouldLog(type)) {
            console.debug.call(null, ...logArgs);
        }
    }
    error(...logArgs) {
        // errors _always_ get logged
        console.error.call(null, ...logArgs);
    }
    getTypes() {
        return this._types;
    }
    getTypesAsEnumValues() {
        return this._types.map(x => utils_1.enumFromString(x));
    }
    setTypes(types) {
        this._types = types || [];
    }
    shouldLog(type) {
        if (!this._types || !this._types.length)
            return false;
        if (this._types.includes("_all_"))
            return true;
        return this._types.includes(type.toString());
    }
}
exports.Logger = Logger;
// tslint:enable no-any
// tslint:enable no-console


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const ConnectivityHandler_1 = __webpack_require__(69);
const ReadPageDetailHandler_1 = __webpack_require__(72);
const ReceiveNewPageHandler_1 = __webpack_require__(73);
const SendNewPageHandler_1 = __webpack_require__(74);
const SendPageResponseHandler_1 = __webpack_require__(75);
const handlers_1 = __webpack_require__(8);
const StartTestModeHandler_1 = __webpack_require__(76);
const PushNotificationResponseHandler_1 = __webpack_require__(71);
const DiagnosticsRequestHandler_1 = __webpack_require__(70);
class PagerMessageTypes extends handlers_1.BaseMessageType {
}
PagerMessageTypes.DiagnosticsRequest = "diagnosticsrequest";
PagerMessageTypes.DiagnosticsResponse = "diagnosticsresponse";
PagerMessageTypes.NewPage = "newpage";
PagerMessageTypes.PageResponse = "pageresponse";
PagerMessageTypes.StartTest = "starttest";
exports.PagerMessageTypes = PagerMessageTypes;
// tslint:disable-next-line no-any
function get(pagerLayer) {
    return [
        new ConnectivityHandler_1.ConnectivityHandler(pagerLayer),
        new DiagnosticsRequestHandler_1.DiagnosticsRequestHandler(pagerLayer),
        new ReadPageDetailHandler_1.ReadPageDetailHandler(pagerLayer),
        new ReceiveNewPageHandler_1.ReceiveNewPageHandler(pagerLayer),
        new SendNewPageHandler_1.SendNewPageHandler(pagerLayer),
        new SendPageResponseHandler_1.SendPageResponseHandler(pagerLayer),
        new StartTestModeHandler_1.StartTestModeHandler(pagerLayer),
        new PushNotificationResponseHandler_1.PushNotificationResponseHandler(pagerLayer)
    ];
}
exports.get = get;


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class BaseEventArgs {
    constructor() {
        this.eventDate = new Date().getTime();
    }
}
exports.BaseEventArgs = BaseEventArgs;


/***/ }),
/* 13 */
/***/ (function(module, exports) {

module.exports = skate;

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Created by Leon.Revill on 19/06/2017.
 */

Object.defineProperty(exports, "__esModule", { value: true });
const ieWindow = window;
const ieDocument = document;
function getPlatformName() {
    const userAgent = window.navigator.userAgent;
    if (/Android/i.test(userAgent)) {
        return "android";
    }
    else if (/iPhone|iPad|iPod/i.test(userAgent)) {
        return "ios";
    }
    else if (/Electron/i.test(userAgent)) {
        return "electron";
    }
    else if (/Chrome/i.test(userAgent)) {
        return "chrome";
    }
    else if (/Safari/i.test(userAgent)) {
        return "safari";
    }
    else if (/Edge/i.test(userAgent)) {
        return "edge";
    }
    else if (!!ieWindow.MSInputMethodContext && !!ieDocument.documentMode) {
        return "ie";
    }
    else {
        // Unsupported platform
        return null;
    }
}
exports.getPlatformName = getPlatformName;
function isElectron() {
    return (getPlatformName() === "electron");
}
exports.isElectron = isElectron;
function isWindows() {
    return (navigator.userAgent.toUpperCase().indexOf("WINDOWS") !== -1);
}
exports.isWindows = isWindows;
function isDevice() {
    const platformName = getPlatformName();
    return (platformName === "android" || platformName === "ios");
}
exports.isDevice = isDevice;
function isBrowser() {
    const platformName = getPlatformName();
    return (platformName === "chrome" || platformName === "safari" || platformName === "ie" || platformName === "edge");
}
exports.isBrowser = isBrowser;


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Created by Leon.Revill on 19/06/2017.
 */

Object.defineProperty(exports, "__esModule", { value: true });
const cWindow = window;
const eWindow = window;
function getSource(pluginName) {
    if (cWindow[pluginName] !== undefined) {
        return cWindow[pluginName];
    }
    else if (cWindow.cordova !== undefined && cWindow.cordova[pluginName] !== undefined) {
        return cWindow.cordova[pluginName];
    }
    else if (cWindow.cordova !== undefined && cWindow.cordova.plugins !== undefined && cWindow.cordova.plugins[pluginName] !== undefined) {
        return cWindow.cordova.plugins[pluginName];
    }
    else if (cWindow.plugins !== undefined && cWindow.plugins[pluginName] !== undefined) {
        return cWindow.plugins[pluginName];
    }
    else if (navigator !== undefined && navigator[pluginName] !== undefined) {
        return navigator[pluginName];
    }
    else if (eWindow.require !== undefined) {
        let plugin = false;
        try {
            plugin = eWindow.require(pluginName);
            return plugin;
        }
        catch (err) {
            if (plugin === false || plugin === undefined) {
                const fixedName = pluginName.replace(/\-/g, "").toLowerCase();
                try {
                    return eWindow.require("@commontimeltd/com.commontime." + fixedName);
                }
                catch (err) {
                    return false;
                }
            }
            return false;
        }
    }
    else {
        console.warn(`Plugin '${pluginName}' is not available.`);
        return false;
    }
}
exports.getSource = getSource;


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Created by Leon.Revill on 25/01/2017.
 */

Object.defineProperty(exports, "__esModule", { value: true });
/* tslint:disable */
// TODO: Fix linting issues
const es6_promise_1 = __webpack_require__(29);
const utils_1 = __webpack_require__(18);
const File = __webpack_require__(40);
const environment_1 = __webpack_require__(14);
const Plugin = __webpack_require__(15);
const vcard_simple_1 = __webpack_require__(42);
const UsersDirectory_1 = __webpack_require__(39);
const timer_1 = __webpack_require__(41);
const index_1 = __webpack_require__(21);
if (!window.Promise) {
    throw new Error("ct-xmpp-client.js has a dependency on Promise, did you forget to include the polyfill?");
}
if (!window.PouchDB) {
    throw new Error("ct-xmpp-client.js has a dependency on PouchDB, please ensure PouchDB is included before ct-xmpp-client.js");
}
class CtXmppClient {
    /**
     * Client constructor method.
     * @param instanceId - Unique identifier for this instance of CtXmppClient
     * @param endpoint - The server location (e.g. wss://chat.commontime.com:5281/websocket)
     * @param options
     */
    constructor(instanceId, endpoint, options) {
        this._userDirectory = null;
        this._includeStanzaFilters = [];
        this._excludeStanzaFilters = [];
        this._pushNodeName = null;
        /**
         * Private method which takes the Strophe status ID and adds a human readable label, saving it to the store
         * @param {number} statusId
         * @param {boolean} dispatch - Whether the status change should be dispatched as an event
         * @private
         */
        this._lastStatusId = null;
        this._pingInterval = null;
        /**
         * Private variable to hold the ping timeout
         */
        this._pingTimeout = null;
        this._alreadyReLoggingIn = false;
        this._reLoginTimeout = null;
        this._reLoginBackOff = 3000;
        /**
         * Method to force a logout and clean up, useful for bailing and cleaning up after a disconnect during login
         */
        this._forcedLogout = false;
        this._sendTimeouts = {};
        this._sendStanzaPromises = {};
        /**
         * Private variable to indicate the databases are being destroyed
         */
        this._destroyingDbs = false;
        this._joinedRooms = {};
        this._saveDebounce = {};
        /**
         * Methods realted to Infinity Bot Communication
         */
        this._botCommandTimeouts = {};
        this._botCommandPromises = {};
        this._initialised = false;
        if (!instanceId) {
            throw new Error("An instance ID must be provided.");
        }
        this._instanceId = instanceId;
        let currentArchiveId = localStorage.getItem(`${this._instanceId}_last_archive_id`);
        if (currentArchiveId === null) {
            currentArchiveId = "0"; // Leave this as a string so we don't have to parseInt
        }
        this._lastArchiveId = currentArchiveId;
        if (!endpoint) {
            throw new Error("XMPP server hostname must be provided.");
        }
        this._serverTimeDiff = null;
        this._eventListeners = {};
        this._options = CtXmppClient._merge({
            sendTimeout: 300000,
            debug: false,
            perfLogging: false,
            mucHost: null,
            uploadHost: null,
            echoHost: null,
            authAttachments: false,
            mam: {
                auto: true,
                defaultTimeLimit: 2.628e+9,
                pageSize: 250
            },
            push: {
                enabled: false,
                packageId: "",
                senderId: ""
            },
            enablePing: true,
            pingInterval: 5000,
            pingTimeout: 10000,
            connectTimeout: 7000,
            autoLogin: false,
            autoReconnect: true,
            autoMarkMessages: true,
            encryption: false,
            fileEncryption: false,
            autoDownloadAttachmentTime: -1,
            autoPurgeOldMessagesAge: -1,
            autoPurgeOldMessagesCount: -1,
            streamResumption: true,
            useEncodedJidAsResource: false,
            adSpn: null,
            adSecurityPackage: null,
            adTokenPlaceholder: "[[AD_PASSWORD_TOKEN]]",
            updateUserDirectoryOnLogin: false,
            enableMessageCarbons: false,
            maxReconnectBackoff: 300000,
            stropheLogging: false,
            forceIndexedDb: false,
            bringToForegroundOnVoipPush: true,
            updateUserDirectoryInterval: 30 * 1000 * 60,
            useConnectionEvents: true,
            autoResumeTimers: true,
            maxStreamResumptionTime: null
        }, options);
        this._endpoint = endpoint;
        this._connection = null;
        this.connected = false;
        this.loggedIn = false;
        this._reLoggingIn = false;
        this._loggingOut = false;
        this._jid = null;
        this.resource = null;
        this._bareJid = null;
        this.username = null;
        this._userDirectory = new UsersDirectory_1.UsersDirectory(this._instanceId, this._options.debug);
        if (this._options.stropheLogging === true) {
            index_1.default.Strophe.log = (level, msg) => {
                this._log(`[${level}]: ${msg}`);
            };
        }
        es6_promise_1.Promise.all([this._getInstallId(), this._initDbs()]).then(() => {
            this._initialised = true;
            this._log("XMPP client successfully initialised.");
            this._dispatchEvent(CtXmppClient.EVENT_TYPES.INITIALISED, null);
            if (this._options.autoLogin === true) {
                const proms = [this._getCacheItem("user_jid"), this._getCacheItem("user_password")];
                es6_promise_1.Promise.all(proms).then((data) => {
                    const jid = data[0];
                    const password = data[1];
                    if (jid !== undefined && password !== undefined) {
                        this._reLogin();
                    }
                }).catch((e) => {
                    this._onError("Unable to get jid/pw: " + e);
                });
            }
        }).catch(e => {
            throw new Error(e);
        });
        // Register events for online/offline
        if (this._options.useConnectionEvents) {
            document.addEventListener("offline", () => {
                this._onOffline();
            }, false);
            document.addEventListener("online", () => {
                this._onOnline();
            }, false);
        }
    }
    /**
     * Method which allows setting the send timeout
     * @param {number} value - The number of milliseconds to wait until marking a message as failed to send
     */
    set sendTimeout(value) {
        if (value === this._options.sendTimeout)
            return;
        this._options.sendTimeout = value;
    }
    /**
     * Getter method which retrieves the current connection status
     */
    get status() {
        this._isMethodReady(true);
        return this._getCacheItem("connection_status");
    }
    /**
     * Getter method to retrieve the bareJid
     * @returns {string}
     */
    get bareJid() {
        return this._bareJid;
    }
    /**
     * Add a filter function that returns true if stanza is NOT to be ignored.
     * @param filter function, takes message, returns boolean
     */
    addIncludeStanzaFilter(filter) {
        this._includeStanzaFilters.push(filter);
    }
    /**
     * Add a filter function that returns true if stanza IS to be ignored.
     * @param filter function, takes message, returns boolean
     */
    addExcludeStanzaFilter(filter) {
        this._excludeStanzaFilters.push(filter);
    }
    /**
     * Run when the device goes offline, and no network is available
     * @private
     */
    _onOffline() {
        this._connection.disconnect("gone_offline");
    }
    /**
     * Run when the device goes online, and network is available
     * @private
     */
    _onOnline() {
        if (!this.connected)
            this.reLoginNow();
    }
    /**
     * Gets us a unique id to use in push and as resource.
     * @returns {Promise<void>}
     * @private
     */
    _getInstallId() {
        const INSTALL_ID = "install_id";
        return new es6_promise_1.Promise((resolve, reject) => {
            const installId = localStorage.getItem(`${this._instanceId}_install_id`);
            if (installId === null) {
                let that = this;
                if (environment_1.getPlatformName() === "ios") {
                    const secureSettings = Plugin.getSource("securesettings");
                    secureSettings.get((value) => {
                        if (typeof value === 'string') {
                            that._installId = value;
                            localStorage.setItem(`${that._instanceId}_install_id`, that._installId);
                            resolve();
                        }
                        else {
                            const newInstallId = utils_1.generateGuid();
                            secureSettings.set(() => {
                                that._installId = newInstallId;
                                localStorage.setItem(`${that._instanceId}_install_id`, that._installId);
                                resolve();
                            }, (error) => {
                                reject(error);
                            }, INSTALL_ID, newInstallId);
                        }
                    }, (error) => {
                        that._log("Secure settings error:", error);
                        reject(error);
                    }, INSTALL_ID);
                }
                else if (environment_1.getPlatformName() === "android") {
                    const devicePlugin = Plugin.getSource("device");
                    this._installId = devicePlugin.uuid;
                    localStorage.setItem(`${this._instanceId}_install_id`, this._installId);
                    resolve();
                }
                else {
                    const newInstallId = utils_1.generateGuid();
                    that._installId = newInstallId;
                    localStorage.setItem(`${this._instanceId}_install_id`, this._installId);
                    resolve();
                }
            }
            else {
                this._installId = installId;
                return resolve();
            }
        });
    }
    /**
     * Private method to create all databases
     * @private
     */
    _initDbs() {
        return new es6_promise_1.Promise((resolve, reject) => {
            const options = {
                auto_compaction: true,
                revs_limit: 1
            };
            this._msgDb = new window.PouchDB(`${this._instanceId}_messages`, options);
            this._contactDb = new window.PouchDB(`${this._instanceId}_contacts`, options);
            this._cacheDb = new window.PouchDB(`${this._instanceId}_cache`, options);
            this._cache = {};
            this._roomDb = new window.PouchDB(`${this._instanceId}_rooms`, options);
            this._participantDb = new window.PouchDB(`${this._instanceId}_participants`, options);
            // Enable encryption if requested
            if (this._options.encryption === true) {
                utils_1.getEncryptionKey(this._instanceId).then((keyBuffer) => {
                    this._cacheDb.crypto({ "key": keyBuffer });
                    this._msgDb.crypto({ "key": keyBuffer });
                    this._contactDb.crypto({ "key": keyBuffer });
                    this._roomDb.crypto({ "key": keyBuffer });
                    this._participantDb.crypto({ "key": keyBuffer });
                    resolve();
                }).catch(reject);
            }
            else {
                console.warn("Encryption has not been enabled! If you have auto-reconnect, auto-login or authenticated attachments enabled your password will be stored unencrypted! 😱");
                resolve();
            }
        });
    }
    _setStatus(statusId, dispatch = true, condition = null) {
        return new es6_promise_1.Promise((resolve, reject) => {
            if (this._lastStatusId === statusId) {
                resolve();
            }
            else {
                const statusObj = {
                    id: statusId,
                    label: null,
                    reason: condition
                };
                switch (statusId) {
                    case index_1.default.Strophe.Status.CONNECTING:
                        statusObj.label = "Connecting";
                        break;
                    case index_1.default.Strophe.Status.CONNFAIL:
                        statusObj.label = "Connection failed";
                        break;
                    case index_1.default.Strophe.Status.DISCONNECTING:
                        statusObj.label = "Disconnecting";
                        break;
                    case index_1.default.Strophe.Status.DISCONNECTED:
                        statusObj.label = "Disconnected";
                        break;
                    case index_1.default.Strophe.Status.CONNECTED:
                        statusObj.label = "Connected";
                        break;
                    case index_1.default.Strophe.Status.AUTHFAIL:
                        statusObj.label = "Authentication failed.";
                        break;
                    case index_1.default.Strophe.Status.ERROR:
                        statusObj.label = condition || "An unknown error occurred.";
                        break;
                }
                if (this._lastStatusId !== statusObj.id && dispatch !== false) {
                    this._dispatchEvent(CtXmppClient.EVENT_TYPES.STATUS, statusObj);
                }
                this._lastStatusId = statusObj.id;
                this._setCacheItem("connection_status", statusObj).then(resolve).catch(reject);
            }
        });
    }
    static _isReasonToReconnect(condition) {
        if (!condition || typeof condition !== "string")
            return true;
        let result = true;
        switch (condition.toLowerCase()) {
            case "kicked by administrator":
            case "replaced by new connection":
            case "conflict":
                result = false;
                break;
        }
        return result;
    }
    static _translateCondition(condition) {
        if (!condition)
            return null;
        switch (condition.toLowerCase()) {
            case "conflict":
                return "You already have an active session. Please log out of any previous sessions or wait for the previous login attempt to timeout.";
            case "system-shutdown":
                return "Remote server was shut down.";
            case "connection-timeout":
                return "The connection to the server timed out.";
            case "socket closed, probably due to no network connectivity.":
            case "invalid username or password":
            case "kicked by administrator":
                return condition;
            default:
                return "Connection closed unexpectedly.";
        }
    }
    /**
     * Private method which is used to initiate a WebSocket connection to the XMPP server using the Strophe API
     * @param {String} jid
     * @param {String} password
     * @returns {Promise}
     * @private
     */
    _connect(jid, password) {
        return new es6_promise_1.Promise((resolve, reject) => {
            if (this._connection) {
                // tslint-disable-next-line
                this._connection.disconnect("make_sure", true);
            }
            // Create a fresh connection object
            this._connection = new index_1.default.Strophe.Connection(this._endpoint, {
                instance_id: this._instanceId
            });
            // Attach various event handlers
            this._connection.addHandler(this._onStanza.bind(this), null, "message");
            this._connection.addHandler(($xml) => {
                return this._onPresence(CtXmppClient.xmlToJson($xml));
            }, null, "presence");
            // We only attempt to connect for this duration and assume connection
            // has failed if we reach this limit
            const connectTimeout = setTimeout(() => {
                // Calling private Strophe method to ensure socket is closed.
                this._connection._doDisconnect();
                reject("Connection took more than 5 seconds to be established, connection closed.");
            }, this._options.connectTimeout);
            const prom = (this._options.streamResumption === true) ? this._getCacheItem("stream_management_id") : es6_promise_1.Promise.resolve();
            prom.then((smId) => {
                this._connection.streamManagement.prevId = smId;
                let finished = false;
                // Start the connection process
                if (this._forcedLogout) {
                    if (this._options.useEncodedJidAsResource === true)
                        this._connection.override = true;
                    this._forcedLogout = false;
                }
                this._connection.connect(jid, password, (status, condition) => {
                    if (this._reLoggingIn !== true)
                        this._setStatus(status, true, condition);
                    if (finished === true)
                        return false;
                    switch (status) {
                        case index_1.default.Strophe.Status.ERROR:
                        case index_1.default.Strophe.Status.AUTHFAIL:
                        case index_1.default.Strophe.Status.CONNFAIL:
                        case index_1.default.Strophe.Status.DISCONNECTED:
                            const reason = CtXmppClient._translateCondition(condition);
                            let msg = "Connection Disconnected";
                            if (status === index_1.default.Strophe.Status.ERROR) {
                                msg = "Connection Error";
                                this._onError(msg, reason);
                            }
                            if (status === index_1.default.Strophe.Status.AUTHFAIL) {
                                msg = "Authentication Failed";
                            }
                            if (status === index_1.default.Strophe.Status.CONNFAIL)
                                msg = "Connection Failed";
                            if (reason !== null) {
                                msg += ": " + reason;
                            }
                            // If we have any outstanding send timeouts, pause them until we re-establish a connection
                            if (Object.keys(this._sendTimeouts).length > 0) {
                                Object.keys(this._sendTimeouts).forEach((messageId) => {
                                    this._log(`Pausing send timer for request with ID '${messageId}'...`);
                                    const timer = this._sendTimeouts[messageId];
                                    if (!timer.paused) {
                                        timer.pause();
                                    }
                                });
                            }
                            // If we have any outstanding bot command timeouts, pause them until we re-establish a connection
                            if (Object.keys(this._botCommandTimeouts).length > 0) {
                                Object.keys(this._botCommandTimeouts).forEach((requestId) => {
                                    this._log(`Pausing bot command timer for request with ID '${requestId}'...`);
                                    const timer = this._botCommandTimeouts[requestId];
                                    if (!timer.paused) {
                                        timer.pause();
                                    }
                                });
                            }
                            clearTimeout(connectTimeout);
                            this.connected = false;
                            // Clear any reconnect timeout so it stops trying to reconnect, we've been fully disconnected
                            // so we need to re-login to create a new socket.
                            this._stopPing();
                            // If the user didn't initiate the logout manually, start the re-login process.
                            this._log("Disconnected:", condition);
                            if (this._loggingOut === false && this._options.autoReconnect === true && status !== index_1.default.Strophe.Status.AUTHFAIL && CtXmppClient._isReasonToReconnect(condition) === true) {
                                // If we've had a disconnect status change then we have lost the WebSocket completely so the "reconnect" phase is over
                                // We now need to re-login to create a new socket.
                                this._log("Attempting to re-login...");
                                this._reLogin();
                            }
                            finished = true;
                            reject({ "msg": msg, "status": status, "condition": condition });
                            break;
                        case index_1.default.Strophe.Status.CONNECTED:
                            clearTimeout(connectTimeout);
                            this.connected = true;
                            resolve(condition);
                    }
                });
            });
        });
    }
    /**
     * Private method used as part of the login process to setup and handle stream management - stream management is a requirement of this XMPP client implementation
     * @returns {Promise}
     * @private
     */
    _enableStreamManagement() {
        return new es6_promise_1.Promise((resolve, reject) => {
            const disconnectCallback = (status) => {
                if (status.id === index_1.default.Strophe.Status.DISCONNECTED) {
                    this.removeEventListener(CtXmppClient.EVENT_TYPES.STATUS, disconnectCallback);
                    reject(`Disconnected during stream management enabling.`);
                }
            };
            this.addEventListener(CtXmppClient.EVENT_TYPES.STATUS, disconnectCallback);
            if (this.connected === false || this._connection === null) {
                reject("You must have an active connection to enable stream management");
            }
            else {
                if (!this._connection.streamManagement) {
                    throw new Error("Stream management is required.");
                }
                try {
                    this._connection.addHandler(($stanza) => {
                        this._log("Stream resumption enabled!");
                        this._setCacheItem("stream_management_id", $stanza.getAttribute("id")).then(() => {
                            this.removeEventListener(CtXmppClient.EVENT_TYPES.STATUS, disconnectCallback);
                            resolve();
                        });
                        return false;
                    }, "urn:xmpp:sm:3", "enabled");
                    this._connection.streamManagement.enable(this._options.maxStreamResumptionTime);
                }
                catch (e) {
                    console.error(e);
                    reject();
                }
            }
        });
    }
    /**
     * Private method used as part of the login process to enable message carbons
     * @returns {Promise}
     * @private
     */
    _enableMessageCarbons() {
        return this.sendIq(null, "set", {
            enable: {
                $attributes: {
                    xmlns: CtXmppClient.NAMESPACES.CARBONS
                },
                $value: ""
            }
        });
    }
    /**
     * Method to start the ping process to detect when we lose connection
     * @returns {Promise}
     * @private
     */
    _initialisePing() {
        return new es6_promise_1.Promise((resolve) => {
            if (this._options.enablePing === true) {
                // Clear any existing interval
                if (this._pingInterval !== null)
                    clearInterval(this._pingInterval);
                // Start the interval which sends the ping
                this._pingInterval = setTimeout(() => {
                    this._sendPing().then(() => {
                        this._initialisePing();
                    }).catch(() => {
                        // If a ping fails then start the reconnect process
                        this._log("Ping failed.");
                        // Stop pinging
                        // clearInterval(this._pingInterval);
                        // Start the reconnect process
                        if (this._options.autoReconnect === true) {
                            this._log("Auto-reconnect enabled, so let's try and reconnect!");
                            if (this._connection)
                                this._connection.disconnect("ping_timeout", true);
                            this._reLogin();
                        }
                    });
                }, this._options.pingInterval);
            }
            resolve();
        });
    }
    /**
     * Method which sends a ping IQ
     * @returns {Promise}
     * @private
     */
    _sendPing() {
        return new es6_promise_1.Promise((resolve, reject) => {
            // Create our own timeout here because the Strophe timeout for IQ messages doesn't work when the WebSocket dies in Safari
            this._pingTimeout = setTimeout(() => {
                // If we are not connected, just ignore this timeout
                if (!this.connected) {
                    resolve();
                    return;
                }
                this.connected = false;
                this._setStatus(index_1.default.Strophe.Status.DISCONNECTED);
                if (this._options.autoReconnect === true)
                    this._setStatus(index_1.default.Strophe.Status.CONNECTING);
                reject();
            }, this._options.pingTimeout);
            this.sendIq(this._domain, "get", {
                ping: {
                    $attributes: {
                        xmlns: CtXmppClient.NAMESPACES.PING
                    }
                }
            }).then(() => {
                // Clear any existing timeout
                clearTimeout(this._pingTimeout);
                resolve();
            }).catch(reject);
        });
    }
    _makeParticipantsOffline() {
        return new es6_promise_1.Promise((resolve, reject) => {
            this._participantDb.allDocs({ "include_docs": true }).then((results) => {
                const participants = results.rows.filter((row) => {
                    // TODO: Figure out what to do with PouchDB views? Filtering them out for now
                    return (!row.doc.language);
                }).map((row) => {
                    row.doc.online = false;
                    return row.doc;
                });
                this._participantDb.bulkDocs(participants).then(resolve).catch((error) => {
                    this._onError(`Unable to bulk update participants to offline status.`, error);
                    reject(error);
                });
            }).catch((error) => {
                this._onError(`Unable to get participants from database.`, error);
                reject(error);
            });
        });
    }
    _makeContactsOffline() {
        return new es6_promise_1.Promise((resolve, reject) => {
            this.getContacts().then(contacts => {
                contacts.forEach((contact) => {
                    contact.online = false;
                });
                this._contactDb.bulkDocs(contacts).then(function () {
                    resolve();
                }).catch((error) => {
                    this._onError(`Unable to bulk update contacts to offline status.`, error);
                    reject(error);
                });
            }).catch((error) => {
                this._onError(`Unable to get contacts from database.`, error);
                reject(error);
            });
        });
    }
    resumeTimers() {
        // Resume any send timeouts
        if (Object.keys(this._sendTimeouts).length > 0) {
            Object.keys(this._sendTimeouts).forEach((messageId) => {
                const timer = this._sendTimeouts[messageId];
                if (timer.paused) {
                    this._log(`Resuming send timer for request with ID '${timer.id}'...`);
                    timer.resume();
                }
            });
        }
        // If we have any paused bot command timeouts, resume them
        if (Object.keys(this._botCommandTimeouts).length > 0) {
            Object.keys(this._botCommandTimeouts).forEach((requestId) => {
                const timer = this._botCommandTimeouts[requestId];
                if (timer.paused) {
                    this._log(`Resuming bot command timer for request with ID '${timer.id}'...`);
                    timer.resume();
                }
            });
        }
    }
    reLoginNow() {
        if (this._alreadyReLoggingIn)
            return;
        this._alreadyReLoggingIn = true;
        // Also call this here incase user calls this method directly
        this._clearReLoginTimeout();
        const proms = [this._getCacheItem("user_jid"), this._getCacheItem("user_password")];
        es6_promise_1.Promise.all(proms).then((data) => {
            const jid = data[0];
            const password = data[1];
            if (jid !== undefined && password !== undefined) {
                this._log(`Auto-logging in with JID '${jid}'.`);
                this._setStatus(index_1.default.Strophe.Status.CONNECTING);
                this._login(jid, password, true).then((resumed) => {
                    // If auto-login is successful reset everything and continue
                    this._reLoginBackOff = 3000;
                    this._log(`Auto-login success.`);
                    this._reLoggingIn = false;
                    this.connected = true;
                    const proms = [];
                    for (let room in this._joinedRooms) {
                        proms.push(this.joinRoom(room));
                    }
                    es6_promise_1.Promise.all(proms).then(() => {
                        this._setStatus(index_1.default.Strophe.Status.CONNECTED).then(() => {
                            // Now we have successfully auto-reconnected resume any paused timers
                            if (this._options.autoResumeTimers !== false)
                                this.resumeTimers();
                            this._dispatchEvent(CtXmppClient.EVENT_TYPES.AUTO_RECONNECTED, {
                                resumed: resumed
                            });
                            this._alreadyReLoggingIn = false;
                        }).catch((e) => {
                            this._alreadyReLoggingIn = false;
                            console.error("Couldn't set connection status:", e);
                        });
                    }).catch((e) => {
                        this._onError("Couldn't join all rooms on re-login, logging out.", e);
                        this.logout();
                        this._alreadyReLoggingIn = false;
                    });
                }).catch((e) => {
                    this._alreadyReLoggingIn = false;
                    if (e.status == index_1.default.Strophe.Status.AUTHFAIL) {
                        const statusObj = {
                            "id": index_1.default.Strophe.Status.DISCONNECTED,
                            "label": "Authentication Failed.",
                            "wontReconnect": true,
                            "reason": e.condition
                        };
                        this._dispatchEvent(CtXmppClient.EVENT_TYPES.STATUS, statusObj);
                    }
                    else {
                        // If we still cannot login then increase the back off value so we can try again soon
                        this._reLoginBackOff += 3000;
                        if (this._reLoginBackOff > this._options.maxReconnectBackoff) {
                            this._reLoginBackOff = this._options.maxReconnectBackoff;
                        }
                        this._log(`Couldn't re-login, trying again in ${(this._reLoginBackOff) / 1000} seconds...`);
                        this._reLogin();
                    }
                });
            }
        });
    }
    /**
     * Method used either on app start or after the WebSocket has died
     * @private
     */
    _reLogin() {
        // Don't do this if the user manually logged out
        if (this._loggingOut === true)
            return;
        this._reLoggingIn = true;
        this._clearReLoginTimeout();
        if (this._reLoginBackOff > 0) {
            const statusObj = {
                "id": index_1.default.Strophe.Status.DISCONNECTED,
                "label": "Disconnected",
                "reconnectTime": this._reLoginBackOff
            };
            this._dispatchEvent(CtXmppClient.EVENT_TYPES.STATUS, statusObj);
        }
        // Create a timeout with the back off value to retry the login process
        this._reLoginTimeout = setTimeout(() => {
            this.reLoginNow();
        }, this._reLoginBackOff);
    }
    _clearReLoginTimeout() {
        if (this._reLoginTimeout !== null) {
            clearTimeout(this._reLoginTimeout);
            this._reLoginTimeout = null;
        }
    }
    /**
     * Simple method which stops the pinging process
     * @private
     */
    _stopPing() {
        if (this._pingTimeout !== null)
            clearTimeout(this._pingTimeout);
        if (this._pingInterval !== null)
            clearInterval(this._pingInterval);
    }
    /**
     * Convenience method to create a presence object using cached data
     * @returns {Promise}
     * @private
     */
    _createPresenceObject() {
        return new es6_promise_1.Promise((resolve) => {
            const pres = {
                "$attributes": {
                    "from": this._jid,
                    "xmlns": CtXmppClient.NAMESPACES.JABBER_CLIENT
                }
            };
            pres.show = "chat";
            pres.status = "Available";
            this._getCacheItem("chat_status").then((statusObject) => {
                if (statusObject !== undefined) {
                    if (statusObject.status) {
                        pres.show = statusObject.status;
                    }
                    if (statusObject.label) {
                        pres.status = statusObject.label;
                    }
                    if (statusObject.metadata) {
                        pres.metadata = CtXmppClient._merge({
                            "$attributes": {
                                "xmlns": CtXmppClient.NAMESPACES.CT_METADATA
                            }
                        }, statusObject.metadata);
                    }
                }
                resolve(pres);
            });
        });
    }
    /**
     * Convenience method to send presence to contacts and joined rooms
     * @private
     */
    _sendPresence() {
        this._createPresenceObject().then(pres => {
            this._connection.send(CtXmppClient.jsonToXml("presence", pres));
            if (!this._options.mucHost)
                return;
            for (let room in this._joinedRooms) {
                pres.$attributes["to"] = `${room}@${this._options.mucHost}`;
                pres["x"] = {
                    "$attributes": {
                        "xmlns": CtXmppClient.NAMESPACES.MUC
                    }
                };
                const $pres = CtXmppClient.jsonToXml("presence", pres);
                this._connection.send($pres);
            }
        });
    }
    /**
     * Method to get the server time and calculate the difference between the client and server time
     * @returns {Promise}
     */
    getServerTime() {
        this._isMethodReady(true, true);
        return new es6_promise_1.Promise((resolve, reject) => {
            this.sendIq(this._domain, "get", {
                time: {
                    $attributes: {
                        xmlns: CtXmppClient.NAMESPACES.TIME
                    }
                }
            }).then((stanza) => {
                if (stanza.iq.time !== undefined && stanza.iq.time.utc) {
                    const server = new Date(stanza.iq.time.utc).valueOf();
                    const client = Date.now();
                    this._serverTimeDiff = (server - client);
                }
                resolve(this._serverTimeDiff);
            }).catch(reject);
        });
    }
    /**
     * Method used to sync a timestamp with the server time
     * @param ts
     * @returns {Number}
     */
    getSyncedTimestamp(ts) {
        // If we don't have a server time to work off then just return the specified ts
        if (this._serverTimeDiff === null)
            return ts;
        const diff = Math.abs(this._serverTimeDiff);
        return (this._serverTimeDiff >= 0) ? (ts + diff) : (ts - diff);
    }
    /**
     * Method to log the user in
     * @param jid
     * @param password
     * @returns {Promise}
     */
    login(jid, password) {
        return this._login(jid, password, false);
    }
    _login(jid, password, isReLogin = false) {
        this._isMethodReady(true);
        if (!jid)
            throw new Error("Parameter 'jid' must be provided.");
        if (!password)
            throw new Error("Parameter 'password' must be provided.");
        if (this._reLoggingIn === true && isReLogin === false) {
            // if we are in a re-logging-in state and a login request has come from a non-re-login source, then reset the flag and clear any pending re-login action
            this._clearReLoginTimeout();
            this._reLoggingIn = false;
        }
        this._loggingOut = false;
        return new es6_promise_1.Promise((resolve, reject) => {
            this._getInstallId().then(() => {
                this._getCacheItem("user_jid").then((previousJid) => {
                    // If we are already logged in with the same user, just continue.
                    if (this.connected === true && this.loggedIn === true && previousJid === index_1.default.Strophe.getBareJidFromJid(jid)) {
                        resolve(false);
                    }
                    else {
                        // Has the resource been specified in the JID? If so, use that and move on.
                        const specifiedResource = index_1.default.Strophe.getResourceFromJid(jid);
                        if (specifiedResource !== null) {
                            this.resource = specifiedResource;
                            this._jid = jid;
                            this._bareJid = index_1.default.getBareJidFromJid(this._jid);
                        }
                        else {
                            this._bareJid = jid;
                            // Are we to use the jid as a resource
                            if (this._options.useEncodedJidAsResource === true) {
                                // If so base64 encode the bareJid and use as the resource
                                this.resource = btoa(this._bareJid);
                            }
                            else {
                                // If not do we have a previously generated one available?
                                const resource = localStorage.getItem(`${this._instanceId}_resource`);
                                // If not, generate one and stash it
                                if (resource === null) {
                                    this.resource = this._installId;
                                    localStorage.setItem(`${this._instanceId}_resource`, this.resource);
                                }
                                else {
                                    this.resource = resource;
                                }
                            }
                            this._jid = this._bareJid + "/" + this.resource;
                        }
                        const onLoginSuccess = () => {
                            // Set the logged-in flag
                            this.loggedIn = true;
                            // Remove the logging-in flag
                            localStorage.removeItem(`${this._instanceId}_logging_in`);
                        };
                        this.username = index_1.default.Strophe.getNodeFromJid(this._jid);
                        this._domain = this._bareJid.split("@")[1];
                        const __completeLogin = () => {
                            let resumed = false;
                            // If the previous login failed then we want to do a force logout to clear the SM ID to prevent stream resumption
                            const forceLogout = (localStorage.getItem(`${this._instanceId}_logging_in`) !== null);
                            if (forceLogout)
                                this._log("Previous login attempt failed, calling a force logout to clean-up.");
                            // Ensure we are logged out before we try and login
                            this.logout(forceLogout, true).then(() => {
                                // If we need to embellish the password with an AD token otherwise just return the password as is
                                return this._embellishPasswordWithAdToken(password);
                            })
                                .then((_password) => {
                                // Use the password provided from the embellish step in-case it has been modified
                                // We don't overwrite the provided password variable because we want the originally provided password
                                // to be persisted so that on re-connect we new AD token is obtained                                
                                return this._connect(this._jid, _password).then(condition => {
                                    resumed = (condition === "resumed");
                                    localStorage.setItem(`${this._instanceId}_logging_in`, "true");
                                    // this.addEventListener("status", onDisconnect);
                                });
                            })
                                .then(() => {
                                // Don't re-enable stream management if we have resumed a stream
                                return (resumed === false) ? this._enableStreamManagement() : es6_promise_1.Promise.resolve();
                            })
                                .then(() => {
                                // If we resumed we don't need to enable message carbons
                                return (resumed === false && this._options.enableMessageCarbons === true) ? this._enableMessageCarbons() : es6_promise_1.Promise.resolve();
                            })
                                .then(() => {
                                // If we have resumed we don't need to get the server time again
                                return (resumed === false) ? this.getServerTime() : es6_promise_1.Promise.resolve();
                            })
                                .then(() => {
                                // If we have resumed we will have the same JID as last time so don't re-cache
                                return (resumed === false) ? this._setCacheItem("user_jid", this._bareJid) : es6_promise_1.Promise.resolve();
                            })
                                .then(() => {
                                return new es6_promise_1.Promise((_resolve, _reject) => {
                                    if (resumed === false && (this._options.autoReconnect === true || this._options.autoLogin === true || this._options.authAttachments === true)) {
                                        this._setCacheItem("user_password", password, true).then(_resolve).catch(_reject);
                                    }
                                    else {
                                        _resolve();
                                    }
                                });
                            })
                                .then(() => {
                                if (!resumed) {
                                    return es6_promise_1.Promise.all([this._makeContactsOffline(), this._makeParticipantsOffline()]);
                                }
                                else {
                                    return;
                                }
                            })
                                .then(() => {
                                return new es6_promise_1.Promise((resolve, reject) => {
                                    if (environment_1.isDevice() && this._options.push.enabled) {
                                        this._getPushToken()
                                            .then((token) => {
                                            return this.registerForPush(token);
                                        })
                                            .then(() => {
                                            resolve();
                                        })
                                            .catch((e) => {
                                            this._log("Failed to register for push: " + e);
                                            resolve();
                                        });
                                    }
                                    else {
                                        resolve();
                                    }
                                });
                            })
                                .then(() => {
                                return this._initialisePing();
                            })
                                .then(() => {
                                return (this._options.updateUserDirectoryOnLogin === true) ? this.updateUserDirectory() : es6_promise_1.Promise.resolve();
                            })
                                .then(() => {
                                // Don't request the roster if we have resumed a stream
                                return (resumed === false) ? this._getCacheItem("roster_version").then((value) => {
                                    return this.sendIq(this._bareJid, "get", {
                                        "query": {
                                            "$attributes": {
                                                "xmlns": "jabber:iq:roster",
                                                "ver": value || ""
                                            }
                                        }
                                    });
                                }) : es6_promise_1.Promise.resolve();
                            })
                                .then(($roster) => {
                                return this._processRoster($roster);
                            })
                                .then(() => {
                                return new es6_promise_1.Promise((_resolve, _reject) => {
                                    if (resumed === false && this._options.mam.auto !== false) {
                                        const archiveId = this.getLastArchiveId();
                                        // Now get a list of the users current subscriptions
                                        this.listSubscriptions().then(subscriptions => {
                                            // For each room query the MAM using the last archive ID
                                            const proms = [];
                                            subscriptions.forEach((sub) => {
                                                proms.push(this.queryMamByRoomName(sub.name, true, archiveId));
                                            });
                                            es6_promise_1.Promise.all(proms).then(() => {
                                                // Now get personal items from the MAM
                                                // Have to do this after the room query otherwise the room query will use an archive ID from one of the MAM messages
                                                this.queryMam(null, archiveId).then(_resolve).catch((e) => {
                                                    this._onError(`Unable to query the MAM for missed messages.`, e);
                                                    _reject(e);
                                                });
                                            }).catch(e => {
                                                this._onError(`Unable to query the MAM for missed messages in a subscribed room.`, e);
                                                _reject(e);
                                            });
                                        }).catch(e => {
                                            this._onError(`Unable to get a list of subscriptions.`, e);
                                            _reject(e);
                                        });
                                    }
                                    else {
                                        _resolve();
                                    }
                                });
                            })
                                .then(() => {
                                if (resumed === false)
                                    this._sendPresence();
                                onLoginSuccess();
                                resolve(resumed);
                            })
                                .catch((e) => {
                                // If we fail part way through the login process and we haven't had a disconnection, fire one.
                                if (this._connection !== null && this._connection.connected === true) {
                                    this._connection.disconnect("fail_during_login");
                                    this._connection = null;
                                }
                                this._onError(`Unable to complete login process with JID '${jid}'.`, e.msg);
                                reject(e);
                            });
                        };
                        // If we are logging in with a different person than last time we need to clear out the database
                        if (previousJid !== undefined && previousJid !== this._bareJid) {
                            this._clearDbsForNewUser().then(() => {
                                __completeLogin();
                            });
                        }
                        else {
                            __completeLogin();
                        }
                    }
                }).catch(reject);
            }).catch(reject);
        });
    }
    /**
     * Method to initiate the logout process
     * @param forceClean - Force a clean-up which clears user password and stream management ID, this will prevent a reconnect
     * @returns {Promise}
     */
    logout(forceClean = false, dontClearPassword = false) {
        return new es6_promise_1.Promise((resolve, reject) => {
            const cleanUp = () => {
                this._joinedRooms = {};
                this._reLoggingIn = false;
                this.connected = false;
                this.loggedIn = false;
                this._stopPing();
                this._clearReLoginTimeout();
                localStorage.removeItem(`${this._instanceId}_logging_in`);
                // Remove password and stream_management_id from cache
                const proms = [this._deleteCacheItem("stream_management_id")];
                if (dontClearPassword !== true)
                    proms.push(this._deleteCacheItem("user_password"));
                es6_promise_1.Promise.all(proms).then(() => {
                    this._loggingOut = false;
                    resolve();
                }).catch(reject);
            };
            if (forceClean !== true && (this.connected === false || this._loggingOut === true)) {
                resolve();
            }
            else if (this._connection !== null && this._connection.connected === true && this._loggingOut === false) {
                this._loggingOut = true;
                const doDisconnect = () => {
                    this._stopPing();
                    this._clearReLoginTimeout();
                    this._connection.disconnect("user_logout");
                    this._connection = null;
                    cleanUp();
                };
                if (environment_1.isDevice() && this._options.push.enabled) {
                    this.disablePush()
                        .then(() => {
                        doDisconnect();
                    });
                }
                else {
                    doDisconnect();
                }
            }
            else {
                cleanUp();
            }
        });
    }
    forceLogout() {
        return new es6_promise_1.Promise((resolve, reject) => {
            this._forcedLogout = true;
            this._loggingOut = true;
            this._joinedRooms = {};
            this._reLoggingIn = false;
            this.connected = false;
            this.loggedIn = false;
            this._stopPing();
            this._clearReLoginTimeout();
            localStorage.removeItem(`${this._instanceId}_logging_in`);
            if (this._connection) {
                this._connection.disconnect("user_logout");
                this._connection = null;
            }
            es6_promise_1.Promise.all([
                this._deleteCacheItem("stream_management_id"),
                this._deleteCacheItem("user_password")
            ]).then(() => {
                this._loggingOut = false;
                resolve();
            }).catch(reject);
        });
    }
    /**
     * Method to (re)send a message given its id
     * @param messageId
     * @returns {Promise}
     */
    resendMessage(messageId) {
        this._isMethodReady(true, true);
        return new es6_promise_1.Promise((resolve, reject) => {
            this.getMessageById(messageId).then(message => {
                this._log(`Resending message with ID '${messageId}':`, message);
                const stanza = {
                    "$attributes": {
                        "id": message._id,
                        "to": message.recipient_id,
                        "from": message.sender_id,
                        "type": message.type,
                        "xmlns": CtXmppClient.NAMESPACES.JABBER_CLIENT
                    },
                    "markable": {
                        "$attributes": {
                            "xmlns": CtXmppClient.NAMESPACES.CHAT_MARKERS
                        }
                    },
                    "body": message.body,
                    "data": message.data,
                    "attachments": []
                };
                if (message.addresses !== undefined) {
                    stanza.addresses = {
                        $attributes: {
                            xmlns: CtXmppClient.NAMESPACES.ADDRESS
                        },
                        address: message.addresses
                    };
                }
                message.attachments.forEach((attachment) => {
                    stanza.attachments.push({
                        name: attachment.name,
                        type: attachment.type,
                        size: "" + attachment.size,
                        get: attachment.get
                    });
                });
                this.sendStanza(stanza).then(() => {
                    resolve(message);
                }).catch(reject);
            }).catch(reject);
        });
    }
    _stanzaResponseHandler(messageId, error) {
        if (this._sendTimeouts[messageId]) {
            this._log(`Clearing send timeout for message with ID '${messageId}'.`);
            this._sendTimeouts[messageId].cancel();
            delete this._sendTimeouts[messageId];
        }
        if (!error) {
            this._resolveSendStanzaPromise(messageId);
        }
        else {
            this._rejectSendStanzaPromise(messageId, error);
        }
    }
    _resolveSendStanzaPromise(messageId, data) {
        if (!this._sendStanzaPromises[messageId])
            return;
        this._log(`Resolving send stanza promise for message with ID '${messageId}'.`);
        this._sendStanzaPromises[messageId].resolve(data);
        delete this._sendStanzaPromises[messageId];
        if (this._sendTimeouts[messageId])
            delete this._sendTimeouts[messageId];
    }
    _rejectSendStanzaPromise(messageId, data) {
        if (!this._sendStanzaPromises[messageId])
            return;
        this._log(`Rejecting send stanza promise for message with ID '${messageId}'.`);
        this._sendStanzaPromises[messageId].reject(data);
        delete this._sendStanzaPromises[messageId];
        if (this._sendTimeouts[messageId])
            delete this._sendTimeouts[messageId];
    }
    /**
 * Method which converts a JSON stanza to XML and then sends it over the socket
 * @param stanza
 * @param store - Hint to ejabberd that this message should be stored in the MAM
 * @returns {Promise}
 */
    sendStanza(stanza, store = true) {
        this._isMethodReady(true, true);
        return new es6_promise_1.Promise((resolve, reject) => {
            // Add stanza ID if it doesn't already have one
            if (!stanza.$attributes)
                stanza.$attributes = {};
            if (stanza.$attributes.id === undefined) {
                stanza.$attributes.id = this.getUniqueId();
            }
            let messageId = stanza.$attributes.id;
            if (this.connected === true && this._connection !== null) {
                this._sendStanzaPromises[messageId] = {
                    resolve: resolve,
                    reject: reject
                };
                // Create a timer for each sent stanza to ensure the promise gets resolved if there is no response from the server
                this._sendTimeouts[messageId] = new timer_1.default(messageId, () => {
                    const msg = `Message with ID '${messageId}' was not received by the server within ${this._options.sendTimeout}ms.`;
                    this._log(msg, stanza);
                    this._rejectSendStanzaPromise(messageId, msg);
                }, this._options.sendTimeout);
                try {
                    if (stanza.$attributes === undefined) {
                        stanza.$attributes = {};
                    }
                    if (stanza.$attributes.from === undefined) {
                        stanza.$attributes.from = this._jid;
                    }
                    if (store === true) {
                        // Add the store hint to ensure all messages get persisted in the MAM
                        stanza.store = {
                            "$attributes": {
                                "xmlns": CtXmppClient.NAMESPACES.HINTS
                            },
                            "$value": ""
                        };
                    }
                    // Add a client timestamp to all messages
                    stanza.timestamp = {
                        "$attributes": {
                            "xmlns": CtXmppClient.NAMESPACES.CT_CLIENT_TIMESTAMP
                        },
                        "$value": Date.now()
                    };
                    const $xml = CtXmppClient.jsonToXml("message", stanza);
                    this._connection.send($xml);
                }
                catch (e) {
                    const msg = "Unable to send XMPP message";
                    this._onError(msg, e);
                    this._rejectSendStanzaPromise(messageId, msg);
                }
            }
            else {
                const msg = "You're not currently connected, please connect and try again.";
                this._onError(msg);
                this._rejectSendStanzaPromise(messageId, msg);
            }
        });
    }
    /**
     * Upload a message's attachments and then send the message
     * @param message
     * @param files
     * @returns {Promise<U>}
     * @private
     */
    _sendMessageWithAttachments(message, files) {
        if (!this._options.uploadHost)
            throw new Error("Cannot send attachments without a upload host configured.");
        this._log(`Sending message with ID ${message._id} with attachments:`, files);
        let promiseChain = es6_promise_1.Promise.resolve({});
        files.forEach((file, index) => {
            promiseChain = promiseChain
                .then(() => {
                return new es6_promise_1.Promise((resolve, reject) => {
                    // Get the size of the file, if encrypted get the unencrypted file size
                    File.getFileSize(file).then((size) => {
                        // Ask for an upload slot for each of the attachments
                        const uploadIq = {
                            "$attributes": {
                                "id": this.getUniqueId(),
                                "to": this._options.uploadHost,
                                "from": this._jid,
                                "type": "get",
                                "xmlns": CtXmppClient.NAMESPACES.JABBER_CLIENT
                            },
                            "request": {
                                "$attributes": {
                                    "xmlns": CtXmppClient.NAMESPACES.HTTP_UPLOAD,
                                },
                                "filename": file.name.replace(".encrypted", ""),
                                "size": "" + size,
                                "content-type": file.type
                            }
                        };
                        this.sendIq(this._options.uploadHost, "get", uploadIq).then(resolve).catch(reject);
                    }).catch(e => {
                        console.error(`Couldn't get file size for file with name '${file.name}'.`, e);
                        reject(e);
                    });
                });
            })
                .then((_stanza) => {
                return new es6_promise_1.Promise(resolve => {
                    // If the attachment endpoints are authenticated then we need to grab the password from the secure DB
                    if (this._options.authAttachments === true) {
                        this._getCacheItem("user_password").then(password => {
                            return this._embellishPasswordWithAdToken(password);
                        }).then(_password => {
                            resolve([_stanza, {
                                    "Authorization": "Basic " + btoa(this._bareJid + ":" + _password),
                                    "Content-Type": file.type
                                }]);
                        });
                    }
                    else {
                        // Otherwise we can just do the upload without any auth
                        resolve([_stanza, {
                                "Content-Type": file.type
                            }]);
                    }
                });
            })
                .then((result) => {
                const _stanza = result[0];
                const _headers = result[1];
                return new es6_promise_1.Promise((resolve, reject) => {
                    // The spec appears not to match reality - there are no headers?
                    // But here is the code that would match the XEP spec
                    // const headers = {};
                    //
                    // if (_stanza.iq.slot.put.header) {
                    //     _stanza.iq.slot.put.header.forEach(function (header) {
                    //         headers[header.name] = header.value;
                    //     });
                    // }
                    const put = _stanza.iq.slot.put;
                    const get = _stanza.iq.slot.get;
                    File.upload(file.path, put, get, _headers).then(() => {
                        this._dispatchEvent(CtXmppClient.EVENT_TYPES.UPLOAD_SUCCESS, message);
                        resolve(["transferred", get, put]);
                    }).catch((e) => {
                        this._dispatchEvent(CtXmppClient.EVENT_TYPES.UPLOAD_FAILED, message);
                        const msg = `Couldn't successfully upload file '${file.path}' to the server:`;
                        this._onError(msg, e);
                        reject({ error: msg, message });
                    });
                });
            })
                .then((result) => {
                const _state = result[0];
                const _get = result[1];
                const _put = result[2];
                return new es6_promise_1.Promise((resolve, reject) => {
                    this.saveMessage(message._id, (_message) => {
                        _message.attachments[index].state = _state;
                        _message.attachments[index].get = _get;
                        _message.attachments[index].put = _put;
                        if (environment_1.isBrowser()) {
                            // If we are in the browser we always want to read from the get URL
                            _message.attachments[index].path = _get;
                        }
                        return _message;
                    }).then(resolve).catch(reject);
                });
            });
        });
        return promiseChain.then(() => {
            return this.resendMessage(message._id);
        });
    }
    _prepareMessageAttachmentsForSend(stanza, attachments) {
        this._log("Preparing to send the following attachments:", attachments);
        return new es6_promise_1.Promise((resolve, reject) => {
            const proms = [];
            attachments.forEach((filePath) => {
                proms.push(new es6_promise_1.Promise((_resolve, _reject) => {
                    this._log("Getting file information for file:", filePath);
                    File.getFileInfo(filePath).then((fileInfo) => {
                        this._log("Got file info for file:", fileInfo);
                        _resolve(Object.assign({ get: "", put: "", state: "transferring" }, fileInfo));
                    }).catch(_reject);
                }));
            });
            es6_promise_1.Promise.all(proms).then((_attachments) => {
                // Put the message in the database, we don't want to send it until the attachments have finished uploading to the server
                this._messageStanzaToDbObject({
                    "message": stanza
                }, {
                    "mine": true,
                    "attachments": _attachments
                }).then((message) => {
                    // Tell outer application that the upload process has started, so the UI can be refreshed
                    this._dispatchEvent(CtXmppClient.EVENT_TYPES.UPLOAD_STARTED, message);
                    // Upload and send the message
                    this._sendMessageWithAttachments(message, _attachments).then(resolve).catch(reject);
                }).catch(reject);
            });
        });
    }
    /**
     * Abstraction of the sendMessage method to make sending a peer-to-peer chat message easier
     * @param to {string}
     * @param body {string}
     * @param data {object}
     * @param attachments {string[]} - Array of file paths to be sent as attachments
     * @returns {Promise}
     */
    sendChatMessage(to, body, data, attachments = [], markable = true) {
        this._isMethodReady(true, true);
        if (!to)
            throw new Error("Parameter 'to' is required.");
        if (this._options.mucHost && to.indexOf(this._options.mucHost) > -1)
            throw new Error("You are trying to send a peer-to-peer chat message to a room, please use the 'sendGroupChatMessage' method instead.");
        return new es6_promise_1.Promise((resolve, reject) => {
            // Construct the message stanza
            const stanza = {
                "$attributes": {
                    "id": this.getUniqueId(),
                    "from": this._jid,
                    "to": to,
                    "type": "chat",
                    "xmlns": CtXmppClient.NAMESPACES.JABBER_CLIENT
                }
            };
            if (markable === true) {
                stanza.markable = {
                    $attributes: {
                        xmlns: CtXmppClient.NAMESPACES.CHAT_MARKERS
                    }
                };
            }
            if (body !== null) {
                stanza.body = body;
            }
            if (data !== null) {
                stanza.data = data;
            }
            // If we don't have any attachments, just send the message
            if (attachments.length < 1) {
                this.sendMessage(stanza).then(resolve).catch(reject);
                // If we do then prepare the attachments and message object then start the upload and send process
            }
            else {
                this._prepareMessageAttachmentsForSend(stanza, attachments).then(resolve).catch(reject);
            }
        });
    }
    /**
     * Send a multicast message
     * @param addresses {object[]} - in the form [{ type, jid, desc },...]
     * @param body {string}
     * @param data {object}
     * @param attachments {string[]}
     * @param markable {Boolean}
     * @returns {Promise}
     */
    sendMulticastMessage(addresses, body, data, attachments = [], markable = true) {
        this._isMethodReady(true, true);
        return new es6_promise_1.Promise((resolve, reject) => {
            const stanza = {
                "$attributes": {
                    "id": this.getUniqueId(),
                    "from": this._jid,
                    "to": `${this._options.multicastHost}`,
                    "type": "chat",
                    "xmlns": CtXmppClient.NAMESPACES.JABBER_CLIENT
                },
                "addresses": {
                    "$attributes": {
                        "xmlns": CtXmppClient.NAMESPACES.ADDRESS
                    },
                    "address": addresses.map((address) => {
                        return {
                            "$attributes": address
                        };
                    })
                }
            };
            if (markable === true) {
                stanza.markable = {
                    $attributes: {
                        xmlns: CtXmppClient.NAMESPACES.CHAT_MARKERS
                    }
                };
            }
            if (body !== null) {
                stanza.body = body;
            }
            if (data !== null) {
                stanza.data = data;
            }
            // If we don't have any attachments, just send the message
            if (attachments.length < 1) {
                this.sendMessage(stanza).then(resolve).catch(reject);
                // If we do then prepare the attachments and message object then start the upload and send process
            }
            else {
                this._prepareMessageAttachmentsForSend(stanza, attachments).then(resolve).catch(reject);
            }
        });
    }
    /**
 * Abstraction of the sendStanza method to make sending a group message easier
 * @param roomName {string}
 * @param body {string}
 * @param data {object}
 * @param attachments {string[]}
 * @param markable {boolean}
 * @returns {Promise}
 */
    sendGroupChatMessage(roomName, body, data, attachments = [], markable = true, personalMam = false) {
        this._isMethodReady(true, true);
        if (!this._options.mucHost)
            throw new Error("'mucHost' must be provided as an option.");
        if (!roomName)
            throw new Error("Parameter 'roomName' is required.");
        return new es6_promise_1.Promise((resolve, reject) => {
            const stanza = {
                $attributes: {
                    id: this.getUniqueId(),
                    from: this._jid,
                    to: `${roomName}@${this._options.mucHost}`,
                    type: "groupchat",
                    xmlns: CtXmppClient.NAMESPACES.JABBER_CLIENT
                }
            };
            if (markable === true) {
                stanza.markable = {
                    $attributes: {
                        xmlns: CtXmppClient.NAMESPACES.CHAT_MARKERS
                    }
                };
            }
            if (body !== null) {
                stanza.body = body;
            }
            if (data !== null) {
                stanza.data = data;
            }
            if (personalMam !== true) {
                stanza.exclude = {
                    $attributes: {
                        xmlns: CtXmppClient.NAMESPACES.INFINITY_MAM,
                        archive: "user"
                    }
                };
            }
            // If we don't have any attachments, just send the message
            if (attachments.length < 1) {
                this.sendMessage(stanza).then(resolve).catch(reject);
                // If we do then prepare the attachments and message object then start the upload and send process
            }
            else {
                this._prepareMessageAttachmentsForSend(stanza, attachments).then(resolve).catch(reject);
            }
        });
    }
    sendMessage(stanza) {
        return new es6_promise_1.Promise((resolve, reject) => {
            // First save the message locally
            this._messageStanzaToDbObject({
                "message": stanza
            }, {
                state: { "sent": false },
                mine: true
            }).then((result) => {
                // Then attempt to send
                this.sendStanza(stanza).then(() => {
                    // If it gets sent successfully then update the message state to sent = true
                    this.saveMessage(result._id, (message) => {
                        message.state.sent = true;
                        return message;
                    }).then(resolve).catch(reject);
                }).catch(reject);
            }).catch(reject);
        });
    }
    /**
     * Method to send an IQ message over the socket and return its response
     * @param to
     * @param type
     * @param payload
     * @param timeout
     * @param id
     * @returns {Promise}
     */
    sendIq(to, type, payload, timeout = 5000, id) {
        this._isMethodReady(true, true);
        const _id = (id === undefined) ? this.getUniqueId() : id;
        return new es6_promise_1.Promise((resolve, reject) => {
            const disconnectCallback = (status) => {
                if (status.id === index_1.default.Strophe.Status.DISCONNECTED) {
                    this.removeEventListener(CtXmppClient.EVENT_TYPES.STATUS, disconnectCallback);
                    reject(`Disconnected during IQ request.`);
                }
            };
            this.addEventListener(CtXmppClient.EVENT_TYPES.STATUS, disconnectCallback);
            let _iq = null;
            try {
                _iq = {
                    "$attributes": {
                        "id": _id,
                        "type": type,
                        "from": this._connection.jid
                    }
                };
                if (to) {
                    _iq.$attributes.to = to;
                }
                for (let key in payload) {
                    _iq[key] = payload[key];
                }
            }
            catch (e) {
                this._onError("Couldn't construct IQ message:", e);
                reject(e);
            }
            if (_iq !== null) {
                const $xml = CtXmppClient.jsonToXml("iq", _iq);
                this._connection.sendIQ($xml, ($stanza) => {
                    try {
                        this.removeEventListener(CtXmppClient.EVENT_TYPES.STATUS, disconnectCallback);
                        resolve(CtXmppClient.xmlToJson($stanza));
                    }
                    catch (e) {
                        this._onError("Couldn't convert IQ response to JSON.", e);
                        reject(e);
                    }
                }, reject, timeout);
            }
        });
    }
    /**
     * Download stored JSON from Private XML Storage
     * @returns {Promise}
     * @private
     */
    getPrivateData() {
        this._isMethodReady(true, true);
        this._log("Fetching Private XML Data for:", this._bareJid);
        const query = {
            "privatexmldata": {
                "$attributes": {
                    "xmlns": CtXmppClient.NAMESPACES.CT_PRIVATE_XML_STORAGE
                }
            }
        };
        return new es6_promise_1.Promise((resolve, reject) => {
            return this._getPrivateXMLStorage(query).then((result) => {
                if (result !== undefined && result.privatexmldata !== undefined && result.privatexmldata.json !== undefined) {
                    resolve(JSON.parse(result.privatexmldata.json));
                }
                else {
                    reject("No private data found, or unable to fetch");
                }
            });
        });
    }
    /**
     * Download the private XML Storage for the supplied XML query
     * @param queryXML
     * @returns {Promise}
     * @private
     */
    _getPrivateXMLStorage(queryXML) {
        this._log("Fetching Private XML Storage Data for: ", this._bareJid);
        return new es6_promise_1.Promise((resolve, reject) => {
            this.sendIq(this._bareJid, "get", {
                "query": Object.assign({ "$attributes": {
                        "xmlns": CtXmppClient.NAMESPACES.PRIVATE_XML_STORAGE
                    } }, queryXML)
            }).then((result) => {
                this._log("Fetched Private XML Storage Data for:", this._bareJid);
                resolve(result.iq.query);
            }).catch((e) => {
                reject("Unable to send IQ for Private XML Storage");
            });
        });
    }
    /**
     * Given some JSON, wrap it in XML and then set it in Private XML Storage
     * @param data: A js object, that will be stringified and stored in Private XML Storage for the current user
     * @returns {Promise}
     * @private
     */
    setPrivateData(data) {
        this._isMethodReady(true, true);
        this._log("Setting Private XML data for:", this._bareJid);
        const strData = JSON.stringify(data);
        const queryData = {
            "privatexmldata": {
                "$attributes": {
                    "xmlns": CtXmppClient.NAMESPACES.CT_PRIVATE_XML_STORAGE
                },
                "json": strData
            }
        };
        return this._setPrivateXMLStorage(queryData);
    }
    /**
     * Given some XML (as json) use it to set in private XML Storage
     * @param jsonXml
     * @returns {Promise<void>}
     * @private
     */
    _setPrivateXMLStorage(jsonXml) {
        const query = {
            "query": Object.assign({ "$attributes": {
                    "xmlns": CtXmppClient.NAMESPACES.PRIVATE_XML_STORAGE
                } }, jsonXml)
        };
        return new es6_promise_1.Promise((resolve, reject) => {
            this.sendIq(null, "set", query)
                .then((result) => {
                resolve();
                this._log("Set Private XML Storage for:", this._bareJid);
            }).catch(reject);
        });
    }
    /**
     * Download a vCard by jid, return a Promise to the vCard as a string.
     * @param jid
     * @returns {Promise}
     * @private
     */
    _getvCard(jid) {
        this._log("🂡 Fetching vCard for:", jid);
        return new es6_promise_1.Promise((resolve, reject) => {
            this.sendIq(jid, "get", {
                "vCard": {
                    "$attributes": {
                        "xmlns": "vcard-temp"
                    }
                }
            })
                .then((result) => {
                this._log("Fetched vCard for:", jid);
                resolve(result.iq.vCard);
            }).catch((e) => {
                reject("Unable to send IQ for vCard");
            });
        });
    }
    /**
     * Upload Changed vCard to the server
     * @param jid
     * @param vCardStr
     * @returns {Promise}
     * @private
     */
    _setvCard(jid, vCardStr) {
        this._log("🂡 Setting vCard for:", jid);
        const doc = (new DOMParser()).parseFromString(vCardStr, 'text/xml');
        const jsonIq = CtXmppClient.xmlToJson(doc);
        return new es6_promise_1.Promise((resolve, reject) => {
            this.sendIq(null, "set", jsonIq["#document"])
                .then((result) => {
                resolve();
                this._log("🂡 Set vCard for:", jid);
            }).catch(reject);
        });
    }
    /**
     * Method used to add an event listener for valid event types
     * @param type
     * @param callback
     */
    addEventListener(type, callback) {
        if (!CtXmppClient._validateEventType(type)) {
            throw new Error("Invalid event type provided.");
        }
        if (type === CtXmppClient.EVENT_TYPES.INITIALISED && this._initialised === true) {
            callback(null);
        }
        else {
            if (this._eventListeners[type] === undefined) {
                this._eventListeners[type] = [];
            }
            this._eventListeners[type].push(callback);
        }
    }
    /**
     * Method used to remove event listeners
     * @param type
     * @param callback
     */
    removeEventListener(type, callback) {
        if (!CtXmppClient._validateEventType(type)) {
            throw new Error("Invalid event type provided.");
        }
        if (this._eventListeners[type] !== undefined) {
            this._eventListeners[type].forEach((cCallback, idx) => {
                if (cCallback === callback) {
                    this._eventListeners[type].splice(idx, 1);
                }
            });
        }
    }
    /**
     * Base method used to search all databases
     * @param db
     * @param query
     * @param sortFields
     * @param includeFields
     * @param limit
     * @param skip
     * @returns {Promise}
     * @private
     */
    _searchDb(db, query, sortFields, includeFields, limit, skip) {
        return new es6_promise_1.Promise((resolve, reject) => {
            const fields = [];
            for (let field in query) {
                if (field.indexOf("$") !== 0) {
                    fields.push(field);
                }
                else if (["$or", "$and", "$not", "$nor", "$all"].indexOf(field) > -1 && Array.isArray(query[field]) && query[field].length > 0) {
                    query[field].forEach((o) => {
                        for (let k in o) {
                            fields.push(k);
                        }
                    });
                }
            }
            if (fields.length > 0) {
                db.createIndex({
                    index: {
                        "fields": fields
                    }
                }).then(() => {
                    let findObj = {
                        "selector": query
                    };
                    if (Array.isArray(sortFields) && sortFields.length > 0) {
                        findObj.sort = sortFields;
                    }
                    if (Array.isArray(includeFields) && includeFields.length > 0) {
                        findObj.fields = includeFields;
                    }
                    if (skip) {
                        findObj.skip = skip;
                    }
                    if (limit) {
                        findObj.limit = limit;
                    }
                    db.find(findObj).then((result) => {
                        resolve(result.docs);
                    }).catch(reject);
                }).catch(reject);
            }
        });
    }
    /**
     * Interactions with the messages database
     */
    /**
     * Method to query the messages database to retrieve specific messages
     * @param {Object} query An object signature to match messages on
     * @param {string[]} [sortFields] Defines a list of fields defining how you want to sort. Note that sorted fields also have to be selected in the query.
     * @param {string[]} [includeFields] Defines a list of fields that you want to receive. If omitted, you get the full documents.
     * @param {number} [skip] Number of docs to skip before returning.
     * @param {number} [limit] Maximum number of documents to return.
     * @returns {Promise}
     */
    findMessages(query, sortFields, includeFields, limit, skip) {
        this._isMethodReady(true);
        return this._searchDb(this._msgDb, query, sortFields, includeFields, limit, skip);
    }
    /**
     * Convenience method to get all message IDs in the local database
     */
    getAllMessageIds() {
        this._isMethodReady(true);
        return new es6_promise_1.Promise((resolve, reject) => {
            this._msgDb.allDocs().then((results) => {
                let ids = [];
                if (results.rows && results.rows.length > 0) {
                    ids = results.rows.map((row) => {
                        return row.id;
                    });
                }
                resolve(ids);
            }).catch(reject);
        });
    }
    /**
     * Method used to fetch chat history for a specific recipient
     * @param recipient
     * @param sortFields
     * @param unread
     * @param limit
     * @param skip
     * @returns {Promise}
     */
    getChatHistory(recipient, sortFields, unread, limit, skip) {
        this._isMethodReady(true);
        // Sort is current broken in PouchDB :(
        // if (!sortFields) {
        //     sortFields = [{"ts": "desc"}];
        // }
        let query = {
            "$or": [
                { "sender_id": recipient },
                { "recipient_id": recipient }
            ]
        };
        if (unread === true) {
            query["state.read"] = true;
        }
        return new es6_promise_1.Promise((resolve, reject) => {
            this.findMessages(query, sortFields, null, limit, skip).then(results => {
                const messages = results.sort((a, b) => {
                    return a.ts - b.ts;
                });
                resolve(messages);
            }).catch(reject);
        });
    }
    getMessagesById(ids) {
        return this._msgDb.allDocs({ include_docs: true }).then(docs => {
            return docs.rows.filter(doc => {
                return ids.includes(doc.id);
            });
        });
    }
    /**
     * Get a message by its ID
     * @param id
     */
    getMessageById(id) {
        this._isMethodReady(true);
        if (!id)
            throw new Error(`A message ID must be provided.`);
        return this._msgDb.get(id);
    }
    /**
     * Method used to delete a single message by passing in the message object
     * @param message
     * @returns {Promise}
     */
    deleteMessage(message, deleteAttachments = true) {
        this._isMethodReady(true);
        return new es6_promise_1.Promise((resolve, reject) => {
            // Ignore if no message provided to method
            if (!message) {
                resolve();
            }
            else {
                const proms = [];
                if (deleteAttachments) {
                    // Also delete any attached files
                    if (message.attachments !== undefined) {
                        message.attachments.forEach((file) => {
                            if (file.path !== undefined) {
                                proms.push(new es6_promise_1.Promise((resolve) => {
                                    if (environment_1.getPlatformName() === "ios" && !file.path.includes("file://")) {
                                        file.path = `file://${file.path}`;
                                    }
                                    return File.deleteFile(file.path).then(resolve).catch(err => {
                                        this._onError(`Couldn't delete attachment: '${file.name}':`, err);
                                        resolve();
                                    });
                                }));
                            }
                        });
                    }
                }
                es6_promise_1.Promise.all(proms).then(() => {
                    this._msgDb.remove(message).then(() => {
                        this._log("Message successfully deleted with ID:", message._id);
                        resolve();
                    }).catch(e => {
                        this._onError(`Couldn't delete message with ID '${message._id}'.`, e);
                        reject(e);
                    });
                }).catch(e => {
                    this._onError(`Couldn't delete attachment(s) for message with ID '${message._id}':`, e);
                    reject(e);
                });
            }
        });
    }
    /**
     * Delete a message locally by the _id
     * @param {string} id
     * @param [deleteAttachments] - defaults to true
     * @returns {Promise}
     */
    deleteMessageById(id, deleteAttachments = true) {
        this._isMethodReady(true);
        this._log("Deleting message with ID:", id);
        return new es6_promise_1.Promise((resolve, reject) => {
            this.getMessageById(id).then(message => {
                this.deleteMessage(message, deleteAttachments).then(resolve).catch(reject);
            }).catch(e => {
                this._onError(`Couldn't get message with ID '${id}' to delete it.`, e);
                reject(e);
            });
        });
    }
    /**
     * Delete multiple messages locally based on a search query
     * @param {object} query
     * @returns {Promise}
     */
    deleteMessages(query) {
        this._isMethodReady(true);
        return new es6_promise_1.Promise((resolve, reject) => {
            this._searchDb(this._msgDb, query).then((results) => {
                this._log("🗑️ There are " + results.length + " messages to delete");
                const proms = [];
                results.forEach((message) => {
                    proms.push(this.deleteMessage(message));
                });
                es6_promise_1.Promise.all(proms).then(resolve).catch((e) => {
                    this._onError(`Couldn't delete messages from database.`, e);
                    reject(e);
                });
            });
        });
    }
    /**
     * Method to be DEPRECATED
     * @param {string} roomName - The name of the room for which all messages should be deleted
     * @returns {Promise}
     */
    deleteMessagesByRoom(roomName) {
        console.warn("This method is going to be DEPRECATED, please use 'deleteMessagesByRoomName' instead.");
        return this.deleteMessages({
            "$or": [
                { "sender_id": roomName },
                { "recipient_id": roomName }
            ]
        });
    }
    /**
     * Method to delete all messages from a single room by the room name
     * @param {string} roomName - The name of the room for which all messages should be deleted
     * @returns {Promise}
     */
    deleteMessagesByRoomName(roomName) {
        if (!this._options.mucHost)
            throw new Error("mucHost must be provided as an option.");
        return this.deleteMessages({
            "$or": [
                { "sender_id": `${roomName}@${this._options.mucHost}` },
                { "recipient_id": `${roomName}@${this._options.mucHost}` }
            ]
        });
    }
    /**
     * Used for efficient partial updates to a message object
     * @param messageId - The ID of the message
     * @param delta - Function which provides the current message as an argument and should return the updated message
     */
    saveMessage(messageId, delta) {
        this._isMethodReady(true);
        return new es6_promise_1.Promise((resolve, reject) => {
            this._saveObject(CtXmppClient.OBJECT_TYPES.MESSAGE, messageId, delta, (object) => {
                resolve(object);
            }, (e) => {
                reject(e);
            });
        });
    }
    /**
     * Private method to be used when a different user logs in
     * @returns {Promise}
     * @private
     */
    _clearDbsForNewUser() {
        return new es6_promise_1.Promise((resolve, reject) => {
            this.destroyDbs(false).then(() => {
                this._dispatchEvent(CtXmppClient.EVENT_TYPES.AUTO_DBS_DESTROYED, null);
                resolve();
            }).catch(reject);
        });
    }
    /**
     * Convenience method used to destroy all databases
     * @param dispatch {Boolean} - Whether to dispatch the DBS_DESTROYED event
     * @param keepCache {Boolean} - Whether to NOT remove the cache database
     * @returns {Promise}
     */
    destroyDbs(dispatch = true, keepCache = false) {
        return new es6_promise_1.Promise((resolve, reject) => {
            // Don't destroy if we're already doing so
            if (this._destroyingDbs) {
                resolve();
                return;
            }
            this._log("💣 Destroying all databases and data...");
            this._destroyingDbs = true;
            // Destroy any localStorage items also
            this._lastArchiveId = null;
            localStorage.removeItem(`${this._instanceId}_last_archive_id`);
            this.resource = null;
            localStorage.removeItem(`${this._instanceId}_resource`);
            localStorage.removeItem(`${this._instanceId}_counters`);
            // Remove the encryption key if stashed in local storage
            if (keepCache !== true)
                localStorage.removeItem(`${this._instanceId}_key`);
            // Remove the login in flag used to detect a failed login
            localStorage.removeItem(`${this._instanceId}_logging_in`);
            const proms = [this._msgDb.destroy(), this._contactDb.destroy(), this._roomDb.destroy(), this._participantDb.destroy()];
            if (Plugin.getSource("file") !== false)
                proms.push(File.deleteAttachments());
            if (keepCache !== true)
                proms.push(this._cacheDb.destroy());
            proms.push(new es6_promise_1.Promise((resolve, reject) => {
                if (this._userDirectory.initialised) {
                    localStorage.removeItem(`${this._instanceId}_ud_iv`);
                    this._userDirectory.destroy().then(() => {
                        resolve();
                    }).catch(reject);
                }
                else {
                    resolve();
                }
            }));
            es6_promise_1.Promise.all(proms).then(() => {
                this._initDbs().then(() => {
                    if (dispatch === true)
                        this._dispatchEvent(CtXmppClient.EVENT_TYPES.DBS_DESTROYED, null);
                    this._log("✅ Successfully destroyed all data.");
                    this._destroyingDbs = false;
                    resolve();
                }).catch(e => {
                    this._destroyingDbs = false;
                    reject(e);
                });
            }).catch(e => {
                this._destroyingDbs = false;
                reject(e);
            });
        });
    }
    deleteAttachments() {
        return File.deleteAttachments();
    }
    /**
     * Set the users current chat status
     * @param status
     * @param label
     * @param send
     * @param metadata
     * @returns {Promise}
     */
    setChatStatus(status, label, send, metadata) {
        this._isMethodReady(true);
        return new es6_promise_1.Promise((resolve, reject) => {
            if (CtXmppClient._validateChatStatus(status)) {
                const statusObject = {
                    status: status,
                    label: label,
                    metadata: metadata
                };
                if (!statusObject.label) {
                    switch (status) {
                        case CtXmppClient.CHAT_STATUSES.CHAT:
                            statusObject.label = "Available";
                            break;
                        case CtXmppClient.CHAT_STATUSES.AWAY:
                            statusObject.label = "Away";
                            break;
                        case CtXmppClient.CHAT_STATUSES.XA:
                            statusObject.label = "Extended Away";
                            break;
                        case CtXmppClient.CHAT_STATUSES.DND:
                            statusObject.label = "Do Not Disturb";
                            break;
                    }
                }
                this._setCacheItem("chat_status", statusObject).then(() => {
                    if (send === true)
                        this._sendPresence();
                    resolve(statusObject);
                }).catch(reject);
            }
            else {
                reject("Invalid chat status provided, one of 'away', 'chat', 'dnd' or 'xa' should be specified.");
            }
        });
    }
    /**
     * Method to return the users current chat status
     * @returns {Promise}
     */
    getChatStatus() {
        this._isMethodReady(true);
        return this._getCacheItem("chat_status");
    }
    /**
     * Method to set the client state
     * @param type
     */
    setClientState(type) {
        this._isMethodReady(true, true);
        if (!CtXmppClient._validateConstants(CtXmppClient.CLIENT_STATES, type))
            throw new Error("Invalid client state specified.");
        const $xml = CtXmppClient.jsonToXml(type, {
            $attributes: {
                xmlns: CtXmppClient.NAMESPACES.CLIENT_STATE_INDICATION
            }
        });
        return this._connection.send($xml);
    }
    /**
     * Interactions with the roster database
     */
    /**
     * Method to query the roster database to retrieve specific contacts
     * @param {Object} query An object signature to match contacts on
     * @param {string[]} [sortFields] Defines a list of fields defining how you want to sort. Note that sorted fields also have to be selected in the query.
     * @param {string[]} [includeFields] Defines a list of fields that you want to receive. If omitted, you get the full documents.
     * @param {number} [skip] Number of docs to skip before returning.
     * @param {number} [limit] Maximum number of documents to return.
     * @returns {Promise}
     */
    findContacts(query, sortFields, includeFields, limit, skip) {
        this._isMethodReady(true);
        return this._searchDb(this._contactDb, query, sortFields, includeFields, limit, skip);
    }
    /**
     * Method used to return a list of the users contacts
     * @returns {Promise}
     */
    getContacts() {
        this._isMethodReady(true);
        return new es6_promise_1.Promise((resolve, reject) => {
            this._contactDb.allDocs({ "include_docs": true }).then((results) => {
                const contacts = results.rows.filter((row) => {
                    //TODO: Figure out what to do with PouchDB views? Filtering them out for now
                    return (!row.doc.language);
                }).map((row) => {
                    return row.doc;
                });
                resolve(contacts);
            }).catch((error) => {
                this._onError(`Unable to get contacts from database.`, error);
                reject(error);
            });
        });
    }
    /**
     * Method to replace the token placeholder
     * @param {string} password
     * @returns {Promise<string | null>}
     * @private
     */
    _embellishPasswordWithAdToken(password) {
        if (!password)
            throw new Error("Password must be provided.");
        return new es6_promise_1.Promise((resolve, reject) => {
            // Determine if we need to acquire an AD token from the current user session on desktop
            if (environment_1.isElectron() === true &&
                environment_1.isWindows() === true &&
                this._options.adTokenPlaceholder &&
                this._options.adSecurityPackage &&
                this._options.adSpn &&
                password.indexOf(this._options.adTokenPlaceholder) > -1) {
                const sspi = Plugin.getSource("sspiclient");
                if (sspi !== false) {
                    sspi.Helper.getUserToken((token) => {
                        resolve(password.replace(this._options.adTokenPlaceholder, token));
                    }, reject, this._options.adSpn, this._options.adSecurityPackage);
                }
                else {
                    reject("Couldn't access sspiclient plugin.");
                }
            }
            else {
                resolve(password);
            }
        });
    }
    /**
     * Methods to deal with chat markers: Read & Acknowledged
     */
    /**
     * Convenience method to determine if a message should be marked or not
     * @param message
     * @param type
     * @returns {boolean}
     * @private
     */
    _shouldMarkMessage(message, type) {
        let result = true;
        // Don't mark a message if it isn't markable
        if (message.markable === false)
            return false;
        // We need to figure out if we've already marked this message with this type
        message.state.markers.every((marker) => {
            if (marker.type === type) {
                if (message.type === "groupchat" && marker.sender_resource === this.username) {
                    result = false;
                    return false;
                }
                else if (marker.sender_id === this._jid) {
                    result = false;
                    return false;
                }
            }
            return true;
        });
        return result;
    }
    /**
     * Mark a single message
     * @param {Object} message - The entire message object to be marked as received
     * @param {String} type - The type of marker (i.e. received, read or acknowledged)
     * @param {Boolean} dispatch - Whether or not to dispatch the message updated event
     * @returns {Promise}
     */
    _markMessage(message, type, dispatch = true) {
        return new es6_promise_1.Promise((resolve, reject) => {
            // If this is our message, or if this message has already been marked with this type before, or if the message hasn't been flagged as markable just resolve
            if (message.mine === true || this._shouldMarkMessage(message, type) === false) {
                resolve(message);
            }
            else {
                // Mark the message as received via chat markers
                const markerMessage = {
                    "$attributes": {
                        "id": this.getUniqueId(),
                        "to": index_1.default.Strophe.getBareJidFromJid(message.stanza.message.$attributes.from),
                        "from": this._connection.jid,
                    },
                    "timestamp": {
                        "$attributes": {
                            "xmlns": CtXmppClient.NAMESPACES.CT_CLIENT_TIMESTAMP
                        },
                        "$value": Date.now()
                    },
                };
                markerMessage[type] = {
                    "$attributes": {
                        "xmlns": CtXmppClient.NAMESPACES.CHAT_MARKERS,
                        "id": message._id
                    }
                };
                if (message.type === "groupchat") {
                    markerMessage.$attributes.type = "groupchat";
                }
                this.sendStanza(markerMessage).then(() => {
                    this.saveMessage(message._id, (doc) => {
                        doc.state[type] = true;
                        return doc;
                    }).then((message) => {
                        if (dispatch !== false)
                            this._dispatchEvent(CtXmppClient.EVENT_TYPES.MESSAGE_UPDATED, message);
                        resolve(message);
                    }).catch(reject);
                }).catch(reject);
            }
        });
    }
    /**
     * Mark Message Read
     */
    /**
     * Abstraction of the markMessage method to quickly mark a single message as read
     * @param message - The message object
     * @returns {Promise<Interfaces.XmppMessageObject>}
     */
    markMessageRead(message) {
        this._isMethodReady(true, true);
        return this._markMessage(message, CtXmppClient.MARKER_TYPES.READ);
    }
    /**
     * Abstraction of the markMessage method to quick mark a single message as read by message ID
     * @param messageId - The ID of the message
     * @returns {Promise<Interfaces.XmppMessageObject>}
     */
    markMessageReadById(messageId) {
        this._isMethodReady(true, true);
        return this.getMessageById(messageId).then((message) => {
            return this.markMessageRead(message);
        });
    }
    /**
     * Mark Message Acknowledged
     */
    /**
     * Abstraction of the markMessage method to quickly mark a single message as acknowledged
     * @param message - The message object
     * @returns {Promise<Interfaces.XmppMessageObject>}
     */
    markMessageAcknowleged(message) {
        this._isMethodReady(true, true);
        return this._markMessage(message, CtXmppClient.MARKER_TYPES.ACKNOWLEDGED);
    }
    /**
     * Abstraction of the markMessage method to quick mark a single message as acknowledged by message ID
     * @param messageId - The ID of the message
     * @returns {Promise<Interfaces.XmppMessageObject>}
     */
    markMessageAcknowledgedById(messageId) {
        this._isMethodReady(true, true);
        return this.getMessageById(messageId).then((message) => {
            return this.markMessageAcknowleged(message);
        });
    }
    /**
     * Private method used to dispatch an event of a specific type
     * @param type
     * @param data
     * @private
     */
    _dispatchEvent(type, data) {
        if (!CtXmppClient._validateEventType(type)) {
            throw new Error("Invalid event type provided.");
        }
        if (this._eventListeners[type] !== undefined) {
            this._eventListeners[type].forEach((callback) => {
                callback(data);
            });
        }
    }
    /**
     * MUCSub - Multi-User Chat Subscription
     * Methods which interface with MUCSub allowing for the creation of and subscription to chat rooms
     */
    /**
     * Method used to create a non-anonymous room
     * @param roomName
     * @returns {Promise}
     */
    createRoom(roomName) {
        this._isMethodReady(true, true);
        if (!this._options.mucHost)
            throw new Error("mucHost must be provided as an option.");
        return new es6_promise_1.Promise((resolve, reject) => {
            const to = `${roomName}@${this._options.mucHost}`;
            let $pres = {
                "$attributes": {
                    "to": `${to}/${this.username}`,
                    "xmlns": CtXmppClient.NAMESPACES.JABBER_CLIENT
                },
                "x": {
                    "$attributes": {
                        "xmlns": CtXmppClient.NAMESPACES.MUC
                    }
                }
            };
            this._connection.addHandler($stanza => {
                const stanza = CtXmppClient.xmlToJson($stanza);
                if (stanza.$attributes !== undefined && stanza.$attributes.type === "error") {
                    const error = new Error(`Failed to create room '${roomName}'.`);
                    this._onError(`Unable to create room with name '${roomName}'.`, error);
                    reject(error);
                }
                else {
                    // Query the room for configuration options
                    this.sendIq(to, "get", {
                        "query": {
                            "$attributes": {
                                "xmlns": CtXmppClient.NAMESPACES.MUC_OWNER
                            }
                        }
                    }).then(() => {
                        // Set the whois configuration to be anyone so we can get users actual JIDs
                        this.sendIq(to, "set", {
                            "query": {
                                "$attributes": {
                                    "xmlns": CtXmppClient.NAMESPACES.MUC_OWNER
                                },
                                "x": {
                                    "$attributes": {
                                        "xmlns": CtXmppClient.NAMESPACES.X_DATA,
                                        "type": "submit"
                                    },
                                    "field": [
                                        {
                                            "$attributes": {
                                                "var": "muc#roomconfig_whois"
                                            },
                                            "value": "anyone"
                                        }
                                    ]
                                }
                            }
                        }).then(() => {
                            // TODO: Handle room creation errors and on success add new room to local DB
                            this._log(`Room '${roomName}' successfully created.`);
                            resolve();
                        }).catch((error) => reject);
                    }).catch((error) => reject);
                }
                return false;
            }, CtXmppClient.NAMESPACES.MUC, "presence", null, null, `${to}/${this.username}`, { ignoreNamespaceFragment: true });
            this._connection.send(CtXmppClient.jsonToXml("presence", $pres));
        });
    }
    /**
     * Method used to destroy a room on the server
     * @param roomName
     * @returns {Promise}
     */
    destroyRoom(roomName) {
        this._isMethodReady(true, true);
        if (!roomName)
            throw new Error("Parameter 'roomName' must be provided.");
        if (!this._options.mucHost)
            throw new Error("mucHost must be provided as an option.");
        return new es6_promise_1.Promise((resolve, reject) => {
            this.sendIq(`${roomName}@${this._options.mucHost}`, "set", {
                "query": {
                    "$attributes": {
                        "xmlns": CtXmppClient.NAMESPACES.MUC_OWNER
                    },
                    "destroy": {}
                }
            }).then(() => {
                // TODO: Handle room destroy errors and on success remove room from local DB
                resolve();
            }).catch((error) => reject);
        });
    }
    /**
     * Method used to list all rooms the client knows about and also query the server for the list of rooms
     * @param queryServer
     * @returns {Promise}
     */
    listRooms(queryServer) {
        this._isMethodReady(true, true);
        if (!this._options.mucHost)
            throw new Error("mucHost must be provided as an option.");
        return new es6_promise_1.Promise((resolve, reject) => {
            const fetchFromDb = () => {
                this._roomDb.allDocs({
                    include_docs: true
                }).then(docs => {
                    const rooms = docs.rows.map(row => {
                        return row.doc;
                    });
                    resolve(rooms);
                }).catch(error => {
                    this._onError(`Couldn't fetch list of rooms from database.`, error);
                    reject(error);
                });
            };
            // If we don't have an active connection or the user request we don't contact the server then we just get the local results
            if (this.connected === true && queryServer !== false) {
                // Otherwise contact the server and merge any updates to the local database
                this.sendIq(this._options.mucHost, "get", {
                    "query": {
                        "$attributes": {
                            "xmlns": "http://jabber.org/protocol/disco#items"
                        }
                    }
                }).then((stanza) => {
                    if (stanza.iq && stanza.iq.query && stanza.iq.query.item) {
                        let rooms = [];
                        // If there are multiple rooms then iterate over them
                        if (Array.isArray(stanza.iq.query.item)) {
                            rooms = stanza.iq.query.item.map((room) => {
                                return {
                                    "_id": room.$attributes.jid,
                                    "name": index_1.default.Strophe.getNodeFromJid(room.$attributes.jid)
                                };
                            });
                            // Or if there is just one, add it to the array
                        }
                        else {
                            rooms = [{
                                    "_id": stanza.iq.query.item.$attributes.jid,
                                    "name": index_1.default.Strophe.getNodeFromJid(stanza.iq.query.item.$attributes.jid)
                                }];
                        }
                        this._roomDb.allDocs({
                            include_docs: true
                        }).then(docs => {
                            const proms = [];
                            // Go through each of the current rooms and compare against the rooms from the server
                            // to figure out which ones we want need to delete
                            docs.rows.forEach((row) => {
                                let cRoom = row.doc;
                                let nRoom = null;
                                rooms.every((room) => {
                                    if (room._id === cRoom._id) {
                                        nRoom = room;
                                        return false;
                                    }
                                    return true;
                                });
                                if (nRoom === null) {
                                    // Room doesn't exist on the server anymore, so delete it locally
                                    proms.push(this._roomDb.remove(cRoom));
                                }
                            });
                            // For either of the new rooms, either add them or update them
                            rooms.forEach((nRoom) => {
                                const update = new es6_promise_1.Promise((resolve, reject) => {
                                    this.saveRoom(nRoom._id, (cRoom) => {
                                        if (cRoom._id !== undefined) {
                                            // Need to update the room
                                            if (cRoom.name !== nRoom.name) {
                                                cRoom.name = nRoom.name;
                                            }
                                            cRoom.updated_at = this.getSyncedTimestamp(Date.now());
                                        }
                                        else {
                                            // Need to create the room
                                            cRoom = {
                                                "_id": nRoom._id,
                                                "name": nRoom.name,
                                                "ts": this.getSyncedTimestamp(Date.now()),
                                                "updated_at": null
                                            };
                                        }
                                        return cRoom;
                                    }).then(resolve).catch(reject);
                                });
                                proms.push(update);
                            });
                            es6_promise_1.Promise.all(proms).then(() => {
                                fetchFromDb();
                            }).catch((e) => {
                                this._onError("Couldn't merge list of rooms from server with locally stored list of rooms.", e);
                                reject(e);
                            });
                        });
                        resolve(rooms);
                    }
                    else {
                        // No rooms on the server
                        resolve([]);
                    }
                }).catch(reject);
            }
            else {
                fetchFromDb();
            }
        });
    }
    /**
     * Method used to list users MUC subscriptions
     * @returns {Promise}
     */
    listSubscriptions() {
        this._isMethodReady(true, true);
        return new es6_promise_1.Promise((resolve, reject) => {
            // If no mucHost registered then just return an empty result set
            if (!this._options.mucHost) {
                resolve([]);
            }
            else {
                this.sendIq(this._options.mucHost, "get", {
                    "subscriptions": {
                        "$attributes": {
                            "xmlns": CtXmppClient.NAMESPACES.MUC_SUB
                        }
                    }
                }).then((stanza) => {
                    let subscriptions = [];
                    if (stanza.iq && stanza.iq.subscriptions && stanza.iq.subscriptions.subscription) {
                        if (Array.isArray(stanza.iq.subscriptions.subscription)) {
                            subscriptions = stanza.iq.subscriptions.subscription.map(sub => {
                                if (sub.$attributes && sub.$attributes.jid) {
                                    return {
                                        "name": index_1.default.Strophe.getNodeFromJid(sub.$attributes.jid),
                                        "jid": sub.$attributes.jid
                                    };
                                }
                            });
                        }
                        else {
                            if (stanza.iq.subscriptions.subscription.$attributes && stanza.iq.subscriptions.subscription.$attributes.jid) {
                                subscriptions = [{
                                        "name": index_1.default.Strophe.getNodeFromJid(stanza.iq.subscriptions.subscription.$attributes.jid),
                                        "jid": stanza.iq.subscriptions.subscription.$attributes.jid
                                    }];
                            }
                        }
                    }
                    resolve(subscriptions);
                }).catch(reject);
            }
        });
    }
    /**
     * Method used to join a room by name as a participant
     * @param roomName
     * @returns {Promise}
     */
    joinRoom(roomName) {
        this._isMethodReady(true, true);
        if (!this._options.mucHost)
            throw new Error("'mucHost' must be provided as an option.");
        if (!roomName)
            throw new Error("Parameter 'roomName' must be provided.");
        return new es6_promise_1.Promise((resolve, reject) => {
            // NOTE: I've not implemented reserved nick functionality, see https://xmpp.org/extensions/xep-0045.html#reservednick
            // The reason for this is that the current XMPP server doesn't appear to support this it returns "service-unavailable"
            // and we don't yet have a requirement for this
            const roomJid = `${roomName}@${this._options.mucHost}`;
            this._createPresenceObject().then(($pres) => {
                $pres.$attributes.to = `${roomJid}/${this.username}`;
                $pres.x = {
                    "$attributes": {
                        "xmlns": CtXmppClient.NAMESPACES.MUC
                    },
                    "history": {
                        "$attributes": {
                            "maxchars": 0 // Don't get any history from the room we will do this with the MAM so we can get chat markers too
                        }
                    }
                };
                // Handler used to catch initial room join presence
                this._connection.addHandler(($stanza) => {
                    try {
                        const stanza = CtXmppClient.xmlToJson($stanza);
                        if (!stanza.presence || stanza.presence.error !== undefined) {
                            this._onError(`Couldn't join room '${roomName}' with nick '${this.username}'.`, $stanza);
                            reject($stanza);
                        }
                        else {
                            this.saveRoom(roomJid, (_room) => {
                                //TODO: Merge duplicate code with listRooms
                                if (_room._id !== undefined) {
                                    if (_room.name !== roomName) {
                                        _room.name = roomName;
                                        _room.updated_at = this.getSyncedTimestamp(Date.now());
                                    }
                                }
                                else {
                                    // Need to create the room
                                    _room = {
                                        "_id": roomJid,
                                        "name": roomName,
                                        "ts": this.getSyncedTimestamp(Date.now()),
                                        "updated_at": null
                                    };
                                }
                                return _room;
                            }).then((room) => {
                                // Add this room to the _joinedRooms object so we know what rooms to send presence to
                                this._joinedRooms[roomName] = Date.now();
                                if (this._options.mam.auto !== false) {
                                    // Query the MAM for any missed messages
                                    this.queryMamByRoomName(roomName).then(() => {
                                        resolve(room);
                                    }).catch(reject);
                                }
                                else {
                                    resolve(room);
                                }
                            }).catch(reject);
                        }
                    }
                    catch (e) {
                        this._onError("Couldn't convert stanza XML to JSON", e);
                        reject(e);
                    }
                    return false;
                }, CtXmppClient.NAMESPACES.JABBER_CLIENT, "presence", null, null, `${roomName}@${this._options.mucHost}/${this.username}`, { ignoreNamespaceFragment: true });
                this._connection.send(CtXmppClient.jsonToXml("presence", $pres));
            });
        });
    }
    /**
     * Method used to leave an already joined room
     * @param roomName
     * @returns {Promise}
     */
    leaveRoom(roomName) {
        this._isMethodReady(true, true);
        if (!this._options.mucHost)
            throw new Error("'mucHost' must be provided as an option.");
        if (!roomName)
            throw new Error("Parameter 'roomName' must be provided.");
        return new es6_promise_1.Promise((resolve) => {
            const $pres = {
                "$attributes": {
                    "from": this._jid,
                    "xmlns": CtXmppClient.NAMESPACES.JABBER_CLIENT,
                    "to": `${roomName}@${this._options.mucHost}/${this.username}`,
                    "type": "unavailable"
                }
            };
            this._connection.send(CtXmppClient.jsonToXml("presence", $pres));
            // Remove the room from the _joinedRoom object
            delete this._joinedRooms[roomName];
            resolve();
        });
    }
    /**
     * Method used to create a new subscription to a room by name
     * @param roomName
     * @param nodes
     * @returns {Promise}
     */
    subscribeToRoom(roomName, nodes) {
        this._isMethodReady(true, true);
        if (!this._options.mucHost)
            throw new Error("mucHost must be provided as an option.");
        if (!roomName)
            throw new Error("Parameter 'roomName' must be provided.");
        return new es6_promise_1.Promise((resolve, reject) => {
            const payload = {
                "subscribe": {
                    "$attributes": {
                        "xmlns": CtXmppClient.NAMESPACES.MUC_SUB,
                        "nick": this.username
                    }
                }
            };
            if (!nodes) {
                nodes = [];
                for (let key in CtXmppClient.MUC_NODES) {
                    nodes.push(CtXmppClient.MUC_NODES[key]);
                }
            }
            if (nodes.length > 0) {
                payload.subscribe.event = [];
                nodes.forEach((node) => {
                    payload.subscribe.event.push({
                        "$attributes": {
                            "node": node
                        }
                    });
                });
            }
            this.sendIq(`${roomName}@${this._options.mucHost}`, "set", payload).then((stanza) => {
                if (stanza.iq && stanza.iq.subscribe) {
                    resolve(stanza);
                }
                else {
                    this._onError(`Couldn't subscribe to room '${roomName}.'`, stanza);
                }
            }).catch(reject);
        });
    }
    /**
     * Method used to list the JIDs of user which are currently subscribed to the specified room - room moderator privileges required
     * @param roomName
     * @returns {Promise}
     */
    listSubscribedUsersForRoom(roomName) {
        this._isMethodReady(true, true);
        if (!this._options.mucHost)
            throw new Error("mucHost must be provided as an option.");
        return new es6_promise_1.Promise((resolve, reject) => {
            this.sendIq(`${roomName}@${this._options.mucHost}`, "get", {
                "subscriptions": {
                    "$attributes": {
                        "xmlns": CtXmppClient.NAMESPACES.MUC_SUB
                    },
                }
            }).then((stanza) => {
                let jids = [];
                if (stanza.iq && stanza.iq.subscriptions !== undefined) {
                    if (Array.isArray(stanza.iq.subscriptions.subscription)) {
                        jids = stanza.iq.subscriptions.subscription.map((sub) => {
                            if (sub.$attributes && sub.$attributes.jid !== undefined) {
                                return sub.$attributes.jid;
                            }
                        });
                    }
                    else if (stanza.iq.subscriptions.subscription !== undefined) {
                        const sub = stanza.iq.subscriptions.subscription;
                        if (sub.$attributes && sub.$attributes.jid !== undefined) {
                            jids = [sub.$attributes.jid];
                        }
                    }
                }
                resolve(jids);
            }).catch(reject);
        });
    }
    /**
     * Method used to remove a subscription to a room by name
     * @param roomName
     * @returns {Promise}
     */
    unsubscribeFromRoom(roomName) {
        this._isMethodReady(true, true);
        if (!this._options.mucHost)
            throw new Error("mucHost must be provided as an option.");
        return new es6_promise_1.Promise((resolve, reject) => {
            this.sendIq(`${roomName}@${this._options.mucHost}`, "set", {
                "unsubscribe": {
                    "$attributes": {
                        "xmlns": CtXmppClient.NAMESPACES.MUC_SUB
                    },
                }
            }).then(resolve).catch(reject);
        });
    }
    /**
     * Get a room by its DB ID (_id)
     * @param id
     */
    getRoomById(id) {
        this._isMethodReady(true);
        if (!id)
            throw new Error(`A room ID must be provided.`);
        this._log("Getting room with ID:", id);
        return this._roomDb.get(id);
    }
    /**
     * Method to query the room database to retrieve specific rooms
     * @param {Object} query An object signature to match rooms on
     * @param {string[]} [sortFields] Defines a list of fields defining how you want to sort. Note that sorted fields also have to be selected in the query.
     * @param {string[]} [includeFields] Defines a list of fields that you want to receive. If omitted, you get the full documents.
     * @param {number} [skip] Number of docs to skip before returning.
     * @param {number} [limit] Maximum number of documents to return.
     * @returns {Promise}
     */
    findRooms(query, sortFields, includeFields, limit, skip) {
        this._isMethodReady(true);
        return this._searchDb(this._roomDb, query, sortFields, includeFields, limit, skip);
    }
    /**
     * User to either save a new room object or udpate an existing one
     * @param roomJid - The JID of the room
     * @param delta - Function which provides the current room as an argument and should return the updated room
     */
    saveRoom(roomJid, delta) {
        this._isMethodReady(true);
        return new es6_promise_1.Promise((resolve, reject) => {
            this._saveObject(CtXmppClient.OBJECT_TYPES.ROOM, roomJid, delta, (object) => {
                resolve(object);
            }, (e) => {
                reject(e);
            });
        });
    }
    /**
     * User to either save a new room object or udpate an existing one
     * @param participantRoomJid - The participants room JID (e.g. test_room@conference.commontime.com/john_doe)
     * @param delta - Function which provides the current room as an argument and should return the updated room
     */
    saveParticipant(participantRoomJid, delta) {
        this._isMethodReady(true);
        return new es6_promise_1.Promise((resolve, reject) => {
            this._saveObject(CtXmppClient.OBJECT_TYPES.PARTICIPANT, participantRoomJid, delta, (object) => {
                resolve(object);
            }, (e) => {
                reject(e);
            });
        });
    }
    /**
     * Method use to list all participants assoicated to a room
     * @param roomName
     * @returns {Promise}
     */
    listParticipantsByRoom(roomName) {
        this._isMethodReady(true);
        return this._searchDb(this._participantDb, {
            "room_name": roomName
        });
    }
    /**
     * Method to get a single participant by room name and user JID
     * @param roomName
     * @param jid
     * @returns {Promise}
     */
    getParticipantByRoomAndJid(roomName, jid) {
        this._isMethodReady(true);
        return new es6_promise_1.Promise((resolve, reject) => {
            return this._searchDb(this._participantDb, {
                "room_name": roomName,
                "jid": jid
            }).then((results) => {
                if (results.length > 0) {
                    resolve(results[0]);
                }
                else {
                    resolve(null);
                }
            }).catch(reject);
        });
    }
    /**
     * Convenience method used to clean up the list of room participants based on a timestamp
     * @param ts
     * @returns {Promise}
     */
    purgeParticipantsByUpdatedAt(ts) {
        this._isMethodReady(true);
        return new es6_promise_1.Promise((resolve, reject) => {
            this._searchDb(this._participantDb, {
                "updated_at": {
                    "$lt": ts
                }
            }).then((results) => {
                const proms = results.map((doc) => {
                    return this._participantDb.remove(doc);
                });
                es6_promise_1.Promise.all(proms).then(resolve).catch(reject);
            }).catch((e) => {
                console.error(e);
            });
        });
    }
    /**
     * Methods interfacing with the Message Archive (XEP-0313)
     */
    /**
     * Private method to make recursive requests to the MAM to retrieve results, including paging through sets of data.
     * @param to {String}
     * @param archiveId {String}
     * @param backward {Boolean}
     * @param jid {String}
     * @param timestamp {Number}
     * @returns {Promise}
     * @private
     */
    _requestMessagesFromMam(to, archiveId = null, backward = false, jid = null, timestamp, max = this._options.mam.pageSize) {
        const _recursiveRequest = (successCallback, errorCallback, queryId, startDate, endDate, stanzas = [], _archiveId = null) => {
            const payload = {
                "query": {
                    "$attributes": {
                        "xmlns": CtXmppClient.NAMESPACES.MAM,
                        "queryid": queryId
                    },
                    "x": {
                        "$attributes": {
                            "xmlns": "jabber:x:data",
                            "type": "submit"
                        },
                        "field": [
                            {
                                "$attributes": {
                                    "var": "FORM_TYPE",
                                    "type": "hidden"
                                },
                                "value": CtXmppClient.NAMESPACES.MAM
                            }
                        ]
                    },
                    "set": {
                        "$attributes": {
                            "xmlns": CtXmppClient.NAMESPACES.RESULT_SET_MANAGEMENT
                        },
                        "max": "" + max
                    }
                }
            };
            this._log(`Querying the message archive for start date '${startDate}' and end date '${endDate}'.`);
            if (startDate !== null || backward === true) {
                let value = "";
                if (backward === true) {
                    // Enable conversation mode
                    value += "inf_conv_mode";
                }
                if (startDate !== null) {
                    value += startDate.toISOString();
                }
                payload.query.x.field.push({
                    "$attributes": {
                        "var": "start"
                    },
                    "value": value
                });
            }
            if (endDate !== null) {
                payload.query.x.field.push({
                    "$attributes": {
                        "var": "end"
                    },
                    "value": endDate.toISOString()
                });
            }
            if (_archiveId !== null) {
                payload.query.set[(backward === true) ? "before" : "after"] = _archiveId;
            }
            if (jid !== null) {
                payload.query.x.field.push({
                    "$attributes": {
                        "var": "with"
                    },
                    "value": jid
                });
            }
            // Set-up the connection handler to listen for the MAM messages
            this._connection.addHandler(($stanza) => {
                // Convert the stanza to JSON
                const stanza = CtXmppClient.xmlToJson($stanza);
                // Add any processable stanzas to the array
                try {
                    if (stanza.message.result !== undefined && stanza.message.result.forwarded !== undefined && stanza.message.result.forwarded.message !== undefined) {
                        const messageStanza = stanza.message.result.forwarded;
                        // HACK (Leon Revill): For some reason the server doesn't provide the archived node for multi-cast messages when fetched from the MAM
                        // we are assuming this is a server bug and patching it for now.
                        if (stanza.message.result.forwarded.message.archived === undefined && stanza.message.result !== undefined && stanza.message.result.$attributes !== undefined && stanza.message.result.$attributes.id !== undefined) {
                            messageStanza.message.archived = {
                                $attributes: {
                                    by: index_1.default.Strophe.getBareJidFromJid(messageStanza.message.$attributes.from),
                                    id: stanza.message.result.$attributes.id,
                                    xmlns: CtXmppClient.NAMESPACES.MAM_TMP
                                }
                            };
                        }
                        stanzas.push(messageStanza);
                    }
                }
                catch (e) {
                    // Message not in the expected format
                    errorCallback(e);
                    return false;
                }
                // Detect when we get the finished message from the MAM query so we know when we've got everything we asked for
                const finished = (stanza.message.fin !== undefined && stanza.message.fin.$attributes !== undefined && stanza.message.fin.$attributes.xmlns === CtXmppClient.NAMESPACES.MAM);
                // If we've finished then its time to process the messages
                if (finished === true) {
                    // Have we got all the messages?
                    if (stanza.message.fin.$attributes.complete == "true" || backward === true) {
                        // Yes so even if we haven't hit the limit yet we don't have any more to fetch
                        // Just return what we have
                        this._log(`Finished paging through result set, got a total of '${stanzas.length}' items.`);
                        successCallback(stanzas);
                    }
                    else {
                        this._log(`Paging through result set to get a total of '${stanza.message.fin.set.count}' items.`);
                        this._log(`Got '${stanzas.length}' items so far...`);
                        // No, continue to page through the results specifying the archive ID of the last message in the current page
                        _recursiveRequest(successCallback, errorCallback, queryId, startDate, endDate, stanzas, stanza.message.fin.set.last);
                    }
                }
                // Stop listening for message when we get the <fin> node (i.e. the server has finished sending messages from the MAM)
                return !finished;
            }, CtXmppClient.NAMESPACES.JABBER_CLIENT, "message", null, null, to);
            // Send the actual MAM query to start the whole process
            this.sendIq(to, "set", payload, null).catch((e) => {
                this._onError("Couldn't query the MAM:", e);
                errorCallback(e);
            });
        };
        let startDate = null;
        let endDate = null;
        if (timestamp !== null) {
            // Work out the date range for the query
            const endTs = Date.now();
            if (timestamp >= endTs)
                throw new Error(`The start timestamp (${timestamp}) cannot be equal to or larger than the end timestamp (${endTs}).`);
            startDate = new Date(timestamp);
            endDate = new Date(endTs);
        }
        return new es6_promise_1.Promise((resolve, reject) => {
            _recursiveRequest(resolve, reject, this.getUniqueId(), startDate, endDate, [], archiveId);
        });
    }
    /**
     * Method to initialise the MAM query, process the messages and emit events
     * @param to - The room JID or null if you want all messages
     * @param archiveId {Number} - The archive ID from the last message which the server should return messages from
     * @param jid {String} - The JID which each returned message should include
     * @param timeLimitTs {Number} - (ms) The maximum number of milliseconds (e.g. 3.6e+6 for 1 hour)
     * @param dispatch
     * @returns {Promise}
     */
    queryMam(to, archiveId = null, jid = null, timeLimitTs, dispatch = true) {
        this._isMethodReady(true, true);
        return new es6_promise_1.Promise((resolve, reject) => {
            const limit = (timeLimitTs || this._options.mam.defaultTimeLimit);
            const timestamp = (Date.now() - limit);
            const timestampWithPadding = this.getSyncedTimestamp(timestamp - 60000); // Minus 1 minute to account for any slight time difference and latency when asking for the server time
            this._log(`Starting the MAM query process...`);
            this._perfStart("requestMessagesFromMam", "Starting the first request for MAM messages", "color: blue;");
            this._requestMessagesFromMam(to, archiveId, false, jid, timestampWithPadding).then((stanzasToProcess) => {
                this._perfEnd("requestMessagesFromMam", "Finished getting all messages from the MAM", "color: blue;");
                this._processMamStanzas(stanzasToProcess, dispatch, false).then(resolve).catch(reject);
            }).then(() => {
                if (this._options.autoPurgeOldMessagesAge > 0) {
                    return this.purgeMessagesOlderThan(this._options.autoPurgeOldMessagesAge);
                }
            }).then(() => {
                if (this._options.autoPurgeOldRetainMessageCount > 0) {
                    return this.purgeOldestMessagesLeavingCount(this._options.autoPurgeOldRetainMessageCount);
                }
            }).catch(reject);
        });
    }
    /**
     * Private method to process stanzas (as objects) which have come from the MAM
     */
    _processMamStanzas(stanzasToProcess, dispatch = true, injected = false, backward = false) {
        return new es6_promise_1.Promise((resolve, reject) => {
            // Array of message IDs we need to post-process (i.e. Mark any that don't already have markers)
            const _messagesToPostProcess = [];
            const _markersToPostProcess = [];
            if (stanzasToProcess.length === 0) {
                resolve([]);
            }
            else {
                this._perfStart("processMamMessages", "Starting to process all messages received from the MAM", "color: yellow; background: black;");
                this._perfStart("preProcessMamMessages", "Starting to pre-process all messages received from the MAM", "color: darkgreen; background: grey;");
                let queriesBiggestArchiveId = "0";
                // Now we've got all the historic messages from the MAM we can go back and mark any we've not seen before
                stanzasToProcess.forEach((stanza) => {
                    const defaults = {
                        state: {
                            sent: true
                        },
                        fromMam: (injected === false),
                        injected: (injected === true)
                    };
                    // If the message doesn't have a timestamp node then we should use the one provided by the MAM
                    let messageTs = false;
                    try {
                        messageTs = (stanza.message.timestamp !== undefined);
                    }
                    catch (e) {
                    }
                    if (messageTs === false) {
                        if (stanza.delay && stanza.delay.$attributes.stamp) {
                            let ts = null;
                            try {
                                ts = new Date(stanza.delay.$attributes.stamp).getTime();
                            }
                            catch (e) {
                                console.error("Couldn't parse stanza timestamp to integer.");
                            }
                            if (ts !== null) {
                                defaults.ts = ts;
                            }
                        }
                    }
                    const stanzasArchiveId = this._getArchiveIdFromStanza(stanza);
                    if (stanzasArchiveId > queriesBiggestArchiveId)
                        queriesBiggestArchiveId = stanzasArchiveId;
                    if (CtXmppClient._isMarkerMessage(stanza)) {
                        this._stanzaResponseHandler(stanza.message.$attributes.id);
                        _markersToPostProcess.push(stanza);
                    }
                    else if (stanza.message.$attributes && stanza.message.$attributes.type === "chat") {
                        _messagesToPostProcess.push(this._messageDelta(stanza, {}, defaults));
                    }
                    else if (stanza.message.$attributes && stanza.message.$attributes.type === "groupchat") {
                        // As this is a groupchat message it might be an echo so clear any send timeouts waiting
                        this._stanzaResponseHandler(stanza.message.$attributes.id);
                        _messagesToPostProcess.push(this._messageDelta(stanza, {}, defaults));
                    }
                    else if (stanza.message.call && stanza.message.call.$attributes && stanza.message.call.$attributes.xmlns === CtXmppClient.NAMESPACES.INFINITY_BOT) {
                        // Bot command message success
                        // We don't want to process these bot command messages but we do want to clear any associated timers
                        this._log(`Processing bot command response from the MAM with request ID '${stanza.message.call.$attributes["request-id"]}':`, stanza);
                        this._botCommandResponseHandler(stanza.message.call.$attributes["request-id"], stanza);
                    }
                    else if (stanza.message.error && stanza.message.error.$attributes && stanza.message.error.$attributes.xmlns === CtXmppClient.NAMESPACES.INFINITY_BOT) {
                        // Bot command message error
                        this._botCommandResponseHandler(stanza.message.error.$attributes["request-id"], stanza);
                    }
                    else if (stanza.message.ack && stanza.message.ack.$attributes && stanza.message.ack.$attributes.xmlns === CtXmppClient.NAMESPACES.INFINITY_ACK) {
                        // Peer-to-peer/multicast ack message
                        // We don't want to process this message just check for any outstanding send timeouts
                        this._stanzaResponseHandler(stanza.message.ack.$attributes["original-id"]);
                    }
                });
                // Once we've processed all the messages its time to go back and mark any messages using chat markers
                // We have to do this after the fact because otherwise we won't know if the next message in the MAM query is actually a chat marker
                // for the message we want to mark and we'd end up marking it twice
                this._perfEnd("preProcessMamMessages", "Finished pre-processing messages from the MAM.", "color: darkgreen; background: grey;");
                this._perfStart("postProcessMamMessages", "Start post-processing messages received from the MAM", "color: lightgreen; background: grey;");
                this._perfStart("addMarkersToMamMessages", "Adding markers to messages", "color: brown; background: #E1E1E1;");
                const markerProms = [];
                let requireNewMessageEvent = {};
                const markerStanzasByMessageId = {};
                _markersToPostProcess.forEach((markerStanza) => {
                    const markerType = CtXmppClient._getMarkerType(markerStanza);
                    const messageId = CtXmppClient._getMarkerMessageId(markerStanza, markerType);
                    if (!markerStanzasByMessageId[messageId])
                        markerStanzasByMessageId[messageId] = [];
                    markerStanzasByMessageId[messageId].push(markerStanza);
                });
                for (let messageId in markerStanzasByMessageId) {
                    const markers = markerStanzasByMessageId[messageId];
                    // Do we have the message in memory
                    let messageInMemory = null;
                    _messagesToPostProcess.every(message => {
                        if (message._id === messageId) {
                            messageInMemory = message;
                            return false;
                        }
                        return true;
                    });
                    // If so use it
                    if (messageInMemory !== null) {
                        markers.forEach(markerStanza => {
                            const markerType = CtXmppClient._getMarkerType(markerStanza);
                            const messageId = CtXmppClient._getMarkerMessageId(markerStanza, markerType);
                            const markerUpdateResult = this._updateMessageMarkers(markerStanza, markerType, messageInMemory);
                            if (markerUpdateResult !== false) {
                                requireNewMessageEvent[messageInMemory._id] = true;
                                messageInMemory = markerUpdateResult;
                            }
                        });
                    }
                    else {
                        // If not we need to look in the database
                        markerProms.push(new es6_promise_1.Promise(resolve => {
                            this.getMessageById(messageId).then(messageInDatabase => {
                                markers.forEach(markerStanza => {
                                    const markerType = CtXmppClient._getMarkerType(markerStanza);
                                    const messageId = CtXmppClient._getMarkerMessageId(markerStanza, markerType);
                                    const markerUpdateResult = this._updateMessageMarkers(markerStanza, markerType, messageInDatabase);
                                    if (markerUpdateResult !== false) {
                                        _messagesToPostProcess.push(markerUpdateResult);
                                    }
                                    else {
                                        // If we are not saving this to the db then we need to at least mark we've dealt with this message already
                                        this._setLastArchiveId(this._getArchiveIdFromStanza(markerStanza));
                                    }
                                });
                                resolve();
                            }).catch(() => {
                                // If the message doesn't exist locally then create a placeholder incase we see the message later
                                this._log(`Not found message with id '${messageId}', creating message placeholder...`);
                                let placeholder = Object.assign({}, CtXmppClient._messageSkeleton(), { _id: messageId, placeholder: true, markable: true, type: null });
                                markers.forEach(markerStanza => {
                                    const markerType = CtXmppClient._getMarkerType(markerStanza);
                                    const messageId = CtXmppClient._getMarkerMessageId(markerStanza, markerType);
                                    const res = this._updateMessageMarkers(markerStanza, markerType, placeholder);
                                    if (res !== false) {
                                        placeholder = res;
                                    }
                                });
                                _messagesToPostProcess.push(placeholder);
                                resolve();
                            });
                        }));
                    }
                }
                es6_promise_1.Promise.all(markerProms).then(() => {
                    this._log("Messages to save from the MAM:", _messagesToPostProcess);
                    if (_messagesToPostProcess.length === 0) {
                        resolve([]);
                    }
                    else {
                        this._perfEnd("addMarkersToMamMessages", "Finished adding markers to messages", "color: brown; background: #E1E1E1;");
                        const proms = [];
                        if (backward === true) {
                            // If we are going backwards we might have message placeholders with chat markers for some or all of these messages                                                
                            _messagesToPostProcess.forEach((message, index, arr) => proms.push(this.saveMessage(message._id, current => {
                                // Check to see if we already have this in the database, if not, return
                                if (!current._id)
                                    return;
                                // We've found the message so lets remove it from the array
                                arr.splice(index, 1);
                                // We want to keep the state on the placeholder object, this contains all the chat markers
                                delete message.state;
                                // Return the new object updated with the new message content
                                return Object.assign({}, current, message); // CtXmppClient._merge(current, message);
                            })));
                        }
                        es6_promise_1.Promise.all(proms).then(results => {
                            this._msgDb.bulkDocs(_messagesToPostProcess).then((messageIds) => {
                                // Now all the messages have been persisted, update the last archive ID with the biggest from this query
                                // if this is bigger than the current last archive ID
                                this._setLastArchiveId(queriesBiggestArchiveId);
                                this._msgDb.bulkGet({
                                    docs: messageIds
                                }).then(response => {
                                    const messages = response.results.map((result) => {
                                        const message = result.docs[0]["ok"];
                                        if (message === undefined)
                                            return null;
                                        // Dispatch an event to indicate a new or updated message as we suppressed these earlier
                                        if (dispatch !== false) {
                                            // Is it new?
                                            if (message.updated_at === null || requireNewMessageEvent[message._id] === true) {
                                                // Yes
                                                this._dispatchEvent(CtXmppClient.EVENT_TYPES.NEW_MESSAGE, message);
                                            }
                                            else {
                                                // No, so its an update
                                                this._dispatchEvent(CtXmppClient.EVENT_TYPES.MESSAGE_UPDATED, message);
                                            }
                                        }
                                        // Mark the message if we haven't already
                                        if (this._options.autoMarkMessages === true)
                                            this._markMessage(message, CtXmppClient.MARKER_TYPES.RECEIVED, dispatch);
                                        return message;
                                    });
                                    requireNewMessageEvent = {};
                                    this._perfEnd("postProcessMamMessages", "Finished post-processing messages received from the MAM", "color: lightgreen; background: grey;");
                                    this._perfEnd("processMamMessages", "Finished processing messages received from the MAM", "color: yellow; background: black;");
                                    resolve(messages.filter(msg => { return msg !== null; }));
                                });
                            }).catch(e => {
                                console.error(e);
                                reject(e);
                            });
                        });
                    }
                });
            }
        });
    }
    processXmlStanzaStringsFromMam(stanzas, dispatch = true) {
        const parser = new DOMParser();
        // Convert the strings to XML Nodes
        const xmlNodes = stanzas.map(xmlStr => parser.parseFromString(xmlStr, "text/xml").childNodes[0]);
        // Convert the XML Nodes to JSON
        const stanzasToProcess = xmlNodes.map(xmlNode => CtXmppClient.xmlToJson(xmlNode));
        // Categorise each message into a room
        const rooms = {};
        stanzasToProcess.forEach(stanza => {
            // Find the room name and ID for each message
            try {
                const messageId = stanza.message.$attributes.id;
                const roomName = stanza.message.$attributes.to.split("@")[0];
                if (rooms[roomName] === undefined)
                    rooms[roomName] = [];
                rooms[roomName].push(messageId);
            }
            catch (e) {
                console.error("The stanza wasn't in the expected format:", e);
            }
        });
        // Look to see if we know about any of the messages for each room
        const proms = Object.keys(rooms).map(roomName => {
            return this.getMessagesById(rooms[roomName]).then(messages => {
                // If we know of a message then we don't do anything
                if (messages.length > 0)
                    return;
                // If we don't know of any of these messages then there is probably a gap so delete all messages from the room  
                this._log(`Deleting all messages in room '${roomName}' because it looks like there might be a gap in history...`);
                return this.deleteMessagesByRoomName(roomName);
            });
        });
        // Once all thats done, process the stanzas as normal
        return es6_promise_1.Promise.all(proms).then(() => {
            return this._processMamStanzas(stanzasToProcess, dispatch, true);
        });
    }
    /**
     * Clean up messages, removes messages older than configured age ms
     * @param age
     * @returns {Promise}
     */
    purgeOldMessages() {
        this._isMethodReady(true);
        return this.purgeMessagesOlderThan(this._options.autoPurgeOldMessagesAge);
    }
    /**
     * Clean up messages, removes messages older than 'age' ms
     * @param age
     * @returns {Promise}
     */
    purgeMessagesOlderThan(age) {
        this._isMethodReady(true);
        this._log("🗑️ Removing messages older than: " + age);
        return this.purgeMessagesFromBefore(this.getSyncedTimestamp(Date.now()) - age);
    }
    /**
     * Clean up messages, removes messages with a timestamp from before 'ts'
     * @param ts
     * @returns {Promise}
     */
    purgeMessagesFromBefore(ts) {
        this._isMethodReady(true);
        this._log("🗑️ Removing messages with timestamp before: " + new Date().toISOString());
        return this.deleteMessages({
            "ts": {
                "$lt": ts
            }
        });
    }
    /**
     * Clean up messages, remove the oldest messages, leaving the newest 'count' behind
     * @param count
     */
    purgeOldestMessagesLeavingCount(count) {
        this._isMethodReady(true);
        this._log("🗑️ Want to restrict to: " + count + " messages in DB");
        return this._msgDb.info().then((info) => {
            this._log("🗑️ There are: " + info.doc_count + " messages in DB");
            const countToDelete = info.doc_count - count;
            if (countToDelete > 0) {
                this._log("🗑️ Going to delete: " + countToDelete + " messages from DB");
                return this.purgeOldestMessagesCount(countToDelete);
            }
        });
    }
    /**
     * Clean up messages, remove the oldest 'count' messages
     * @param count
     */
    purgeOldestMessagesCount(count) {
        this._isMethodReady(true);
        return this._msgDb.createIndex({ index: { fields: ['ts'] } }).then(() => {
            this._msgDb.find({ selector: {},
                sort: ['ts'],
                limit: count,
                fields: ['_id']
            }).then(messageIds => {
                let promiseChain = es6_promise_1.Promise.resolve();
                messageIds.docs.forEach(doc => {
                    promiseChain = promiseChain.then(() => {
                        this._log("🗑️ Deleting message: " + doc._id);
                        return this.deleteMessageById(doc._id).then(() => {
                            this._log("🗑️ Deleted message: " + doc._id);
                        });
                    });
                });
                return promiseChain;
            });
        });
    }
    _setLastArchiveId(archiveId) {
        if (archiveId > this._lastArchiveId) {
            this._lastArchiveId = archiveId;
            localStorage.setItem(`${this._instanceId}_last_archive_id`, archiveId);
        }
    }
    getLastArchiveId() {
        return this._lastArchiveId;
    }
    getLastArchiveIdForRoom(roomName) {
        this._isMethodReady(true);
        if (!this._options.mucHost)
            throw new Error("'mucHost' must be provided as an option.");
        return new es6_promise_1.Promise((resolve, reject) => {
            const to = `${roomName}@${this._options.mucHost}`;
            let archiveId = "0";
            this.getChatHistory(to).then((results) => {
                if (results.length > 0) {
                    // Chat history only sorts by the timestamp, we also need to filter on updated_at so we know when we last stanza
                    // for this room was received. We also want the last message first.
                    const filteredItems = results.sort((a, b) => {
                        // Sort on the updated_at field
                        const x = b.updated_at - a.updated_at;
                        // Then sort on the ts field
                        return (x === 0) ? b.ts - a.ts : x;
                    });
                    const lastMessage = filteredItems[0];
                    archiveId = lastMessage.archive_id;
                }
                resolve(archiveId);
            }).catch(reject);
        });
    }
    getFirstArchiveIdForRoom(roomName) {
        this._isMethodReady(true);
        if (!this._options.mucHost)
            throw new Error("'mucHost' must be provided as an option.");
        return new es6_promise_1.Promise((resolve, reject) => {
            const to = `${roomName}@${this._options.mucHost}`;
            let archiveId = "0";
            this.getChatHistory(to).then((results) => {
                if (results.length > 0) {
                    // Chat history only sorts by the timestamp, we also need to filter on updated_at so we know when we last stanza
                    // for this room was received. We also want the last message first.
                    const filteredItems = results.sort((a, b) => {
                        return a.ts - b.ts;
                    });
                    const firstMessage = filteredItems[0];
                    archiveId = firstMessage.archive_id;
                }
                resolve(archiveId);
            }).catch(reject);
        });
    }
    /**
     * Method to get missed messages for a specific room
     * @param roomName {String}
     * @param dispatch {Boolean}
     * @param archiveId {String|null} - Archive ID to use for MAM query instead of querying the room messages
     * @returns {Promise}
     */
    queryMamByRoomName(roomName, dispatch = true, archiveId = null) {
        this._isMethodReady(true, true);
        if (!this._options.mucHost)
            throw new Error("'mucHost' must be provided as an option.");
        this._perfStart("queryMamByRoomName", `- Querying the MAM for room '${roomName}'`, "color: green;");
        return new es6_promise_1.Promise((resolve, reject) => {
            const to = `${roomName}@${this._options.mucHost}`;
            const doQuery = (archiveId) => {
                this.queryMam(to, archiveId, null, null, dispatch).then((res) => {
                    this._perfEnd("queryMamByRoomName", `- Finished querying the MAM for message in room '${roomName}'.`, "color: green;");
                    resolve(res);
                }).catch(reject);
            };
            if (archiveId === null) {
                this.getLastArchiveIdForRoom(roomName).then(_archiveId => {
                    doQuery(_archiveId);
                }).catch(resolve);
            }
            else {
                doQuery(archiveId);
            }
        });
    }
    /**
     * Method to query room history by name
     * @param roomName {String} - The name of the room
     * @param beforeArchiveId {String|null} - Get messages from before this archive ID
     * @param dispatch {Boolean} - Whether to dispatch events as messages are processed
     * @returns {Promise}
     */
    queryMamRoomHistoryByName(roomName, beforeArchiveId = null, count = 5, dispatch = true) {
        this._isMethodReady(true, true);
        if (!this._options.mucHost)
            throw new Error("'mucHost' must be provided as an option.");
        this._perfStart("queryMamRoomHistoryByName", `Querying MAM history for room '${roomName}'`, "color: purple;");
        return new es6_promise_1.Promise((resolve, reject) => {
            const to = `${roomName}@${this._options.mucHost}`;
            this._requestMessagesFromMam(to, beforeArchiveId, true, null, null, count).then((stanzasToProcess) => {
                this._perfEnd("queryMamRoomHistoryByName", `Finished querying the MAM history for '${count}' messages in the '${roomName}' room.`, "color: purple;");
                this._processMamStanzas(stanzasToProcess, dispatch, false, true).then(resolve).catch(reject);
            }).then(() => {
                if (this._options.autoPurgeOldMessagesAge > 0) {
                    return this.purgeMessagesOlderThan(this._options.autoPurgeOldMessagesAge);
                }
            }).then(() => {
                if (this._options.autoPurgeOldRetainMessageCount > 0) {
                    return this.purgeOldestMessagesLeavingCount(this._options.autoPurgeOldRetainMessageCount);
                }
            }).catch(reject);
        });
    }
    /**
     * Convenience method to retrieve messages from the MAM by recipient
     * @param recipient
     * @param dispatch
     * @returns {Promise}
     */
    queryMamByRecipient(recipient, dispatch = true) {
        this._isMethodReady(true, true);
        return new es6_promise_1.Promise((resolve, reject) => {
            this.getChatHistory(recipient).then((results) => {
                let archiveId = null;
                if (results.length > 0) {
                    // Chat history only sorts by the timestamp, we also need to filter on updated_at so we know when we last stanza
                    // for this room was received. We also want the last message first.
                    const filteredItems = results.sort((a, b) => {
                        // Sort on the updated_at field
                        const x = b.updated_at - a.updated_at;
                        // Then sort on the ts field
                        return (x === 0) ? b.ts - a.ts : x;
                    });
                    const lastMessage = filteredItems[0];
                    archiveId = lastMessage.archive_id;
                }
                this.queryMam(null, archiveId, recipient, null, dispatch).then(resolve).catch(reject);
            }).catch((e) => console.error);
        });
    }
    /**
     * Base method used to persist objects to a database
     * @param object
     * @param id
     * @param delta
     * @param successCb
     * @param errorCb
     * @private
     */
    _saveObject(object, id, delta, successCb, errorCb) {
        // Don't try and save if we are in the process of destroying the DBs
        if (this._destroyingDbs) {
            this._log(`Couldn't save '${object}' because the databases are being destroyed.`);
            if (errorCb)
                errorCb(CtXmppClient.ERROR_CODES.DESTROYING_DBS);
            return;
        }
        let _db = null;
        switch (object) {
            case CtXmppClient.OBJECT_TYPES.MESSAGE:
                _db = this._msgDb;
                break;
            case CtXmppClient.OBJECT_TYPES.CONTACT:
                _db = this._contactDb;
                break;
            case CtXmppClient.OBJECT_TYPES.ROOM:
                _db = this._roomDb;
                break;
            case CtXmppClient.OBJECT_TYPES.PARTICIPANT:
                _db = this._participantDb;
                break;
            case CtXmppClient.OBJECT_TYPES.CACHE_ITEM:
                _db = this._cacheDb;
                break;
        }
        if (_db === null)
            throw new Error(`The object type provided (${object}) is not valid.`);
        if (this._saveDebounce[object] === undefined)
            this._saveDebounce[object] = {};
        if (!this._saveDebounce[object][id]) {
            this._saveDebounce[object][id] = true;
            _db.upsert(id, delta).then((res) => {
                // There might be a case where we returned false in the upsert delta and therefore a message was never created
                // if that's the case there won't be a revision and nothing to get, so just ignore
                if (res.rev !== undefined) {
                    _db.get(id).then((doc) => {
                        delete this._saveDebounce[object][id];
                        if (successCb)
                            successCb(doc);
                    }).catch((e) => {
                        this._onError(`Couldn't get ${object} with ID '${id}' after performing an update.`, e);
                        delete this._saveDebounce[object][id];
                        if (errorCb)
                            errorCb(e);
                    });
                }
                else {
                    delete this._saveDebounce[object][id];
                    if (successCb)
                        successCb(null);
                }
            }).catch((e) => {
                this._log(`Couldn't update ${object} with ID '${id}'.`, e);
                delete this._saveDebounce[object][id];
                if (errorCb)
                    errorCb(e);
            });
        }
        else {
            setTimeout(() => {
                this._saveObject(object, id, delta, successCb, errorCb);
            }, 250);
        }
    }
    /**
     * Private method used to perform the actual download and figure out if Basic Authentication is needed
     * @param url {String}
     * @returns {Promise}
     * @private
     */
    doDownload(url) {
        return new es6_promise_1.Promise((resolve, reject) => {
            const __doDownload = headers => {
                File.download(url, headers).then((result) => {
                    var fileEncryption = Plugin.getSource("fileEncryption");
                    if (environment_1.isDevice() && this._options.fileEncryption && fileEncryption) {
                        fileEncryption.encrypt(function (encryptedUri) {
                            result.source = encryptedUri;
                            resolve(result);
                        }, function (error) {
                            reject(error);
                        }, result.source);
                    }
                    else {
                        resolve(result);
                    }
                }).catch(reject);
            };
            if (this._options.authAttachments === true) {
                this._getCacheItem("user_password").then(password => {
                    return this._embellishPasswordWithAdToken(password);
                }).then(_password => {
                    __doDownload({
                        "Authorization": "Basic " + btoa(this._bareJid + ":" + _password)
                    });
                });
            }
            else {
                __doDownload(null);
            }
        });
    }
    /**
     * Download a specific attachment, from a message and an attachment number.
     * @param message - the message object with the attachent
     * @param attachmentNumber - 0 indexed attachment number
     * @param dispatch - fire event when message is updated with attachment
     * @returns {Promise}
     */
    downloadAttachment(message, attachmentNumber, dispatch = true) {
        this._isMethodReady(true, true);
        return new es6_promise_1.Promise((resolve, reject) => {
            if (attachmentNumber > message.attachments.length - 1) {
                return reject("No such attachment: " + attachmentNumber);
            }
            const attachment = message.attachments[attachmentNumber];
            if (attachment.path === undefined) {
                this.doDownload(attachment.get).then((result) => {
                    attachment.path = result.source;
                    attachment.state = "transferred";
                    this.saveMessage(message._id, (oldMessage) => {
                        // Update message with attachments by returning the updated object
                        oldMessage.attachments[attachmentNumber] = attachment;
                        return oldMessage;
                    }).then((_message) => {
                        if (dispatch !== false) {
                            this._dispatchEvent(CtXmppClient.EVENT_TYPES.MESSAGE_UPDATED, _message);
                        }
                        resolve();
                    });
                }).catch(reject);
            }
            else {
                resolve();
            }
        });
    }
    /**
     * Method used to manually initialise the user directory, searchUsers and updateUserDirectory methods call this automatically
     * @returns {Promise<void | string>}
     */
    initUserDirectory() {
        return new es6_promise_1.Promise((resolve, reject) => {
            // Check to see if the index has already been initialised
            if (this._userDirectory.initialised === true) {
                // If so just resolve
                resolve();
            }
            else {
                // If not let's initialise it
                // Create an IV
                let ivArr = null;
                let iv = localStorage.getItem(`${this._instanceId}_ud_iv`);
                if (iv == null) {
                    ivArr = window.crypto.getRandomValues(new Uint8Array(16));
                    let stringArray = [];
                    for (let i = 0; i < 16; i++) {
                        stringArray.push(String.fromCharCode(ivArr[i]));
                    }
                    const str = stringArray.join("");
                    localStorage.setItem(`${this._instanceId}_ud_iv`, str);
                }
                else {
                    const bufView = new Uint8Array(16);
                    for (let i = 0; i < iv.length; i++) {
                        bufView[i] = iv.charCodeAt(i);
                    }
                    ivArr = bufView;
                }
                utils_1.getEncryptionKey(this._instanceId).then((key) => {
                    this._userDirectory.initialise(key, ivArr, this._options.userDirectoryEncryptionBlockSize || 2000).then(resolve).catch(reject);
                });
            }
        });
    }
    _updateUserDirectoryTimer() {
        setTimeout(() => {
            this.updateUserDirectory().then((result) => {
                this._log(`👱🏼 Updated user directory: ${result}`);
            }).catch((e) => {
                this._log(`👱🏼 Couldn't update user directory: ${e.message}`);
            });
        }, this._options.updateUserDirectoryInterval);
    }
    /**
     * Method used to get any updates to the user directory from the server
     * @returns {Promise<DirectoryUser[]>}
     */
    updateUserDirectory() {
        // Initialise the index if not already done
        return this.initUserDirectory().then(() => {
            this._log("👱🏼 Updating user directory...");
            // Get the user_directory_hash if we have one
            return this._getCacheItem("user_directory_hash").then(hash => {
                // Construct the payload
                const payload = {
                    query: {
                        $attributes: {
                            xmlns: CtXmppClient.NAMESPACES.DIRECTORY
                        }
                    }
                };
                // Include the hash if we have one
                if (hash)
                    payload.query.$attributes.hash = hash;
                // Do the IQ request to obtain the download URL to be passed to the worker for download and indexing
                return this.sendIq(this._domain, "get", payload).then((res) => {
                    try {
                        // Grab the download URL from the response
                        const url = res.iq.query.$attributes.url;
                        // If the url is undefined then there is no change so just return
                        if (url === undefined) {
                            this._updateUserDirectoryTimer();
                            return `No change since last update.`;
                        }
                        // Get the user password to pass to the worker to do the download
                        return this._getCacheItem("user_password").then(password => {
                            return this._embellishPasswordWithAdToken(password);
                        }).then(_password => {
                            // Call the user's class to do the download and indexing
                            return this._userDirectory.update(this._bareJid, _password, url).then(data => {
                                // Cache the hash returned from the JSON response to be used on the next request
                                return this._setCacheItem("user_directory_hash", data.hash).then(() => {
                                    this._log("✅ User directory successfully updated.");
                                    this._updateUserDirectoryTimer();
                                    // Return the message
                                    return data.msg;
                                });
                            });
                        });
                    }
                    catch (e) {
                        this._updateUserDirectoryTimer();
                        return es6_promise_1.Promise.reject("Couldn't obtain directory URL from server.");
                    }
                });
            });
        }).catch(e => {
            return this._getCacheItem("user_directory_hash").then(hash => {
                if (hash !== undefined) {
                    return this._deleteCacheItem("user_directory_hash").then(() => {
                        return this.updateUserDirectory().then((data) => {
                            return es6_promise_1.Promise.resolve(data);
                        }).catch((e) => {
                            return es6_promise_1.Promise.reject(e);
                        });
                    });
                }
                else {
                    return es6_promise_1.Promise.reject(e);
                }
            });
        });
    }
    /**
     * Method used to do a full-text search on all users in the user directory. Searchable fields are jid, prefix, firstName, lastName and title
     * @param query {String}
     * @param fields {Array}
     * @returns {Promise<any>}
     */
    searchUsers(query, fields) {
        return this.initUserDirectory().then(() => {
            return this._userDirectory.search(query, fields);
        });
    }
    /**
     * Method used to return all users from the user directory - use at your own risk if there are many users.
     * @returns {Promise<any>}
     */
    getAllUsers() {
        return this.initUserDirectory().then(() => {
            return this._userDirectory.getAllUsers();
        });
    }
    /**
     * Method used to get a single user from the user directory by the JID
     * @param jid {String}
     * @returns {Promise<any>}
     */
    getUserByJid(jid) {
        return this.initUserDirectory().then(() => {
            return this._userDirectory.getUserByJid(jid);
        });
    }
    downloadAttachments(message, dispatch = true) {
        return new es6_promise_1.Promise((resolve, reject) => {
            if (Array.isArray(message.attachments) && message.attachments.length > 0) {
                // Download attachments
                let promiseChain = es6_promise_1.Promise.resolve({});
                message.attachments.forEach((attachment, index) => {
                    promiseChain = promiseChain.then(() => {
                        return new es6_promise_1.Promise((resolve, reject) => {
                            // Only download the file if we haven't done already
                            if (attachment.path === undefined) {
                                this.doDownload(attachment.get).then((result) => {
                                    message.attachments[index].path = result.source;
                                    message.attachments[index].mediaType = File.getMediaTypeFromExtension(result.source);
                                    message.attachments[index].state = "transferred";
                                    resolve();
                                }).catch(reject);
                            }
                            else {
                                resolve();
                            }
                        });
                    });
                });
                promiseChain.then(() => {
                    this.saveMessage(message._id, () => {
                        // Update message with attachments by returning the updated object
                        return message;
                    }).then((_message) => {
                        // Dispatch the appropriate event
                        if (dispatch !== false) {
                            this._dispatchEvent(CtXmppClient.EVENT_TYPES.MESSAGE_UPDATED, _message);
                        }
                        this._log(`Successfully updated message '${_message._id}' with attachments.`, _message);
                        resolve(_message);
                    }).catch((e) => {
                        this._onError(`Unable to update message '${message._id}' with attachments:`, e);
                        reject(e);
                    });
                }).catch((e) => {
                    this._onError("Unable to download all message attachments:", e);
                    reject(e);
                });
            }
            else {
                // No attachments so no modifications needed
                resolve(message);
            }
        });
    }
    /**
     * Private method used to internally process a new message
     * @param stanza
     * @param overrides
     * @param mark
     * @param dispatch
     * @returns {Promise}
     * @private
     */
    _processNewMessage(stanza, overrides, mark = true, dispatch = true) {
        this._perfStart(`processNewMessage (${stanza.message.$attributes.id.split("-")[0]})`, "Starting to process a new message", "color: purple;");
        return new es6_promise_1.Promise((resolve, reject) => {
            this._setLastArchiveId(this._getArchiveIdFromStanza(stanza));
            this._messageStanzaToDbObject(stanza, overrides)
                .then((message) => {
                // Dispatch the appropriate event
                if (dispatch !== false) {
                    if (message.updated_at === null) {
                        this._dispatchEvent(CtXmppClient.EVENT_TYPES.NEW_MESSAGE, message);
                    }
                    else {
                        this._dispatchEvent(CtXmppClient.EVENT_TYPES.MESSAGE_UPDATED, message);
                    }
                }
                // Check message timestamp to see if we want to download attachments
                // TODO: Put as function shouldDownloadAttachments
                const diff = this.getSyncedTimestamp(new Date().getTime()) - message.ts;
                if (diff < this._options.autoDownloadAttachmentTime || this._options.autoDownloadAttachmentTime == -1) {
                    return this.downloadAttachments(message, dispatch);
                }
                else {
                    return message;
                }
            })
                .then((message) => {
                // Only mark the message if the sender say's it can be marked based on XEP-0333 and its not our message
                if (stanza.message.markable && mark === true && this._options.autoMarkMessages === true) {
                    this._markMessage(message, CtXmppClient.MARKER_TYPES.RECEIVED, dispatch).then((res) => {
                        this._perfEnd(`processNewMessage (${stanza.message.$attributes.id.split("-")[0]})`, "Finished processing a new message", "color: purple;");
                        resolve(res);
                    }).catch(reject);
                }
                else {
                    this._perfEnd(`processNewMessage (${stanza.message.$attributes.id.split("-")[0]})`, "Finished processing a new message", "color: purple;");
                    resolve(message);
                }
            }).catch(reject);
        });
    }
    /**
     * Abstraction of the _processNewMessage method to specifically handle group messages
     * @param stanza
     * @param overrides
     * @param mark
     * @param dispatch
     * @returns {Promise}
     * @private
     */
    _processGroupMessage(stanza, overrides, mark = true, dispatch = true) {
        // Get the nickname from the room JID to determine if we sent this message
        const _overrides = CtXmppClient._merge({
            type: "groupchat",
            mine: (index_1.default.Strophe.getBareJidFromJid(stanza.message.$attributes.from) === this._bareJid || index_1.default.Strophe.getResourceFromJid(stanza.message.$attributes.from) === this.username)
        }, overrides);
        try {
            this._stanzaResponseHandler(stanza.message.$attributes.id);
        }
        catch (e) {
            this._onError(`Couldn't process stanza response handler for stanza:`, stanza);
        }
        return this._processNewMessage(stanza, _overrides, mark, dispatch);
    }
    _updateMessageMarkers(stanza, markerType, message) {
        // If the message doesn't already exists then ignore
        if (!message._id)
            return false;
        // Don't mark the message unless its been marked as markable
        if (!message.markable)
            return false;
        const from = index_1.default.Strophe.getBareJidFromJid(stanza.message.$attributes.from);
        const resource = index_1.default.Strophe.getResourceFromJid(stanza.message.$attributes.from);
        // If we've already had a marker of this type for this message from the same person, ignore it.
        const ignore = message.state.markers.some((_marker) => {
            if (_marker.type === markerType && ((_marker.sender_id === from && _marker.sender_resource === resource) || (_marker.sender_resource === this.bareJid))) {
                return true;
            }
        });
        if (ignore === true)
            return false;
        const marker = {
            type: markerType,
            sender_id: from,
            sender_resource: resource,
            recipient_id: stanza.message.$attributes.to,
            ts: this._getTimestampFromStanza(stanza),
            priority: CtXmppClient.MARKER_PRIORITIES[markerType]
        };
        // Add the new marker to the markers array
        message.state.markers.push(marker);
        // Sort the markers based on priority and then timestamp
        message.state.markers = message.state.markers.sort(function (a, b) {
            if (a.priority !== b.priority) {
                return (a.priority - b.priority);
            }
            else if (b.ts !== null && a.ts !== null) {
                return (b.ts - a.ts);
            }
        });
        // Update the flag to indicate we have had at least one of this type of marker
        message.state[markerType] = true;
        // If the message wasn't marked sent we know it has been because we have received a marker for it
        if (message.state.sent !== true)
            message.state.sent = true;
        // Update the messages updated_at
        message.updated_at = this.getSyncedTimestamp(Date.now());
        return message;
    }
    static _getMarkerType(stanza) {
        // Figure out if and which type of chat marker we are dealing with
        let markerType = null;
        if (stanza.message.received) {
            markerType = CtXmppClient.MARKER_TYPES.RECEIVED;
        }
        else if (stanza.message.read) {
            markerType = CtXmppClient.MARKER_TYPES.READ;
        }
        else if (stanza.message.acknowledged) {
            markerType = CtXmppClient.MARKER_TYPES.ACKNOWLEDGED;
        }
        return markerType;
    }
    static _getMarkerMessageId(stanza, markerType) {
        return (stanza.message[markerType].$attributes !== undefined && stanza.message[markerType].$attributes.id !== undefined) ? stanza.message[markerType].$attributes.id : null;
    }
    /**
     * Private method used to process incoming marker messages and mark local messages accordingly
     * @param stanza
     * @param dispatch
     * @returns {Promise}
     * @private
     */
    _processMarkerMessage(stanza, dispatch = true) {
        return new es6_promise_1.Promise((resolve, reject) => {
            this._setLastArchiveId(this._getArchiveIdFromStanza(stanza));
            // Figure out if and which type of chat marker we are dealing with
            const markerType = CtXmppClient._getMarkerType(stanza);
            // If we are dealing with a chat marker then let's do it
            if (markerType !== null) {
                // We've received a chat marker telling us the recipient has either received, read or acknowledged one of our messages, let's find that message and mark it so
                const messageId = CtXmppClient._getMarkerMessageId(stanza, markerType);
                if (messageId !== null) {
                    this._log(`Processing marker of type '${markerType}' for message with ID '${messageId}':`, stanza);
                    this._stanzaResponseHandler(stanza.message.$attributes.id);
                    const from = index_1.default.Strophe.getBareJidFromJid(stanza.message.$attributes.from);
                    const resource = index_1.default.Strophe.getResourceFromJid(stanza.message.$attributes.from);
                    this.saveMessage(messageId, (message) => {
                        return this._updateMessageMarkers(stanza, markerType, message);
                    }).then((message) => {
                        if (message !== null) {
                            const receipt = {
                                message_id: message._id,
                                message: message,
                                type: markerType,
                                sender_id: from,
                                sender_resource: resource
                            };
                            if (dispatch !== false)
                                this._dispatchEvent(CtXmppClient.EVENT_TYPES.RECEIPT_RECEIVED, receipt);
                            if (dispatch !== false)
                                this._dispatchEvent(CtXmppClient.EVENT_TYPES.MESSAGE_UPDATED, message);
                            resolve(receipt);
                        }
                        else {
                            // We got a marker for a message we don't know about, so just ignore it
                            resolve(null);
                        }
                    }).catch(reject);
                }
            }
        });
    }
    /**
     * Private method used to process error stanzas
     * @param stanza
     * @returns {Promise}
     * @private
     */
    _processErrorMessage(stanza) {
        return new es6_promise_1.Promise((resolve, reject) => {
            const messageId = (stanza.message.$attributes && stanza.message.$attributes.id) ? stanza.message.$attributes.id : null;
            if (messageId !== null) {
                const msg = (stanza.message.error && stanza.message.error.text && stanza.message.error.text.$value) ? stanza.message.error.text.$value : `The server returned an error for stanza with ID '${messageId}'.`;
                this._onError(msg, Object.assign({}, stanza.message.error, { messageId }));
                this._stanzaResponseHandler(messageId, msg);
                this.saveMessage(messageId, (message) => {
                    // We only want to update existing messages
                    if (message._id === undefined)
                        return false;
                    // There was an error so mark it as failed to send (Unless we've had a received or read marker)
                    if (message.state.read !== true && message.state.received !== true && message.state.acknowledged !== true) {
                        message.state.sent = false;
                    }
                    else if (message.state.sent !== true) {
                        // If we've had a marker but the message was never marked sent, mark it sent.
                        message.state.sent = true;
                    }
                    return message;
                }).then(() => {
                    resolve({
                        id: messageId,
                        msg: msg
                    });
                }).catch(reject);
            }
            else {
                resolve();
            }
        });
    }
    /**
     * Private method used to process ack stanzas
     * @param stanza
     * @returns {Promise}
     * @private
     */
    _processAckMessage(stanza) {
        return new es6_promise_1.Promise((resolve, reject) => {
            if (stanza.message.ack && stanza.message.ack.$attributes && stanza.message.ack.$attributes["original-id"]) {
                const messageId = stanza.message.ack.$attributes["original-id"];
                this._stanzaResponseHandler(messageId);
                this._dispatchEvent(CtXmppClient.EVENT_TYPES.ACK_RECEIVED, messageId);
                // Find the message this ack is for and update the sent flag if not done already
                this.saveMessage(messageId, (message) => {
                    // We only want to update existing messages
                    if (message._id === undefined)
                        return false;
                    if (message.state.sent !== true)
                        message.state.sent = true;
                    return message;
                }).then(resolve).catch(reject);
            }
            else {
                resolve();
            }
        });
    }
    /**
     * Method used to handle incoming messages
     * @param $stanza
     * @returns {boolean}
     * @private
     */
    _onStanza($stanza) {
        // If any stanza is received then we must be connected
        this.connected = true;
        this._setStatus(index_1.default.Strophe.Status.CONNECTED);
        try {
            const stanza = CtXmppClient.xmlToJson($stanza);
            if (this._isFilteredOut(stanza)) {
                return true;
            }
            this._log(`[1] - Processing stanza with ID '${stanza.message.$attributes.id}':`, stanza);
            // Process a carbon copy of a message this user has sent on another device
            if (stanza.message.$attributes && stanza.message.$attributes.type === "chat" && stanza.message.sent !== undefined && stanza.message.sent.$attributes !== undefined && stanza.message.sent.$attributes.xmlns === CtXmppClient.NAMESPACES.CARBONS && stanza.message.sent.forwarded !== undefined) {
                this._processNewMessage(stanza.message.sent.forwarded, { state: { sent: true } });
                // Process a standard XMPP chat message
            }
            else if (stanza.message.$attributes && stanza.message.$attributes.type === "chat") {
                // Save the message to the database and mark the message if it is markable (Chat Markers)
                this._processNewMessage(stanza);
                // Process a groupchat message received as a room subscription (MUC/Sub)
            }
            else if (stanza.message.event && stanza.message.event.items) {
                const __processItem = (item) => {
                    if (CtXmppClient._isMarkerMessage(item)) {
                        this._log(`[2] - Processing stanza with ID '${stanza.message.$attributes.id}':`, stanza);
                        this._processMarkerMessage(item);
                    }
                    else {
                        this._processGroupMessage(item);
                    }
                };
                if (Array.isArray(stanza.message.event.items.item)) {
                    stanza.message.event.items.forEach(item => {
                        if (item.message && item.message.$attributes && item.message.$attributes.type === "groupchat") {
                            __processItem(item);
                        }
                        else if (item.presence) {
                            this._onPresence(item);
                        }
                    });
                }
                else if (typeof stanza.message.event.items.item === "object" && stanza.message.event.items.item.message && stanza.message.event.items.item.message.$attributes && stanza.message.event.items.item.message.$attributes.type === "groupchat") {
                    __processItem(stanza.message.event.items.item);
                }
                else if (typeof stanza.message.event.items.item === "object" && stanza.message.event.items.item.presence) {
                    this._onPresence(stanza.message.event.items.item);
                }
                // Deal with chat markers
            }
            else if (CtXmppClient._isMarkerMessage(stanza)) {
                this._log(`[3] - Processing stanza with ID '${stanza.message.$attributes.id}':`, stanza);
                this._processMarkerMessage(stanza);
                // Process a groupchat message received as a room participant (MUC)
            }
            else if (stanza.message.$attributes && stanza.message.$attributes.type === "groupchat" && stanza.message.$attributes.id) {
                this._processGroupMessage(stanza);
            }
            else if (stanza.message.$attributes && stanza.message.$attributes.type === "error") {
                this._processErrorMessage(stanza);
            }
            else if (stanza.message.ack !== undefined) {
                this._processAckMessage(stanza);
            }
            else if (stanza.message.call && stanza.message.call.$attributes && stanza.message.call.$attributes.xmlns === CtXmppClient.NAMESPACES.INFINITY_BOT) {
                // Bot command message success
                this._log(`Processing bot command response with request ID '${stanza.message.call.$attributes["request-id"]}':`, stanza);
                this._botCommandResponseHandler(stanza.message.call.$attributes["request-id"], stanza);
            }
            else if (stanza.message.error && stanza.message.error.$attributes && stanza.message.error.$attributes.xmlns === CtXmppClient.NAMESPACES.INFINITY_BOT) {
                // Bot command message error
                this._botCommandResponseHandler(stanza.message.error.$attributes["request-id"], stanza);
            }
        }
        catch (error) {
            this._onError("An error occurred when processing an incoming message stanza:", error);
        }
        return true;
    }
    /**
     * Returns true if message is filtered out by inclusive or exclusive filters
     *
     * @param stanza
     * @returns {boolean}
     * @private
     */
    _isFilteredOut(stanza) {
        let filteredIn = true;
        if (this._includeStanzaFilters.length > 0) {
            filteredIn = false;
            // If any filter returns true then always include this message, if a filter function throws an exception then do not include
            if (this._includeStanzaFilters.some((filter) => {
                try {
                    return filter(stanza);
                }
                catch (e) {
                    this._log("Include filter function failed: " + e);
                    this._onError("Include filter function failed: " + e);
                    return false;
                }
            })) {
                filteredIn = true;
            }
        }
        // If any filter returns true then always exclude this message, if a filter function throws an exception then do not exclude
        if (this._excludeStanzaFilters.some((filter) => {
            try {
                return filter(stanza);
            }
            catch (e) {
                this._log("Exclude filter function failed: " + e);
                this._onError("Exclude filter function failed: " + e);
                return false;
            }
        })) {
            filteredIn = false;
        }
        return !filteredIn;
    }
    /**
     * Convenience method used to determine if a message is in a group chat
     * @param messageStanza
     * @returns {string|boolean}
     * @private
     */
    _messageIsGroupChat(messageStanza) {
        return (this._options.mucHost && messageStanza.$attributes && typeof messageStanza.$attributes.from === "string" && messageStanza.$attributes.from.indexOf(this._options.mucHost) > -1);
    }
    /**
     * Private method used to handle all incoming presence updates
     * @param json
     * @returns {boolean}
     * @private
     */
    _onPresence(json) {
        if (json.presence !== undefined) {
            const presence = json.presence;
            if (presence.$attributes !== undefined && presence.$attributes.from !== undefined) {
                if (presence.$attributes.type === "error") {
                    this._onError("An error from the server was received in a presence stanza:", presence);
                    return true;
                }
                // Ensure the jid is present and its not the currently logged in user
                const jid = index_1.default.Strophe.getBareJidFromJid(presence.$attributes.from);
                if (!jid)
                    return true;
                // Check to see if this presence update is from the currently logged in user on another device
                if (jid === this._bareJid) {
                    // If it is then we need to update the current clients chat status based on this new information
                    this.setChatStatus(presence.show, presence.status, false, presence.metadata);
                }
                else {
                    // Figure out if we are dealing with room presence or standard presence
                    const domain = CtXmppClient.getDomainFromJid(jid);
                    if (this._options.mucHost === domain) {
                        this.saveParticipant(presence.$attributes.from, (participant) => {
                            if (participant._id !== undefined) {
                                // Update
                                try {
                                    participant.show = presence.show;
                                    participant.status = presence.status;
                                    participant.online = (presence.$attributes.type !== "unavailable");
                                    participant.affiliation = presence.x.item.$attributes.affiliation;
                                    participant.room_role = presence.x.item.$attributes.role;
                                    participant.last_stanza = presence;
                                    if (presence.metadata !== undefined) {
                                        const metadata = presence.metadata;
                                        delete metadata.$attributes;
                                        participant.metadata = metadata;
                                    }
                                    participant.updated_at = this.getSyncedTimestamp(Date.now());
                                }
                                catch (e) {
                                    this._onError(`Presence stanza wasn't in the expected format when trying to update participant with ID '${participant._id}' and JID '${participant.jid}'.`, e);
                                }
                            }
                            else {
                                // Create
                                try {
                                    participant._id = presence.$attributes.from;
                                    participant.jid = index_1.default.Strophe.getBareJidFromJid(presence.x.item.$attributes.jid);
                                    participant.is_current_user = (participant.jid === this._jid);
                                    participant.username = index_1.default.Strophe.getNodeFromJid(participant.jid);
                                    participant.room_name = index_1.default.Strophe.getNodeFromJid(presence.$attributes.from);
                                    participant.affiliation = presence.x.item.$attributes.affiliation;
                                    participant.room_role = presence.x.item.$attributes.role;
                                    // Flag if the user is online/offline
                                    participant.online = (presence.$attributes.type !== "unavailable");
                                    participant.show = presence.show;
                                    participant.status = presence.status;
                                    participant.ts = this.getSyncedTimestamp(Date.now());
                                    if (presence.metadata !== undefined) {
                                        const metadata = presence.metadata;
                                        delete metadata.$attributes;
                                        participant.metadata = metadata;
                                    }
                                    participant.updated_at = null;
                                    participant.last_stanza = presence;
                                }
                                catch (e) {
                                    this._onError(`Presence stanza wasn't in the expected format when trying to create a new participant with ID '${participant._id}' and JID '${participant.jid}'.`, e);
                                }
                            }
                            return participant;
                        }).then((participant) => {
                            if (participant.updated_at === null) {
                                this._dispatchEvent(CtXmppClient.EVENT_TYPES.NEW_PARTICIPANT, participant);
                            }
                            else {
                                this._dispatchEvent(CtXmppClient.EVENT_TYPES.PARTICIPANT_UPDATED, participant);
                            }
                        }).catch((e) => {
                            this._onError("Couldn't upsert participant database.", e);
                        });
                    }
                    else {
                        this._saveObject(CtXmppClient.OBJECT_TYPES.CONTACT, jid, (contact) => {
                            if (contact !== undefined) {
                                // Flag if the user is online/offline
                                contact.online = (presence.$attributes.type !== "unavailable");
                                if (presence.show !== undefined) {
                                    contact.show = presence.show;
                                }
                                if (presence.status !== undefined) {
                                    contact.status = presence.status;
                                }
                                if (presence.metadata !== undefined) {
                                    const metadata = presence.metadata;
                                    delete metadata.$attributes;
                                    contact.metadata = metadata;
                                }
                            }
                            return contact;
                        }, (contact) => {
                            let vCardUpdate = false;
                            // If there has been a vCard avatar update, fetch the new vCard
                            if (presence.x && presence.x.$attributes && presence.x.$attributes.xmlns && presence.x.$attributes.xmlns === CtXmppClient.NAMESPACES.VCARD_UPDATE) {
                                if (presence.x.photo !== undefined && typeof presence.x.photo === "string") {
                                    if (contact.avatarHash === undefined || contact.avatarHash !== presence.x.photo) {
                                        vCardUpdate = true;
                                        // This contact's avatar has changed.  Fetch new vcard for them
                                        this._log("🂡 Avatar update for:", jid);
                                        this._log("🂡 New avatar hash:", presence.x.photo);
                                        this.updatevCardForContact(jid).then(() => {
                                            // Contact updated.
                                            this._saveObject(CtXmppClient.OBJECT_TYPES.CONTACT, jid, (contact) => {
                                                contact.avatarHash = presence.x.photo;
                                                return contact;
                                            }, (contact) => {
                                                // Contact updated with avatar hash
                                                this._dispatchEvent(CtXmppClient.EVENT_TYPES.PRESENCE_UPDATE, contact);
                                            }, (e) => {
                                                this._onError("Couldn't update contact with vCard: ", e);
                                            });
                                        }).catch((e) => {
                                            this._onError("Couldn't get updated vCard for contact: ", e);
                                        });
                                    }
                                }
                            }
                            if (vCardUpdate === false) {
                                this._dispatchEvent(CtXmppClient.EVENT_TYPES.PRESENCE_UPDATE, contact);
                            }
                        }, (e) => {
                            this._onError("Couldn't upsert contacts database.", e);
                        });
                    }
                }
            }
        }
        return true;
    }
    /**
     * Fetch a contact by it's jid
     * @param {string} jid
     * @returns {Promise<Contact>}
     */
    getContactByJid(jid) {
        this._isMethodReady(true);
        return new es6_promise_1.Promise((resolve, reject) => {
            this.findContacts({
                "id": jid
            }).then((results) => {
                let contact = results[0];
                if (contact !== undefined) {
                    resolve(contact);
                }
                else {
                    reject("No contact found: " + jid);
                }
            }).catch(reject);
        });
    }
    /**
     * Fetch a vCard for a user, store it on their contact
     * @param jid
     * @returns {Promise}
     */
    updatevCardForContact(jid) {
        this._isMethodReady(true, true);
        this._log("🂡 Updating vCard for Contact:", jid);
        return new es6_promise_1.Promise((resolve, reject) => {
            this.findContacts({
                "id": jid
            }).then((results) => {
                let contact = results[0];
                if (contact !== undefined) {
                    return contact;
                }
                else {
                    this._log("🂡 No contact:", jid);
                    reject("No contact found: " + jid);
                }
            }).then((contact) => {
                this._getvCard(jid).then((vCardStr) => {
                    if (vCardStr !== undefined) {
                        const card = vcard_simple_1.VCardSimple.fromXml(vCardStr);
                        if (card !== undefined) {
                            this._saveObject(CtXmppClient.OBJECT_TYPES.CONTACT, jid, (contact) => {
                                contact.vCard = card.toJSON();
                                return contact;
                            }, (contact) => {
                                this._log("🂡 vCard Updated:", jid);
                                resolve(contact);
                            }, (e) => {
                                this._log("🂡 Couldn't save contact:", jid);
                                reject("Couldn't save contact: " + e);
                            });
                        }
                        else {
                            this._log("🂡 Bad vCard:", jid);
                            reject("Bad vCard");
                        }
                    }
                    else {
                        this._log("🂡 No vCard:", jid);
                        resolve(null);
                    }
                }).catch(reject);
            }).catch(reject);
        });
    }
    /**
     * Private method to process the roster and convert items to contacts
     * @param roster
     * @returns {Promise}
     * @private
     */
    _processRoster(roster) {
        return new es6_promise_1.Promise((resolve, reject) => {
            if (roster !== undefined && roster.iq !== undefined && roster.iq.query !== undefined) {
                // Cache the current roster version if we've been given one by the server
                if (roster.iq.query.$attributes !== undefined && roster.iq.query.$attributes.ver !== undefined) {
                    this._setCacheItem("roster_version", roster.iq.query.$attributes.ver).catch(reject);
                }
                if (roster.iq.query.item !== undefined) {
                    const items = (Array.isArray(roster.iq.query.item)) ? roster.iq.query.item : [roster.iq.query.item];
                    const contacts = [];
                    items.forEach((item) => {
                        if (item.$attributes["jid"] !== undefined) {
                            const contact = {
                                id: item.$attributes["jid"],
                                subscription: item.$attributes["subscription"],
                                online: false
                            };
                            if (item.group !== undefined) {
                                if (typeof item.group === "string") {
                                    contact.groups = [item.group];
                                }
                                else if (Array.isArray(item.group)) {
                                    contact.groups = item.group;
                                }
                            }
                            contacts.push(contact);
                        }
                    });
                    // Get the local list of contacts
                    this._contactDb.allDocs({
                        "include_docs": true
                    }).then((docs) => {
                        const proms = [];
                        // Go through each of the current contacts and compare against the contacts from the server
                        docs.rows.forEach((row) => {
                            let cContact = row.doc;
                            let nContact = null;
                            contacts.every((contact, idx) => {
                                if (contact.id === cContact.id) {
                                    nContact = contact;
                                    // Remove the nContact from the contacts array so we know which ones are new
                                    delete contacts[idx];
                                    return false;
                                }
                                return true;
                            });
                            if (nContact === null) {
                                // Contact doesn't exist on the server anymore, so delete it locally
                                proms.push(this._contactDb.remove(cContact));
                                // If something has changed then merge the new contact into the current one
                            }
                            else if (cContact.subscription !== nContact.subscription || !CtXmppClient._arraysEqual(cContact.groups, nContact.groups)) {
                                // Server is the master, update properties changed on the server but don't remove local properties
                                cContact = CtXmppClient._merge(cContact, nContact);
                                this._log("MERGED CONTACT:", cContact);
                                // Save the updated contact to the database
                                proms.push(this._contactDb.post(cContact));
                            }
                        });
                        // Find out which contacts are left, these are new ones which need adding
                        contacts.forEach((contact) => {
                            this._log("ADDING NEW CONTACT:", contact);
                            proms.push(new es6_promise_1.Promise((resolve, reject) => {
                                this._saveObject(CtXmppClient.OBJECT_TYPES.CONTACT, contact.id, (noContact) => {
                                    return contact;
                                }, (doc) => {
                                    this._log("CONTACT ADDED:", contact.id);
                                    resolve(doc);
                                }, (e) => {
                                    this._log("CONTACT ADD FAILED:" + contact.id + ": " + e);
                                    reject(e);
                                });
                            }));
                        });
                        es6_promise_1.Promise.all(proms).then(resolve).catch((error) => {
                            this._onError("Couldn't merge contacts from server with locally sorted contacts.", error);
                            reject(error);
                        });
                    });
                }
                else {
                    // Nothing in the roster to process so just resolve
                    resolve();
                }
            }
            else {
                // We could get an empty response because we are using roster versioning
                // An empty response means nothing has changed since we last requested the roster
                resolve();
            }
        });
    }
    /**
     * Fetch vCards for all contacts, storing them as 'vCard' on contacts object
     * @returns {Promise}
     */
    getvCardsForAllContacts() {
        this._isMethodReady(true, true);
        this._log("🂡 Fetching all vCards...");
        return new es6_promise_1.Promise((resolve1, reject1) => {
            this.getContacts().then((contacts) => {
                const proms = [];
                contacts.forEach((contact, index) => {
                    this._log("🂡 Fetching vCard for:", contact.id);
                    proms.push(new es6_promise_1.Promise((resolve2, reject2) => {
                        this.updatevCardForContact(contact.id).then(() => {
                            this._log("🂡 Fetched vCard for:", contact.id);
                            resolve2();
                        }).catch((e) => {
                            // Ignore error - move on to next contact
                            resolve2();
                        });
                    }));
                });
                es6_promise_1.Promise.all(proms).then(resolve1).catch(reject1);
            });
        });
    }
    /**
     * Retrieves current user vCard as JSON
     * @returns {Promise}
     */
    getOurvCard() {
        this._isMethodReady(true, true);
        this._log("🂡 Fetching vCard for:", this._bareJid);
        return new es6_promise_1.Promise((resolve, reject) => {
            this._getvCard(this._bareJid).then((vCardStr) => {
                if (vCardStr === undefined || vCardStr.length < 1) {
                    return reject("No vCard");
                }
                const card = vcard_simple_1.VCardSimple.fromXml(vCardStr);
                if (card !== undefined) {
                    this._log("🂡 Fetched vCard: ", card.toJSON());
                    resolve(card.toJSON());
                }
                else {
                    this._log("🂡 Bad vCard: ", this._bareJid);
                    reject("Bad vCard");
                }
            }).catch(reject);
        });
    }
    /**
     * save a replacement vCard back to the server
     * @param cardJSON
     * @returns {Promise}
     */
    saveOurvCard(cardJSON) {
        this._isMethodReady(true, true);
        this._log("🂡 Saving vCard for:", this._bareJid);
        return new es6_promise_1.Promise((resolve, reject) => {
            const card = vcard_simple_1.VCardSimple.fromJSON(cardJSON);
            this._setvCard(this._bareJid, card.toXML(true)).then(() => {
                this._log("🂡 Saved vCard for:", this._bareJid);
                resolve();
            }).catch(reject);
        });
    }
    /**
     * Private method used to dispatch error events
     * @param errorDesc
     * @param errorObj
     * @private
     */
    _onError(errorDesc, errorObj) {
        console.error(errorDesc, errorObj || "");
        this._dispatchEvent(CtXmppClient.EVENT_TYPES.ERROR, errorObj);
    }
    /**
     * Private method used to set an item in the cache
     * @param id
     * @param value
     * @param secret
     * @returns {Promise}
     * @private
     */
    _setCacheItem(id, value, secret = false) {
        return new es6_promise_1.Promise((resolve, reject) => {
            const save = () => {
                this._saveObject(CtXmppClient.OBJECT_TYPES.CACHE_ITEM, id, (item) => {
                    if (item.value === value)
                        return false;
                    item.value = value;
                    item.secret = (secret === true);
                    return item;
                }, (item) => {
                    const value = item.value;
                    if (item.secret === false) {
                        this._cache[id] = value;
                    }
                    resolve(item.value);
                }, (e) => {
                    // If the databases are being destoryed then we don't care so just resolve
                    // so we don't get any unwanted errors
                    if (e === CtXmppClient.ERROR_CODES.DESTROYING_DBS) {
                        resolve();
                    }
                    else {
                        this._onError(`Couldn't set cache item '${id}' with value '${value}'.`);
                        reject(e);
                    }
                });
            };
            // If the current value is the same we don't want to try and save it
            this._getCacheItem(id).then(currentValue => {
                if (currentValue === value) {
                    resolve(currentValue);
                }
                else {
                    save();
                }
            }).catch(save);
        });
    }
    /**
     * Private method used to get an item from the cache
     * @param id
     * @param attempts
     * @returns {Promise}
     * @private
     */
    _getCacheItem(id, attempts = 0) {
        const MAX_ATTEMPTS = 5;
        return new es6_promise_1.Promise((resolve) => {
            if (this._cache[id] !== undefined) {
                resolve(this._cache[id]);
            }
            else {
                this._cacheDb.get(id).then((item) => {
                    if (this._options.encryption && !item.hasOwnProperty("value")) {
                        // it is possible that the db isn't yet decripted - if this is the case, try again in 100ms
                        attempts = attempts + 1;
                        if (attempts === MAX_ATTEMPTS) {
                            // we've tried enough - bail with an undefined value
                            resolve();
                        }
                        else {
                            setTimeout(() => {
                                this._getCacheItem(id, attempts).then(resolve);
                            }, 100);
                        }
                    }
                    else {
                        const value = item.value;
                        if (item.secret === false) {
                            this._cache[id] = value;
                        }
                        resolve(value);
                    }
                }).catch(() => {
                    // Cache item doesn't exist, resolve nothing.
                    resolve();
                });
            }
        });
    }
    /**
     * Private method used to delete an item from the cache
     * @param id
     * @returns {Promise}
     * @private
     */
    _deleteCacheItem(id) {
        return new es6_promise_1.Promise((resolve, reject) => {
            this._cacheDb.get(id).then((item) => {
                this._cacheDb.remove(item).then(() => {
                    delete this._cache[id];
                    resolve();
                }).catch(reject);
            }).catch(() => {
                // Cache item doesn't exist, resolve nothing.
                resolve();
            });
        });
    }
    _messageDelta(stanza, message, defaults) {
        const fullJid = stanza.message.$attributes.from;
        const senderId = index_1.default.Strophe.getBareJidFromJid(fullJid);
        const senderResource = index_1.default.Strophe.getResourceFromJid(fullJid);
        // Does the message already exist?
        if (message._id !== undefined) {
            // Yes, so update the bits which need updating
            if (stanza !== message.stanza) {
                message.stanza = stanza;
            }
            if (stanza.message.body !== undefined && stanza.message.body !== message.body) {
                message.body = stanza.message.body;
            }
            if (message.type === null) {
                message.type = stanza.message.$attributes.type;
            }
            if (message.type === "groupchat") {
                message.state.sent = true;
            }
            if (message.jid === null) {
                message.jid = fullJid;
            }
            if (message.sender_id === null) {
                message.sender_id = senderId;
            }
            if (message.sender_resource === null) {
                message.sender_resource = senderResource;
            }
            if (message.recipient_id === null) {
                message.recipient_id = stanza.message.$attributes.to;
            }
            if (stanza.message.data !== undefined && stanza.message.data !== message.data) {
                message.data = stanza.message.data;
            }
            if (message.ts === null || (stanza.message.timestamp && stanza.message.timestamp.length > 1)) {
                message.ts = this._getTimestampFromStanza(stanza);
            }
            if (message.mine === null) {
                message.mine = (senderId === this._bareJid);
            }
            message.placeholder = false;
            message.archive_id = this._getArchiveIdFromStanza(stanza);
            message.updated_at = this.getSyncedTimestamp(Date.now());
            message = CtXmppClient._merge(message, defaults);
        }
        else {
            // No, so create a new one        
            let attachments = [];
            if (stanza.message.attachments !== undefined) {
                if (!Array.isArray(stanza.message.attachments)) {
                    attachments.push(stanza.message.attachments);
                }
                else {
                    attachments = stanza.message.attachments;
                }
            }
            let messageSkeleton = {
                _id: stanza.message.$attributes.id,
                stanza: stanza,
                archive_id: this._getArchiveIdFromStanza(stanza),
                jid: fullJid,
                sender_id: senderId,
                sender_resource: senderResource,
                recipient_id: stanza.message.$attributes.to,
                body: stanza.message.body || null,
                updated_at: null,
                ts: this._getTimestampFromStanza(stanza),
                state: {
                    sent: null,
                    markers: [],
                    received: null,
                    read: null,
                    acknowledged: null
                },
                data: stanza.message.data || {},
                attachments: attachments,
                type: stanza.message.$attributes.type || "chat",
                mine: (senderId === this._bareJid),
                markable: (stanza.message.markable !== undefined),
                fromMam: false,
                injected: false,
                placeholder: false
            };
            let addresses = [];
            if (stanza.message.addresses !== undefined) {
                if (!Array.isArray(stanza.message.addresses.address)) {
                    addresses.push(stanza.message.addresses.address);
                }
                else {
                    addresses = stanza.message.addresses.address;
                }
            }
            message = Object.assign({}, CtXmppClient._messageSkeleton(), {
                _id: stanza.message.$attributes.id,
                stanza: stanza,
                archive_id: this._getArchiveIdFromStanza(stanza),
                jid: fullJid,
                sender_id: senderId,
                sender_resource: senderResource,
                recipient_id: stanza.message.$attributes.to,
                body: stanza.message.body,
                ts: this._getTimestampFromStanza(stanza),
                data: stanza.message.data,
                attachments: attachments,
                type: stanza.message.$attributes.type,
                mine: (senderId === this._bareJid),
                markable: (stanza.message.markable !== undefined),
                addresses: addresses
            });
        }
        if (stanza.message.$attributes && stanza.message.$attributes.type === "groupchat") {
            message.type = "groupchat";
            message.mine = (index_1.default.Strophe.getBareJidFromJid(stanza.message.$attributes.from) === this._bareJid || index_1.default.Strophe.getResourceFromJid(stanza.message.$attributes.from) === this.username);
        }
        return CtXmppClient._merge(message, defaults);
    }
    static _messageSkeleton() {
        return {
            _id: null,
            stanza: null,
            archive_id: null,
            jid: null,
            sender_id: null,
            sender_resource: null,
            recipient_id: null,
            body: null,
            updated_at: null,
            ts: null,
            state: {
                sent: null,
                markers: [],
                received: null,
                read: null,
                acknowledged: null
            },
            data: {},
            attachments: [],
            type: "chat",
            mine: null,
            markable: false,
            fromMam: false,
            placeholder: false,
            injected: false
        };
    }
    /**
     * Convenience method used to convert an XMPP stanza to a message database object
     * @param stanza
     * @param defaults
     * @param persist
     * @returns {Promise}
     * @private
     */
    _messageStanzaToDbObject(stanza, defaults) {
        return new es6_promise_1.Promise((resolve, reject) => {
            if (stanza.message !== undefined && stanza.message.$attributes !== undefined) {
                this.saveMessage(stanza.message.$attributes.id, (message) => {
                    return this._messageDelta(stanza, message, defaults);
                }).then(resolve).catch((e) => {
                    this._onError("Unable to convert message stanza to DB object.", e);
                    reject(e);
                });
            }
            else {
                const msg = "No message part present in the stanza.";
                this._onError(msg);
                reject(msg);
            }
        });
    }
    _getTimestampFromStanza(stanza) {
        let ts = null;
        if (stanza.message !== undefined && stanza.message.timestamp !== undefined) {
            if (Array.isArray(stanza.message.timestamp)) {
                const timestamps = stanza.message.timestamp.filter((stanza) => {
                    return (stanza.$attributes !== undefined && stanza.$attributes.xmlns === CtXmppClient.NAMESPACES.CT_SERVER_TIMESTAMP);
                });
                if (timestamps[0] !== undefined) {
                    ts = parseInt(timestamps[0].$value);
                }
            }
            else if (stanza.message.timestamp.$value !== undefined) {
                ts = parseInt(stanza.message.timestamp.$value);
            }
        }
        if (ts === null) {
            ts = this.getSyncedTimestamp(Date.now());
        }
        return ts;
    }
    _getArchiveIdFromStanza(stanza) {
        let archiveId = null;
        if (stanza.message.archived !== undefined) {
            const archiveObj = (Array.isArray(stanza.message.archived)) ? stanza.message.archived[0] : stanza.message.archived;
            if (archiveObj.$attributes !== undefined && archiveObj.$attributes.id !== undefined) {
                archiveId = archiveObj.$attributes.id;
            }
        }
        return archiveId;
    }
    /**
     * Private method used to output debugging information to the console
     * @param detail
     * @param value
     * @private
     */
    _log(detail, value) {
        if (this._options.debug === true) {
            console.debug("[" + new Date().toString() + "] ", detail, value || "");
        }
    }
    /**
     * Method used to generate a unique GUID to be used as message IDs
     * @returns {string}
     */
    getUniqueId() {
        this._isMethodReady(true, true);
        return this._connection.getUniqueId(`${this._instanceId}-${performance.now()}`);
    }
    _clearBotTimeout(requestId) {
        if (this._botCommandTimeouts[requestId]) {
            this._log(`Bot command response verified, removing bot timeout for request '${requestId}'.`);
            this._botCommandTimeouts[requestId].cancel();
            delete this._botCommandTimeouts[requestId];
        }
    }
    _clearBotPromise(requestId) {
        if (!this._botCommandPromises[requestId])
            return;
        this._log(`Clearing bot command promise for request '${requestId}'.`);
        delete this._botCommandPromises[requestId];
    }
    _botCommandResponseHandler(requestId, stanza) {
        if (!this._botCommandPromises[requestId])
            return false;
        if (stanza.message !== undefined && stanza.message.$attributes !== undefined && stanza.message.$attributes.type === "error") {
            const _requestId = (stanza.message.error !== undefined && stanza.message.error.$attributes !== undefined && stanza.message.error.$attributes["request-id"]) ? stanza.message.error.$attributes["request-id"] : null;
            if (_requestId === requestId) {
                this._clearBotTimeout(_requestId);
                const errorMsg = (stanza.message.error !== undefined && stanza.message.error.text !== undefined) ? stanza.message.error.text.$value : "An unexpected error occurred";
                this._botCommandPromises[requestId].reject(errorMsg);
                this._clearBotPromise(requestId);
            }
        }
        else if (stanza.message !== undefined && stanza.message.call !== undefined && stanza.message.call.$attributes !== undefined && stanza.message.call.$attributes.type === "result" && stanza.message.call.$attributes["request-id"] === requestId) {
            this._clearBotTimeout(requestId);
            if (stanza.message.call.json !== undefined && stanza.message.call.json.$value !== undefined) {
                let json = null;
                try {
                    json = JSON.parse(stanza.message.call.json.$value);
                }
                catch (e) {
                    this._onError("Couldn't parse JSON from bot command response:", e);
                    this._botCommandPromises[requestId].reject(e);
                    this._clearBotPromise(requestId);
                }
                if (json !== null) {
                    this._botCommandPromises[requestId].resolve(json);
                    this._clearBotPromise(requestId);
                }
            }
            // We've got our response so we no longer need the handler
            return false;
        }
        // Not got our response yet so keep the handler open
        return true;
    }
    /**
     * Method used to send a command to a bot and retrieve the result
     * @param botJid {String}
     * @param operationName {String}
     * @param data {Object}
     * @param timeout {Number} - If we don't get a response in this time then assume its not worked and reject
     * @returns {Promise}
     */
    sendBotCommand(botJid, operationName, data, timeout = 5000) {
        this._isMethodReady(true, true);
        return new es6_promise_1.Promise((resolve, reject) => {
            const requestId = this.getUniqueId();
            const stanza = {
                $attributes: {
                    to: botJid,
                    type: "normal"
                },
                call: {
                    $attributes: {
                        xmlns: CtXmppClient.NAMESPACES.INFINITY_BOT,
                        "request-id": requestId,
                        type: "get",
                        name: operationName
                    }
                }
            };
            let jsonString = null;
            try {
                jsonString = JSON.stringify(data);
            }
            catch (e) {
                this._onError("Couldn't stringify JSON:", e);
            }
            if (jsonString !== null) {
                stanza.call.json = {
                    $attributes: {
                        xmlns: "urn:xmpp:json:0"
                    },
                    $value: jsonString
                };
            }
            this._botCommandPromises[requestId] = {
                resolve: resolve,
                reject: reject
            };
            // Response handler defined in _onStanza so that responses get handled across disconnects
            this.sendStanza(stanza, false).then(() => {
                this._log(`Creating bot command timer for request '${requestId}'...`);
                this._botCommandTimeouts[requestId] = new timer_1.default(requestId, () => {
                    this._log(`Bot command timer finished for request '${requestId}'.`);
                    this._onError(`Didn't get a response from the bot within ${timeout}ms.`, {
                        operationName: operationName
                    });
                    this._botCommandPromises[requestId].reject("Your request took longer then expected, please try again.");
                }, timeout);
            }).catch(e => {
                this._onError("Couldn't send bot command:", e);
                reject(e);
            });
        });
    }
    _pushHandler(data) {
        this._log("Push Received: ", data);
    }
    /**
     * Method used to fetch a push token using the plugin
     * @returns {Promise<string>}
     * @private
     */
    _getPushToken() {
        return new es6_promise_1.Promise((resolve, reject) => {
            var config = null;
            if (environment_1.getPlatformName() === "android") {
                config = {
                    "senderID": this._options.push.senderId
                };
            }
            else if (environment_1.getPlatformName() === "ios") {
                config = {
                    "badge": "true",
                    "sound": "true",
                    "alert": "true"
                };
            }
            if (config !== null) {
                if (this._options.push.voip && environment_1.getPlatformName() === "ios") {
                    const that = this;
                    const voipPushPlugin = Plugin.getSource("VoIPPushNotification");
                    if (voipPushPlugin !== false) {
                        const voipPush = voipPushPlugin.init();
                        voipPush.on("registration", function (data) {
                            that._log("Registered for push: ", data.deviceToken);
                            that._setCacheItem("push_token", data.deviceToken).then(() => {
                                resolve(data.deviceToken);
                            });
                        });
                        voipPush.on("notification", function (data) {
                            const insomnia = Plugin.getSource("insomnia");
                            if (insomnia && that._options.bringToForegroundOnVoipPush !== false) {
                                insomnia.switchOnScreenAndForeground();
                                that._pushHandler(data);
                            }
                            if (that._options.push.reLoginOnPushiOS) {
                                if (!that.connected)
                                    that.reLoginNow();
                            }
                        });
                        voipPush.on("error", function (e) {
                            that._log("VOIP Push Error: " + e);
                        });
                    }
                    else {
                        this._log("Could not find VOIP Push plugin");
                        reject("Could not find VOIP Push plugin");
                    }
                }
                else {
                    const NotificationPlugin = Plugin.getSource("notification");
                    if (NotificationPlugin !== false) {
                        this._log("Registering for push notifications...");
                        const that = this;
                        NotificationPlugin.registerForPush(function (token) {
                            that._log("Registered for push:", token);
                            // Listen for push notifications incoming
                            NotificationPlugin.on("pushReceived", function (data) {
                                that._pushHandler(data);
                                if (that._options.push.reLoginOnPushAndroid) {
                                    if (!that.connected)
                                        that.reLoginNow();
                                }
                            });
                            // Set the token in the model so it can be used later in the app
                            that._setCacheItem("push_token", token).then(() => {
                                resolve(token);
                            });
                        }, function (error) {
                            that._log("Error registering for push:", error);
                            reject(error);
                        }, config);
                    }
                    else {
                        this._log("Could not find Push plugin");
                        reject("Could not find Push plugin");
                    }
                }
            }
        });
    }
    /**
     * Method to contact the server to register for push notifications
     * @returns {Promise}
     * @private
     */
    registerForPush(token) {
        if (!environment_1.isDevice())
            throw new Error("This platform does not support push notifications.");
        return new es6_promise_1.Promise((resolve, reject) => {
            this.sendIq(null, "set", {
                push: {
                    $attributes: {
                        xmlns: CtXmppClient.NAMESPACES.CT_PUSH
                    },
                    notification: {
                        package: this._options.push.packageId,
                        type: (environment_1.getPlatformName() === "ios") ? "apns" : "gcm",
                        token: token,
                        installation_id: this._installId
                    }
                }
            }).then((result) => {
                let pushJid = null;
                try {
                    pushJid = result.iq.push.notification.$attributes.jid;
                    this._pushNodeName = result.iq.push.notification.$attributes.node;
                }
                catch (e) {
                    this._onError("Couldn't enable push notifications.", e);
                    reject(e);
                }
                if (pushJid !== null) {
                    this._setCacheItem("push_jid", pushJid).then(() => {
                        this.enablePush().then(resolve).catch(reject);
                    });
                }
            }).catch(e => {
                this._onError("Couldn't register for push notifications:", e);
                reject(e);
            });
        });
    }
    /**
     * Method to contact the server to enable push notifications
     * @returns {Promise}
     * @private
     */
    enablePush() {
        return new es6_promise_1.Promise((resolve, reject) => {
            this._getCacheItem("push_jid").then((pushJid) => {
                if (pushJid !== undefined) {
                    this.sendIq(null, "set", {
                        enable: {
                            $attributes: {
                                xmlns: CtXmppClient.NAMESPACES.PUSH,
                                jid: pushJid,
                                node: this._pushNodeName
                            }
                        }
                    }).then(resolve).catch(e => {
                        this._onError("Unable to enable push notifications:", e);
                        reject(e);
                    });
                }
                else {
                    this._onError("'registerForPush' must be called before 'enablePush'.");
                    reject();
                }
            });
        });
    }
    /**
     * Method to contact the server to disable push notifications
     * @returns {Promise}
     * @private
     */
    disablePush() {
        return new es6_promise_1.Promise((resolve, reject) => {
            this._getCacheItem("push_jid").then((pushJid) => {
                if (pushJid !== undefined) {
                    this.sendIq(null, "set", {
                        disable: {
                            $attributes: {
                                xmlns: CtXmppClient.NAMESPACES.PUSH,
                                jid: pushJid,
                                node: this._pushNodeName
                            }
                        }
                    }).then(resolve).catch(e => {
                        this._onError("Unable to disable push notifications:", e);
                        reject(e);
                    });
                }
                else {
                    resolve();
                }
            });
        });
    }
    /** Performance related logging methods **/
    _perfStart(key, msg, style) {
        if (this._options.perfLogging !== true)
            return;
        console.log(`%c[START: ${key}] ${msg}`, style);
        console.time(key);
    }
    _perfEnd(key, msg, style) {
        if (this._options.perfLogging !== true)
            return;
        console.log(`%c[END: ${key}] ${msg}`, style);
        console.timeEnd(key);
    }
    /**
     * Static method used to convert JSON stanza to XML stanzas
     * @param type
     * @param json
     * @returns {any}
     */
    static jsonToXml(type, json) {
        return CtXmppClient._parseJsonNode(json, CtXmppClient._createElement(type, json.$attributes));
    }
    static _parseJsonNode(json, $parent) {
        for (let key in json) {
            let value = json[key];
            if (key.indexOf("$") !== 0) {
                if (Array.isArray(value) && value.length > 0) {
                    value.forEach((item) => {
                        let $item = CtXmppClient._createElement(key, item.$attributes);
                        $item = CtXmppClient._parseJsonNode(item, $item);
                        $parent.appendChild($item);
                    });
                }
                else {
                    const $attrs = (typeof value === "object" && value !== null) ? value.$attributes : undefined;
                    let $element = CtXmppClient._createElement(key, $attrs);
                    if (typeof value === "object" && value !== null && Object.keys(value).length > 0) {
                        $element = CtXmppClient._parseJsonNode(value, $element);
                    }
                    else if (typeof value === "string") {
                        const $txt = CtXmppClient.doc.createTextNode(value);
                        $element.appendChild($txt);
                    }
                    $parent.appendChild($element);
                }
            }
            else if (key === "$value") {
                const $txt = CtXmppClient.doc.createTextNode(value);
                $parent.appendChild($txt);
            }
            else if (key === "$cdata") {
                const $cdata = CtXmppClient.doc.createCDATASection(value);
                $parent.appendChild($cdata);
            }
        }
        return $parent;
    }
    static xmlToJson($xml) {
        return CtXmppClient._parseXmlNode($xml, {});
    }
    static _parseXmlNode($xml, obj) {
        let _node = {};
        if ($xml.attributes !== undefined && $xml.attributes.length > 0) {
            _node.$attributes = {};
            for (let i = 0; i < $xml.attributes.length; i++) {
                const attr = $xml.attributes[i];
                _node.$attributes[attr.nodeName] = attr.value;
            }
        }
        if ($xml.childNodes.length > 0) {
            for (let j = 0; j < $xml.childNodes.length; j++) {
                const $child = $xml.childNodes[j];
                if ($child.nodeType === 3) {
                    if (_node.$attributes !== undefined) {
                        _node.$value = $child.textContent;
                    }
                    else {
                        _node = $child.textContent;
                    }
                }
                else if ($child.nodeType === 4) {
                    _node.$cdata = $child.textContent;
                }
                else {
                    // vCards come littered with textnodes that are just newlines.
                    // This causes some problems and they aren't useful.
                    if (_node === "\n") {
                        continue;
                    }
                    CtXmppClient._parseXmlNode($child, _node);
                }
            }
        }
        if (obj[$xml.nodeName] !== undefined && Array.isArray(obj[$xml.nodeName]) === false) {
            obj[$xml.nodeName] = [obj[$xml.nodeName]];
        }
        if (Array.isArray(obj[$xml.nodeName])) {
            obj[$xml.nodeName].push(_node);
        }
        else {
            obj[$xml.nodeName] = _node;
        }
        return obj;
    }
    static _createElement(name, attributes) {
        if (CtXmppClient.doc === null) {
            CtXmppClient.doc = document.implementation.createDocument('ct:xmpp:client', 'infinity', null);
        }
        const $element = CtXmppClient.doc.createElement(name);
        if (attributes !== undefined && Object.keys(attributes).length > 0) {
            for (let attr in attributes) {
                $element.setAttribute(attr, attributes[attr]);
            }
        }
        return $element;
    }
    static _getContactFromRosterByJid(jid, roster) {
        let result = null;
        if (roster !== undefined && roster.contacts !== undefined && roster.contacts.length > 0) {
            roster.contacts.forEach((contact) => {
                if (contact.jid === jid) {
                    result = contact;
                }
            });
        }
        return result;
    }
    static _isObject(item) {
        return (item && typeof item === 'object' && !Array.isArray(item));
    }
    static _merge(target, ...sources) {
        if (!sources.length)
            return target;
        const source = sources.shift();
        if (CtXmppClient._isObject(target) && CtXmppClient._isObject(source)) {
            for (const key in source) {
                if (CtXmppClient._isObject(source[key])) {
                    if (!target[key])
                        Object.assign(target, { [key]: {} });
                    CtXmppClient._merge(target[key], source[key]);
                }
                else {
                    Object.assign(target, { [key]: source[key] });
                }
            }
        }
        return CtXmppClient._merge(target, ...sources);
    }
    static _arraysEqual(arr1, arr2) {
        if (!Array.isArray(arr1) || !Array.isArray(arr2)) {
            return (arr1 === arr2);
        }
        if (arr1.length !== arr2.length)
            return false;
        for (let i = arr1.length; i--;) {
            if (arr1[i] !== arr2[i])
                return false;
        }
        return true;
    }
    /**
     * Static method used to validate a user provided event type against the constants
     * @param type
     * @returns {boolean}
     * @private
     */
    static _validateEventType(type) {
        return CtXmppClient._validateConstants(CtXmppClient.EVENT_TYPES, type);
    }
    /**
     * Static method used to validate a user provided chat status against the constants
     * @param type
     * @returns {boolean}
     * @private
     */
    static _validateChatStatus(type) {
        return CtXmppClient._validateConstants(CtXmppClient.CHAT_STATUSES, type);
    }
    ;
    /**
     * Static method used to validate against a set of constants
     * @param type
     * @returns {boolean}
     * @private
     */
    static _validateConstants(constants, value) {
        for (let t in constants) {
            if (constants[t] === value) {
                return true;
            }
        }
        return false;
    }
    ;
    /**
     * Static method to get the domain from the provided JID
     * @param jid
     * @private
     */
    static getDomainFromJid(jid) {
        const bare = index_1.default.Strophe.getBareJidFromJid(jid);
        return bare.split("@")[1];
    }
    static _isMarkerMessage(stanza) {
        return (stanza.message.received && stanza.message.received.$attributes && stanza.message.received.$attributes.xmlns === CtXmppClient.NAMESPACES.CHAT_MARKERS)
            || (stanza.message.read && stanza.message.read.$attributes && stanza.message.read.$attributes.xmlns === CtXmppClient.NAMESPACES.CHAT_MARKERS)
            || (stanza.message.acknowledged && stanza.message.acknowledged.$attributes && stanza.message.acknowledged.$attributes.xmlns === CtXmppClient.NAMESPACES.CHAT_MARKERS);
    }
    static getNodeFromJid(jid) {
        return index_1.default.Strophe.getNodeFromJid(jid);
    }
    /**
     *
     * @param options
     *
     * contain one of:
     *
     * mediaType: (MEDIA_TYPES)
     * or
     * mimeTypes: [array of mime types]
     *
     * If neither is supplied, then all file types are assumed
     *
     * @returns {Promise}
     */
    static pickFile(options = {}) {
        return File.pickFile(options);
    }
    _isMethodReady(initialisationRequired = true, connectionRequired = false) {
        if (initialisationRequired === true && this._initialised !== true)
            throw new Error(`XMPP client has not yet been fully initialised.`);
        if (connectionRequired === true && this.connected === false)
            throw new Error(`An active connection is required to perform this action.`);
    }
}
CtXmppClient.doc = null;
CtXmppClient.MARKER_TYPES = {
    "RECEIVED": "received",
    "READ": "read",
    "ACKNOWLEDGED": "acknowledged"
};
CtXmppClient.EVENT_TYPES = {
    "INITIALISED": "initialised",
    "STATUS": "status",
    "NEW_MESSAGE": "newmessage",
    "ERROR": "error",
    "MESSAGE_UPDATED": "messageupdated",
    "PRESENCE_UPDATE": "presenceupdate",
    "NEW_PARTICIPANT": "newparticipant",
    "PARTICIPANT_UPDATED": "participantupdated",
    "RECEIPT_RECEIVED": "receiptreceived",
    "AUTO_RECONNECTED": "autoreconnected",
    "DBS_DESTROYED": "dbsdestroyed",
    "AUTO_DBS_DESTROYED": "autodbsdestroyed",
    "ACK_RECEIVED": "ackreceived",
    "UPLOAD_STARTED": "uploadstarted",
    "UPLOAD_SUCCESS": "uploadsuccess",
    "UPLOAD_FAILED": "uploadfailed"
};
CtXmppClient.CHAT_STATUSES = {
    "AWAY": "away",
    "CHAT": "chat",
    "DND": "dnd",
    "XA": "xa"
};
CtXmppClient.NAMESPACES = {
    "MUC": "http://jabber.org/protocol/muc",
    "MUC_SUB": "urn:xmpp:mucsub:0",
    "MUC_OWNER": "http://jabber.org/protocol/muc#owner",
    "X_DATA": "jabber:x:data",
    "DISCO_INFO": "http://jabber.org/protocol/disco#info",
    "DISCO_ITEMS": "http://jabber.org/protocol/disco#items",
    "JABBER_CLIENT": "jabber:client",
    "MAM": "urn:xmpp:mam:0",
    "MAM_TMP": "urn:xmpp:mam:tmp",
    "RESULT_SET_MANAGEMENT": "http://jabber.org/protocol/rsm",
    "CHAT_MARKERS": "urn:xmpp:chat-markers:0",
    "CT_METADATA": "ct:metadata:0",
    "HINTS": "urn:xmpp:hints",
    "CT_CLIENT_TIMESTAMP": "ct:client-timestamp:0",
    "CT_SERVER_TIMESTAMP": "urn:commontime:infinity:timestamps",
    "HTTP_UPLOAD": "urn:xmpp:http:upload",
    "PING": "urn:xmpp:ping",
    "CLIENT_STATE_INDICATION": "urn:xmpp:csi:0",
    "ADDRESS": "http://jabber.org/protocol/address",
    "VCARD_UPDATE": "vcard-temp:x:update",
    "TIME": "urn:xmpp:time",
    "INFINITY_BOT": "urn:commontime:infinity:api",
    "PRIVATE_XML_STORAGE": "jabber:iq:private",
    "CT_PRIVATE_XML_STORAGE": "ct:private-xml-data",
    "CT_PUSH": "urn:commontime:infinity:push",
    "PUSH": "urn:xmpp:push:0",
    "DIRECTORY": "urn:commontime:infinity:directory",
    "CARBONS": "urn:xmpp:carbons:2",
    "INFINITY_MAM": "urn:commontime:infinity:mam",
    "INFINITY_ACK": "urn:commontime:infinity:ack"
};
CtXmppClient.MUC_NODES = {
    "PRESENCE": "urn:xmpp:mucsub:nodes:presence",
    "MESSAGES": "urn:xmpp:mucsub:nodes:messages",
    "AFFILIATIONS": "urn:xmpp:mucsub:nodes:affiliations",
    "CONFIG": "urn:xmpp:mucsub:nodes:config",
    "SUBJECT": "urn:xmpp:mucsub:nodes:subject",
    "SYSTEM": "urn:xmpp:mucsub:nodes:system"
};
CtXmppClient.MARKER_PRIORITIES = {
    "received": 3,
    "read": 2,
    "acknowledged": 1
};
CtXmppClient.OBJECT_TYPES = {
    "MESSAGE": "message",
    "CONTACT": "contact",
    "ROOM": "room",
    "PARTICIPANT": "participant",
    "CACHE_ITEM": "cache_item",
    "OBJECT_URL": "object_url"
};
CtXmppClient.CLIENT_STATES = {
    "ACTIVE": "active",
    "INACTIVE": "inactive"
};
CtXmppClient.ERROR_CODES = {
    "DESTROYING_DBS": "destroying_dbs"
};
exports.CtXmppClient = CtXmppClient;
window.CtXmppClient = CtXmppClient;


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const Comms_1 = __webpack_require__(64);
const Store_1 = __webpack_require__(81);
const Models = __webpack_require__(7);
const Handlers = __webpack_require__(11);
const base_1 = __webpack_require__(0);
const Events_1 = __webpack_require__(6);
const testingUtils_1 = __webpack_require__(82);
const utils_1 = __webpack_require__(3);
const models_1 = __webpack_require__(2);
const ResumableCommsEventArgs_1 = __webpack_require__(49);
const Handlers_1 = __webpack_require__(11);
const utils_2 = __webpack_require__(3);
const pagerUtils_1 = __webpack_require__(9);
class PagerLayer extends base_1.BaseLayer {
    // === Constructor === //
    constructor(name, config, dependencyInjections) {
        super(name, config);
        this._postLoginTimeout = null;
        // Private variable which indicates a login was initiated but a MAM fetch wasn't completed so we know to do it on auto reconnect
        this._needMamFetch = false;
        this.name = name;
        this.config = config;
        const store = (dependencyInjections && dependencyInjections.store) || new Store_1.Store(name, this.logger, this.config);
        const comms = (dependencyInjections && dependencyInjections.comms) || new Comms_1.Comms(name, this.config.xmpp, store, this.logger);
        comms.onDatabasesAutoDestroyed(() => __awaiter(this, void 0, void 0, function* () {
            // tslint:disable-next-line
            console.log("New user detected: clearing all data.");
            yield this.store.clearAllData();
            this.emit(Events_1.PagerEvents.DatabasesAutoDestroyed);
        }));
        comms.onAutoReconnected((data) => __awaiter(this, void 0, void 0, function* () {
            this._resumed = data.resumed;
            this.enableSuppressMode("pagerLayer#autoreconnect", true);
            const requiresMamFetch = (!this._resumed || this._needMamFetch);
            if (!this._resumed)
                this.showWaitingMessage("Updating...");
            yield this._postLogin(requiresMamFetch);
            yield this.purgeOldPages(true);
            if (!this._resumed)
                this.dismissWaitingMessage();
            this.emit(Events_1.PagerEvents.LoginResult, new ResumableCommsEventArgs_1.ResumableCommsEventArgs(data.resumed, true));
            yield this.cancelSuppressMode("pagerLayer#autoreconnect");
            this.emit(Events_1.PagerEvents._Request_CheckForPendingPages);
        }));
        comms.onError((err) => __awaiter(this, void 0, void 0, function* () {
            if (typeof err === "string") {
                if (err.toLowerCase().includes("kicked")) {
                    this.emit(Events_1.PagerEvents._Request_Component_Clear_Data);
                    this.emit(Events_1.PagerEvents.LogoutRequestConfirmed);
                    this.emit(Events_1.PagerEvents._Request_RaiseAlert, models_1.DefaultAlerts.AlertAcknowledge("Disconnected", "You have been disconnected by an Administrator."));
                }
            }
        }));
        this.bootstrap(comms, store);
        if (this.config.testMode) {
            // Testing
            window.sendTestMessages = testingUtils_1.sendBatchMessages;
            window.respondToTestMessages = testingUtils_1.respondToAllPendingMessages;
        }
        if (window.cti) {
            window.cti.store.schema.pagerVersion = window.CtPagerLayer.VERSION;
        }
    }
    mute() {
        this.emit(Events_1.PagerEvents.Mute);
    }
    login(user, password) {
        const _super = name => super[name];
        return __awaiter(this, void 0, void 0, function* () {
            const disconnectMsg = "Disconnected during login, please try again.";
            this.enableSuppressMode("pagerLayer#login", true);
            let resumed = false;
            try {
                resumed = yield _super("login").call(this, user, password);
            }
            catch (ex) {
                const msg = (typeof ex === "object" && ex.msg) ? ex.msg : disconnectMsg;
                this._handleLoginFailure(msg);
                return;
            }
            // Prepare for some scoping madness. We've had to move to a traditional that = this to ensure the 
            // scope for the '_pl_disconnected' event listener is correct and appropriately rejects the promise.
            // tslint:disable-next-line no-any
            const that = this;
            // tslint:disable-next-line no-any
            yield new Promise(function (_resolve, _reject) {
                // tslint:disable-next-line no-any
                let onDisconnect = function () {
                    _reject({
                        msg: disconnectMsg
                    });
                    document.removeEventListener("_pl_disconnected", onDisconnect);
                };
                onDisconnect = onDisconnect.bind(this);
                document.addEventListener("_pl_disconnected", onDisconnect);
                that.showWaitingMessage("Logging in...");
                that._postLogin(!resumed).then(() => {
                    return new Promise((resolve, reject) => {
                        that.purgeOldPages(true).then(() => {
                            resolve();
                        }).catch(reject);
                    });
                }).then(() => {
                    return new Promise((resolve, reject) => {
                        that.comms.getAllContacts().then(() => {
                            that.comms.getAllContactVCards().then(() => {
                                resolve();
                            }).catch(reject);
                        }).catch(reject);
                    });
                }).then(() => {
                    return new Promise((resolve, reject) => {
                        that.comms.getOurVCard().then((vCard) => {
                            if (utils_1.validateVCardObject(vCard)) {
                                if (utils_1.validateVCardObject(vCard.name)) {
                                    that.config.xmpp.user.displayName = `${vCard.name.given || ""} ${vCard.name.family || ""}`.trim();
                                    that.emit(Events_1.PagerEvents.CurrentUserVCardUpdate);
                                }
                            }
                            resolve();
                        }).catch(reject);
                    });
                }).then(() => {
                    that.dismissWaitingMessage();
                    that.cancelSuppressMode("pagerLayer#login").then(() => {
                        that.emit(Events_1.PagerEvents._Request_CheckForPendingPages);
                        _resolve();
                    });
                }).catch(_reject);
            }).catch(ex => {
                const msg = (typeof ex === "object" && ex.msg) ? ex.msg : disconnectMsg;
                that._handleLoginFailure(msg);
                return;
            });
        });
    }
    _postLogin(doMamFetch) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                clearTimeout(this._postLoginTimeout);
                const _handlePostLoginFailure = (ex) => {
                    this.dismissWaitingMessage();
                    clearTimeout(this._postLoginTimeout);
                    this.logger.error("Failure in post-login:", ex);
                    reject(ex);
                    return;
                };
                const loginTimeoutDuration = this.config.xmpp.loginTimeout || 10000;
                this._postLoginTimeout = setTimeout(() => {
                    clearTimeout(this._postLoginTimeout);
                    reject(new Error("Login took longer than expected, please try again."));
                }, loginTimeoutDuration);
                let users = [];
                try {
                    users = yield this.comms.getAllContacts();
                }
                catch (ex) {
                    return _handlePostLoginFailure(ex);
                }
                const noConsoleUsers = users.reduce((acc, cur) => {
                    if (cur && (!cur.groups || !cur.groups.includes("Console Users"))) {
                        acc.push(cur);
                    }
                    return acc;
                }, []);
                if (this.config.isBroadcaster && noConsoleUsers.length === 0) {
                    this.emit(Events_1.PagerEvents._Request_RaiseAlert, models_1.DefaultAlerts.AlertErrorWithOkayButton("Unauthorised", "You are not authorised to use the console application.", 1, {
                        okay: () => {
                            if (window.cti) {
                                window.cti.utils.callAction("go-to-page", { name: "Login" });
                            }
                        }
                    }));
                    this.emit(Events_1.PagerEvents._Request_Component_Clear_Data);
                    yield this.comms.logout();
                }
                else {
                    if (doMamFetch) {
                        this._needMamFetch = true;
                        try {
                            const messages = yield this.comms.getMessagesFromMam(this.getCurrentUserJid());
                            if (messages && messages.length > 0) {
                                yield this._processMamHistory(messages);
                            }
                            this._needMamFetch = false;
                        }
                        catch (ex) {
                            return _handlePostLoginFailure(ex);
                        }
                    }
                }
                clearTimeout(this._postLoginTimeout);
                resolve();
            }));
        });
    }
    _processMamHistory(messages) {
        return __awaiter(this, void 0, void 0, function* () {
            const newPages = [];
            const pageResponses = [];
            messages.map(msg => {
                msg.isFromMam = true;
                const messageType = utils_2.getMessageType(msg.data);
                if (messageType === Handlers_1.PagerMessageTypes.NewPage) {
                    let page = JSON.parse(msg.data[messageType]);
                    page.messageId = msg._id;
                    page.ts = msg.ts;
                    if (msg.attachments.length > 0) {
                        page = pagerUtils_1.addAttachmentsToPage(msg, page);
                    }
                    newPages.push(page);
                }
                else if (messageType === Handlers_1.PagerMessageTypes.PageResponse) {
                    pageResponses.push(JSON.parse(msg.data[messageType]));
                }
            });
            pageResponses.map((res) => __awaiter(this, void 0, void 0, function* () {
                let page = newPages.find(x => x._id === res.pageId);
                if (!page) {
                    page = yield this.store.getPageById(res.pageId);
                    if (page)
                        newPages.push(page);
                }
                if (page) {
                    const responses = page.individuals.find(x => x.jid === res.from).responses;
                    const existing = responses.find(x => x.type === res.response.type);
                    if (!existing) {
                        responses.push(res.response);
                    }
                }
            }));
            newPages
                .sort((a, b) => a.openedDate - b.openedDate)
                .map((page) => __awaiter(this, void 0, void 0, function* () {
                page.messageSplit = pagerUtils_1.parseMessageContent(page.message);
                yield this.store.addOrUpdatePage(page);
                if (!this.config.isBroadcaster) {
                    const user = page.individuals.find(x => x.jid === this.getCurrentUserJid());
                    const response = user.responses.find(x => x.type === Models.ContactResponseType.Response);
                    if (!response) {
                        const readReceipt = user.responses.find(x => x.type === Models.ContactResponseType.Received);
                        if (!readReceipt) {
                            this.sendReadReceipt(page);
                        }
                        if (this.config.xmpp.maxMessageAlertAge) {
                            const now = new Date().getTime();
                            const pageDate = page.openedDate;
                            if (now - pageDate <= this.config.xmpp.maxMessageAlertAge) {
                                yield this.store.addToPendingPages(page);
                                this.emit(Events_1.PagerEvents.NewPageReceived, page);
                            }
                        }
                        else {
                            yield this.store.addToPendingPages(page);
                            this.emit(Events_1.PagerEvents.NewPageReceived, page);
                        }
                    }
                    else {
                        this.emit(Events_1.PagerEvents.PageUpdate, page);
                    }
                }
                else {
                    this.emit(Events_1.PagerEvents.PageUpdate, page);
                }
            }));
        });
    }
    _handleLoginFailure(errorMsg) {
        return __awaiter(this, void 0, void 0, function* () {
            this.logger.error("😱 Handle login failure called:", errorMsg);
            this.dismissWaitingMessage();
            yield this.cancelSuppressMode("*");
            this._needMamFetch = false;
            if (errorMsg)
                this.emit(Events_1.PagerEvents._Request_RaiseAlert, models_1.DefaultAlerts.AlertErrorWithOkayButton("Error logging in", errorMsg, 1, {}));
            this.emit(Events_1.PagerEvents._Request_Component_Clear_Data);
            this.emit(Events_1.PagerEvents.LogoutRequestConfirmed);
            yield this.comms.logout(true);
            yield this.clearAllData();
        });
    }
    purgeOldPages(del = true) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.store.purgeOldPages(del);
            yield this.comms.purgeOldMessages();
        });
    }
    createNewPage() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                this.comms.getAllContactVCards();
                this._raiseNewPageModal.createNewPage();
            }
            catch (ex) {
                this.logger.error(ex);
            }
        });
    }
    getAllContacts(filter = false, filterType = Models.FilterType.Exclude, groupFilter = []) {
        return __awaiter(this, void 0, void 0, function* () {
            // await this.comms.getContactsWithVCards();
            let contacts = yield this.comms.getAllContacts();
            contacts = contacts.filter(x => x !== null);
            if (filter) {
                const filter = groupFilter.length > 0 ? groupFilter : this.config.filteredGroups;
                if (filter) {
                    const filtered = contacts.filter(contact => {
                        const groups = filter.filter(g => contact.groups.includes(g));
                        if (filterType === Models.FilterType.Exclude) {
                            return groups.length === 0 ? contact : null;
                        }
                        else {
                            return groups.length > 0 ? contact : null;
                        }
                    });
                    return filtered;
                }
                else
                    return contacts;
            }
            else
                return contacts;
        });
    }
    getOurVCard() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.comms.getOurVCard();
        });
    }
    setSelectedContacts(contacts) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.store.setSelectedContacts(contacts);
        });
    }
    getSelectedContacts() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.store.getSelectedContacts();
        });
    }
    getPages(amountToGet, offset) {
        return this.store.getPages(this.getCurrentUserJid(), this.config.isBroadcaster, amountToGet, offset);
    }
    setSelectedPage(page) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.store.setSelectedPage(page);
        });
    }
    getSelectedPage() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.store.getSelectedPage();
        });
    }
    getPendingPages() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.store.getPendingPages(this.getCurrentUserJid());
        });
    }
    deletePage(page) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.store.deletePage(page);
        });
    }
    updatePage(page) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.store.updatePage(page);
        });
    }
    addContactResponseToPage(page, response, jid) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!jid)
                jid = this.getCurrentUserJid();
            return yield this.store.addContactResponseToPage(page, response, jid);
        });
    }
    downloadAttachmentsByMessageId(messageId) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.comms.downloadAttachments(messageId);
        });
    }
    photoAttachmentsEnabled() {
        // Default is that they are enabled
        if (this.config.options && this.config.options.enablePhotoAttachments === false) {
            return false;
        }
        else {
            return true;
        }
    }
    audioAttachmentsEnabled() {
        // Default is that they are enabled
        if (this.config.options && this.config.options.enableAudioAttachments === false) {
            return false;
        }
        else {
            return true;
        }
    }
    sendReadReceipt(page) {
        const response = {
            ts: new Date().getTime(),
            type: Models.ContactResponseType.Received
        };
        // Emit event to say page has been received
        this.emit(Events_1.PagerEvents.PageResponse, new Events_1.SendPageResponseEventArgs(page._id, response, page.sender, page.isTestPage));
    }
    // === Private methods === //
    generateCommonComponents(host) {
        return __awaiter(this, void 0, void 0, function* () {
            this._raiseNewPageModal = document.querySelector("ct-pg-raise-new-page");
            if (this.config.isBroadcaster && !this._raiseNewPageModal) {
                this._raiseNewPageModal = document.createElement("ct-pg-raise-new-page");
                this._raiseNewPageModal.owner = this.name;
                host.appendChild(this._raiseNewPageModal);
            }
            this._readOnlyPageModal = document.querySelector("ct-pg-read-only-page");
            if (this.config.isBroadcaster && !this._readOnlyPageModal) {
                this._readOnlyPageModal = document.createElement("ct-pg-read-only-page");
                this._readOnlyPageModal.owner = this.name;
                host.appendChild(this._readOnlyPageModal);
            }
            this._newPageModal = document.querySelector("ct-pg-new-page-modal");
            if (!this.config.isBroadcaster && !this._newPageModal) {
                this._newPageModal = document.createElement("ct-pg-new-page-modal");
                this._newPageModal.owner = this.name;
                host.appendChild(this._newPageModal);
            }
            this._clientReadOnlyModal = document.querySelector("ct-pg-read-only-client");
            if (!this.config.isBroadcaster && !this._clientReadOnlyModal) {
                this._clientReadOnlyModal = document.createElement("ct-pg-read-only-client");
                this._clientReadOnlyModal.owner = this.name;
                host.appendChild(this._clientReadOnlyModal);
            }
        });
    }
    // tslint:disable-next-line no-any
    getHandlers() {
        return Handlers.get(this);
    }
}
// === Public fields === //
PagerLayer.VERSION = "0.2.5";
exports.PagerLayer = PagerLayer;
window.CtPagerLayer = PagerLayer;


/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Created by leon on 5/19/2017.
 */

Object.defineProperty(exports, "__esModule", { value: true });
/* tslint:disable */
// TODO: Fix linting issues
const plugin_1 = __webpack_require__(15);
const buffer_1 = __webpack_require__(98);
function isNumber(value) {
    return !isNaN(parseFloat(value)) && isFinite(value);
}
exports.isNumber = isNumber;
function generateGuid() {
    let d = Date.now();
    if (window.performance && typeof window.performance.now === "function") {
        d += performance.now(); // use high-precision timer if available
    }
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
        const r = (d + Math.random() * 16) % 16 | 0;
        d = Math.floor(d / 16);
        return (c === "x" ? r : (r & 0x3 | 0x8)).toString(16);
    });
}
exports.generateGuid = generateGuid;
function getEncryptionKey(id) {
    return new Promise((resolve, reject) => {
        const SecureSettings = plugin_1.getSource("securesettings");
        if (SecureSettings !== false) {
            SecureSettings.getOrCreateCryptographicKey(function (key) {
                function hexToBytes(hex) {
                    let bytes = [];
                    for (let c = 0; c < hex.length; c += 2)
                        bytes.push(parseInt(hex.substr(c, 2), 16));
                    return bytes;
                }
                const keyBuffer = buffer_1.Buffer.from(hexToBytes(key));
                resolve(keyBuffer);
            }, reject, id, 256);
        }
        else {
            console.warn("Oh no! 😱 Your databases are encrypted but the key couldn't be secured because this platform doesn't support secure settings.");
            const storedKey = localStorage.getItem(`${id}_key`);
            if (storedKey !== null) {
                const keyBuffer = buffer_1.Buffer.from(JSON.parse(storedKey));
                resolve(keyBuffer);
            }
            else {
                let arr = [], i;
                if (window.crypto && window.crypto.getRandomValues) {
                    var arr8 = new Uint8Array(32);
                    window.crypto.getRandomValues(arr8);
                    for (i = 0; i < 32; i++) {
                        arr[i] = arr8[i];
                    }
                }
                else {
                    for (let i = 0; i < 32; i++) {
                        arr[i] = Math.floor(Math.random() * 256);
                    }
                }
                localStorage.setItem(`${id}_key`, JSON.stringify(arr));
                const keyBuffer = buffer_1.Buffer.from(arr);
                resolve(keyBuffer);
            }
        }
    });
}
exports.getEncryptionKey = getEncryptionKey;


/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const base_1 = __webpack_require__(0);
const Models_1 = __webpack_require__(7);
const utils_1 = __webpack_require__(3);
const renderUtils_1 = __webpack_require__(4);
const components_1 = __webpack_require__(1);
const pagerUtils_1 = __webpack_require__(9);
var TabNames;
(function (TabNames) {
    // tslint:disable no-any
    TabNames[TabNames["Individuals"] = "individuals"] = "Individuals";
    TabNames[TabNames["Groups"] = "groups"] = "Groups";
    // tslint:enable no-any
})(TabNames || (TabNames = {}));
class CTPGContactSelection extends base_1.CTLayerComponent {
    constructor() {
        super(...arguments);
        this.tabSelected = TabNames.Individuals;
    }
    static get is() {
        return "ct-pg-contact-selection";
    }
    initialize() {
        return __awaiter(this, void 0, void 0, function* () { });
    }
    setupListeners() { }
    attributeChangedCallback(name, oldVal, newVal) {
        const _super = name => super[name];
        return __awaiter(this, void 0, void 0, function* () {
            _super("attributeChangedCallback").call(this, name, oldVal, newVal);
            if (name === "showing") {
                // TODO: this is quite un-optimised and is a candidate for a re-write at some point
                this.tabSelected = TabNames.Individuals;
                this.contacts = yield this.layer.getAllContacts(true);
                // Setup selected contacts
                this.contacts.map((contact) => {
                    const selected = this.selectedContacts.find(x => x.name === contact.id);
                    if (selected)
                        contact.selected = true;
                    else {
                        contact.selected = false;
                        contact.groups.map(groupName => {
                            const selectedGroup = this.selectedContacts.find(x => x.isGroup && x.name === groupName);
                            if (selectedGroup)
                                contact.selected = true;
                        });
                    }
                    contact.groups.map(group => {
                        const existing = this.groups[group];
                        if (!existing) {
                            this.groups[group] = {
                                id: group,
                                selectedCount: 0,
                                contactCount: 1,
                                selected: false
                            };
                        }
                        else {
                            existing.contactCount += 1;
                        }
                    });
                    return contact;
                });
                // Reset Groups
                Object.keys(this.groups).map(x => this.groups[x].selected = false);
                // Setup selected groups
                const groups = this.selectedContacts.filter(x => x.isGroup).sort((a, b) => {
                    if (a.name < b.name)
                        return -1;
                    if (a.name > b.name)
                        return 1;
                    return 0;
                });
                groups.map(group => {
                    this.groups[group.name].selected = true;
                });
                this.contacts.sort((a, b) => {
                    if (a.id < b.id)
                        return -1;
                    if (a.id > b.id)
                        return 1;
                    return 0;
                });
            }
        });
    }
    close() {
        this.showing = false;
        this.resetContactSelections();
        if (this.closeFunction)
            this.closeFunction();
    }
    selectTab(name) {
        this.tabSelected = name;
    }
    toggleContactSelection(nameOrId, isGroup = false) {
        if (!isGroup) {
            const contact = this.contacts.find(x => x.id === nameOrId);
            contact.selected = !contact.selected;
            if (contact.selected === false) {
                contact.groups.map(group => this.groups[group].selected = false);
            }
        }
        else {
            const group = this.groups[nameOrId];
            group.selected = !group.selected;
            this.contacts.map(contact => {
                const isInGroup = contact.groups.includes(group.id);
                if (isInGroup) {
                    contact.selected = group.selected;
                }
            });
        }
        this.forceRedraw();
    }
    resetContactSelections() {
        this.contacts = this.contacts.map(contact => (Object.assign({}, contact, { selected: false })));
        Object.keys(this.groups).map(group => this.groups[group].selected = false);
    }
    confirmSelectedContacts() {
        return __awaiter(this, void 0, void 0, function* () {
            this.selectedContacts = utils_1.deepCloneArray(pagerUtils_1.convertContacts(this.groups, this.contacts));
            yield this.layer.setSelectedContacts(this.selectedContacts);
            this.close();
        });
    }
    get generateComponentStyles() {
        return `:host{color:#333536;font-weight:400}:host h1,:host h2,:host h3,:host h4,:host h5,:host h6{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}:host,:host *{box-sizing:border-box}.user-html p{margin:0}.user-html p+p{margin:.8em 0 0 0}.user-html strong{font-weight:600}:host{width:100%;height:100%;display:flex;background-color:rgba(0,0,0,0.6);opacity:0;visibility:hidden;position:fixed;z-index:2;top:0}:host .container{display:flex;flex-direction:column;margin:auto;width:50vw;height:90vh;min-width:500px;transform:translateY(100%);will-change:transform;transition:transform 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);visibility:hidden}:host .container .title{display:flex;justify-content:flex-end;flex:0 0 var(--header-height, 60px);padding:10px 0 10px 20px}:host .container .title h2{position:absolute;left:50%;top:0;transform:translateX(-50%)}:host .container .tabs{display:flex;flex:0 0 var(--header-height, 60px)}:host .container .tabs .tab{flex-basis:50%;display:flex;cursor:pointer}:host .container .tabs .tab h4{margin:auto}:host .container .contacts{overflow:auto;-webkit-overflow-scrolling:touch}:host .container .contacts div.inner{display:flex;flex-direction:column;width:100%}:host .container .contacts div.inner div.row{width:100%;padding:15px 30px;margin:auto;cursor:pointer;display:flex;justify-content:space-between}:host .container .buttonsContainer{display:flex;flex:0 0 10vh;margin-top:auto;width:100%;justify-content:flex-end}:host .container .buttonsContainer div{width:50%;margin:auto}@media screen and (max-width: 640px){:host .container{width:100%;height:100%;min-width:100%;max-height:100%}}:host([showing]){visibility:visible;transition:opacity 0.25s ease-in;opacity:1}:host([showing]) div.container{visibility:visible;transform:translateY(0)}:host .container{background-color:var(--default-bg-color);color:var(--default-font-color)}:host .container .title{background-color:var(--primary-color, #15233B);color:var(--primary-font-color, #fff)}:host .container .tabs .tab{background-color:var(--primary-color, #15233B);color:var(--primary-font-color, #fff)}:host .container .tabs .tab.selected{background-color:var(--default-bg-color);color:var(--default-font-color)}:host .container .contacts div.inner div.row{border-bottom:1px solid var(--default-border-color)}:host .container .buttonsContainer{background-color:var(--default-bg-color-dark)}
        `;
    }
    generateComponentMarkup() {
        return (window.__CTRender("div", { className: "container" },
            window.__CTRender("div", { className: "title" },
                window.__CTRender("h2", null, "To:"),
                window.__CTRender(components_1.CTButton, { type: "transparent", icon: Models_1.Icons.FONTAWESOME.Cross, iconColor: "#fff", onClick: () => this.close() })),
            window.__CTRender("div", { className: "tabs" },
                window.__CTRender("div", { className: `tab ${this.tabSelected === TabNames.Individuals ? "selected" : ""}`, onClick: (e) => this.selectTab(TabNames.Individuals) },
                    window.__CTRender("h4", null, "Individuals")),
                window.__CTRender("div", { className: `tab ${this.tabSelected === TabNames.Groups ? "selected" : ""}`, onClick: (e) => this.selectTab(TabNames.Groups) },
                    window.__CTRender("h4", null, "Groups"))),
            window.__CTRender("div", { className: "contacts" }, this._renderContactsList()),
            window.__CTRender("div", { className: "buttonsContainer" },
                window.__CTRender("div", null,
                    window.__CTRender(components_1.CTButton, { type: "primary", onClick: () => this.confirmSelectedContacts() }, "Done")))));
    }
    _renderContactsList() {
        return renderUtils_1.renderIfElse(this.tabSelected === TabNames.Individuals, window.__CTRender("div", { className: "inner" }, this.contacts.map(x => this._renderContactRow(x))), window.__CTRender("div", { className: "inner" },
            " ",
            Object.keys(this.groups).map(x => this._renderContactRow(this.groups[x], true))));
    }
    _renderContactRow(contact, isGroup = false) {
        return (window.__CTRender("div", { className: `row ${contact.selected ? "selected" : ""}`, onClick: (e) => this.toggleContactSelection(contact.id, isGroup) },
            !isGroup ? pagerUtils_1.getNameFromContact(contact) : contact.id,
            renderUtils_1.renderIf(contact.selected, window.__CTRender(components_1.CTIcon, { width: "18", height: "18", icon: Models_1.Icons.FONTAWESOME.CheckCircleFilled }))));
    }
}
__decorate([
    base_1.prop({ type: Boolean, attribute: true, default: false })
], CTPGContactSelection.prototype, "showing", void 0);
__decorate([
    base_1.prop({ type: Array, attribute: false, default: [] })
], CTPGContactSelection.prototype, "contacts", void 0);
__decorate([
    base_1.prop({ type: Array, attribute: false, default: [] })
], CTPGContactSelection.prototype, "groups", void 0);
__decorate([
    base_1.prop({ type: Array, attribute: false })
], CTPGContactSelection.prototype, "selectedContacts", void 0);
__decorate([
    base_1.prop({ type: String, attribute: false })
], CTPGContactSelection.prototype, "tabSelected", void 0);
exports.CTPGContactSelection = CTPGContactSelection;
CTPGContactSelection.register();


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const base_1 = __webpack_require__(0);
const Icons_1 = __webpack_require__(27);
const components_1 = __webpack_require__(1);
const ct_xmpp_client_1 = __webpack_require__(16);
class CTPGFilePicker extends base_1.CTLayerComponent {
    constructor() {
        super(...arguments);
        this.btnClick = () => __awaiter(this, void 0, void 0, function* () {
            const files = yield ct_xmpp_client_1.CtXmppClient.pickFile({ mimeTypes: this.fileTypes });
            let isAcceptableFile = true;
            if (files) {
                files.forEach(x => {
                    if (!this._isAcceptableFile(x)) {
                        isAcceptableFile = false;
                    }
                });
                if (isAcceptableFile) {
                    this.callback(files);
                }
                else {
                    // Emit error
                    this.layer.error("Invalid File Type", `Please add a file type that matches one of: ${this.extensions.join(",")}`);
                }
            }
        });
    }
    static get is() {
        return "ct-pg-file-picker";
    }
    // === End properties === //
    initialize() {
        return __awaiter(this, void 0, void 0, function* () {
            this.extensions = this.fileTypes.reduce((acc, cur) => {
                const split = cur.split("/");
                if (split.length > 0) {
                    acc.push(split[1].toLowerCase());
                }
                return acc;
            }, []);
        });
    }
    setupListeners() {
    }
    _isAcceptableFile(filePath) {
        const lastIdx = filePath.lastIndexOf(".") + 1;
        const extension = filePath.substring(lastIdx).toLowerCase();
        return this.extensions.includes(extension);
    }
    get generateComponentStyles() {
        return ``;
    }
    generateComponentMarkup() {
        return (window.__CTRender("div", null,
            window.__CTRender(components_1.CTButton, { icon: Icons_1.Icons.FONTAWESOME.PlusSign, iconColor: "#fff", onClick: this.btnClick })));
    }
}
__decorate([
    base_1.prop({ type: Array, attribute: true, default: ["image/jpg", "image/jpeg", "image/png", "image/gif"] })
], CTPGFilePicker.prototype, "fileTypes", void 0);
__decorate([
    base_1.prop({ type: Function, attribute: false })
], CTPGFilePicker.prototype, "callback", void 0);
exports.CTPGFilePicker = CTPGFilePicker;
CTPGFilePicker.register();


/***/ }),
/* 21 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__strophe_ct__ = __webpack_require__(37);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__strophe_ct___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__strophe_ct__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__strophe_stream_management__ = __webpack_require__(38);
/**
 * Created by Leon.Revill on 11/08/2017.
 */


// Apply Strophe plugins


/* harmony default export */ __webpack_exports__["default"] = (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__strophe_stream_management__["a" /* default */])(__WEBPACK_IMPORTED_MODULE_0__strophe_ct___default.a));

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const skate = __webpack_require__(13);
const mixins_1 = __webpack_require__(55);
const utils_1 = __webpack_require__(3);
// tslint:disable typedef
// tslint:disable no-any
window.__CTRender = window.skate.h;
const allMixins = [
    mixins_1.OverridingStylesMixin,
    mixins_1.ComponentStylesMixin,
    mixins_1.RenderMixin
];
const allMixinsBase = allMixins.reduce((cls, mixin) => mixin(cls), skate.Component);
class CTBaseComponent extends allMixinsBase {
    // === Protected utility functions === //
    renderHtml(htmlString) {
        if (htmlString === undefined || htmlString === null)
            htmlString = "";
        const containsHtml = (htmlString.indexOf("<") !== -1 && htmlString.indexOf(">") !== -1);
        if (!containsHtml)
            return htmlString;
        const id = `html_${utils_1.generateRandomSixString()}_${utils_1.generateRandomSixString()}`;
        this.onRenderComplete(() => {
            const el = this.shadowRoot.querySelector(`#${id}`);
            if (el)
                el.innerHTML = htmlString;
        }, true);
        return skate.h("span", { id: id, class: "user-html", style: { display: "inline-block" } });
    }
    onRenderComplete(handler, oneTimeOnly = false) {
        if (this.shadowRoot) {
            this.addEventListener("render-complete", function wrappedFunction() {
                handler();
                if (oneTimeOnly) {
                    this.removeEventListener("render-complete", wrappedFunction);
                }
            });
        }
    }
    renderedCallback() {
        super.renderedCallback();
        this.dispatchEvent(new CustomEvent("render-complete"));
    }
    // === Static functions === //
    static register() {
        if (this.is === null) {
            // tslint:disable-next-line no-console
            console.error("Could not register component, please ensure that it has a static is property");
            return;
        }
        const existing = customElements.get(this.is);
        if (!existing) {
            customElements.define(this.is, this);
        }
    }
}
CTBaseComponent.is = null;
exports.CTBaseComponent = CTBaseComponent;
// tslint:enable no-any
// tslint:enable typedef


/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class LayerRegistration {
    static addInstance(name, instance) {
        LayerRegistration.ensureRegistrationsObject();
        window.__CTLayers[name] = {
            instance: instance,
            isReady: false
        };
    }
    static getInstance(name) {
        LayerRegistration.ensureRegistrationsObject();
        const layer = window.__CTLayers[name];
        return (!!layer)
            ? layer.instance
            : null;
    }
    static onReady(name, callback) {
        LayerRegistration.ensureRegistrationsObject();
        const layer = window.__CTLayers[name];
        const isReady = (!!layer)
            ? layer.isReady
            : false;
        if (isReady) {
            setTimeout(() => {
                callback();
            }, 0);
        }
        else {
            document.addEventListener(`base-layer-ready:${name}`, (e) => {
                setTimeout(() => {
                    callback();
                }, 0);
            });
        }
    }
    static fireReady(name) {
        LayerRegistration.ensureRegistrationsObject();
        const layer = window.__CTLayers[name];
        if (!!layer) {
            layer.isReady = true;
        }
        document.dispatchEvent(new CustomEvent(`base-layer-ready:${name}`));
    }
    static ensureRegistrationsObject() {
        if (!window.__CTLayers) {
            window.__CTLayers = {};
        }
    }
}
exports.LayerRegistration = LayerRegistration;
window.CtLayerRegistration = LayerRegistration;
// tslint:enable no-any


/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseEventArgs_1 = __webpack_require__(12);
class CommsEventArgs extends BaseEventArgs_1.BaseEventArgs {
    constructor(success, errorMessage) {
        super();
        this.success = success;
        if (errorMessage) {
            this.errorMessage = errorMessage;
        }
    }
}
exports.CommsEventArgs = CommsEventArgs;


/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var DefaultAlerts;
(function (DefaultAlerts) {
    function generateId() {
        return "alert_" + new Date().getTime().toString();
    }
    DefaultAlerts.generateId = generateId;
    function AlertWaiting(message) {
        return {
            id: generateId(),
            raisedOn: new Date().getTime(),
            priority: 1,
            type: "info",
            title: "Please wait...",
            body: message,
            showLoadingAnimation: true
        };
    }
    DefaultAlerts.AlertWaiting = AlertWaiting;
    function AlertErrorWithOkayButton(title = "Error", body = "An error occurred", priority = 1, action = {}) {
        return {
            id: generateId(),
            raisedOn: new Date().getTime(),
            priority: priority,
            type: "error",
            title: title,
            body: body,
            buttons: [
                {
                    text: "Okay",
                    action: action.okay,
                    type: "primary"
                }
            ]
        };
    }
    DefaultAlerts.AlertErrorWithOkayButton = AlertErrorWithOkayButton;
    function AlertYesNoQuestion(title, body, priority = 0, action = {}) {
        return {
            id: generateId(),
            raisedOn: new Date().getTime(),
            priority: priority,
            type: "question",
            title: title,
            body: body,
            buttons: [
                {
                    text: "No",
                    action: action.no,
                    type: "primary"
                },
                {
                    text: "Yes",
                    action: action.yes,
                    type: "primary"
                }
            ]
        };
    }
    DefaultAlerts.AlertYesNoQuestion = AlertYesNoQuestion;
    function AlertQuestion(title, body, priority = 0, buttons) {
        return {
            id: generateId(),
            raisedOn: new Date().getTime(),
            priority: priority,
            type: "question",
            title: title,
            body: body,
            buttons: buttons
        };
    }
    DefaultAlerts.AlertQuestion = AlertQuestion;
    function AlertAcknowledge(title, body, priority = 0, action = {}, buttonLabel) {
        return {
            id: generateId(),
            raisedOn: new Date().getTime(),
            priority: priority,
            type: "success",
            title: title,
            body: body,
            buttons: [
                {
                    text: buttonLabel || "Okay",
                    action: action.okay,
                    type: "primary"
                }
            ]
        };
    }
    DefaultAlerts.AlertAcknowledge = AlertAcknowledge;
})(DefaultAlerts = exports.DefaultAlerts || (exports.DefaultAlerts = {}));


/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var Icons;
(function (Icons) {
    Icons.COMMON = {
        StatusOnline: {
            viewBox: "0 0 1024 1024",
            paths: [
                "M470.923457,555.52087 L517.156966,555.52087 L678.97425,987.033627 L309.106173,987.033627 L470.923457,555.52087 Z M581.144144,581.041767 L537.561355,537.458979 C548.780687,526.239647 555.684891,510.828477 555.684891,493.87619 C555.684891,459.848327 528.068075,432.231511 494.040212,432.231511 C459.950704,432.231511 432.395532,459.848327 432.395532,493.87619 C432.395532,510.828477 439.238091,526.239647 450.457423,537.458979 L406.874635,581.041767 C384.559261,558.726393 370.750852,527.904054 370.750852,493.87619 C370.750852,425.75882 425.922841,370.586831 494.040212,370.586831 C562.095938,370.586831 617.329571,425.75882 617.329571,493.87619 C617.329571,527.904054 603.459518,558.726393 581.144144,581.041767 Z M494.040212,185.652792 L493.916922,185.652792 C664.179527,185.652792 802.14032,323.67523 802.14032,493.87619 C802.14032,579.007493 767.680944,656.063343 711.892509,711.851778 L668.309721,668.268989 C712.940469,623.638241 740.495641,561.993561 740.495641,493.937835 C740.495641,357.764738 630.213309,247.359117 494.040212,247.359117 C357.80547,247.359117 247.461493,357.764738 247.461493,493.937835 C247.461493,561.993561 274.95502,623.638241 319.647413,668.268989 L276.064625,711.851778 C220.337834,656.063343 185.816814,579.007493 185.816814,493.87619 C185.816814,323.67523 323.777607,185.652792 494.040212,185.652792 Z M494.040212,0.718753674 C766.386406,0.718753674 987.197648,221.529996 987.197648,493.87619 C987.197648,630.049288 931.964016,753.338647 842.702519,842.600143 L799.119731,799.017354 C877.22354,720.97519 925.552969,613.097001 925.552969,493.87619 C925.552969,255.557859 732.296898,62.3634333 494.040212,62.3634333 C255.72188,62.3634333 62.5274544,255.557859 62.5274544,493.87619 C62.5274544,613.097001 110.733594,720.97519 188.899048,799.017354 L145.316259,842.600143 C56.0547631,753.338647 0.882774838,630.049288 0.882774838,493.87619 C0.882774838,221.529996 221.632372,0.718753674 494.040212,0.718753674 Z"
            ]
        },
        StatusOffline: {
            viewBox: "0 0 1024 1024",
            paths: [
                "M586.678306,210.286115 C562.139482,203.996961 536.419525,200.652792 509.916922,200.652792 L510.040212,200.652792 C339.777607,200.652792 201.816814,338.67523 201.816814,508.87619 C201.816814,535.342777 205.153389,561.028843 211.426433,585.537988 L264.560722,532.403699 C263.833299,524.67956 263.461493,516.852047 263.461493,508.937835 C263.461493,372.764738 373.80547,262.359117 510.040212,262.359117 C517.95418,262.359117 525.7807,262.732021 533.503206,263.461215 L586.678306,210.286115 Z M806.86787,425.990261 C814.213724,452.364232 818.14032,480.162284 818.14032,508.87619 C818.14032,594.007493 783.680944,671.063343 727.892509,726.851778 L684.309721,683.268989 C728.940469,638.638241 756.495641,576.993561 756.495641,508.937835 C756.495641,498.546495 755.853446,488.305204 754.606559,478.251572 L806.86787,425.990261 Z",
                "M729.725748,67.238671 C663.573003,34.2656239 588.970927,15.7187537 510.040212,15.7187537 C237.632372,15.7187537 16.8827748,236.529996 16.8827748,508.87619 C16.8827748,587.810373 35.420918,662.415536 68.3909758,728.573445 L114.711707,682.252714 C91.4312107,629.204161 78.5274544,570.558265 78.5274544,508.87619 C78.5274544,270.557859 271.72188,77.3634333 510.040212,77.3634333 C571.684303,77.3634333 630.316005,90.2960769 683.367584,113.596835 L729.725747,67.2386739 L729.725748,67.238671 Z M948.986253,283.87188 C983.639793,351.333945 1003.19765,427.822772 1003.19765,508.87619 C1003.19765,645.049288 947.964016,768.338647 858.702519,857.600143 L815.119731,814.017354 C893.22354,735.97519 941.552969,628.097001 941.552969,508.87619 C941.552969,445.074231 927.701805,384.506419 902.844202,330.013931 L948.98625,283.871881 L948.986253,283.87188 Z",
                "M568.387956,664.470175 L694.97425,1002.03363 L325.106173,1002.03363 L381.675174,851.182956 L568.387956,664.470175 Z M38.537334,1018.85532 L3.14468065,983.537334 L984.462666,0.144680652 L1019.85532,35.462666 L38.537334,1018.85532 Z"
            ]
        },
        LoadingSpinner: {
            viewBox: "0 0 1024 1024",
            paths: [
                "M1005.714 512c0 272.571-221.143 493.714-493.714 493.714s-493.714-221.143-493.714-493.714c0-248 182.857-453.143 420.571-488.571v130.286c-166.857 33.714-292.571 181.714-292.571 358.286 0 201.714 164 365.714 365.714 365.714s365.714-164 365.714-365.714c0-176.571-125.714-324.571-292.571-358.286v-130.286c237.714 35.429 420.571 240.571 420.571 488.571z"
            ]
        },
        ChevronDown: {
            viewBox: "0 0 1024 1024",
            paths: [
                "M614.286 420.571q0 7.429-5.714 13.143l-266.286 266.286q-5.714 5.714-13.143 5.714t-13.143-5.714l-266.286-266.286q-5.714-5.714-5.714-13.143t5.714-13.143l28.571-28.571q5.714-5.714 13.143-5.714t13.143 5.714l224.571 224.571 224.571-224.571q5.714-5.714 13.143-5.714t13.143 5.714l28.571 28.571q5.714 5.714 5.714 13.143z"
            ]
        },
        ChevonLeft: {
            viewBox: "0 0 1024 1024",
            paths: [
                "M669.143 172l-303.429 303.429 303.429 303.429q10.857 10.857 10.857 25.714t-10.857 25.714l-94.857 94.857q-10.857 10.857-25.714 10.857t-25.714-10.857l-424-424q-10.857-10.857-10.857-25.714t10.857-25.714l424-424q10.857-10.857 25.714-10.857t25.714 10.857l94.857 94.857q10.857 10.857 10.857 25.714t-10.857 25.714z"
            ]
        },
        ChevronRight: {
            viewBox: "0 0 1024 1024",
            paths: [
                "M632.571 501.143l-424 424q-10.857 10.857-25.714 10.857t-25.714-10.857l-94.857-94.857q-10.857-10.857-10.857-25.714t10.857-25.714l303.429-303.429-303.429-303.429q-10.857-10.857-10.857-25.714t10.857-25.714l94.857-94.857q10.857-10.857 25.714-10.857t25.714 10.857l424 424q10.857 10.857 10.857 25.714t-10.857 25.714z"
            ]
        },
        ChevronUp: {
            viewBox: "0 0 1024 1024",
            paths: [
                "M614.286 676.571q0 7.429-5.714 13.143l-28.571 28.571q-5.714 5.714-13.143 5.714t-13.143-5.714l-224.571-224.571-224.571 224.571q-5.714 5.714-13.143 5.714t-13.143-5.714l-28.571-28.571q-5.714-5.714-5.714-13.143t5.714-13.143l266.286-266.286q5.714-5.714 13.143-5.714t13.143 5.714l266.286 266.286q5.714 5.714 5.714 13.143z"
            ]
        },
        ClearTextbox: {
            viewBox: "0 0 1024 1024",
            paths: [
                "M1014.662 822.66c-0.004-0.004-0.008-0.008-0.012-0.010l-310.644-310.65 310.644-310.65c0.004-0.004 0.008-0.006 0.012-0.010 3.344-3.346 5.762-7.254 7.312-11.416 4.246-11.376 1.824-24.682-7.324-33.83l-146.746-146.746c-9.148-9.146-22.45-11.566-33.828-7.32-4.16 1.55-8.070 3.968-11.418 7.31 0 0.004-0.004 0.006-0.008 0.010l-310.648 310.652-310.648-310.65c-0.004-0.004-0.006-0.006-0.010-0.010-3.346-3.342-7.254-5.76-11.414-7.31-11.38-4.248-24.682-1.826-33.83 7.32l-146.748 146.748c-9.148 9.148-11.568 22.452-7.322 33.828 1.552 4.16 3.97 8.072 7.312 11.416 0.004 0.002 0.006 0.006 0.010 0.010l310.65 310.648-310.65 310.652c-0.002 0.004-0.006 0.006-0.008 0.010-3.342 3.346-5.76 7.254-7.314 11.414-4.248 11.376-1.826 24.682 7.322 33.83l146.748 146.746c9.15 9.148 22.452 11.568 33.83 7.322 4.16-1.552 8.070-3.97 11.416-7.312 0.002-0.004 0.006-0.006 0.010-0.010l310.648-310.65 310.648 310.65c0.004 0.002 0.008 0.006 0.012 0.008 3.348 3.344 7.254 5.762 11.414 7.314 11.378 4.246 24.684 1.826 33.828-7.322l146.746-146.748c9.148-9.148 11.57-22.454 7.324-33.83-1.552-4.16-3.97-8.068-7.314-11.414z"
            ]
        },
        ShowPassword: {
            viewBox: "0 0 1024 1024",
            paths: [
                "M512 192c-223.318 0-416.882 130.042-512 320 95.118 189.958 288.682 320 512 320 223.312 0 416.876-130.042 512-320-95.116-189.958-288.688-320-512-320zM764.45 361.704c60.162 38.374 111.142 89.774 149.434 150.296-38.292 60.522-89.274 111.922-149.436 150.296-75.594 48.218-162.89 73.704-252.448 73.704-89.56 0-176.858-25.486-252.452-73.704-60.158-38.372-111.138-89.772-149.432-150.296 38.292-60.524 89.274-111.924 149.434-150.296 3.918-2.5 7.876-4.922 11.86-7.3-9.96 27.328-15.41 56.822-15.41 87.596 0 141.382 114.616 256 256 256 141.382 0 256-114.618 256-256 0-30.774-5.452-60.268-15.408-87.598 3.978 2.378 7.938 4.802 11.858 7.302v0zM512 416c0 53.020-42.98 96-96 96s-96-42.98-96-96 42.98-96 96-96 96 42.982 96 96z"
            ]
        },
        AlertQuestion: {
            viewBox: "0 0 1024 1024",
            paths: [
                "M512 786.286v-109.714q0-8-5.143-13.143t-13.143-5.143h-109.714q-8 0-13.143 5.143t-5.143 13.143v109.714q0 8 5.143 13.143t13.143 5.143h109.714q8 0 13.143-5.143t5.143-13.143zM658.286 402.286q0-50.286-31.714-93.143t-79.143-66.286-97.143-23.429q-138.857 0-212 121.714-8.571 13.714 4.571 24l75.429 57.143q4 3.429 10.857 3.429 9.143 0 14.286-6.857 30.286-38.857 49.143-52.571 19.429-13.714 49.143-13.714 27.429 0 48.857 14.857t21.429 33.714q0 21.714-11.429 34.857t-38.857 25.714q-36 16-66 49.429t-30 71.714v20.571q0 8 5.143 13.143t13.143 5.143h109.714q8 0 13.143-5.143t5.143-13.143q0-10.857 12.286-28.286t31.143-28.286q18.286-10.286 28-16.286t26.286-20 25.429-27.429 16-34.571 7.143-46.286zM877.714 512q0 119.429-58.857 220.286t-159.714 159.714-220.286 58.857-220.286-58.857-159.714-159.714-58.857-220.286 58.857-220.286 159.714-159.714 220.286-58.857 220.286 58.857 159.714 159.714 58.857 220.286z"
            ]
        },
        AlertWarning: {
            viewBox: "0 0 1024 1024",
            paths: [
                "M585.143 785.714v-108.571c0-10.286-8-18.857-18.286-18.857h-109.714c-10.286 0-18.286 8.571-18.286 18.857v108.571c0 10.286 8 18.857 18.286 18.857h109.714c10.286 0 18.286-8.571 18.286-18.857zM584 572l10.286-262.286c0-3.429-1.714-8-5.714-10.857-3.429-2.857-8.571-6.286-13.714-6.286h-125.714c-5.143 0-10.286 3.429-13.714 6.286-4 2.857-5.714 8.571-5.714 12l9.714 261.143c0 7.429 8.571 13.143 19.429 13.143h105.714c10.286 0 18.857-5.714 19.429-13.143zM576 38.286l438.857 804.571c12.571 22.286 12 49.714-1.143 72s-37.143 36-62.857 36h-877.714c-25.714 0-49.714-13.714-62.857-36s-13.714-49.714-1.143-72l438.857-804.571c12.571-23.429 37.143-38.286 64-38.286s51.429 14.857 64 38.286z"
            ]
        },
        Search: {
            viewBox: "0 0 1024 1024",
            paths: [
                "M658.286 475.429c0-141.143-114.857-256-256-256s-256 114.857-256 256 114.857 256 256 256 256-114.857 256-256zM950.857 950.857c0 40-33.143 73.143-73.143 73.143-19.429 0-38.286-8-51.429-21.714l-196-195.429c-66.857 46.286-146.857 70.857-228 70.857-222.286 0-402.286-180-402.286-402.286s180-402.286 402.286-402.286 402.286 180 402.286 402.286c0 81.143-24.571 161.143-70.857 228l196 196c13.143 13.143 21.143 32 21.143 51.429z"
            ]
        },
        UserIconEmpty: {
            viewBox: "0 0 1024 1024",
            paths: [
                "M686.286 448c80.571 23.429 191.429 102.857 191.429 362.857 0 117.714-87.429 213.143-194.857 213.143h-488c-107.429 0-194.857-95.429-194.857-213.143 0-260 110.857-339.429 191.429-362.857-28.571-45.143-45.143-98.286-45.143-155.429 0-161.143 131.429-292.571 292.571-292.571s292.571 131.429 292.571 292.571c0 57.143-16.571 110.286-45.143 155.429zM438.857 73.143c-121.143 0-219.429 98.286-219.429 219.429s98.286 219.429 219.429 219.429 219.429-98.286 219.429-219.429-98.286-219.429-219.429-219.429zM682.857 950.857c66.857 0 121.714-62.286 121.714-140 0-180-60.571-292.571-173.714-298.286-51.429 45.143-118.286 72.571-192 72.571s-140.571-27.429-192-72.571c-113.143 5.714-173.714 118.286-173.714 298.286 0 77.714 54.857 140 121.714 140h488z"
            ]
        },
        PlusSign: {
            viewBox: "0 0 1024 1024",
            paths: [
                "M804.571 420.571v109.714q0 22.857-16 38.857t-38.857 16h-237.714v237.714q0 22.857-16 38.857t-38.857 16h-109.714q-22.857 0-38.857-16t-16-38.857v-237.714h-237.714q-22.857 0-38.857-16t-16-38.857v-109.714q0-22.857 16-38.857t38.857-16h237.714v-237.714q0-22.857 16-38.857t38.857-16h109.714q22.857 0 38.857 16t16 38.857v237.714h237.714q22.857 0 38.857 16t16 38.857z"
            ]
        }
    };
})(Icons = exports.Icons || (exports.Icons = {}));


/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var Icons;
(function (Icons) {
    Icons.ICOMOON = {
        CheckBoxEmpty: {
            viewBox: "0 0 1024 1024",
            paths: [
                "M896 0h-768c-70.4 0-128 57.6-128 128v768c0 70.4 57.6 128 128 128h768c70.4 0 128-57.6 128-128v-768c0-70.4-57.6-128-128-128zM896 896h-768v-768h768v768z"
            ]
        },
        CheckBoxChecked: {
            viewBox: "0 0 1024 1024",
            paths: [
                "M896 0h-768c-70.4 0-128 57.6-128 128v768c0 70.4 57.6 128 128 128h768c70.4 0 128-57.6 128-128v-768c0-70.4-57.6-128-128-128zM448 794.51l-237.254-237.256 90.51-90.508 146.744 146.744 306.746-306.746 90.508 90.51-397.254 397.256z"
            ]
        },
        CheckCircleFilled: {
            viewBox: "0 0 1024 1024",
            paths: [
                "M733.714 419.429q0-16-10.286-26.286l-52-51.429q-10.857-10.857-25.714-10.857t-25.714 10.857l-233.143 232.571-129.143-129.143q-10.857-10.857-25.714-10.857t-25.714 10.857l-52 51.429q-10.286 10.286-10.286 26.286 0 15.429 10.286 25.714l206.857 206.857q10.857 10.857 25.714 10.857 15.429 0 26.286-10.857l310.286-310.286q10.286-10.286 10.286-25.714zM877.714 512q0 119.429-58.857 220.286t-159.714 159.714-220.286 58.857-220.286-58.857-159.714-159.714-58.857-220.286 58.857-220.286 159.714-159.714 220.286-58.857 220.286 58.857 159.714 159.714 58.857 220.286z"
            ]
        },
        CrossCircleFilled: {
            viewBox: "0 0 1024 1024",
            paths: [
                "M656.571 641.143q0-14.857-10.857-25.714l-103.429-103.429 103.429-103.429q10.857-10.857 10.857-25.714 0-15.429-10.857-26.286l-51.429-51.429q-10.857-10.857-26.286-10.857-14.857 0-25.714 10.857l-103.429 103.429-103.429-103.429q-10.857-10.857-25.714-10.857-15.429 0-26.286 10.857l-51.429 51.429q-10.857 10.857-10.857 26.286 0 14.857 10.857 25.714l103.429 103.429-103.429 103.429q-10.857 10.857-10.857 25.714 0 15.429 10.857 26.286l51.429 51.429q10.857 10.857 26.286 10.857 14.857 0 25.714-10.857l103.429-103.429 103.429 103.429q10.857 10.857 25.714 10.857 15.429 0 26.286-10.857l51.429-51.429q10.857-10.857 10.857-26.286zM877.714 512q0 119.429-58.857 220.286t-159.714 159.714-220.286 58.857-220.286-58.857-159.714-159.714-58.857-220.286 58.857-220.286 159.714-159.714 220.286-58.857 220.286 58.857 159.714 159.714 58.857 220.286z"
            ]
        },
        ExclamationCircleFilled: {
            viewBox: "0 0 1024 1024",
            paths: [
                "M512 0c-282.77 0-512 229.23-512 512s229.23 512 512 512 512-229.23 512-512-229.23-512-512-512zM576 832h-128v-128h128v128zM576 576h-128v-384h128v384z"
            ]
        },
        QuestionCircleFilled: {
            viewBox: "0 0 1024 1024",
            paths: [
                "M512 0c-282.77 0-512 229.23-512 512s229.23 512 512 512 512-229.23 512-512-229.23-512-512-512zM512 832c-35.346 0-64-28.654-64-64s28.654-64 64-64 64 28.654 64 64-28.654 64-64 64zM617.538 504.158c-39.112 24.57-57.538 38.114-57.538 56.092v32c0 26.51-21.49 48-48 48s-48-21.49-48-48v-32c0-33.618 12.964-63.854 38.532-89.87 18.864-19.194 41.778-33.59 63.936-47.512 45.564-28.624 65.532-43.978 65.532-70.868 0-29.252-16.88-48.788-31.042-60.026-22.734-18.040-54.328-27.974-88.958-27.974-52.534 0-99.792 35.082-114.924 85.314-7.648 25.382-34.422 39.758-59.806 32.114-25.382-7.648-39.76-34.422-32.114-59.806 13.112-43.52 40.398-82.63 76.832-110.124 37.71-28.456 82.668-43.498 130.012-43.498 56.208 0 108.994 17.322 148.63 48.776 43.444 34.474 67.37 82.496 67.37 135.224 0 82.76-63.846 122.872-110.462 152.158z"
            ]
        },
        Mute: {
            viewBox: "0 0 16 16",
            paths: [
                "M0 5h3l5-5v16l-5-5h-3v-6zM14.326 8l1.674 1.674v1.326h-1.326l-1.674-1.674-1.674 1.674h-1.326v-1.326l1.674-1.674-1.674-1.674v-1.326h1.326l1.674 1.674 1.674-1.674h1.326v1.326l-1.674 1.674z"
            ]
        }
    };
    Icons.FONTAWESOME = {
        BellFilled: {
            viewBox: "0 0 1024 1024",
            paths: [
                "M521.143 969.143c0-5.143-4-9.143-9.143-9.143-45.143 0-82.286-37.143-82.286-82.286 0-5.143-4-9.143-9.143-9.143s-9.143 4-9.143 9.143c0 55.429 45.143 100.571 100.571 100.571 5.143 0 9.143-4 9.143-9.143zM987.429 804.571c0 40-33.143 73.143-73.143 73.143h-256c0 80.571-65.714 146.286-146.286 146.286s-146.286-65.714-146.286-146.286h-256c-40 0-73.143-33.143-73.143-73.143 84.571-71.429 182.857-199.429 182.857-475.429 0-109.714 90.857-229.714 242.286-252-2.857-6.857-4.571-14.286-4.571-22.286 0-30.286 24.571-54.857 54.857-54.857s54.857 24.571 54.857 54.857c0 8-1.714 15.429-4.571 22.286 151.429 22.286 242.286 142.286 242.286 252 0 276 98.286 404 182.857 475.429z"
            ]
        },
        CircleNotch: {
            viewBox: "0 0 1024 1024",
            paths: [
                "M1005.714 512c0 272.571-221.143 493.714-493.714 493.714s-493.714-221.143-493.714-493.714c0-248 182.857-453.143 420.571-488.571v130.286c-166.857 33.714-292.571 181.714-292.571 358.286 0 201.714 164 365.714 365.714 365.714s365.714-164 365.714-365.714c0-176.571-125.714-324.571-292.571-358.286v-130.286c237.714 35.429 420.571 240.571 420.571 488.571z"
            ]
        },
        CheckBoxEmpty: {
            viewBox: "0 0 1024 1024",
            paths: [
                "M640 146.286h-475.429q-37.714 0-64.571 26.857t-26.857 64.571v475.429q0 37.714 26.857 64.571t64.571 26.857h475.429q37.714 0 64.571-26.857t26.857-64.571v-475.429q0-37.714-26.857-64.571t-64.571-26.857zM804.571 237.714v475.429q0 68-48.286 116.286t-116.286 48.286h-475.429q-68 0-116.286-48.286t-48.286-116.286v-475.429q0-68 48.286-116.286t116.286-48.286h475.429q68 0 116.286 48.286t48.286 116.286z"
            ]
        },
        CheckBoxChecked: {
            viewBox: "0 0 1024 1024",
            paths: [
                "M391.429 742.286l350.857-350.857q10.857-10.857 10.857-25.714t-10.857-25.714l-58.286-58.286q-10.857-10.857-25.714-10.857t-25.714 10.857l-266.857 266.857-120.571-120.571q-10.857-10.857-25.714-10.857t-25.714 10.857l-58.286 58.286q-10.857 10.857-10.857 25.714t10.857 25.714l204.571 204.571q10.857 10.857 25.714 10.857t25.714-10.857zM877.714 237.714v548.571q0 68-48.286 116.286t-116.286 48.286h-548.571q-68 0-116.286-48.286t-48.286-116.286v-548.571q0-68 48.286-116.286t116.286-48.286h548.571q68 0 116.286 48.286t48.286 116.286z"
            ]
        },
        CheckCircleFilled: {
            viewBox: "0 0 1024 1024",
            paths: [
                "M733.714 419.429q0-16-10.286-26.286l-52-51.429q-10.857-10.857-25.714-10.857t-25.714 10.857l-233.143 232.571-129.143-129.143q-10.857-10.857-25.714-10.857t-25.714 10.857l-52 51.429q-10.286 10.286-10.286 26.286 0 15.429 10.286 25.714l206.857 206.857q10.857 10.857 25.714 10.857 15.429 0 26.286-10.857l310.286-310.286q10.286-10.286 10.286-25.714zM877.714 512q0 119.429-58.857 220.286t-159.714 159.714-220.286 58.857-220.286-58.857-159.714-159.714-58.857-220.286 58.857-220.286 159.714-159.714 220.286-58.857 220.286 58.857 159.714 159.714 58.857 220.286z"
            ]
        },
        ChevonLeft: {
            viewBox: "0 0 1024 1024",
            paths: [
                "M669.143 172l-303.429 303.429 303.429 303.429q10.857 10.857 10.857 25.714t-10.857 25.714l-94.857 94.857q-10.857 10.857-25.714 10.857t-25.714-10.857l-424-424q-10.857-10.857-10.857-25.714t10.857-25.714l424-424q10.857-10.857 25.714-10.857t25.714 10.857l94.857 94.857q10.857 10.857 10.857 25.714t-10.857 25.714z"
            ]
        },
        Cross: {
            viewBox: "0 0 1024 1024",
            paths: [
                "M741.714 755.429q0 22.857-16 38.857l-77.714 77.714q-16 16-38.857 16t-38.857-16l-168-168-168 168q-16 16-38.857 16t-38.857-16l-77.714-77.714q-16-16-16-38.857t16-38.857l168-168-168-168q-16-16-16-38.857t16-38.857l77.714-77.714q16-16 38.857-16t38.857 16l168 168 168-168q16-16 38.857-16t38.857 16l77.714 77.714q16 16 16 38.857t-16 38.857l-168 168 168 168q16 16 16 38.857z"
            ]
        },
        CrossCircleFilled: {
            viewBox: "0 0 1024 1024",
            paths: [
                "M656.571 641.143q0-14.857-10.857-25.714l-103.429-103.429 103.429-103.429q10.857-10.857 10.857-25.714 0-15.429-10.857-26.286l-51.429-51.429q-10.857-10.857-26.286-10.857-14.857 0-25.714 10.857l-103.429 103.429-103.429-103.429q-10.857-10.857-25.714-10.857-15.429 0-26.286 10.857l-51.429 51.429q-10.857 10.857-10.857 26.286 0 14.857 10.857 25.714l103.429 103.429-103.429 103.429q-10.857 10.857-10.857 25.714 0 15.429 10.857 26.286l51.429 51.429q10.857 10.857 26.286 10.857 14.857 0 25.714-10.857l103.429-103.429 103.429 103.429q10.857 10.857 25.714 10.857 15.429 0 26.286-10.857l51.429-51.429q10.857-10.857 10.857-26.286zM877.714 512q0 119.429-58.857 220.286t-159.714 159.714-220.286 58.857-220.286-58.857-159.714-159.714-58.857-220.286 58.857-220.286 159.714-159.714 220.286-58.857 220.286 58.857 159.714 159.714 58.857 220.286z"
            ]
        },
        Ellipsis: {
            viewBox: "0 0 1024 1024",
            paths: [
                "M219.429 420.571v109.714c0 30.286-24.571 54.857-54.857 54.857h-109.714c-30.286 0-54.857-24.571-54.857-54.857v-109.714c0-30.286 24.571-54.857 54.857-54.857h109.714c30.286 0 54.857 24.571 54.857 54.857zM512 420.571v109.714c0 30.286-24.571 54.857-54.857 54.857h-109.714c-30.286 0-54.857-24.571-54.857-54.857v-109.714c0-30.286 24.571-54.857 54.857-54.857h109.714c30.286 0 54.857 24.571 54.857 54.857zM804.571 420.571v109.714c0 30.286-24.571 54.857-54.857 54.857h-109.714c-30.286 0-54.857-24.571-54.857-54.857v-109.714c0-30.286 24.571-54.857 54.857-54.857h109.714c30.286 0 54.857 24.571 54.857 54.857z"
            ]
        },
        ExclamationCircleFilled: {
            viewBox: "0 0 1024 1024",
            paths: [
                "M438.857 73.143q119.429 0 220.286 58.857t159.714 159.714 58.857 220.286-58.857 220.286-159.714 159.714-220.286 58.857-220.286-58.857-159.714-159.714-58.857-220.286 58.857-220.286 159.714-159.714 220.286-58.857zM512 785.714v-108.571q0-8-5.143-13.429t-12.571-5.429h-109.714q-7.429 0-13.143 5.714t-5.714 13.143v108.571q0 7.429 5.714 13.143t13.143 5.714h109.714q7.429 0 12.571-5.429t5.143-13.429zM510.857 589.143l10.286-354.857q0-6.857-5.714-10.286-5.714-4.571-13.714-4.571h-125.714q-8 0-13.714 4.571-5.714 3.429-5.714 10.286l9.714 354.857q0 5.714 5.714 10t13.714 4.286h105.714q8 0 13.429-4.286t6-10z"
            ]
        },
        InfoCircleFilled: {
            viewBox: "0 0 1024 1024",
            paths: [
                "M585.143 786.286v-91.429c0-10.286-8-18.286-18.286-18.286h-54.857v-292.571c0-10.286-8-18.286-18.286-18.286h-182.857c-10.286 0-18.286 8-18.286 18.286v91.429c0 10.286 8 18.286 18.286 18.286h54.857v182.857h-54.857c-10.286 0-18.286 8-18.286 18.286v91.429c0 10.286 8 18.286 18.286 18.286h256c10.286 0 18.286-8 18.286-18.286zM512 274.286v-91.429c0-10.286-8-18.286-18.286-18.286h-109.714c-10.286 0-18.286 8-18.286 18.286v91.429c0 10.286 8 18.286 18.286 18.286h109.714c10.286 0 18.286-8 18.286-18.286zM877.714 512c0 242.286-196.571 438.857-438.857 438.857s-438.857-196.571-438.857-438.857 196.571-438.857 438.857-438.857 438.857 196.571 438.857 438.857z"
            ]
        },
        Paperclip: {
            viewBox: "0 0 1024 1024",
            paths: [
                "M802.286 791.429q0 66.857-45.143 112t-112 45.143q-77.143 0-134.286-57.143l-444-443.429q-64.571-65.714-64.571-154.857 0-90.857 62.857-154.286t153.714-63.429q90.286 0 156 64.571l345.714 346.286q5.714 5.714 5.714 12.571 0 9.143-17.429 26.571t-26.571 17.429q-7.429 0-13.143-5.714l-346.286-346.857q-45.143-44-103.429-44-60.571 0-102.286 42.857t-41.714 103.429q0 60 43.429 103.429l443.429 444q36 36 82.857 36 36.571 0 60.571-24t24-60.571q0-46.857-36-82.857l-332-332q-14.857-13.714-34.286-13.714-16.571 0-27.429 10.857t-10.857 27.429q0 18.286 14.286 33.714l234.286 234.286q5.714 5.714 5.714 12.571 0 9.143-17.714 26.857t-26.857 17.714q-6.857 0-12.571-5.714l-234.286-234.286q-36-34.857-36-85.143 0-46.857 32.571-79.429t79.429-32.571q50.286 0 85.143 36l332 332q57.143 56 57.143 134.286z"
            ]
        },
        PlusSign: {
            viewBox: "0 0 1024 1024",
            paths: [
                "M804.571 420.571v109.714q0 22.857-16 38.857t-38.857 16h-237.714v237.714q0 22.857-16 38.857t-38.857 16h-109.714q-22.857 0-38.857-16t-16-38.857v-237.714h-237.714q-22.857 0-38.857-16t-16-38.857v-109.714q0-22.857 16-38.857t38.857-16h237.714v-237.714q0-22.857 16-38.857t38.857-16h109.714q22.857 0 38.857 16t16 38.857v237.714h237.714q22.857 0 38.857 16t16 38.857z"
            ]
        },
        QuestionCircleFilled: {
            viewBox: "0 0 1024 1024",
            paths: [
                "M512 786.286v-109.714q0-8-5.143-13.143t-13.143-5.143h-109.714q-8 0-13.143 5.143t-5.143 13.143v109.714q0 8 5.143 13.143t13.143 5.143h109.714q8 0 13.143-5.143t5.143-13.143zM658.286 402.286q0-50.286-31.714-93.143t-79.143-66.286-97.143-23.429q-138.857 0-212 121.714-8.571 13.714 4.571 24l75.429 57.143q4 3.429 10.857 3.429 9.143 0 14.286-6.857 30.286-38.857 49.143-52.571 19.429-13.714 49.143-13.714 27.429 0 48.857 14.857t21.429 33.714q0 21.714-11.429 34.857t-38.857 25.714q-36 16-66 49.429t-30 71.714v20.571q0 8 5.143 13.143t13.143 5.143h109.714q8 0 13.143-5.143t5.143-13.143q0-10.857 12.286-28.286t31.143-28.286q18.286-10.286 28-16.286t26.286-20 25.429-27.429 16-34.571 7.143-46.286zM877.714 512q0 119.429-58.857 220.286t-159.714 159.714-220.286 58.857-220.286-58.857-159.714-159.714-58.857-220.286 58.857-220.286 159.714-159.714 220.286-58.857 220.286 58.857 159.714 159.714 58.857 220.286z"
            ]
        },
        TrashCan: {
            viewBox: "0 0 1024 1024",
            paths: [
                "M292.571 420.571v329.143q0 8-5.143 13.143t-13.143 5.143h-36.571q-8 0-13.143-5.143t-5.143-13.143v-329.143q0-8 5.143-13.143t13.143-5.143h36.571q8 0 13.143 5.143t5.143 13.143zM438.857 420.571v329.143q0 8-5.143 13.143t-13.143 5.143h-36.571q-8 0-13.143-5.143t-5.143-13.143v-329.143q0-8 5.143-13.143t13.143-5.143h36.571q8 0 13.143 5.143t5.143 13.143zM585.143 420.571v329.143q0 8-5.143 13.143t-13.143 5.143h-36.571q-8 0-13.143-5.143t-5.143-13.143v-329.143q0-8 5.143-13.143t13.143-5.143h36.571q8 0 13.143 5.143t5.143 13.143zM658.286 834.286v-541.714h-512v541.714q0 12.571 4 23.143t8.286 15.429 6 4.857h475.429q1.714 0 6-4.857t8.286-15.429 4-23.143zM274.286 219.429h256l-27.429-66.857q-4-5.143-9.714-6.286h-181.143q-5.714 1.143-9.714 6.286zM804.571 237.714v36.571q0 8-5.143 13.143t-13.143 5.143h-54.857v541.714q0 47.429-26.857 82t-64.571 34.571h-475.429q-37.714 0-64.571-33.429t-26.857-80.857v-544h-54.857q-8 0-13.143-5.143t-5.143-13.143v-36.571q0-8 5.143-13.143t13.143-5.143h176.571l40-95.429q8.571-21.143 30.857-36t45.143-14.857h182.857q22.857 0 45.143 14.857t30.857 36l40 95.429h176.571q8 0 13.143 5.143t5.143 13.143z"
            ]
        },
        WarningTriangle: {
            viewBox: "0 0 1024 1024",
            paths: [
                "M585.143 785.714v-108.571c0-10.286-8-18.857-18.286-18.857h-109.714c-10.286 0-18.286 8.571-18.286 18.857v108.571c0 10.286 8 18.857 18.286 18.857h109.714c10.286 0 18.286-8.571 18.286-18.857zM584 572l10.286-262.286c0-3.429-1.714-8-5.714-10.857-3.429-2.857-8.571-6.286-13.714-6.286h-125.714c-5.143 0-10.286 3.429-13.714 6.286-4 2.857-5.714 8.571-5.714 12l9.714 261.143c0 7.429 8.571 13.143 19.429 13.143h105.714c10.286 0 18.857-5.714 19.429-13.143zM576 38.286l438.857 804.571c12.571 22.286 12 49.714-1.143 72s-37.143 36-62.857 36h-877.714c-25.714 0-49.714-13.714-62.857-36s-13.714-49.714-1.143-72l438.857-804.571c12.571-23.429 37.143-38.286 64-38.286s51.429 14.857 64 38.286z"
            ]
        },
        Wifi: {
            viewBox: "0 0 1024 1024",
            paths: [
                "M585.143 870.286c-14.857 0-94.857-80-94.857-95.429 0-28 73.143-43.429 94.857-43.429s94.857 15.429 94.857 43.429c0 15.429-80 95.429-94.857 95.429zM739.429 715.429c-8 0-70.286-57.143-154.286-57.143-84.571 0-145.714 57.143-154.286 57.143-13.714 0-96.571-82.286-96.571-96 0-5.143 2.286-9.714 5.714-13.143 61.143-60.571 160.571-94.286 245.143-94.286s184 33.714 245.143 94.286c3.429 3.429 5.714 8 5.714 13.143 0 13.714-82.857 96-96.571 96zM895.429 560c-4.571 0-9.714-2.286-13.143-4.571-94.286-73.143-173.714-116.571-297.143-116.571-172.571 0-304 121.143-310.286 121.143-13.143 0-95.429-82.286-95.429-96 0-4.571 2.286-9.143 5.714-12.571 102.286-102.286 256.571-158.857 400-158.857s297.714 56.571 400 158.857c3.429 3.429 5.714 8 5.714 12.571 0 13.714-82.286 96-95.429 96zM1050.286 405.143c-4.571 0-9.143-2.286-12.571-5.143-132-116-274.286-180.571-452.571-180.571s-320.571 64.571-452.571 180.571c-3.429 2.857-8 5.143-12.571 5.143-13.143 0-96-82.286-96-96 0-5.143 2.286-9.714 5.714-13.143 144.571-143.429 353.143-222.857 555.429-222.857s410.857 79.429 555.429 222.857c3.429 3.429 5.714 8 5.714 13.143 0 13.714-82.857 96-96 96z"
            ]
        }
    };
})(Icons = exports.Icons || (exports.Icons = {}));


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const base_1 = __webpack_require__(0);
const models_1 = __webpack_require__(2);
const renderUtils_1 = __webpack_require__(4);
const components_1 = __webpack_require__(1);
class CTButton extends base_1.CTLayerComponent {
    constructor() {
        super(...arguments);
        // === End properties === //
        this._rippleTimeout = null;
    }
    static get is() {
        return "ct-button";
    }
    initialize() {
        return __awaiter(this, void 0, void 0, function* () {
        });
    }
    setupListeners() {
    }
    get generateComponentStyles() {
        return `:host{color:#333536;font-weight:400}:host h1,:host h2,:host h3,:host h4,:host h5,:host h6{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}:host,:host *{box-sizing:border-box}.user-html p{margin:0}.user-html p+p{margin:.8em 0 0 0}.user-html strong{font-weight:600}@keyframes ripple{100%{transform:scale(2);opacity:0}}:host{display:block;position:relative}:host button{position:relative;background:transparent;color:#000;padding:0.55em 1em;border:1px solid transparent;border-radius:0;font-size:inherit;font-weight:inherit;outline:none;cursor:pointer;overflow:hidden;width:100%;height:100%}:host button .button-content{pointer-events:none;display:inline-flex;justify-content:center;align-items:center}:host button .button-content .icon{display:block}:host button .button-content .label{display:block}:host button .button-content .icon+.label{margin:0 0 0 5px}:host button .ripple{background-color:white;border-radius:50%;opacity:0.4;transform:scale(0.01);position:absolute;pointer-events:none}:host button .ripple.animate{animation:ripple 0.6s ease-out}:host button.primary{background-color:var(--button-primary-bg, #15233B);border:var(--button-primary-border, #15233B);color:var(--button-primary-text, #fff)}:host button.primary .ripple{background-color:var(--button-primary-ripple, #fff)}:host button.secondary{background-color:var(--button-secondary-bg, rgba(0,0,0,0));border:var(--button-secondary-border, none);color:var(--button-secondary-text, #fff)}:host button.secondary .ripple{background-color:var(--button-secondary-ripple, #000)}:host button.tertiary{background-color:var(--button-tertiary-bg, #ddd);border:var(--button-tertiary-border, 1px solid #ddd);color:var(--button-tertiary-text, #000)}:host button.tertiary .ripple{background-color:var(--button-tertiary-ripple, #fff)}:host button.invert-primary{background:var(--button-invert-primary-bg, #fff);border:var(--button-invert-primary-border, 1px solid #fff);color:var(--button-invert-primary-text, #2c394e)}:host button.invert-primary .ripple{background-color:var(--button-invert-primary-ripple, #2c394e)}:host button.invert-secondary{background:var(--button-invert-secondary-bg, rgba(0,0,0,0));border:var(--button-invert-secondary-border, 1px solid #fff);color:var(--button-invert-secondary-text, #fff)}:host button.invert-secondary .ripple{background-color:var(--button-invert-secondary-ripple, #fff)}:host button.selected{background-color:var(--button-selected-bg, #000);border:var(--button-selected-border, #000);color:var(--button-selected-text, #fff)}:host button.selected .ripple{background-color:var(--button-selected-ripple, #fff)}:host button.cancel{background-color:var(--button-cancel-bg, rgba(0,0,0,0));border:var(--button-cancel-border, 1px solid #fff);color:var(--button-cancel-text, #000)}:host button.cancel .ripple{background-color:var(--button-cancel-ripple, #000)}:host button.warning{background-color:var(--button-warning-bg, #fdb851);border:var(--button-warning-border, #fdb851);color:var(--button-warning-text, #fff)}:host button.warning .ripple{background-color:var(--button-warning-ripple, #fff)}:host button.dangerous{background-color:var(--button-dangerous-bg, #f24647);border:var(--button-dangerous-border, #f24647);color:var(--button-dangerous-text, #fff)}:host button.dangerous .ripple{background-color:var(--button-dangerous-ripple, #fff)}:host button.headerBack{background-color:#231f20;border:none;color:white}:host button.headerBack .ripple{background-color:white}:host button.transparent{background-color:transparent;border:none}:host button.large{padding:1.25em 1em}:host button[disabled]{opacity:0.5;cursor:not-allowed}
        `;
    }
    generateComponentMarkup() {
        const cssClasses = [
            this.type
        ];
        if (this.selected) {
            cssClasses.push("selected");
        }
        if (this.large) {
            cssClasses.push("large");
        }
        if (this.isWaiting) {
            cssClasses.push("waiting");
        }
        if (this.isTransparent) {
            cssClasses.push("transparent");
        }
        const loadingSpinnerIcon = models_1.Icons.COMMON.LoadingSpinner;
        const textColorStyles = renderUtils_1.buildStyles(!!this.textColor
            ? { color: this.textColor }
            : {});
        return (window.__CTRender("button", { class: cssClasses.join(" "), style: textColorStyles, disabled: this.isWaiting || this.disabled, onClick: e => this.handleButtonClick(e) },
            window.__CTRender("div", { class: "button-content" },
                renderUtils_1.renderIf(!this.isWaiting && !!this.icon, window.__CTRender(components_1.CTIcon, { icon: this.icon, color: this.iconColor, width: this.iconWidth, height: this.iconHeight, class: "icon" })),
                renderUtils_1.renderIfElse(this.isWaiting, window.__CTRender(components_1.CTIcon, { icon: loadingSpinnerIcon, color: this.iconColor, width: this.iconHeight, height: this.iconHeight, spin: true, class: "icon" }), window.__CTRender("div", { class: "label" },
                    window.__CTRender("slot", null))))));
    }
    // === Event handlers === //
    handleButtonClick(e) {
        if (!this.disabled) {
            this._ripple(e.offsetX, e.offsetY, e.target);
            if (typeof (this.onClick) === "function") {
                const clickEvent = Object.create(e, {
                    target: {
                        value: this
                    }
                });
                this.onClick(clickEvent);
            }
        }
    }
    // === Helper functions === //
    _ripple(clickX, clickY, button) {
        const previousRipple = button.querySelector(".ripple");
        if (previousRipple) {
            previousRipple.remove();
        }
        const width = button.clientWidth;
        const height = button.clientHeight;
        const size = Math.max(width, height);
        const x = clickX - (size / 2);
        const y = clickY - (size / 2);
        clearTimeout(this._rippleTimeout);
        this._rippleTimeout = setTimeout(() => {
            const ripple = document.createElement("span");
            ripple.classList.add("ripple");
            ripple.style.width = `${size}px`;
            ripple.style.height = `${size}px`;
            ripple.style.left = `${x}px`;
            ripple.style.top = `${y}px`;
            button.insertBefore(ripple, button.firstChild);
            ripple.addEventListener("animationend", () => {
                ripple.remove();
            });
            ripple.classList.add("animate");
        }, 0);
    }
}
__decorate([
    base_1.prop({ type: String, attribute: true, default: "primary" })
], CTButton.prototype, "type", void 0);
__decorate([
    base_1.prop({ type: base_1.Stroolean, attribute: true, default: false })
], CTButton.prototype, "selected", void 0);
__decorate([
    base_1.prop({ type: base_1.Stroolean, attribute: true, default: false })
], CTButton.prototype, "disabled", void 0);
__decorate([
    base_1.prop({ type: base_1.Stroolean, attribute: true, default: false })
], CTButton.prototype, "large", void 0);
__decorate([
    base_1.prop({ type: String, attribute: true })
], CTButton.prototype, "textColor", void 0);
__decorate([
    base_1.prop({ type: String, attribute: true, default: "auto" })
], CTButton.prototype, "iconColor", void 0);
__decorate([
    base_1.prop({ type: String, attribute: true, default: "18px" })
], CTButton.prototype, "iconWidth", void 0);
__decorate([
    base_1.prop({ type: String, attribute: true, default: "18px" })
], CTButton.prototype, "iconHeight", void 0);
__decorate([
    base_1.prop({ type: Function, attribute: true })
], CTButton.prototype, "onClick", void 0);
__decorate([
    base_1.prop({ type: base_1.Stroolean, attribute: true, default: false })
], CTButton.prototype, "isTransparent", void 0);
__decorate([
    base_1.prop({ type: Object, attribute: false, default: null })
], CTButton.prototype, "icon", void 0);
__decorate([
    base_1.prop({ type: base_1.Stroolean, attribute: false, default: false })
], CTButton.prototype, "isWaiting", void 0);
exports.CTButton = CTButton;
CTButton.register();


/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process, global) {var require;/*!
 * @overview es6-promise - a tiny implementation of Promises/A+.
 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
 * @license   Licensed under MIT license
 *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE
 * @version   4.1.0
 */

(function (global, factory) {
     true ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    (global.ES6Promise = factory());
}(this, (function () { 'use strict';

function objectOrFunction(x) {
  return typeof x === 'function' || typeof x === 'object' && x !== null;
}

function isFunction(x) {
  return typeof x === 'function';
}

var _isArray = undefined;
if (!Array.isArray) {
  _isArray = function (x) {
    return Object.prototype.toString.call(x) === '[object Array]';
  };
} else {
  _isArray = Array.isArray;
}

var isArray = _isArray;

var len = 0;
var vertxNext = undefined;
var customSchedulerFn = undefined;

var asap = function asap(callback, arg) {
  queue[len] = callback;
  queue[len + 1] = arg;
  len += 2;
  if (len === 2) {
    // If len is 2, that means that we need to schedule an async flush.
    // If additional callbacks are queued before the queue is flushed, they
    // will be processed by this flush that we are scheduling.
    if (customSchedulerFn) {
      customSchedulerFn(flush);
    } else {
      scheduleFlush();
    }
  }
};

function setScheduler(scheduleFn) {
  customSchedulerFn = scheduleFn;
}

function setAsap(asapFn) {
  asap = asapFn;
}

var browserWindow = typeof window !== 'undefined' ? window : undefined;
var browserGlobal = browserWindow || {};
var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;
var isNode = typeof self === 'undefined' && typeof process !== 'undefined' && ({}).toString.call(process) === '[object process]';

// test for web worker but not in IE10
var isWorker = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined';

// node
function useNextTick() {
  // node version 0.10.x displays a deprecation warning when nextTick is used recursively
  // see https://github.com/cujojs/when/issues/410 for details
  return function () {
    return process.nextTick(flush);
  };
}

// vertx
function useVertxTimer() {
  if (typeof vertxNext !== 'undefined') {
    return function () {
      vertxNext(flush);
    };
  }

  return useSetTimeout();
}

function useMutationObserver() {
  var iterations = 0;
  var observer = new BrowserMutationObserver(flush);
  var node = document.createTextNode('');
  observer.observe(node, { characterData: true });

  return function () {
    node.data = iterations = ++iterations % 2;
  };
}

// web worker
function useMessageChannel() {
  var channel = new MessageChannel();
  channel.port1.onmessage = flush;
  return function () {
    return channel.port2.postMessage(0);
  };
}

function useSetTimeout() {
  // Store setTimeout reference so es6-promise will be unaffected by
  // other code modifying setTimeout (like sinon.useFakeTimers())
  var globalSetTimeout = setTimeout;
  return function () {
    return globalSetTimeout(flush, 1);
  };
}

var queue = new Array(1000);
function flush() {
  for (var i = 0; i < len; i += 2) {
    var callback = queue[i];
    var arg = queue[i + 1];

    callback(arg);

    queue[i] = undefined;
    queue[i + 1] = undefined;
  }

  len = 0;
}

function attemptVertx() {
  try {
    var r = require;
    var vertx = __webpack_require__(102);
    vertxNext = vertx.runOnLoop || vertx.runOnContext;
    return useVertxTimer();
  } catch (e) {
    return useSetTimeout();
  }
}

var scheduleFlush = undefined;
// Decide what async method to use to triggering processing of queued callbacks:
if (isNode) {
  scheduleFlush = useNextTick();
} else if (BrowserMutationObserver) {
  scheduleFlush = useMutationObserver();
} else if (isWorker) {
  scheduleFlush = useMessageChannel();
} else if (browserWindow === undefined && "function" === 'function') {
  scheduleFlush = attemptVertx();
} else {
  scheduleFlush = useSetTimeout();
}

function then(onFulfillment, onRejection) {
  var _arguments = arguments;

  var parent = this;

  var child = new this.constructor(noop);

  if (child[PROMISE_ID] === undefined) {
    makePromise(child);
  }

  var _state = parent._state;

  if (_state) {
    (function () {
      var callback = _arguments[_state - 1];
      asap(function () {
        return invokeCallback(_state, child, callback, parent._result);
      });
    })();
  } else {
    subscribe(parent, child, onFulfillment, onRejection);
  }

  return child;
}

/**
  `Promise.resolve` returns a promise that will become resolved with the
  passed `value`. It is shorthand for the following:

  ```javascript
  let promise = new Promise(function(resolve, reject){
    resolve(1);
  });

  promise.then(function(value){
    // value === 1
  });
  ```

  Instead of writing the above, your code now simply becomes the following:

  ```javascript
  let promise = Promise.resolve(1);

  promise.then(function(value){
    // value === 1
  });
  ```

  @method resolve
  @static
  @param {Any} value value that the returned promise will be resolved with
  Useful for tooling.
  @return {Promise} a promise that will become fulfilled with the given
  `value`
*/
function resolve(object) {
  /*jshint validthis:true */
  var Constructor = this;

  if (object && typeof object === 'object' && object.constructor === Constructor) {
    return object;
  }

  var promise = new Constructor(noop);
  _resolve(promise, object);
  return promise;
}

var PROMISE_ID = Math.random().toString(36).substring(16);

function noop() {}

var PENDING = void 0;
var FULFILLED = 1;
var REJECTED = 2;

var GET_THEN_ERROR = new ErrorObject();

function selfFulfillment() {
  return new TypeError("You cannot resolve a promise with itself");
}

function cannotReturnOwn() {
  return new TypeError('A promises callback cannot return that same promise.');
}

function getThen(promise) {
  try {
    return promise.then;
  } catch (error) {
    GET_THEN_ERROR.error = error;
    return GET_THEN_ERROR;
  }
}

function tryThen(then, value, fulfillmentHandler, rejectionHandler) {
  try {
    then.call(value, fulfillmentHandler, rejectionHandler);
  } catch (e) {
    return e;
  }
}

function handleForeignThenable(promise, thenable, then) {
  asap(function (promise) {
    var sealed = false;
    var error = tryThen(then, thenable, function (value) {
      if (sealed) {
        return;
      }
      sealed = true;
      if (thenable !== value) {
        _resolve(promise, value);
      } else {
        fulfill(promise, value);
      }
    }, function (reason) {
      if (sealed) {
        return;
      }
      sealed = true;

      _reject(promise, reason);
    }, 'Settle: ' + (promise._label || ' unknown promise'));

    if (!sealed && error) {
      sealed = true;
      _reject(promise, error);
    }
  }, promise);
}

function handleOwnThenable(promise, thenable) {
  if (thenable._state === FULFILLED) {
    fulfill(promise, thenable._result);
  } else if (thenable._state === REJECTED) {
    _reject(promise, thenable._result);
  } else {
    subscribe(thenable, undefined, function (value) {
      return _resolve(promise, value);
    }, function (reason) {
      return _reject(promise, reason);
    });
  }
}

function handleMaybeThenable(promise, maybeThenable, then$$) {
  if (maybeThenable.constructor === promise.constructor && then$$ === then && maybeThenable.constructor.resolve === resolve) {
    handleOwnThenable(promise, maybeThenable);
  } else {
    if (then$$ === GET_THEN_ERROR) {
      _reject(promise, GET_THEN_ERROR.error);
      GET_THEN_ERROR.error = null;
    } else if (then$$ === undefined) {
      fulfill(promise, maybeThenable);
    } else if (isFunction(then$$)) {
      handleForeignThenable(promise, maybeThenable, then$$);
    } else {
      fulfill(promise, maybeThenable);
    }
  }
}

function _resolve(promise, value) {
  if (promise === value) {
    _reject(promise, selfFulfillment());
  } else if (objectOrFunction(value)) {
    handleMaybeThenable(promise, value, getThen(value));
  } else {
    fulfill(promise, value);
  }
}

function publishRejection(promise) {
  if (promise._onerror) {
    promise._onerror(promise._result);
  }

  publish(promise);
}

function fulfill(promise, value) {
  if (promise._state !== PENDING) {
    return;
  }

  promise._result = value;
  promise._state = FULFILLED;

  if (promise._subscribers.length !== 0) {
    asap(publish, promise);
  }
}

function _reject(promise, reason) {
  if (promise._state !== PENDING) {
    return;
  }
  promise._state = REJECTED;
  promise._result = reason;

  asap(publishRejection, promise);
}

function subscribe(parent, child, onFulfillment, onRejection) {
  var _subscribers = parent._subscribers;
  var length = _subscribers.length;

  parent._onerror = null;

  _subscribers[length] = child;
  _subscribers[length + FULFILLED] = onFulfillment;
  _subscribers[length + REJECTED] = onRejection;

  if (length === 0 && parent._state) {
    asap(publish, parent);
  }
}

function publish(promise) {
  var subscribers = promise._subscribers;
  var settled = promise._state;

  if (subscribers.length === 0) {
    return;
  }

  var child = undefined,
      callback = undefined,
      detail = promise._result;

  for (var i = 0; i < subscribers.length; i += 3) {
    child = subscribers[i];
    callback = subscribers[i + settled];

    if (child) {
      invokeCallback(settled, child, callback, detail);
    } else {
      callback(detail);
    }
  }

  promise._subscribers.length = 0;
}

function ErrorObject() {
  this.error = null;
}

var TRY_CATCH_ERROR = new ErrorObject();

function tryCatch(callback, detail) {
  try {
    return callback(detail);
  } catch (e) {
    TRY_CATCH_ERROR.error = e;
    return TRY_CATCH_ERROR;
  }
}

function invokeCallback(settled, promise, callback, detail) {
  var hasCallback = isFunction(callback),
      value = undefined,
      error = undefined,
      succeeded = undefined,
      failed = undefined;

  if (hasCallback) {
    value = tryCatch(callback, detail);

    if (value === TRY_CATCH_ERROR) {
      failed = true;
      error = value.error;
      value.error = null;
    } else {
      succeeded = true;
    }

    if (promise === value) {
      _reject(promise, cannotReturnOwn());
      return;
    }
  } else {
    value = detail;
    succeeded = true;
  }

  if (promise._state !== PENDING) {
    // noop
  } else if (hasCallback && succeeded) {
      _resolve(promise, value);
    } else if (failed) {
      _reject(promise, error);
    } else if (settled === FULFILLED) {
      fulfill(promise, value);
    } else if (settled === REJECTED) {
      _reject(promise, value);
    }
}

function initializePromise(promise, resolver) {
  try {
    resolver(function resolvePromise(value) {
      _resolve(promise, value);
    }, function rejectPromise(reason) {
      _reject(promise, reason);
    });
  } catch (e) {
    _reject(promise, e);
  }
}

var id = 0;
function nextId() {
  return id++;
}

function makePromise(promise) {
  promise[PROMISE_ID] = id++;
  promise._state = undefined;
  promise._result = undefined;
  promise._subscribers = [];
}

function Enumerator(Constructor, input) {
  this._instanceConstructor = Constructor;
  this.promise = new Constructor(noop);

  if (!this.promise[PROMISE_ID]) {
    makePromise(this.promise);
  }

  if (isArray(input)) {
    this._input = input;
    this.length = input.length;
    this._remaining = input.length;

    this._result = new Array(this.length);

    if (this.length === 0) {
      fulfill(this.promise, this._result);
    } else {
      this.length = this.length || 0;
      this._enumerate();
      if (this._remaining === 0) {
        fulfill(this.promise, this._result);
      }
    }
  } else {
    _reject(this.promise, validationError());
  }
}

function validationError() {
  return new Error('Array Methods must be provided an Array');
};

Enumerator.prototype._enumerate = function () {
  var length = this.length;
  var _input = this._input;

  for (var i = 0; this._state === PENDING && i < length; i++) {
    this._eachEntry(_input[i], i);
  }
};

Enumerator.prototype._eachEntry = function (entry, i) {
  var c = this._instanceConstructor;
  var resolve$$ = c.resolve;

  if (resolve$$ === resolve) {
    var _then = getThen(entry);

    if (_then === then && entry._state !== PENDING) {
      this._settledAt(entry._state, i, entry._result);
    } else if (typeof _then !== 'function') {
      this._remaining--;
      this._result[i] = entry;
    } else if (c === Promise) {
      var promise = new c(noop);
      handleMaybeThenable(promise, entry, _then);
      this._willSettleAt(promise, i);
    } else {
      this._willSettleAt(new c(function (resolve$$) {
        return resolve$$(entry);
      }), i);
    }
  } else {
    this._willSettleAt(resolve$$(entry), i);
  }
};

Enumerator.prototype._settledAt = function (state, i, value) {
  var promise = this.promise;

  if (promise._state === PENDING) {
    this._remaining--;

    if (state === REJECTED) {
      _reject(promise, value);
    } else {
      this._result[i] = value;
    }
  }

  if (this._remaining === 0) {
    fulfill(promise, this._result);
  }
};

Enumerator.prototype._willSettleAt = function (promise, i) {
  var enumerator = this;

  subscribe(promise, undefined, function (value) {
    return enumerator._settledAt(FULFILLED, i, value);
  }, function (reason) {
    return enumerator._settledAt(REJECTED, i, reason);
  });
};

/**
  `Promise.all` accepts an array of promises, and returns a new promise which
  is fulfilled with an array of fulfillment values for the passed promises, or
  rejected with the reason of the first passed promise to be rejected. It casts all
  elements of the passed iterable to promises as it runs this algorithm.

  Example:

  ```javascript
  let promise1 = resolve(1);
  let promise2 = resolve(2);
  let promise3 = resolve(3);
  let promises = [ promise1, promise2, promise3 ];

  Promise.all(promises).then(function(array){
    // The array here would be [ 1, 2, 3 ];
  });
  ```

  If any of the `promises` given to `all` are rejected, the first promise
  that is rejected will be given as an argument to the returned promises's
  rejection handler. For example:

  Example:

  ```javascript
  let promise1 = resolve(1);
  let promise2 = reject(new Error("2"));
  let promise3 = reject(new Error("3"));
  let promises = [ promise1, promise2, promise3 ];

  Promise.all(promises).then(function(array){
    // Code here never runs because there are rejected promises!
  }, function(error) {
    // error.message === "2"
  });
  ```

  @method all
  @static
  @param {Array} entries array of promises
  @param {String} label optional string for labeling the promise.
  Useful for tooling.
  @return {Promise} promise that is fulfilled when all `promises` have been
  fulfilled, or rejected if any of them become rejected.
  @static
*/
function all(entries) {
  return new Enumerator(this, entries).promise;
}

/**
  `Promise.race` returns a new promise which is settled in the same way as the
  first passed promise to settle.

  Example:

  ```javascript
  let promise1 = new Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 1');
    }, 200);
  });

  let promise2 = new Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 2');
    }, 100);
  });

  Promise.race([promise1, promise2]).then(function(result){
    // result === 'promise 2' because it was resolved before promise1
    // was resolved.
  });
  ```

  `Promise.race` is deterministic in that only the state of the first
  settled promise matters. For example, even if other promises given to the
  `promises` array argument are resolved, but the first settled promise has
  become rejected before the other promises became fulfilled, the returned
  promise will become rejected:

  ```javascript
  let promise1 = new Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 1');
    }, 200);
  });

  let promise2 = new Promise(function(resolve, reject){
    setTimeout(function(){
      reject(new Error('promise 2'));
    }, 100);
  });

  Promise.race([promise1, promise2]).then(function(result){
    // Code here never runs
  }, function(reason){
    // reason.message === 'promise 2' because promise 2 became rejected before
    // promise 1 became fulfilled
  });
  ```

  An example real-world use case is implementing timeouts:

  ```javascript
  Promise.race([ajax('foo.json'), timeout(5000)])
  ```

  @method race
  @static
  @param {Array} promises array of promises to observe
  Useful for tooling.
  @return {Promise} a promise which settles in the same way as the first passed
  promise to settle.
*/
function race(entries) {
  /*jshint validthis:true */
  var Constructor = this;

  if (!isArray(entries)) {
    return new Constructor(function (_, reject) {
      return reject(new TypeError('You must pass an array to race.'));
    });
  } else {
    return new Constructor(function (resolve, reject) {
      var length = entries.length;
      for (var i = 0; i < length; i++) {
        Constructor.resolve(entries[i]).then(resolve, reject);
      }
    });
  }
}

/**
  `Promise.reject` returns a promise rejected with the passed `reason`.
  It is shorthand for the following:

  ```javascript
  let promise = new Promise(function(resolve, reject){
    reject(new Error('WHOOPS'));
  });

  promise.then(function(value){
    // Code here doesn't run because the promise is rejected!
  }, function(reason){
    // reason.message === 'WHOOPS'
  });
  ```

  Instead of writing the above, your code now simply becomes the following:

  ```javascript
  let promise = Promise.reject(new Error('WHOOPS'));

  promise.then(function(value){
    // Code here doesn't run because the promise is rejected!
  }, function(reason){
    // reason.message === 'WHOOPS'
  });
  ```

  @method reject
  @static
  @param {Any} reason value that the returned promise will be rejected with.
  Useful for tooling.
  @return {Promise} a promise rejected with the given `reason`.
*/
function reject(reason) {
  /*jshint validthis:true */
  var Constructor = this;
  var promise = new Constructor(noop);
  _reject(promise, reason);
  return promise;
}

function needsResolver() {
  throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
}

function needsNew() {
  throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
}

/**
  Promise objects represent the eventual result of an asynchronous operation. The
  primary way of interacting with a promise is through its `then` method, which
  registers callbacks to receive either a promise's eventual value or the reason
  why the promise cannot be fulfilled.

  Terminology
  -----------

  - `promise` is an object or function with a `then` method whose behavior conforms to this specification.
  - `thenable` is an object or function that defines a `then` method.
  - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).
  - `exception` is a value that is thrown using the throw statement.
  - `reason` is a value that indicates why a promise was rejected.
  - `settled` the final resting state of a promise, fulfilled or rejected.

  A promise can be in one of three states: pending, fulfilled, or rejected.

  Promises that are fulfilled have a fulfillment value and are in the fulfilled
  state.  Promises that are rejected have a rejection reason and are in the
  rejected state.  A fulfillment value is never a thenable.

  Promises can also be said to *resolve* a value.  If this value is also a
  promise, then the original promise's settled state will match the value's
  settled state.  So a promise that *resolves* a promise that rejects will
  itself reject, and a promise that *resolves* a promise that fulfills will
  itself fulfill.


  Basic Usage:
  ------------

  ```js
  let promise = new Promise(function(resolve, reject) {
    // on success
    resolve(value);

    // on failure
    reject(reason);
  });

  promise.then(function(value) {
    // on fulfillment
  }, function(reason) {
    // on rejection
  });
  ```

  Advanced Usage:
  ---------------

  Promises shine when abstracting away asynchronous interactions such as
  `XMLHttpRequest`s.

  ```js
  function getJSON(url) {
    return new Promise(function(resolve, reject){
      let xhr = new XMLHttpRequest();

      xhr.open('GET', url);
      xhr.onreadystatechange = handler;
      xhr.responseType = 'json';
      xhr.setRequestHeader('Accept', 'application/json');
      xhr.send();

      function handler() {
        if (this.readyState === this.DONE) {
          if (this.status === 200) {
            resolve(this.response);
          } else {
            reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));
          }
        }
      };
    });
  }

  getJSON('/posts.json').then(function(json) {
    // on fulfillment
  }, function(reason) {
    // on rejection
  });
  ```

  Unlike callbacks, promises are great composable primitives.

  ```js
  Promise.all([
    getJSON('/posts'),
    getJSON('/comments')
  ]).then(function(values){
    values[0] // => postsJSON
    values[1] // => commentsJSON

    return values;
  });
  ```

  @class Promise
  @param {function} resolver
  Useful for tooling.
  @constructor
*/
function Promise(resolver) {
  this[PROMISE_ID] = nextId();
  this._result = this._state = undefined;
  this._subscribers = [];

  if (noop !== resolver) {
    typeof resolver !== 'function' && needsResolver();
    this instanceof Promise ? initializePromise(this, resolver) : needsNew();
  }
}

Promise.all = all;
Promise.race = race;
Promise.resolve = resolve;
Promise.reject = reject;
Promise._setScheduler = setScheduler;
Promise._setAsap = setAsap;
Promise._asap = asap;

Promise.prototype = {
  constructor: Promise,

  /**
    The primary way of interacting with a promise is through its `then` method,
    which registers callbacks to receive either a promise's eventual value or the
    reason why the promise cannot be fulfilled.
  
    ```js
    findUser().then(function(user){
      // user is available
    }, function(reason){
      // user is unavailable, and you are given the reason why
    });
    ```
  
    Chaining
    --------
  
    The return value of `then` is itself a promise.  This second, 'downstream'
    promise is resolved with the return value of the first promise's fulfillment
    or rejection handler, or rejected if the handler throws an exception.
  
    ```js
    findUser().then(function (user) {
      return user.name;
    }, function (reason) {
      return 'default name';
    }).then(function (userName) {
      // If `findUser` fulfilled, `userName` will be the user's name, otherwise it
      // will be `'default name'`
    });
  
    findUser().then(function (user) {
      throw new Error('Found user, but still unhappy');
    }, function (reason) {
      throw new Error('`findUser` rejected and we're unhappy');
    }).then(function (value) {
      // never reached
    }, function (reason) {
      // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.
      // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.
    });
    ```
    If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.
  
    ```js
    findUser().then(function (user) {
      throw new PedagogicalException('Upstream error');
    }).then(function (value) {
      // never reached
    }).then(function (value) {
      // never reached
    }, function (reason) {
      // The `PedgagocialException` is propagated all the way down to here
    });
    ```
  
    Assimilation
    ------------
  
    Sometimes the value you want to propagate to a downstream promise can only be
    retrieved asynchronously. This can be achieved by returning a promise in the
    fulfillment or rejection handler. The downstream promise will then be pending
    until the returned promise is settled. This is called *assimilation*.
  
    ```js
    findUser().then(function (user) {
      return findCommentsByAuthor(user);
    }).then(function (comments) {
      // The user's comments are now available
    });
    ```
  
    If the assimliated promise rejects, then the downstream promise will also reject.
  
    ```js
    findUser().then(function (user) {
      return findCommentsByAuthor(user);
    }).then(function (comments) {
      // If `findCommentsByAuthor` fulfills, we'll have the value here
    }, function (reason) {
      // If `findCommentsByAuthor` rejects, we'll have the reason here
    });
    ```
  
    Simple Example
    --------------
  
    Synchronous Example
  
    ```javascript
    let result;
  
    try {
      result = findResult();
      // success
    } catch(reason) {
      // failure
    }
    ```
  
    Errback Example
  
    ```js
    findResult(function(result, err){
      if (err) {
        // failure
      } else {
        // success
      }
    });
    ```
  
    Promise Example;
  
    ```javascript
    findResult().then(function(result){
      // success
    }, function(reason){
      // failure
    });
    ```
  
    Advanced Example
    --------------
  
    Synchronous Example
  
    ```javascript
    let author, books;
  
    try {
      author = findAuthor();
      books  = findBooksByAuthor(author);
      // success
    } catch(reason) {
      // failure
    }
    ```
  
    Errback Example
  
    ```js
  
    function foundBooks(books) {
  
    }
  
    function failure(reason) {
  
    }
  
    findAuthor(function(author, err){
      if (err) {
        failure(err);
        // failure
      } else {
        try {
          findBoooksByAuthor(author, function(books, err) {
            if (err) {
              failure(err);
            } else {
              try {
                foundBooks(books);
              } catch(reason) {
                failure(reason);
              }
            }
          });
        } catch(error) {
          failure(err);
        }
        // success
      }
    });
    ```
  
    Promise Example;
  
    ```javascript
    findAuthor().
      then(findBooksByAuthor).
      then(function(books){
        // found books
    }).catch(function(reason){
      // something went wrong
    });
    ```
  
    @method then
    @param {Function} onFulfilled
    @param {Function} onRejected
    Useful for tooling.
    @return {Promise}
  */
  then: then,

  /**
    `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
    as the catch block of a try/catch statement.
  
    ```js
    function findAuthor(){
      throw new Error('couldn't find that author');
    }
  
    // synchronous
    try {
      findAuthor();
    } catch(reason) {
      // something went wrong
    }
  
    // async with promises
    findAuthor().catch(function(reason){
      // something went wrong
    });
    ```
  
    @method catch
    @param {Function} onRejection
    Useful for tooling.
    @return {Promise}
  */
  'catch': function _catch(onRejection) {
    return this.then(null, onRejection);
  }
};

function polyfill() {
    var local = undefined;

    if (typeof global !== 'undefined') {
        local = global;
    } else if (typeof self !== 'undefined') {
        local = self;
    } else {
        try {
            local = Function('return this')();
        } catch (e) {
            throw new Error('polyfill failed because global object is unavailable in this environment');
        }
    }

    var P = local.Promise;

    if (P) {
        var promiseToString = null;
        try {
            promiseToString = Object.prototype.toString.call(P.resolve());
        } catch (e) {
            // silently ignored
        }

        if (promiseToString === '[object Promise]' && !P.cast) {
            return;
        }
    }

    local.Promise = Promise;
}

// Strange compat..
Promise.polyfill = polyfill;
Promise.Promise = Promise;

return Promise;

})));
//# sourceMappingURL=es6-promise.map

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(99), __webpack_require__(30)))

/***/ }),
/* 30 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const base_1 = __webpack_require__(0);
const Models_1 = __webpack_require__(7);
const Events_1 = __webpack_require__(6);
const utils_1 = __webpack_require__(3);
const renderUtils_1 = __webpack_require__(4);
const components_1 = __webpack_require__(1);
const slideReveal_1 = __webpack_require__(94);
const models_1 = __webpack_require__(2);
class CTPGList extends base_1.CTLayerComponent {
    constructor() {
        super(...arguments);
        this.atTop = true;
        this.listPagination = 20;
        this.paginationStart = 1;
        this.paginationDebounce = 0;
    }
    static get is() {
        return "ct-pg-list";
    }
    initialize() {
        return __awaiter(this, void 0, void 0, function* () {
            this.clearData();
            this.contacts = [];
            this.onRenderComplete(() => __awaiter(this, void 0, void 0, function* () {
                this.contacts = yield this.layer.getAllContacts();
                this.ourVCard = yield this.layer.getOurVCard();
            }), true);
            this.getPages();
        });
    }
    setupListeners() {
        this.addListener(Events_1.PagerEvents.PageUpdate, () => {
            this.getPages();
        });
        this.addListener(Events_1.PagerEvents._Request_Component_Clear_Data, () => {
            this.clearData();
        });
        this.addListener(Events_1.PagerEvents.NewPageReceived, () => {
            this.getPages();
            this.forceRedraw();
        });
    }
    clearData() {
        this.pages = utils_1.deepCloneArray([]);
        this.paginationStart = 1;
        this.paginationDebounce = 0;
    }
    getPages() {
        this.pages = [...this.layer.getPages(this.listPagination * this.paginationStart)];
    }
    rowClick(page) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.layer.setSelectedPage(page);
            this.emitEvent(Events_1.PagerEvents._Request_ReadPageDetail, new Events_1.ReadPageDetailEventArgs(page));
        });
    }
    deletePage(page) {
        return __awaiter(this, void 0, void 0, function* () {
            const alert = models_1.DefaultAlerts.AlertYesNoQuestion("Delete?", "Are you sure you wish to delete this page?", 1, {
                yes: () => __awaiter(this, void 0, void 0, function* () {
                    yield this.layer.deletePage(page);
                    this.emitEvent(Events_1.PagerEvents.PageUpdate);
                })
            });
            this.emitEvent(Events_1.PagerEvents._Request_RaiseAlert, alert);
        });
    }
    onScroll(e) {
        const container = e.currentTarget;
        const scrollHeight = container.scrollHeight;
        const scrollTop = container.scrollTop;
        const containerHeight = container.clientHeight;
        const boundary = containerHeight / 10;
        if (scrollHeight - scrollTop < (containerHeight + boundary)) {
            const now = new Date().getTime();
            if (now - this.paginationDebounce || 0 > 1000) {
                this.paginationDebounce = now;
                ++this.paginationStart;
                this.getPages();
            }
            return;
        }
        if (scrollTop < boundary) {
            this.paginationStart = 1;
            this.getPages();
            return;
        }
    }
    get generateComponentStyles() {
        return `:host{color:#333536;font-weight:400}:host h1,:host h2,:host h3,:host h4,:host h5,:host h6{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}:host,:host *{box-sizing:border-box}.user-html p{margin:0}.user-html p+p{margin:.8em 0 0 0}.user-html strong{font-weight:600}:host{display:flex;flex-direction:column;width:100%;height:100%}:host div.container{height:100%;display:flex;flex-direction:column}:host div.container div.header{display:none}:host div.container div.header h3{color:white;margin:auto auto}@media screen and (max-width: 640px){:host div.container div.header{display:flex;flex:0 0 40px}}:host div.container p{text-align:center}:host div.container div.scrollable{overflow-y:scroll;-webkit-overflow-scrolling:touch;flex:1 1}@media screen and (max-width: 640px){:host div.container div.scrollable .innerHeader{display:none}}:host div.container div.scrollable div.row{position:relative;height:auto}:host div.container div.scrollable div.row div.background{position:absolute;right:0;top:0;z-index:0;height:100%;width:30vw;display:flex;background-color:#f2f2f2}:host div.container div.scrollable div.row div.background ct-button{margin:auto;height:100%;width:100%}:host div.container div.scrollable div.row div.foreground{display:flex;justify-content:space-between;padding:15px 0;cursor:pointer;position:relative;z-index:100}:host div.container div.scrollable div.row div.foreground.header{padding:5px 0;font-size:12px}:host div.container div.scrollable div.row div.foreground div{padding:0 10px;display:flex;justify-content:flex-start;overflow:hidden;white-space:nowrap}:host div.container div.scrollable div.row div.foreground span{overflow:hidden;text-overflow:ellipsis;margin:auto 0}:host div.container div.scrollable div.row div.foreground div.type{flex-basis:10%;order:1;flex:1 1 250px}:host div.container div.scrollable div.row div.foreground div.type span.color{margin:auto 5px auto 0;height:8px;width:8px;border-radius:50%}:host div.container div.scrollable div.row div.foreground div.from{flex-basis:10%;order:2}:host div.container div.scrollable div.row div.foreground div.to{flex-basis:20%;order:3}:host div.container div.scrollable div.row div.foreground div.subject{flex-basis:20%;order:4}:host div.container div.scrollable div.row div.foreground div.message{flex-basis:25%;order:5}:host div.container div.scrollable div.row div.foreground div.attachment{flex-basis:10%;order:6;flex:1 1 100px}:host div.container div.scrollable div.row div.foreground div.attachment ct-pg-icon{margin:auto}:host div.container div.scrollable div.row div.foreground div.raised{flex-basis:5%;order:6;flex:1 1 150px}@media screen and (max-width: 640px){:host div.container div.scrollable div.row div.foreground{flex-wrap:wrap}:host div.container div.scrollable div.row div.foreground div.type{order:1;flex-basis:50%}:host div.container div.scrollable div.row div.foreground div.attachment{order:2;flex:0 1 auto}:host div.container div.scrollable div.row div.foreground div.raised{order:3;flex:0 1 auto}:host div.container div.scrollable div.row div.foreground div.from{order:4;flex-basis:100%}:host div.container div.scrollable div.row div.foreground div.to{order:5;flex-basis:100%;display:none}:host div.container div.scrollable div.row div.foreground div.subject{order:6;flex-basis:100%}:host div.container div.scrollable div.row div.foreground div.message{order:7;flex-basis:100%}:host div.container div.scrollable div.row div.foreground div.from span,:host div.container div.scrollable div.row div.foreground div.subject span,:host div.container div.scrollable div.row div.foreground div.message span{padding-left:14px}}:host .container{background-color:var(--default-bg-color, #fff);color:var(--default-font-color, #333536)}:host .container .header{background-color:var(--secondary-color, #2c394e)}:host .container .scrollable{background-color:var(--default-bg-color, #fff)}:host .container .scrollable .row{border-bottom:1px solid var(--default-border-color, #d9d9d9)}:host .container .scrollable .row div.foreground{background-color:var(--default-bg-color, #fff)}:host .container .scrollable .row div.foreground.header{background-color:var(--default-border-color, #d9d9d9);color:var(--default-font-color-light, #9d9d9d)}:host .container .scrollable .row div.foreground div{color:var(--default-font-color, #333536)}@media screen and (max-width: 640px){:host .container .scrollable .row div.foreground div.from,:host .container .scrollable .row div.foreground div.message{color:var(--default-font-color-light, #9d9d9d)}}
        `;
    }
    generateComponentMarkup() {
        return (window.__CTRender("div", { className: "container" },
            renderUtils_1.renderIf(this.pages.length > 0, window.__CTRender("div", { className: "header" },
                window.__CTRender("h3", null, "Recent Messages"))),
            window.__CTRender("div", { class: "scrollable", onscroll: (e) => this.onScroll(e) },
                renderUtils_1.renderIf(this.pages.length > 0, window.__CTRender("div", { className: "row innerHeader" },
                    window.__CTRender("div", { className: "foreground header" },
                        window.__CTRender("div", { className: "type" },
                            window.__CTRender("span", null, "Type")),
                        window.__CTRender("div", { className: "from" },
                            window.__CTRender("span", null, "From")),
                        window.__CTRender("div", { className: "to" },
                            window.__CTRender("span", null, "To")),
                        window.__CTRender("div", { className: "subject" },
                            window.__CTRender("span", null, "Subject")),
                        window.__CTRender("div", { className: "message" },
                            window.__CTRender("span", null, "Message")),
                        window.__CTRender("div", { className: "attachment" },
                            window.__CTRender("span", null, "Attachment")),
                        window.__CTRender("div", { className: "raised" },
                            window.__CTRender("span", null, "Raised"))))),
                this._renderPageList(),
                this._renderLoading())));
    }
    _renderPageList() {
        if (this.pages.length === 0) {
            return [
                window.__CTRender("p", null, "There are no pages to display.")
            ];
        }
        return this.pages.map((item) => window.__CTRender("div", { className: "row" },
            window.__CTRender("div", { style: renderUtils_1.buildStyles({ transform: "translateX(0vw)" }), className: "foreground", onClick: () => this.rowClick(item), ontouchmove: this.enableTouchFeatures ? (e) => slideReveal_1.slideToReveal(e, 30) : null, ontouchend: this.enableTouchFeatures ? (e) => slideReveal_1.slideToRevealEnd(e, 30) : null },
                window.__CTRender("div", { className: "type" },
                    window.__CTRender("span", { className: "color", style: renderUtils_1.buildStyles({ backgroundColor: item.pageType.colorCode }) }),
                    window.__CTRender("span", null, item.pageType.name)),
                window.__CTRender("div", { className: "from" },
                    window.__CTRender("span", null, utils_1.getVCardNameOrUsername(item.sender, this.contacts, item.sender === this.layer.getCurrentUserJid(), this.ourVCard))),
                window.__CTRender("div", { className: "to" },
                    window.__CTRender("span", null, item.to.map(contact => utils_1.getVCardNameOrUsername(contact.name, this.contacts, contact.name === this.layer.getCurrentUserJid(), this.ourVCard)).join(", "))),
                window.__CTRender("div", { className: "subject" },
                    window.__CTRender("span", null, item.subject)),
                window.__CTRender("div", { className: "message" },
                    window.__CTRender("span", null, item.message)),
                window.__CTRender("div", { className: "attachment" }, renderUtils_1.renderIf(item.attachments, window.__CTRender(components_1.CTIcon, { width: "20", height: "20", icon: Models_1.Icons.FONTAWESOME.Paperclip }))),
                window.__CTRender("div", { className: "raised" },
                    window.__CTRender("span", null, utils_1.formatDateForTimeOrDate(new Date(item.openedDate), false, this.layer.config.xmpp.showSecondsOnTimestamps)))),
            window.__CTRender("div", { className: "background" },
                window.__CTRender(components_1.CTButton, { icon: Models_1.Icons.FONTAWESOME.TrashCan, iconColor: "red", type: "cancel", iconWidth: "30", iconHeight: "30", onClick: () => this.deletePage(item) }))));
    }
    _renderLoading() {
        if (this.renderLoading) {
            return (window.__CTRender("div", { className: "row" },
                window.__CTRender("p", null, "Loading...")));
        }
        else {
            return null;
        }
    }
}
__decorate([
    base_1.prop({ type: Array, attribute: false, default: [] })
], CTPGList.prototype, "pages", void 0);
__decorate([
    base_1.prop({ type: base_1.Stroolean, attribute: true, default: false })
], CTPGList.prototype, "enableTouchFeatures", void 0);
__decorate([
    base_1.prop({ type: Boolean, attribute: false, default: false })
], CTPGList.prototype, "renderLoading", void 0);
exports.CTPGList = CTPGList;
CTPGList.register();


/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const base_1 = __webpack_require__(0);
const models_1 = __webpack_require__(2);
const Models_1 = __webpack_require__(7);
const Events_1 = __webpack_require__(6);
const utils_1 = __webpack_require__(3);
const renderUtils_1 = __webpack_require__(4);
const components_1 = __webpack_require__(1);
class CTPGNewPageModal extends base_1.CTLayerComponent {
    constructor() {
        super(...arguments);
        // === End properties === //
        this.buttonsDisabled = false;
        this.hide = false;
        this.viewImage = (e) => {
            const img = e.target;
            utils_1.displayImage(img.src).catch(e => this.emitEvent(Events_1.PagerEvents._Request_RaiseAlert, models_1.DefaultAlerts.AlertErrorWithOkayButton("Error", "Could not open image file.", 1, {})));
        };
        this.mute = () => {
            this.layer.mute();
            this.muted = true;
        };
    }
    static get is() {
        return "ct-pg-new-page-modal";
    }
    initialize() {
        return __awaiter(this, void 0, void 0, function* () {
            this.connectivityStatus = this.layer.getConnectionStatus();
        });
    }
    setupListeners() {
        this.addListener(Events_1.PagerEvents.NewPageReceived, (page) => __awaiter(this, void 0, void 0, function* () {
            this.muted = false;
            yield this.checkForPendingPages();
        }));
        this.addListener(Events_1.PagerEvents.PageUpdate, (page) => __awaiter(this, void 0, void 0, function* () {
            yield this.checkForPendingPages();
        }));
        this.addListener(Events_1.PagerEvents._Request_CheckForPendingPages, () => __awaiter(this, void 0, void 0, function* () {
            yield this.checkForPendingPages();
        }));
        this.addListener(Events_1.PagerEvents.ConnectionStatusChange, (detail) => {
            this.connectivityStatus = detail.status;
            if (detail.status === models_1.ConnectionStatus.Connected) {
                this.buttonsDisabled = false;
                this.hide = false;
                this.muted = false;
                // if (this.showing) {
                //     // make noise
                //     this.emitEvent(PagerEvents.RequestMakeAudioNotification, this.page);
                // }
            }
            else {
                this.buttonsDisabled = true;
            }
            if (detail.status === models_1.ConnectionStatus.Disconnected) {
                if (detail.disconnectStatus.getReason() === "Replaced by new connection") {
                    this.replyMenuShowing = false;
                    this.hide = true;
                    this.layer.clearAllData();
                    this.checkForPendingPages();
                }
            }
        }, {
            dontSuppress: true
        });
    }
    checkForPendingPages() {
        return __awaiter(this, void 0, void 0, function* () {
            const pendingPages = yield this.layer.getPendingPages();
            if (!this.replyMenuShowing) {
                if (pendingPages.length > 0) {
                    this.page = Object.assign({}, pendingPages[0]);
                    if (this.page.attachments && !this.page.attachmentsLoaded) {
                        yield this.layer.downloadAttachmentsByMessageId(this.page.messageId);
                    }
                }
                else {
                    this.page = null;
                }
                this.showing = !this.hide && this.page ? true : false;
                this.responseSendPending = false;
                if (this.showing) {
                    // make noise
                    this.emitEvent(Events_1.PagerEvents.RequestMakeAudioNotification, this.page);
                }
            }
        });
    }
    respondToPage(value) {
        return __awaiter(this, void 0, void 0, function* () {
            this.responseSendPending = true;
            this.replyMenuShowing = false;
            const response = {
                ts: new Date().getTime(),
                content: value,
                type: Models_1.ContactResponseType.Response
            };
            yield this.layer.addContactResponseToPage(this.page, response);
            this.emitEvent(Events_1.PagerEvents.PageResponse, new Events_1.SendPageResponseEventArgs(this.page._id, response, this.page.sender));
            if (this.page.audio.length > 0) {
                const audio = this.shadowRoot.querySelector("audio");
                if (audio) {
                    audio.pause();
                    audio.parentElement.removeChild(audio);
                }
            }
        });
    }
    toggleReplyMenu() {
        this.replyMenuShowing = !this.replyMenuShowing;
    }
    get generateComponentStyles() {
        return `:host{color:#333536;font-weight:400}:host h1,:host h2,:host h3,:host h4,:host h5,:host h6{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}:host,:host *{box-sizing:border-box}.user-html p{margin:0}.user-html p+p{margin:.8em 0 0 0}.user-html strong{font-weight:600}:host{background-color:var(--primary-color, #000);height:100%;width:100%;display:flex;flex-direction:column;transform:translateY(100%);will-change:transform;transition:transform 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);visibility:hidden;position:fixed;top:0;z-index:1;overflow:hidden}:host .container{height:100%;width:100%;display:flex;flex-direction:column}:host .container .title{display:flex;width:100%;flex:0 0 var(--header-height, 60px);padding:0 20px;justify-content:space-between;align-items:center}:host .container .content{flex:1 1;display:flex;flex-direction:column;margin:5px}:host .container .content .panel{flex:1 1;display:flex;flex-direction:column;overflow:auto}:host .container .content .panel .data{display:flex;flex-direction:row;margin:0 0 1px 0;padding:10px 20px;flex:0 0 var(--header-height, 60px)}:host .container .content .panel .data ct-icon.bell-filled{margin-left:10px}:host .container .content .panel .data ct-online-indicator{margin:auto 0}:host .container .content .panel .data.subject{display:flex;flex:0 1 auto;overflow:hidden}:host .container .content .panel .data.subject span{margin:auto 0}:host .container .content .panel .data.severity .name{margin:auto 0;font-size:18px}:host .container .content .panel .data.severity .time{margin:auto 0 auto auto;font-weight:300;font-size:18px}:host .container .content .panel .data.severity .mute{margin:3px 0 3px auto;font-weight:300}@media screen and (max-width: 640px){:host .container .content .panel .data.severity .name{font-size:16px}:host .container .content .panel .data.severity .time{font-size:12px}}:host .container .content .panel .message{padding:10px 20px;overflow:auto;-webkit-overflow-scrolling:touch;flex:1 1}:host .container .content .panel .message span{display:block;margin-bottom:15px}:host .container .content .panel .message ct-icon{margin:auto}:host .container .content .panel .message ct-audio,:host .container .content .panel .message ct-img{width:100%;margin:10px 0}:host .container .content .panel .message p{font-size:18px;line-height:28px}:host .container .content .panel .replyContainer{margin:auto 0 20px;padding:20px 20px 0}:host .container .replyMenuContainer{background-color:rgba(0,0,0,0.6);position:absolute;top:0;width:inherit;height:inherit;opacity:0;visibility:hidden}:host .container .replyMenuContainer.showing{visibility:visible;transition:opacity 0.25s ease-in;opacity:1}:host .container .replyMenuContainer .panel{position:absolute;bottom:0;width:100vw;display:flex;flex-direction:column;padding:25px 20px}:host .container .replyMenuContainer .panel ct-button{margin-top:15px}:host .container .replyMenuContainer .panel ct-button:first-child{margin-top:0}:host([showing]){visibility:visible;transform:translateY(0)}:host .container{background-color:var(--default-bg-color);color:var(--default-font-color)}:host .container .content{background-color:var(--default-bg-color)}:host .container .replyMenuContainer .panel{background-color:var(--default-bg-color)}
        `;
    }
    generateComponentMarkup() {
        if (!this.page)
            return null;
        return (window.__CTRender("div", { className: "container" },
            window.__CTRender("div", { className: "content" },
                window.__CTRender("div", { className: "panel" },
                    this._renderHeader(),
                    this._renderSubject(),
                    window.__CTRender("div", { className: "message" },
                        this._renderPageMessage(),
                        this._renderAttachments()),
                    window.__CTRender("div", { className: "replyContainer" }, this._renderReplyButton()))),
            this._buildReplyMenu()));
    }
    _renderHeader() {
        if (this.connectivityStatus === models_1.ConnectionStatus.Connected) {
            return (window.__CTRender("div", { className: "data severity", style: renderUtils_1.buildStyles({ backgroundColor: this.page.pageType.colorCode, color: renderUtils_1.decideTextColorFromBgColor(this.page.pageType.colorCode) }) },
                window.__CTRender("div", { className: "name" }, this.page.pageType.name),
                window.__CTRender("div", { className: "time" }, utils_1.formatDate(this.page.openedDate, "HH:mm")),
                window.__CTRender(components_1.CTIcon, { width: "18", class: "bell-filled", height: "18", icon: Models_1.Icons.FONTAWESOME.BellFilled })));
        }
        else {
            return (window.__CTRender("div", { className: "data severity", style: renderUtils_1.buildStyles({ backgroundColor: "#9b9b9b", color: renderUtils_1.decideTextColorFromBgColor("#9b9b9b") }) },
                window.__CTRender(components_1.CTOnlineIndicator, null),
                renderUtils_1.renderIf(!this.muted, window.__CTRender(components_1.CTButton, { className: "mute", type: "invert-secondary", onClick: e => this.mute() },
                    window.__CTRender(components_1.CTIcon, { width: "16", height: "16", color: "#FFF", icon: Models_1.Icons.ICOMOON.Mute })))));
        }
    }
    _renderSubject() {
        if (this.page.subject) {
            return (window.__CTRender("div", { className: "data subject", style: renderUtils_1.buildStyles({ backgroundColor: this.page.pageType.colorCode, color: renderUtils_1.decideTextColorFromBgColor(this.page.pageType.colorCode) }) },
                window.__CTRender("span", null, this.page.subject)));
        }
        else
            return null;
    }
    _renderPageMessage() {
        if (this.page.messageSplit && this.page.messageSplit.length) {
            const container = [];
            this.page.messageSplit.forEach(x => {
                container.push(window.__CTRender("p", null, x));
            });
            return (window.__CTRender("div", null, container));
        }
        else {
            return (window.__CTRender("span", null, this.page.message));
        }
    }
    _renderAttachments() {
        if (!this.page.attachments)
            return null;
        let markup = (window.__CTRender("div", null,
            window.__CTRender(components_1.CTIcon, { width: 20, height: 20, icon: Models_1.Icons.FONTAWESOME.CircleNotch, spin: true })));
        if (this.page.attachmentsLoaded) {
            markup = (window.__CTRender("div", null,
                renderUtils_1.renderIf(this.page.audio.length > 0, window.__CTRender(components_1.CTAudio, { src: this.page.audio[0] })),
                renderUtils_1.renderIf(this.page.image.length > 0, window.__CTRender(components_1.CTImg, { onclick: this.viewImage, src: this.page.image[0] }))));
        }
        return markup;
    }
    _renderReplyButton() {
        if (this.page.replyTemplate && this.page.replyTemplate.buttons.length === 1) {
            const btn = this.page.replyTemplate.buttons[0];
            return window.__CTRender(components_1.CTButton, { disabled: this.buttonsDisabled, type: "primary", onClick: () => this.respondToPage(btn.value), isWaiting: this.responseSendPending, large: true }, btn.label);
        }
        else if (this.page.replyTemplate && this.page.replyTemplate.buttons.length > 1) {
            return window.__CTRender(components_1.CTButton, { disabled: this.buttonsDisabled, type: "primary", onClick: () => this.toggleReplyMenu(), isWaiting: this.responseSendPending, large: true }, "Reply");
        }
        else {
            return window.__CTRender(components_1.CTButton, { disabled: this.buttonsDisabled, type: "primary", onClick: () => this.respondToPage("Acknowledge"), isWaiting: this.responseSendPending, large: true }, "Acknowledge");
        }
    }
    _buildReplyMenu() {
        const buttons = [];
        if (this.page.replyTemplate && this.page.replyTemplate.buttons) {
            this.page.replyTemplate.buttons.map((btn) => {
                buttons.push(window.__CTRender(components_1.CTButton, { disabled: this.buttonsDisabled, type: "primary", onClick: () => this.respondToPage(btn.value), large: true }, btn.label));
            });
            buttons.push(window.__CTRender(components_1.CTButton, { type: "cancel", onClick: () => this.toggleReplyMenu(), large: true }, "Cancel"));
            return (window.__CTRender("div", { className: `replyMenuContainer ${this.replyMenuShowing ? "showing" : ""}` },
                window.__CTRender("div", { className: "panel" }, buttons)));
        }
        else {
            return null;
        }
    }
}
__decorate([
    base_1.prop({ type: Boolean, attribute: true, default: false })
], CTPGNewPageModal.prototype, "showing", void 0);
__decorate([
    base_1.prop({ type: Object, attribute: false, default: null })
], CTPGNewPageModal.prototype, "page", void 0);
__decorate([
    base_1.prop({ type: Boolean, attribute: false, default: false })
], CTPGNewPageModal.prototype, "replyMenuShowing", void 0);
__decorate([
    base_1.prop({ type: String, attribute: false })
], CTPGNewPageModal.prototype, "connectivityStatus", void 0);
__decorate([
    base_1.prop({ type: Boolean, attribute: false, default: false })
], CTPGNewPageModal.prototype, "responseSendPending", void 0);
__decorate([
    base_1.prop({ type: Boolean, attribute: false, default: false })
], CTPGNewPageModal.prototype, "muted", void 0);
exports.CTPGNewPageModal = CTPGNewPageModal;
CTPGNewPageModal.register();


/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const base_1 = __webpack_require__(0);
const models_1 = __webpack_require__(2);
const Models_1 = __webpack_require__(7);
const Events_1 = __webpack_require__(6);
const ct_pg_contact_selection_1 = __webpack_require__(19);
const utils_1 = __webpack_require__(3);
const ct_pg_file_picker_1 = __webpack_require__(20);
const components_1 = __webpack_require__(1);
const renderUtils_1 = __webpack_require__(4);
const pagerUtils_1 = __webpack_require__(9);
var AttachmentType;
(function (AttachmentType) {
    // tslint:disable no-any
    AttachmentType[AttachmentType["Audio"] = "audio"] = "Audio";
    AttachmentType[AttachmentType["Image"] = "image"] = "Image";
    // tslint:enable no-any
})(AttachmentType || (AttachmentType = {}));
class CTPGRaiseNewPage extends base_1.CTLayerComponent {
    constructor() {
        super(...arguments);
        this.closeContacts = () => __awaiter(this, void 0, void 0, function* () {
            this.selectedContacts = utils_1.deepCloneArray(yield this.layer.getSelectedContacts());
            this.newPage.to = this.selectedContacts;
            this.contactSelectionShowing = false;
            this.validate();
        });
        this.addAttachments = (type, files) => {
            if (files) {
                this.newPage[type] = [];
                for (const f of files) {
                    this.newPage[type].push(f);
                }
                this.forceRedraw();
            }
        };
        this.deleteAttachment = (type) => {
            this.newPage[type] = [];
            this.forceRedraw();
        };
        this.sendPage = () => {
            const page = pagerUtils_1.createNewPage(this.newPage, this.layer.getCurrentUserJid(), this.layer.config.pageTypes[this.newPage.type], this.layer.config.replyTemplates[this.newPage.replyTemplate]);
            this.isWaiting = true;
            this.emitEvent(Events_1.PagerEvents._Request_SendNewPage, new Events_1.SendNewPageEventArgs(page));
            // this.close();
        };
    }
    static get is() {
        return "ct-pg-raise-new-page";
    }
    initialize() {
        return __awaiter(this, void 0, void 0, function* () {
            this.types = this.layer.config.pageTypes.map((item, idx) => {
                return { key: idx, value: item.name };
            });
            this.replyTemplates = this.layer.config.replyTemplates.map((item, idx) => {
                return { key: idx, value: item.name };
            });
            this.connectivityStatus = this.layer.getConnectionStatus();
        });
    }
    setupListeners() {
        this.addListener(Events_1.PagerEvents.ConnectionStatusChange, (detail) => {
            this.connectivityStatus = detail.status;
            this.validate();
        });
        this.addListener(Events_1.PagerEvents._Request_CloseSendNewPageModal, () => {
            this.close();
        });
        this.addListener(Events_1.PagerEvents.SendingPageError, () => this.isWaiting = false);
    }
    createNewPage() {
        this.newPage = Object.assign({}, {
            to: [],
            type: 0,
            replyTemplate: 0,
            subject: "",
            message: "",
            image: [],
            audio: []
        });
        this.isValidated = false;
        this.showing = true;
    }
    close() {
        this.isWaiting = false;
        this.showing = false;
        this.selectedContacts = [];
        this.layer.setSelectedContacts(this.selectedContacts);
    }
    showContactSelection() {
        this.contactSelectionShowing = true;
    }
    removeContact(name) {
        this.selectedContacts = utils_1.deepCloneArray(this.selectedContacts.filter(x => x.name !== name));
        this.newPage.to = this.selectedContacts;
        this.validate();
        // this.forceRedraw();
    }
    selectionAction(target, selection) {
        this.newPage[target] = parseInt(selection);
    }
    validate() {
        let validated = true;
        if (this.newPage) {
            if (this.newPage.subject.length > 255) {
                validated = false;
            }
            if (!this.newPage.message || this.newPage.message.length > 4000) {
                validated = false;
            }
            if (this.newPage.to.length === 0) {
                validated = false;
            }
            if (this.connectivityStatus !== models_1.ConnectionStatus.Connected) {
                validated = false;
            }
        }
        else {
            validated = false;
        }
        this.isValidated = validated;
    }
    textFieldInput(e) {
        switch (e.key) {
            case "subject":
                this.newPage.subject = e.value;
                break;
            case "message":
                this.newPage.message = e.value;
                break;
        }
        this.validate();
    }
    get generateComponentStyles() {
        return `:host{color:#333536;font-weight:400}:host h1,:host h2,:host h3,:host h4,:host h5,:host h6{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}:host,:host *{box-sizing:border-box}.user-html p{margin:0}.user-html p+p{margin:.8em 0 0 0}.user-html strong{font-weight:600}:host{width:100%;height:100%;display:flex;background-color:rgba(0,0,0,0.6);opacity:0;visibility:hidden;position:fixed;z-index:1}:host .container{display:flex;flex-direction:column;margin:auto;width:95vw;height:95vh;min-width:500px;transform:translateY(100%);will-change:transform;transition:transform 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);visibility:hidden}:host .container .title{display:flex;justify-content:space-between;align-items:center;flex:0 0 var(--header-height, 60px);padding:10px 0 10px 20px}:host .container .title h2{position:absolute;left:50%;top:0;transform:translateX(-50%)}@media screen and (max-width: 640px){:host .container .title h2{display:none}}:host .container .content{overflow:auto;-webkit-overflow-scrolling:touch}:host .container .content div.columns{display:flex;flex-direction:row;flex-wrap:wrap;overflow:auto;margin-bottom:10vh}:host .container .content div.columns h4{font-weight:400;margin:8px 0 0}:host .container .content div.columns .to{display:flex;flex:1 1 100%;justify-content:flex-start;width:100%;padding:20px;min-height:87px}:host .container .content div.columns .to h4{margin:auto 20px auto 0}:host .container .content div.columns .to div.contactContainer{display:flex;flex-grow:1;margin-right:20px;flex-wrap:wrap}:host .container .content div.columns .to div.contactContainer span.contactPill{display:flex;justify-content:space-between;font-size:12px;height:30px;padding:0 15px;border-radius:20px;margin:0 5px 5px 0;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;cursor:pointer}:host .container .content div.columns .to div.contactContainer span.contactPill span,:host .container .content div.columns .to div.contactContainer span.contactPill ct-icon{margin:auto 10px auto 0;height:15px}:host .container .content div.columns .to div.contactContainer span.contactPill ct-icon{margin:auto 0}:host .container .content div.columns .to ct-button{margin:auto 0 auto auto}:host .container .content div.columns .types{display:flex;flex-wrap:wrap;flex:1 1 100%}:host .container .content div.columns .types div{flex:1 1 100%;padding:10px 20px;display:flex;overflow:auto}:host .container .content div.columns .types div h4{margin:auto;flex-basis:30%}:host .container .content div.columns .types div ct-selection-list{margin:auto 0 auto 2%}:host .container .content div.columns .subject{display:flex;flex-basis:100%;flex-direction:column;padding:0 20px}:host .container .content div.columns .subject ct-textbox{margin-bottom:5px}:host .container .content div.columns .pageContent{display:flex;flex-basis:100%;flex-direction:column;padding:0 20px;overflow:auto}:host .container .content div.columns .pageContent ct-textbox{margin-bottom:5px}:host .container .content div.columns .attachments{display:flex;flex:1 1 100%;min-height:150px;justify-content:flex-start;align-items:flex-start}@media screen and (max-width: 640px){:host .container .content div.columns .attachments{flex-wrap:wrap}}:host .container .content div.columns .attachments div{flex:0 0 50%;padding:10px 20px;display:flex;overflow:auto;flex-direction:column}@media screen and (max-width: 640px){:host .container .content div.columns .attachments div{flex-basis:100%}}:host .container .content div.columns .attachments div h4{flex:1 1 100%}:host .container .content div.columns .attachments div ct-pg-file-picker{margin:20px 0 10px;flex:0 1 15%;width:15%}:host .container .content div.columns .attachments div ct-button{margin:0 0 10px;flex:0 1 15%;width:15%}:host .container .content div.columns .attachments div img{flex:0 0 auto}:host .container .buttonsContainer{display:flex;height:10vh;width:100%;justify-content:flex-end;position:fixed;bottom:0}:host .container .buttonsContainer div{margin:auto 20px}:host .container .buttonsContainer div ct-button{flex:1 1 40%}@media screen and (max-width: 640px){:host .container{width:100%;height:100%;min-width:100%;max-height:100%}}:host([showing]){visibility:visible;transition:opacity 0.25s ease-in;opacity:1}:host([showing]) div.container{visibility:visible;transform:translateY(0)}:host .container{background-color:var(--default-bg-color);color:var(--default-font-color)}:host .container .title{background-color:var(--primary-color, #15233B);color:var(--primary-font-color, #fff)}:host .container .content{background-color:var(--default-bg-color)}:host .container .content div.columns .to,:host .container .content div.columns .types,:host .container .content div.columns .subject,:host .container .content div.columns .pageContent{border-bottom:1px solid var(--default-border-color)}:host .container .content div.columns .to div.contactContainer span.contactPill{background-color:var(--primary-color);color:var(--primary-font-color)}:host .container .content div.columns .to div.contactContainer span.contactPill:hover{background-color:#223961}:host .container .content div.columns .attachments:first-child{border-right:1px solid var(--default-border-color)}:host .container .buttonsContainer{background-color:var(--default-bg-color-dark)}
        `;
    }
    generateComponentMarkup() {
        if (!this.newPage)
            return null;
        return (window.__CTRender("div", { className: `container` },
            window.__CTRender("div", { className: "title" }, this._renderTitle()),
            window.__CTRender("div", { class: "content" }, this._renderBody()),
            window.__CTRender("div", { className: "buttonsContainer" },
                window.__CTRender("div", null,
                    window.__CTRender(components_1.CTButton, { type: "primary", disabled: !this.isValidated, isWaiting: this.isWaiting, onClick: this.sendPage }, "Send Message"))),
            window.__CTRender(ct_pg_contact_selection_1.CTPGContactSelection, { showing: this.contactSelectionShowing, closeFunction: this.closeContacts, selectedContacts: this.newPage.to })));
    }
    _renderTitle() {
        return [
            window.__CTRender(components_1.CTOnlineIndicator, null),
            window.__CTRender("h2", null, "New Message"),
            window.__CTRender(components_1.CTButton, { type: "transparent", icon: Models_1.Icons.FONTAWESOME.Cross, iconColor: "#fff", onClick: () => this.close() })
        ];
    }
    _renderBody() {
        return (window.__CTRender("div", { className: "columns" },
            window.__CTRender("div", { className: "to" },
                window.__CTRender("h4", null, "To:"),
                window.__CTRender("div", { className: "contactContainer" }, this.newPage.to.map((contact) => window.__CTRender("span", { className: "contactPill", onClick: () => this.removeContact(contact.name) },
                    window.__CTRender("span", null, contact.displayName),
                    window.__CTRender(components_1.CTIcon, { width: "13", height: "13", icon: Models_1.Icons.FONTAWESOME.Cross })))),
                window.__CTRender(components_1.CTButton, { type: "primary", icon: Models_1.Icons.FONTAWESOME.Ellipsis, iconColor: "#fff", onClick: () => this.showContactSelection() })),
            window.__CTRender("div", { className: "types" },
                window.__CTRender("div", null,
                    window.__CTRender("h4", null, "Type:"),
                    window.__CTRender(components_1.CTSelectionList, { options: this.types, selected: this.newPage.type, forceDropdown: true, onSelect: (e) => this.selectionAction("type", e) })),
                window.__CTRender("div", null,
                    window.__CTRender("h4", null, "Reply Template:"),
                    window.__CTRender(components_1.CTSelectionList, { options: this.replyTemplates, selected: this.newPage.replyTemplate, forceDropdown: true, onSelect: (e) => this.selectionAction("replyTemplate", e) }))),
            window.__CTRender("div", { className: "subject" },
                window.__CTRender("h4", null, "Subject:"),
                window.__CTRender(components_1.CTTextbox, { fullBorder: true, type: "text", name: "subject", defaultValue: this.newPage.subject, showClearOptions: false, callback: (e) => this.textFieldInput(e), max: 255 })),
            window.__CTRender("div", { className: "pageContent" },
                window.__CTRender("h4", null, "Message:"),
                window.__CTRender(components_1.CTTextbox, { fullBorder: true, type: "textarea", name: "message", defaultValue: this.newPage.message, showClearOptions: false, callback: (e) => this.textFieldInput(e), max: 4000 })),
            window.__CTRender("div", { className: "attachments" },
                !this.layer.audioAttachmentsEnabled() ? null :
                    window.__CTRender("div", null,
                        window.__CTRender("h4", null, "Audio Message:"),
                        window.__CTRender(ct_pg_file_picker_1.CTPGFilePicker, { fileTypes: ["audio/mpeg", "audio/mp3"], callback: (files) => this.addAttachments(AttachmentType.Audio, files) }),
                        renderUtils_1.renderIf(this.newPage.audio.length > 0, window.__CTRender(components_1.CTButton, { type: "primary", icon: Models_1.Icons.FONTAWESOME.TrashCan, iconColor: "#fff", onClick: () => this.deleteAttachment(AttachmentType.Audio) })),
                        this._renderAudioAttachments()),
                !this.layer.photoAttachmentsEnabled() ? null :
                    window.__CTRender("div", null,
                        window.__CTRender("h4", null, "Image Attachment:"),
                        window.__CTRender(ct_pg_file_picker_1.CTPGFilePicker, { callback: (files) => this.addAttachments(AttachmentType.Image, files) }),
                        renderUtils_1.renderIf(this.newPage.image.length > 0, window.__CTRender(components_1.CTButton, { type: "primary", icon: Models_1.Icons.FONTAWESOME.TrashCan, iconColor: "#fff", onClick: () => this.deleteAttachment(AttachmentType.Image) })),
                        this._renderImageAttachments()))));
    }
    _renderAudioAttachments() {
        return this.newPage.audio.map(x => window.__CTRender("audio", { controls: true },
            window.__CTRender("source", { src: x, type: "audio/mpeg" })));
    }
    _renderImageAttachments() {
        return this.newPage.image.map(x => window.__CTRender("img", { src: x, width: 150 }));
    }
}
__decorate([
    base_1.prop({ type: Boolean, attribute: true, default: false })
], CTPGRaiseNewPage.prototype, "showing", void 0);
__decorate([
    base_1.prop({ type: Boolean, attribute: true, default: false })
], CTPGRaiseNewPage.prototype, "isValidated", void 0);
__decorate([
    base_1.prop({ type: Boolean, attribute: true, default: false })
], CTPGRaiseNewPage.prototype, "isWaiting", void 0);
__decorate([
    base_1.prop({ type: Boolean, attribute: false, default: false })
], CTPGRaiseNewPage.prototype, "contactSelectionShowing", void 0);
__decorate([
    base_1.prop({ type: Array, attribute: false, default: [] })
], CTPGRaiseNewPage.prototype, "selectedContacts", void 0);
__decorate([
    base_1.prop({ type: String, attribute: false })
], CTPGRaiseNewPage.prototype, "connectivityStatus", void 0);
exports.CTPGRaiseNewPage = CTPGRaiseNewPage;
CTPGRaiseNewPage.register();


/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const base_1 = __webpack_require__(0);
const models_1 = __webpack_require__(2);
const Models_1 = __webpack_require__(7);
const Events_1 = __webpack_require__(6);
const utils_1 = __webpack_require__(3);
const renderUtils_1 = __webpack_require__(4);
const components_1 = __webpack_require__(1);
class CTPGReadOnlyClient extends base_1.CTLayerComponent {
    constructor() {
        super(...arguments);
        this.close = () => {
            this.showing = false;
            if (this.page.audio.length > 0) {
                const audio = this.shadowRoot.querySelector("ct-audio");
                audio.pause();
            }
            this.page = null;
        };
        this.viewImage = (e) => {
            const img = e.target;
            utils_1.displayImage(img.src).catch(e => this.emitEvent(Events_1.PagerEvents._Request_RaiseAlert, models_1.DefaultAlerts.AlertErrorWithOkayButton("Error", "Could not open image file.", 1, {})));
        };
        this._attachmentLoadedCount = 0;
    }
    static get is() {
        return "ct-pg-read-only-client";
    }
    initialize() {
        return __awaiter(this, void 0, void 0, function* () {
            this._attachmentLoaded = this._attachmentLoaded.bind(this);
        });
    }
    setupListeners() {
        this.addListener(Events_1.PagerEvents._Request_OpenClientReadModal, (page) => __awaiter(this, void 0, void 0, function* () {
            this.page = Object.assign({}, page);
            this.response = this.page.individuals
                .find(x => x.id === this.layer.getCurrentUserJid()).responses
                .find(x => x.type === Models_1.ContactResponseType.Response);
            this.showing = true;
            if (this.page.attachments && !this.page.attachmentsLoaded) {
                this.attachmentsLoading = true;
                yield this.layer.downloadAttachmentsByMessageId(this.page.messageId);
            }
        }));
        this.addListener(Events_1.PagerEvents.PageUpdate, (page) => {
            if (!this.page || !page)
                return;
            if (page._id === this.page._id) {
                this.page = page;
                this.forceRedraw();
            }
        });
    }
    get generateComponentStyles() {
        return `:host{color:#333536;font-weight:400}:host h1,:host h2,:host h3,:host h4,:host h5,:host h6{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}:host,:host *{box-sizing:border-box}.user-html p{margin:0}.user-html p+p{margin:.8em 0 0 0}.user-html strong{font-weight:600}:host{background-color:var(--primary-color, #000);height:100%;width:100%;display:flex;flex-direction:column;transform:translateX(100%);will-change:transform;transition:transform 0.15s linear;visibility:hidden;position:fixed;top:0;z-index:1;overflow:hidden}:host .container{height:100%;width:100%;display:flex;flex-direction:column}:host .container .content{flex:1 1;display:flex;flex-direction:column;background-color:white}:host .container .content .panel{flex:1 1;display:flex;flex-direction:column;overflow:auto}:host .container .content .panel .data{display:flex;flex-direction:row;font-size:18px;padding:10px 20px;flex:0 0 var(--header-height, 60px)}:host .container .content .panel .data.title{background-color:#231f20;color:white;flex:0 0 var(--header-height, 60px);justify-content:flex-start;padding:10px 20px 10px 0}:host .container .content .panel .data.title .name{margin:auto 0}:host .container .content .panel .data.title .colorCircle{width:20px;height:20px;border-radius:50%;margin:auto auto auto 10px}:host .container .content .panel .data.title .time{margin:auto 0 auto auto}@media screen and (max-width: 640px){:host .container .content .panel .data.title .name{font-size:16px}:host .container .content .panel .data.title .time{font-size:12px}}:host .container .content .panel .data.subject{display:flex;flex:0 1 auto;overflow-x:hidden}:host .container .content .panel .data.subject span{margin:auto 0}:host .container .content .panel .data ct-icon{margin-right:10px}:host .container .content .panel .data.severity .time{margin:0 0 0 auto;font-weight:300}:host .container .content .panel .message{padding:10px 20px;overflow:auto;-webkit-overflow-scrolling:touch;flex:1 1}:host .container .content .panel .message span{display:block;margin-bottom:15px}:host .container .content .panel .message ct-audio,:host .container .content .panel .message ct-img{width:100%;margin:10px 0}:host .container .content .panel .message p{font-size:18px;line-height:28px}:host .container .content .panel .replyContainer{margin:auto 0 40px;padding:0 20px}:host .container .content .panel .replyContainer h4{text-align:center;font-weight:400;color:#646566;margin-bottom:10px}:host .container .content .panel .replyContainer .replyPill{display:flex;justify-content:center;background-color:#646566;color:white;padding:5px 20px;border-radius:20px;font-weight:300;max-width:70%;margin:0 auto;text-align:center}:host([showing]){visibility:visible;transform:translateX(0)}:host .container{background-color:var(--default-bg-color);color:var(--default-font-color)}:host .container .content .panel{background-color:var(--default-bg-color)}:host .container .content .panel .data.subject{background-color:var(--default-bg-color);border-bottom:1px solid var(--default-border-color)}:host .container .content .panel .message{background-color:var(--default-bg-color)}:host .container .content .panel .replyContainer{background-color:var(--default-bg-color)}:host .container .content .panel .replyContainer h4{color:var(--default-font-color-light)}
        `;
    }
    generateComponentMarkup() {
        if (!this.page)
            return null;
        return (window.__CTRender("div", { className: "container" },
            window.__CTRender("div", { className: "content" },
                window.__CTRender("div", { className: "panel" },
                    window.__CTRender("div", { className: "data title" },
                        window.__CTRender(components_1.CTButton, { type: "transparent", icon: Models_1.Icons.FONTAWESOME.ChevonLeft, iconColor: "#fff", onClick: this.close }),
                        window.__CTRender("div", { className: "name" }, this.page.pageType.name),
                        window.__CTRender("div", { className: "colorCircle", style: renderUtils_1.buildStyles({ backgroundColor: this.page.pageType.colorCode }) }),
                        window.__CTRender("div", { className: "time" }, utils_1.formatDateForTimeOrDate(this.page.openedDate, false, this.layer.config.xmpp.showSecondsOnTimestamps))),
                    this.page.subject
                        ?
                            window.__CTRender("div", { className: "data subject" },
                                window.__CTRender("span", null, this.page.subject))
                        : null,
                    window.__CTRender("div", { className: "message" },
                        this._renderPageMessage(),
                        this._renderAttachments()),
                    this._generateResponseDisplay()))));
    }
    _renderPageMessage() {
        if (this.page.messageSplit && this.page.messageSplit.length) {
            const container = [];
            this.page.messageSplit.forEach(x => {
                container.push(window.__CTRender("p", null, x));
            });
            return (window.__CTRender("div", null, container));
        }
        else {
            return (window.__CTRender("span", null, this.page.message));
        }
    }
    _attachmentLoaded() {
        if (++this._attachmentLoadedCount >= (this.page.audio.length + this.page.image.length)) {
            this.attachmentsLoading = false;
        }
    }
    _renderAttachments() {
        return (window.__CTRender("div", null,
            renderUtils_1.renderIf(this.attachmentsLoading, window.__CTRender(components_1.CTIcon, { width: 20, height: 20, icon: Models_1.Icons.FONTAWESOME.CircleNotch, spin: true })),
            renderUtils_1.renderIf(this.page.audio.length > 0 && this.page.attachmentsLoaded, window.__CTRender(components_1.CTAudio, { src: this.page.audio[0], onLoad: this._attachmentLoaded })),
            renderUtils_1.renderIf(this.page.image.length > 0 && this.page.attachmentsLoaded, window.__CTRender(components_1.CTImg, { onclick: this.viewImage, src: this.page.image[0], onLoad: this._attachmentLoaded }))));
    }
    _generateResponseDisplay() {
        if (this.response) {
            return (window.__CTRender("div", { className: "replyContainer" },
                window.__CTRender("h4", null,
                    "You replied at ",
                    utils_1.formatDateForTimeOrDate(this.response.ts, false, this.layer.config.xmpp.showSecondsOnTimestamps)),
                window.__CTRender("div", { className: "replyPill" },
                    window.__CTRender("span", null, this.response.content))));
        }
        else
            return null;
    }
}
__decorate([
    base_1.prop({ type: Boolean, attribute: true, default: false })
], CTPGReadOnlyClient.prototype, "showing", void 0);
__decorate([
    base_1.prop({ type: Object, attribute: false, default: null })
], CTPGReadOnlyClient.prototype, "page", void 0);
__decorate([
    base_1.prop({ type: Boolean, attribute: false, default: false })
], CTPGReadOnlyClient.prototype, "attachmentsLoading", void 0);
exports.CTPGReadOnlyClient = CTPGReadOnlyClient;
CTPGReadOnlyClient.register();


/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const base_1 = __webpack_require__(0);
const Models_1 = __webpack_require__(7);
const Events_1 = __webpack_require__(6);
const utils_1 = __webpack_require__(3);
const renderUtils_1 = __webpack_require__(4);
const pagerUtils_1 = __webpack_require__(9);
const components_1 = __webpack_require__(1);
var ReadViewOptions;
(function (ReadViewOptions) {
    // tslint:disable no-any
    ReadViewOptions[ReadViewOptions["Replies"] = "replies"] = "Replies";
    ReadViewOptions[ReadViewOptions["MessageContent"] = "message-content"] = "MessageContent";
    // tslint:enable no-any
})(ReadViewOptions || (ReadViewOptions = {}));
class CTPGReadOnlyPage extends base_1.CTLayerComponent {
    constructor() {
        super(...arguments);
        this.viewOption = ReadViewOptions.Replies;
    }
    static get is() {
        return "ct-pg-read-only-page";
    }
    // === End properties === //
    initialize() {
        return __awaiter(this, void 0, void 0, function* () { });
    }
    setupListeners() {
        this.addListener(Events_1.PagerEvents._Request_OpenBroadcasterReadModal, (page) => {
            this.page = Object.assign({}, page);
            if (this.page.attachmentsLoaded === false) {
                this.layer.downloadAttachmentsByMessageId(this.page.messageId);
            }
            this.viewOption = ReadViewOptions.Replies;
            this.showing = true;
        });
        this.addListener(Events_1.PagerEvents.PageUpdate, (page) => __awaiter(this, void 0, void 0, function* () {
            if (!this.page || !page)
                return;
            if (page._id === this.page._id) {
                this.page = page;
                this.forceRedraw();
            }
        }));
    }
    close() {
        this.showing = false;
    }
    viewOptionBtnClick(option) {
        this.viewOption = option;
    }
    get generateComponentStyles() {
        return `:host{color:#333536;font-weight:400}:host h1,:host h2,:host h3,:host h4,:host h5,:host h6{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}:host,:host *{box-sizing:border-box}.user-html p{margin:0}.user-html p+p{margin:.8em 0 0 0}.user-html strong{font-weight:600}:host{width:100%;height:100%;display:flex;background-color:rgba(0,0,0,0.6);opacity:0;visibility:hidden;position:fixed;z-index:1}:host .container{display:flex;flex-direction:column;margin:auto;width:95vw;height:95vh;min-width:500px;will-change:transform;transition:transform 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);visibility:hidden}:host .container .title{display:flex;justify-content:space-between;align-items:center;flex:0 0 var(--header-height, 60px);padding:10px 0 10px 20px}@media screen and (max-width: 640px){:host .container .title{justify-content:flex-end}:host .container .title ct-online-indicator{display:none}:host .container .title .tabs{width:80%}}:host .container .title .tabs{position:absolute;display:flex;align-items:flex-end;top:0;left:50%;height:59px;transform:translateX(-50%)}:host .container .title h2{position:absolute;left:50%;top:0;transform:translateX(-50%)}:host .container .content{overflow:auto;display:flex;flex-direction:column;padding:20px}:host .container .content div.row{display:flex;justify-content:flex-start;padding:15px 0;min-height:62px;overflow:auto}:host .container .content div.row.header{min-height:30px;padding:5px 0;font-size:12px}:host .container .content div.row div{margin:auto 0}:host .container .content div.row .user{flex-basis:40%}:host .container .content div.row .received{flex-basis:20%}:host .container .content div.row .reply{flex-basis:35%}:host .container .content div.row .label{flex-basis:15%}@media screen and (max-width: 640px){:host .container .content div.row .label{flex-basis:50%}}:host .container .content div.row .value{flex-basis:70%}@media screen and (max-width: 640px){:host .container .content div.row .value{flex-basis:50%}}:host .container .content div.row .responsePill{display:flex;justify-content:space-between;padding:5px 20px;border-radius:20px;font-weight:300}@media screen and (max-width: 640px){:host .container{width:100%;height:100%;min-width:100%;max-height:100%}}:host([showing]){visibility:visible;transition:opacity 0.25s ease-in;opacity:1}:host([showing]) div.container{visibility:visible}:host .container{background-color:var(--default-bg-color);color:var(--default-font-color)}:host .container .title{background-color:var(--primary-color, #15233B);color:var(--primary-font-color, #fff)}:host .container .content{background-color:var(--default-bg-color)}:host .container .content div.row{border-bottom:1px solid var(--default-border-color)}:host .container .content div.row.header,:host .container .content div.row .label{color:var(--default-font-color-light)}:host .container .content div.row .responsePill{background-color:#646566;color:white}
        `;
    }
    generateComponentMarkup() {
        if (Object.keys(this.page).length === 0)
            return null;
        return (window.__CTRender("div", { className: `container` },
            window.__CTRender("div", { className: "title" }, this._renderTitle()),
            window.__CTRender("div", { class: "content" }, this._renderBody())));
    }
    _renderTitle() {
        return [
            window.__CTRender(components_1.CTOnlineIndicator, null),
            window.__CTRender("div", { className: "tabs" },
                window.__CTRender(components_1.CTButton, { type: "primary", selected: this.viewOption === ReadViewOptions.Replies, onClick: () => this.viewOptionBtnClick(ReadViewOptions.Replies) }, "Replies"),
                window.__CTRender(components_1.CTButton, { type: "primary", selected: this.viewOption === ReadViewOptions.MessageContent, onClick: () => this.viewOptionBtnClick(ReadViewOptions.MessageContent) }, "Message Content")),
            window.__CTRender(components_1.CTButton, { type: "transparent", icon: Models_1.Icons.FONTAWESOME.Cross, iconColor: "#fff", onClick: () => this.close() })
        ];
    }
    _renderBody() {
        return renderUtils_1.renderIfElse(this.viewOption === ReadViewOptions.Replies, window.__CTRender("div", null, this._renderReplies()), window.__CTRender("div", null, this._renderReadOnlyMessage()));
    }
    _renderReplies() {
        const elements = [];
        elements.push(window.__CTRender("div", { className: "row header" },
            window.__CTRender("div", { className: "user" },
                window.__CTRender("span", null, "User")),
            window.__CTRender("div", { className: "received" },
                window.__CTRender("span", null, "Received")),
            window.__CTRender("div", { className: "reply" },
                window.__CTRender("span", null, "Reply"))));
        this.page.individuals.map((item) => {
            const received = pagerUtils_1.getResponse(item, Models_1.ContactResponseType.Received);
            const response = pagerUtils_1.getResponse(item, Models_1.ContactResponseType.Response);
            elements.push(window.__CTRender("div", { className: "row" },
                window.__CTRender("div", { className: "user" },
                    window.__CTRender("span", null, pagerUtils_1.getNameFromContact(item))),
                window.__CTRender("div", { className: "received" },
                    window.__CTRender("span", null, received !== null ? utils_1.formatDateForTimeOrDate(new Date(received.ts), false, this.layer.config.xmpp.showSecondsOnTimestamps) : "")),
                window.__CTRender("div", { className: "reply" }, response
                    ?
                        window.__CTRender("div", { className: "responsePill" },
                            window.__CTRender("span", null, response.content),
                            window.__CTRender("span", null, utils_1.formatDateForTimeOrDate(new Date(response.ts), false, this.layer.config.xmpp.showSecondsOnTimestamps)))
                    :
                        null)));
        });
        return elements;
    }
    _renderReadOnlyMessage() {
        const elems = [
            window.__CTRender("div", { className: "row" },
                window.__CTRender("div", { className: "label" }, "Sent:"),
                window.__CTRender("div", { className: "value" }, utils_1.formatDateForTimeOrDate(new Date(this.page.openedDate), false, this.layer.config.xmpp.showSecondsOnTimestamps))),
            window.__CTRender("div", { className: "row" },
                window.__CTRender("div", { className: "label" }, "Type:"),
                window.__CTRender("div", { className: "value" }, this.page.pageType.name)),
            window.__CTRender("div", { className: "row" },
                window.__CTRender("div", { className: "label" }, "Reply Template:"),
                window.__CTRender("div", { className: "value" }, this.page.replyTemplate ? this.page.replyTemplate.name : "Not Found")),
            window.__CTRender("div", { className: "row" },
                window.__CTRender("div", { className: "label" }, "Subject:"),
                window.__CTRender("div", { className: "value" }, this.page.subject)),
            window.__CTRender("div", { className: "row" },
                window.__CTRender("div", { className: "label" }, "Message:"),
                window.__CTRender("div", { className: "value" }, this._renderPageContent()))
        ];
        if (this.layer.audioAttachmentsEnabled()) {
            elems.push(window.__CTRender("div", { className: "row" },
                window.__CTRender("div", { className: "label" }, "Audio:"),
                window.__CTRender("div", { className: "value" }, this._renderAudioAttachments())));
        }
        if (this.layer.photoAttachmentsEnabled()) {
            elems.push(window.__CTRender("div", { className: "row" },
                window.__CTRender("div", { className: "label" }, "Image:"),
                window.__CTRender("div", { className: "value" }, this._renderImageAttachments())));
        }
        return elems;
    }
    _renderPageContent() {
        const messageLines = pagerUtils_1.parseMessageContent(this.page.message);
        if (messageLines.length) {
            const container = [];
            messageLines.forEach(x => {
                container.push(window.__CTRender("p", null, x));
            });
            return (window.__CTRender("div", null, container));
        }
        else {
            return (window.__CTRender("span", null, this.page.message));
        }
    }
    _renderAudioAttachments() {
        if (this.page.audio.length === 0) {
            return [window.__CTRender("span", null, "No audio attached")];
        }
        if (this.page.attachmentsLoaded !== true) {
            return [window.__CTRender("div", null, "Loading...")];
        }
        return this.page.audio.map(x => window.__CTRender("audio", { controls: true },
            window.__CTRender("source", { src: x, type: "audio/mpeg" })));
    }
    _renderImageAttachments() {
        if (this.page.image.length === 0) {
            return [window.__CTRender("span", null, "No image attached")];
        }
        if (this.page.attachmentsLoaded !== true) {
            return [window.__CTRender("div", null, "Loading...")];
        }
        return this.page.image.map(x => window.__CTRender("img", { src: x, width: 150 }));
    }
}
__decorate([
    base_1.prop({ type: Boolean, attribute: true, default: false })
], CTPGReadOnlyPage.prototype, "showing", void 0);
__decorate([
    base_1.prop({ type: Object, attribute: false })
], CTPGReadOnlyPage.prototype, "page", void 0);
__decorate([
    base_1.prop({ type: String, attribute: false })
], CTPGReadOnlyPage.prototype, "viewOption", void 0);
exports.CTPGReadOnlyPage = CTPGReadOnlyPage;
CTPGReadOnlyPage.register();


/***/ }),
/* 36 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["default"] = workerFunction;
function workerFunction() {

    // The crypto library, null if using pure JS implementation
    let subtle = null;
    let _initialised = false;
    let _idx = null;
    let _db = null;
    let _dbName = null;
    let _idxKey = "lunr_index";
    let _idxBlock = "idxBlock";
    let _docBlock = "docBlock";
    const elasticlunr = createLunr();
    let _key = null;
    let _iv = null;
    let _blockSize = 2000;
    let _debug = true;

    function utoa(str) {
        return btoa(unescape(encodeURIComponent(str)));
    }

    // DB row for whether using pure JS
    let _usePureJs = "pureJs";

    self.onmessage = function (e) {

        switch (e.data.action) {
            case "initialise":

                const _initSuccess = () => {
                    _initialised = true;
                    self.postMessage({
                        _id: e.data._id,
                        action: "initialisation-complete",
                        success: true,
                        msg: "Successfully initialised the user index."
                    });
                };

                const _initFail = (msg) => {
                    self.postMessage({
                        _id: e.data._id,
                        action: "initialisation-complete",
                        success: false,
                        msg: msg
                    });
                };

                if (!e.data.instanceId) {
                    _initFail("Error initialising user index database.");
                    return;
                }

                _debug = (e.data.debug === true);

                _dbName = `${e.data.instanceId}_user_index`;
                const openRequest = indexedDB.open(_dbName);
                this._blockSize = e.data.blockSize || this._blockSize;
                var that = this;

                openRequest.onupgradeneeded = function (event) {
                    event.target.result.createObjectStore(_dbName);
                };

                openRequest.onerror = function () {
                    _initFail("Failed opening database.");
                };

                openRequest.onsuccess = function (event) {

                    _db = event.target.result;

                    // Should we use pure JS implementation?
                    useOldCrypto()
                        .then(old => {
                        if (old) {
                            aes();
                            that.subtle = null;
                        } else {
                            that.subtle = self.crypto.subtle;
                        }

                        importKey(e.data.key)
                            .then(key => {
                            that._key = key;
                            that._iv = e.data.iv;

                            retrieveIndex().then(data => {
                                if (data) {
                                    _idx = elasticlunr.Index.load(data);
                                }
                                _initSuccess();
                            }).catch(e => {
                                _initFail("Failed reading database for previously stored index.");
                            });
                        }).catch(e => {
                            _initFail("Failed importing key for previously stored index.");
                        });
                    }).catch(e => {
                        _initFail("Failed detecting crypto type for previously stored index");
                    });
                };
                break;
            case "fetch":
                // Make sure we've initialised
                if (_initialised === false) {
                    self.postMessage({
                        _id: e.data._id,
                        success: false,
                        action: "index-complete",
                        msg: "Initialisation must be completed before the 'fetch' action can take place."
                    });
                    return;
                }

                const fetchStart = Date.now();
                fetch(e.data.endpoint, {
                    method: "GET",
                    headers: {
                        "Authorization": "Basic " + utoa(`${e.data.jid}:${e.data.pass}`)
                    }
                }).then(response => {
                    return response.json();
                }).then(results => {
                    const data = {
                        added: results.added || [],
                        updated: results.updated || [],
                        removed: results.removed || []
                    };
                    if (results.full !== undefined) {
                        // If we've been given a "full" data set then we need to trash anything we previously new about and start again to ensure everything stays in sync
                        _idx = null;
                        // Then we shift the objects on the "full" property on to the added property
                        data.added = results.full;
                    }
                    const downloadTime = Date.now() - fetchStart;
                    const info = [`Downloaded '${data.added.length}' additions, '${data.updated.length}' updates and '${data.removed.length}' deletions in ${downloadTime}ms`];
                    if (_idx === null) {

                        _idx = elasticlunr(function () {
                            this.setRef("jid");
                            this.addField("jid");
                            this.addField("firstName");
                            this.addField("lastName");
                            this.addField("jobTitle");
                            this.addField("telephone");
                            this.addField("group");
                            this.saveDocument(true);
                        });
                        info.push(`Created a fresh index`);
                    }

                    if (data.added.length > 0) {
                        data.added.forEach(user => _idx.addDoc(user));
                        info.push(`Added '${data.added.length}' users to index`);
                    }
                    if (data.updated.length > 0) {
                        data.updated.forEach(user => _idx.updateDoc(user));
                        info.push(`Updated '${data.updated.length}' users in index`);
                    }
                    if (data.removed.length > 0) {
                        data.removed.forEach(user => _idx.removeDoc(user));
                        info.push(`Removed '${data.removed.length}' users from index`);
                    }

                    saveIndex(_blockSize).then(() => {
                        self.postMessage({
                            _id: e.data._id,
                            success: true,
                            action: "index-complete",
                            hash: results.hash || null,
                            msg: `${info.join(", ")} | Completed in ${Date.now() - fetchStart}ms.`
                        });
                    }).catch(err => {
                        self.postMessage({
                            _id: e.data._id,
                            success: false,
                            action: "index-complete",
                            msg: "Couldn't persist updated index."
                        });
                    });

                }).catch(err => {
                    const msg = `Unable to download user directory from location '${e.data.endpoint}'`;
                    console.error(msg, err);
                    self.postMessage({
                        _id: e.data._id,
                        success: false,
                        action: "index-complete",
                        msg: msg
                    });
                });

                break;
            case "search":

                // Remove all the stop words, we are searching users here so we will want to search for "and" for example
                elasticlunr.clearStopWords();

                // Make sure we've initialised
                if (_initialised === false) {
                    self.postMessage({
                        _id: e.data._id,
                        success: false,
                        action: "search-complete",
                        msg: "Initialisation must be completed before the 'search' action can take place."
                    });
                    return;
                }

                // Make sure we have an index to search
                if (_idx === null) {
                    self.postMessage({
                        _id: e.data._id,
                        success: false,
                        action: "search-complete",
                        msg: "There is no index to be searched, have you updated the index yet?"
                    });
                    return;
                }

                const searchStart = Date.now();
                let results = null;

                if (Array.isArray(e.data.fields) && e.data.fields.length > 0) {
                    const config = {
                        fields: {},
                        bool: "OR",
                        expand: true
                    };
                    e.data.fields.forEach(field => {
                        config.fields[field] = {};
                    });
                    results = _idx.search(e.data.query, config);
                } else {
                    results = _idx.search(e.data.query, {
                        expand: true
                    });
                }

                const data = results.map(res => {
                    return res.doc;
                });
                self.postMessage({
                    _id: e.data._id,
                    success: true,
                    action: "search-complete",
                    msg: `Found ${data.length} users in ${Date.now() - searchStart}ms.`,
                    results: data
                });

                break;
            case "jid-search":

                // Make sure we've initialised
                if (_initialised === false) {
                    self.postMessage({
                        _id: e.data._id,
                        success: false,
                        action: "jid-search-complete",
                        msg: "Initialisation must be completed before the 'jid-search' action can take place."
                    });
                    return;
                }

                // Make sure we have an index to search
                if (_idx === null) {
                    self.postMessage({
                        _id: e.data._id,
                        success: false,
                        action: "jid-search-complete",
                        msg: "There is no index to be searched, have you updated the index yet?"
                    });
                    return;
                }
                const jidSearchStart = Date.now();
                const result = _idx.search(e.data.jid, {
                    expand: true
                })[0];
                const user = (result !== undefined) ? result.doc : null;
                self.postMessage({
                    _id: e.data._id,
                    success: true,
                    action: "jid-search-complete",
                    msg: (user !== null) ? `Found user with JID '${e.data.jid}' in ${Date.now() - jidSearchStart}ms.` : `No user with JID '${e.data.jid}' could be found.`,
                    result: user
                });

                break;

            case "get-all-users":

                // Make sure we've initialised
                if (_initialised === false) {
                    self.postMessage({
                        _id: e.data._id,
                        success: false,
                        action: "get-all-users-complete",
                        msg: "Initialisation must be completed before the 'get-all-users' action can take place."
                    });
                    return;
                }

                // Make sure we have an index to search
                if (_idx === null) {
                    self.postMessage({
                        _id: e.data._id,
                        success: false,
                        action: "get-all-users-complete",
                        msg: "There is no index available, have you updated the index yet?"
                    });
                    return;
                }

                const getAllUsersStart = Date.now();
                const users = [];
                for (let jid in _idx.documentStore.docs) {
                    users.push(_idx.documentStore.docs[jid])
                }

                self.postMessage({
                    _id: e.data._id,
                    success: true,
                    action: "get-all-users-complete",
                    msg: `Fetched '${users.length}' users in ${Date.now() - getAllUsersStart}ms.`,
                    results: users
                });

                break;

            case "destroy":

                if (_db !== null) {

                    // First close the database so a delete isn't blocked
                    _db.close();
                    const deleteRequest = indexedDB.deleteDatabase(_dbName);

                    deleteRequest.onerror = function (event) {
                        self.postMessage({
                            _id: e.data._id,
                            success: false,
                            action: "destroy-complete",
                            msg: "Error deleting user directory database."
                        });
                    };

                    deleteRequest.onsuccess = function () {
                        // Reset the global private vars
                        _initialised = false;
                        _idx = null;
                        _db = null;
                        _dbName = null;
                        self.postMessage({
                            _id: e.data._id,
                            success: true,
                            action: "destroy-complete",
                            msg: null
                        });
                        self.close();
                    };

                    deleteRequest.onblocked = function () {
                        self.postMessage({
                            _id: e.data._id,
                            success: false,
                            action: "destroy-complete",
                            msg: "Couldn't delete user directory database due to the operation being blocked."
                        });
                    };

                } else {

                    self.postMessage({
                        _id: e.data._id,
                        success: true,
                        action: "destroy-complete",
                        msg: "Database not yet initialised, so nothing to destroy."
                    });
                    self.close();
                }

                break;
            default:
                self.postMessage({
                    _id: e.data._id,
                    success: true,
                    msg: `Invalid action '${e.data.action}' was specified.`
                });
        }

        function encryptRecord(user) {
            return new Promise( (resolve, reject) => {
                textToByteArray(JSON.stringify(user)).then(buf => {
                    if(this.subtle) {
                        this.subtle.encrypt({
                            name: "AES-CBC",
                            iv: this._iv
                        }, this._key, buf).then(encrypted => {
                            resolve(encrypted);
                        }).catch(reject);
                    } else {
                        const aes = new aesjs.ModeOfOperation.ctr(this._key);
                        const encrypted = aes.encrypt(buf);
                        resolve(encrypted);
                    }
                }).catch(reject);
            });
        }

        function decryptRecord(encrypted) {
            return new Promise((resolve, reject) => {
                if(this.subtle) {
                    this.subtle.decrypt(
                        {
                            name: "AES-CBC",
                            iv: this._iv
                        },
                        this._key,
                        encrypted
                    ).then(decrypted => {
                        const charArray = new Uint8Array(decrypted);
                        byteArrayToText(charArray).then(str => {
                            resolve(JSON.parse(str));
                        }).catch(reject);
                    }).catch(reject);
                } else {
                    const aes = new aesjs.ModeOfOperation.ctr(this._key);
                    const charArray = aes.decrypt(encrypted);
                    byteArrayToText(charArray).then(str => {
                        resolve(JSON.parse(str));
                    }).catch(reject);
                }
            });
        }

        function storeRecord(key, data) {
            return new Promise((resolve, reject) => {
                const transaction = _db.transaction([_dbName], "readwrite");
                transaction.oncomplete = function() {
                    resolve();
                };
                transaction.onerror = function(e) {
                    reject(e);
                };
                const store = transaction.objectStore(_dbName);
                store.put(data, key);
            });
        }

        function retrieveRecord(key) {
            return new Promise((resolve, reject) => {
                const store = _db.transaction([_dbName]).objectStore(_dbName);
                const getRequest = store.get(key);
                getRequest.onsuccess = function () {
                    const data = getRequest.result;
                    resolve(data);
                };
                getRequest.onerror = function(e) {
                    reject(e);
                }
            });
        }

        function saveIndex(blocksize = 1000) {
            if (_debug) console.time("encrypt");
            return new Promise((resolve, reject) => {
                let blocks = 0;
                let chunks = 0;
                const index = _idx.toJSON();
                const copy = JSON.parse(JSON.stringify(index));
                const docKeys = Object.keys(copy.documentStore.docs);
                const idxKeys = Object.keys(copy.index);

                function cycle() {
                    if (docKeys.length === 0) {
                        if (_debug) console.timeEnd("encrypt");
                        if (_debug) console.time("index");

                        copy.documentStore.docs = {};
                        if (_debug) console.time("index2");
                        cycle2();
                    } else {
                        const props = docKeys.splice(0, blocksize);
                        const temp = {};
                        props.forEach(prop => {
                            const entry = index.documentStore.docs[prop];
                            temp[prop] = entry;
                        });
                        if (_debug) console.time("block")
                        encryptRecord(temp).then(encrypted => {
                            storeRecord(_docBlock + blocks++, encrypted).then(() => {
                                if (_debug) console.timeEnd("block");
                                cycle();
                            }).catch(reject);
                        }).catch(reject);
                    }
                }

                function cycle2() {
                    if (idxKeys.length === 0) {;

                        copy.index = {};
                        encryptRecord(copy).then(encrypted => {
                            if (_debug) console.timeEnd("index2");
                            storeRecord(_idxKey, encrypted).then(resolve).catch(reject);
                        });
                    } else {
                        const prop = idxKeys.shift();
                        if (_debug) console.time("chunk")
                        encryptRecord({"prop": prop, "data": copy.index[prop]}).then(encrypted => {
                            storeRecord(_idxBlock + chunks++, encrypted).then(() => {
                                if (_debug) console.timeEnd("chunk");
                                cycle2();
                            });
                        });
                    }
                }

                cycle();
            });
        }

        function retrieveIndex() {
            return new Promise((resolve, reject) => {
                let index = null;
                let block = 0;
                let chunk = 0;

                // Get the main block of index
                retrieveRecord(_idxKey).then(encrypted => {
                    if(!encrypted) {
                        // There wasn't one, must be first time
                        return resolve(index);
                    }
                    decryptRecord(encrypted).then(idx => {
                        index = idx;
                        cycle();
                    }).catch(reject);
                }).catch(reject);

                // Cycle through blocks of index, decrypting each until there are no more
                function cycle() {
                    retrieveRecord(_docBlock + block).then(data => {
                        if (!data) {
                            return cycle2();
                        } else {
                            decryptRecord(data).then(parent => {
                                index.documentStore.docs = Object.assign(index.documentStore.docs, parent);
                                block++;
                                cycle();
                            }).catch(reject);
                        }
                    }).catch(reject);
                }

                function cycle2() {
                    retrieveRecord(_idxBlock + chunk).then(data => {
                        if (!data) {
                            return resolve(index);
                        } else {
                            decryptRecord(data).then(parent => {
                                index.index[parent.prop] = parent.data;
                                chunk++;
                                cycle2();
                            }).catch(reject);
                        }
                    }).catch(reject);
                }
            });
        }

        // Detect and store whether using pure JS AES
        function useOldCrypto() {
            return new Promise((resolve, reject) => {
                retrieveRecord(_usePureJs).then(old => {
                    if(old === undefined) {
                        const newOld = self.crypto.subtle === undefined;
                        storeRecord(_usePureJs, newOld).then(() => {
                            resolve(newOld);
                        });
                    } else {
                        resolve(old);
                    }
                });
            });
        }

        function textToByteArray(text) {
            return new Promise( (resolve, reject) => {
                let blob = new Blob([text], { type: "text/plain" });
                let reader = new FileReader();

                reader.onload = event => {
                    resolve(new Uint8Array(event.target.result));
                };
                reader.readAsArrayBuffer(blob);
            });
        }

        function byteArrayToText(bytes, encoding) {
            return new Promise((resolve, reject) => {
                let blob = new Blob([bytes], { type: "application/octet-stream" });
                let reader = new FileReader();

                reader.onload = event => {
                    resolve(event.target.result);
                };

                if(encoding) { reader.readAsText(blob, encoding); } else { reader.readAsText(blob); }
            });
        }

        function importKey(key) {
            return new Promise((resolve, reject) => {
                if(this.subtle) {
                    this.subtle.importKey("raw", key, {name: "AES-CBC"}, false, ["encrypt", "decrypt"]).then(outKey => {
                        resolve(outKey);
                    });
                } else {
                    resolve(key);
                }
            });
        }

    };

    function createLunr () {

        var elasticlunr = function(config) {
            var idx = new elasticlunr.Index;

            idx.pipeline.add(
                elasticlunr.trimmer,
                elasticlunr.stopWordFilter,
                elasticlunr.stemmer
            );

            if (config) config.call(idx, idx);

            return idx;
        };

        elasticlunr.version = "0.9.5";

        lunr = elasticlunr;

        elasticlunr.utils = {};

        elasticlunr.utils.warn = (function(global) {
            return function(message) {
                if (global.console && console.warn) {
                    console.warn(message);
                }
            };
        })(this);

        elasticlunr.utils.toString = function(obj) {
            if (obj === void 0 || obj === null) {
                return "";
            }

            return obj.toString();
        };

        elasticlunr.EventEmitter = function() {
            this.events = {};
        };

        elasticlunr.EventEmitter.prototype.addListener = function() {
            var args = Array.prototype.slice.call(arguments),
                fn = args.pop(),
                names = args;

            if (typeof fn !== "function") throw new TypeError("last argument must be a function");

            names.forEach(function(name) {
                if (!this.hasHandler(name)) this.events[name] = [];
                this.events[name].push(fn);
            }, this);
        };

        elasticlunr.EventEmitter.prototype.removeListener = function(name, fn) {
            if (!this.hasHandler(name)) return;

            var fnIndex = this.events[name].indexOf(fn);
            if (fnIndex === -1) return;

            this.events[name].splice(fnIndex, 1);

            if (this.events[name].length == 0) delete this.events[name];
        };

        elasticlunr.EventEmitter.prototype.emit = function(name) {
            if (!this.hasHandler(name)) return;

            var args = Array.prototype.slice.call(arguments, 1);

            this.events[name].forEach(function(fn) {
                fn.apply(undefined, args);
            }, this);
        };

        elasticlunr.EventEmitter.prototype.hasHandler = function(name) {
            return name in this.events;
        };

        elasticlunr.tokenizer = function(str) {
            if (!arguments.length || str === null || str === undefined) return [];
            if (Array.isArray(str)) {
                var arr = str.filter(function(token) {
                    if (token === null || token === undefined) {
                        return false;
                    }

                    return true;
                });

                arr = arr.map(function(t) {
                    return elasticlunr.utils.toString(t).toLowerCase();
                });

                var out = [];
                arr.forEach(function(item) {
                    var tokens = item.split(elasticlunr.tokenizer.seperator);
                    out = out.concat(tokens);
                }, this);

                return out;
            }

            return str.toString().trim().toLowerCase().split(elasticlunr.tokenizer.seperator);
        };

        elasticlunr.tokenizer.defaultSeperator = /[\s\-]+/;

        elasticlunr.tokenizer.seperator = elasticlunr.tokenizer.defaultSeperator;

        elasticlunr.tokenizer.setSeperator = function(sep) {
            if (sep !== null && sep !== undefined && typeof(sep) === 'object') {
                elasticlunr.tokenizer.seperator = sep;
            }
        }

        elasticlunr.tokenizer.resetSeperator = function() {
            elasticlunr.tokenizer.seperator = elasticlunr.tokenizer.defaultSeperator;
        }

        elasticlunr.tokenizer.getSeperator = function() {
            return elasticlunr.tokenizer.seperator;
        }

        elasticlunr.Pipeline = function() {
            this._queue = [];
        };

        elasticlunr.Pipeline.registeredFunctions = {};

        elasticlunr.Pipeline.registerFunction = function(fn, label) {
            if (label in elasticlunr.Pipeline.registeredFunctions) {
                elasticlunr.utils.warn('Overwriting existing registered function: ' + label);
            }

            fn.label = label;
            elasticlunr.Pipeline.registeredFunctions[label] = fn;
        };

        elasticlunr.Pipeline.getRegisteredFunction = function(label) {
            if ((label in elasticlunr.Pipeline.registeredFunctions) !== true) {
                return null;
            }

            return elasticlunr.Pipeline.registeredFunctions[label];
        };

        elasticlunr.Pipeline.warnIfFunctionNotRegistered = function(fn) {
            var isRegistered = fn.label && (fn.label in this.registeredFunctions);

            if (!isRegistered) {
                elasticlunr.utils.warn('Function is not registered with pipeline. This may cause problems when serialising the index.\n', fn);
            }
        };

        elasticlunr.Pipeline.load = function(serialised) {
            var pipeline = new elasticlunr.Pipeline;

            serialised.forEach(function(fnName) {
                var fn = elasticlunr.Pipeline.getRegisteredFunction(fnName);

                if (fn) {
                    pipeline.add(fn);
                } else {
                    throw new Error('Cannot load un-registered function: ' + fnName);
                }
            });

            return pipeline;
        };

        elasticlunr.Pipeline.prototype.add = function() {
            var fns = Array.prototype.slice.call(arguments);

            fns.forEach(function(fn) {
                elasticlunr.Pipeline.warnIfFunctionNotRegistered(fn);
                this._queue.push(fn);
            }, this);
        };

        elasticlunr.Pipeline.prototype.after = function(existingFn, newFn) {
            elasticlunr.Pipeline.warnIfFunctionNotRegistered(newFn);

            var pos = this._queue.indexOf(existingFn);
            if (pos === -1) {
                throw new Error('Cannot find existingFn');
            }

            this._queue.splice(pos + 1, 0, newFn);
        };

        elasticlunr.Pipeline.prototype.before = function(existingFn, newFn) {
            elasticlunr.Pipeline.warnIfFunctionNotRegistered(newFn);

            var pos = this._queue.indexOf(existingFn);
            if (pos === -1) {
                throw new Error('Cannot find existingFn');
            }

            this._queue.splice(pos, 0, newFn);
        };

        elasticlunr.Pipeline.prototype.remove = function(fn) {
            var pos = this._queue.indexOf(fn);
            if (pos === -1) {
                return;
            }

            this._queue.splice(pos, 1);
        };

        elasticlunr.Pipeline.prototype.run = function(tokens) {
            var out = [],
                tokenLength = tokens.length,
                pipelineLength = this._queue.length;

            for (var i = 0; i < tokenLength; i++) {
                var token = tokens[i];

                for (var j = 0; j < pipelineLength; j++) {
                    token = this._queue[j](token, i, tokens);
                    if (token === void 0 || token === null) break;
                };

                if (token !== void 0 && token !== null) out.push(token);
            };

            return out;
        };

        elasticlunr.Pipeline.prototype.reset = function() {
            this._queue = [];
        };

        elasticlunr.Pipeline.prototype.get = function() {
            return this._queue;
        };

        elasticlunr.Pipeline.prototype.toJSON = function() {
            return this._queue.map(function(fn) {
                elasticlunr.Pipeline.warnIfFunctionNotRegistered(fn);
                return fn.label;
            });
        };

        elasticlunr.Index = function() {
            this._fields = [];
            this._ref = 'id';
            this.pipeline = new elasticlunr.Pipeline;
            this.documentStore = new elasticlunr.DocumentStore;
            this.index = {};
            this.eventEmitter = new elasticlunr.EventEmitter;
            this._idfCache = {};

            this.on('add', 'remove', 'update', (function() {
                this._idfCache = {};
            }).bind(this));
        };

        elasticlunr.Index.prototype.on = function() {
            var args = Array.prototype.slice.call(arguments);
            return this.eventEmitter.addListener.apply(this.eventEmitter, args);
        };

        elasticlunr.Index.prototype.off = function(name, fn) {
            return this.eventEmitter.removeListener(name, fn);
        };

        elasticlunr.Index.load = function(serialisedData) {
            if (serialisedData.version !== elasticlunr.version) {
                elasticlunr.utils.warn('version mismatch: current ' +
                    elasticlunr.version + ' importing ' + serialisedData.version);
            }

            var idx = new this;

            idx._fields = serialisedData.fields;
            idx._ref = serialisedData.ref;
            idx.documentStore = elasticlunr.DocumentStore.load(serialisedData.documentStore);
            idx.pipeline = elasticlunr.Pipeline.load(serialisedData.pipeline);
            idx.index = {};
            for (var field in serialisedData.index) {
                idx.index[field] = elasticlunr.InvertedIndex.load(serialisedData.index[field]);
            }

            return idx;
        };

        elasticlunr.Index.prototype.addField = function(fieldName) {
            this._fields.push(fieldName);
            this.index[fieldName] = new elasticlunr.InvertedIndex;
            return this;
        };

        elasticlunr.Index.prototype.setRef = function(refName) {
            this._ref = refName;
            return this;
        };

        elasticlunr.Index.prototype.saveDocument = function(save) {
            this.documentStore = new elasticlunr.DocumentStore(save);
            return this;
        };

        elasticlunr.Index.prototype.addDoc = function(doc, emitEvent) {
            if (!doc) return;
            var emitEvent = emitEvent === undefined ? true : emitEvent;

            var docRef = doc[this._ref];

            this.documentStore.addDoc(docRef, doc);
            this._fields.forEach(function(field) {
                var fieldTokens = this.pipeline.run(elasticlunr.tokenizer(doc[field]));
                this.documentStore.addFieldLength(docRef, field, fieldTokens.length);

                var tokenCount = {};
                fieldTokens.forEach(function(token) {
                    if (token in tokenCount) tokenCount[token] += 1;
                    else tokenCount[token] = 1;
                }, this);

                for (var token in tokenCount) {
                    var termFrequency = tokenCount[token];
                    termFrequency = Math.sqrt(termFrequency);
                    this.index[field].addToken(token, {
                        ref: docRef,
                        tf: termFrequency
                    });
                }
            }, this);

            if (emitEvent) this.eventEmitter.emit('add', doc, this);
        };

        elasticlunr.Index.prototype.removeDocByRef = function(docRef, emitEvent) {
            if (!docRef) return;
            if (this.documentStore.isDocStored() === false) {
                return;
            }

            if (!this.documentStore.hasDoc(docRef)) return;
            var doc = this.documentStore.getDoc(docRef);
            this.removeDoc(doc, false);
        };

        elasticlunr.Index.prototype.removeDoc = function(doc, emitEvent) {
            if (!doc) return;

            var emitEvent = emitEvent === undefined ? true : emitEvent;

            var docRef = doc[this._ref];
            if (!this.documentStore.hasDoc(docRef)) return;

            this.documentStore.removeDoc(docRef);

            this._fields.forEach(function(field) {
                var fieldTokens = this.pipeline.run(elasticlunr.tokenizer(doc[field]));
                fieldTokens.forEach(function(token) {
                    this.index[field].removeToken(token, docRef);
                }, this);
            }, this);

            if (emitEvent) this.eventEmitter.emit('remove', doc, this);
        };

        elasticlunr.Index.prototype.updateDoc = function(doc, emitEvent) {
            var emitEvent = emitEvent === undefined ? true : emitEvent;

            this.removeDocByRef(doc[this._ref], false);
            this.addDoc(doc, false);

            if (emitEvent) this.eventEmitter.emit('update', doc, this);
        };

        elasticlunr.Index.prototype.idf = function(term, field) {
            var cacheKey = "@" + field + '/' + term;
            if (Object.prototype.hasOwnProperty.call(this._idfCache, cacheKey)) return this._idfCache[cacheKey];

            var df = this.index[field].getDocFreq(term);
            var idf = 1 + Math.log(this.documentStore.length / (df + 1));
            this._idfCache[cacheKey] = idf;

            return idf;
        };

        /**
         * get fields of current index instance
         *
         * @return {Array}
         */
        elasticlunr.Index.prototype.getFields = function() {
            return this._fields.slice();
        };

        /**
         * Searches the index using the passed query.
         * Queries should be a string, multiple words are allowed.
         *
         * If config is null, will search all fields defaultly, and lead to OR based query.
         * If config is specified, will search specified with query time boosting.
         *
         * All query tokens are passed through the same pipeline that document tokens
         * are passed through, so any language processing involved will be run on every
         * query term.
         *
         * Each query term is expanded, so that the term 'he' might be expanded to
         * 'hello' and 'help' if those terms were already included in the index.
         *
         * Matching documents are returned as an array of objects, each object contains
         * the matching document ref, as set for this index, and the similarity score
         * for this document against the query.
         *
         * @param {String} query The query to search the index with.
         * @param {JSON} userConfig The user query config, JSON format.
         * @return {Object}
         * @see Index.prototype.idf
         * @see Index.prototype.documentVector
         * @memberOf Index
         */
        elasticlunr.Index.prototype.search = function(query, userConfig) {
            if (!query) return [];
            if (typeof query === 'string') {
                query = {
                    any: query
                };
            } else {
                query = JSON.parse(JSON.stringify(query));
            }

            var configStr = null;
            if (userConfig != null) {
                configStr = JSON.stringify(userConfig);
            }

            var config = new elasticlunr.Configuration(configStr, this.getFields()).get();

            var queryTokens = {};
            var queryFields = Object.keys(query);

            for (var i = 0; i < queryFields.length; i++) {
                var key = queryFields[i];

                queryTokens[key] = this.pipeline.run(elasticlunr.tokenizer(query[key]));
            }

            var queryResults = {};

            for (var field in config) {
                var tokens = queryTokens[field] || queryTokens.any;
                if (!tokens) {
                    continue;
                }

                var fieldSearchResults = this.fieldSearch(tokens, field, config);
                var fieldBoost = config[field].boost;

                for (var docRef in fieldSearchResults) {
                    fieldSearchResults[docRef] = fieldSearchResults[docRef] * fieldBoost;
                }

                for (var docRef in fieldSearchResults) {
                    if (docRef in queryResults) {
                        queryResults[docRef] += fieldSearchResults[docRef];
                    } else {
                        queryResults[docRef] = fieldSearchResults[docRef];
                    }
                }
            }

            var results = [];
            var result;
            for (var docRef in queryResults) {
                result = {
                    ref: docRef,
                    score: queryResults[docRef]
                };
                if (this.documentStore.hasDoc(docRef)) {
                    result.doc = this.documentStore.getDoc(docRef);
                }
                results.push(result);
            }

            results.sort(function(a, b) {
                return b.score - a.score;
            });
            return results;
        };

        /**
         * search queryTokens in specified field.
         *
         * @param {Array} queryTokens The query tokens to query in this field.
         * @param {String} field Field to query in.
         * @param {elasticlunr.Configuration} config The user query config, JSON format.
         * @return {Object}
         */
        elasticlunr.Index.prototype.fieldSearch = function(queryTokens, fieldName, config) {
            var booleanType = config[fieldName].bool;
            var expand = config[fieldName].expand;
            var boost = config[fieldName].boost;
            var scores = null;
            var docTokens = {};

            // Do nothing if the boost is 0
            if (boost === 0) {
                return;
            }

            queryTokens.forEach(function(token) {
                var tokens = [token];
                if (expand == true) {
                    tokens = this.index[fieldName].expandToken(token);
                }
                // Consider every query token in turn. If expanded, each query token
                // corresponds to a set of tokens, which is all tokens in the
                // index matching the pattern queryToken* .
                // For the set of tokens corresponding to a query token, find and score
                // all matching documents. Store those scores in queryTokenScores,
                // keyed by docRef.
                // Then, depending on the value of booleanType, combine the scores
                // for this query token with previous scores.  If booleanType is OR,
                // then merge the scores by summing into the accumulated total, adding
                // new document scores are required (effectively a union operator).
                // If booleanType is AND, accumulate scores only if the document
                // has previously been scored by another query token (an intersection
                // operation0.
                // Furthermore, since when booleanType is AND, additional
                // query tokens can't add new documents to the result set, use the
                // current document set to limit the processing of each new query
                // token for efficiency (i.e., incremental intersection).

                var queryTokenScores = {};
                tokens.forEach(function(key) {
                    var docs = this.index[fieldName].getDocs(key);
                    var idf = this.idf(key, fieldName);

                    if (scores && booleanType == 'AND') {
                        // special case, we can rule out documents that have been
                        // already been filtered out because they weren't scored
                        // by previous query token passes.
                        var filteredDocs = {};
                        for (var docRef in scores) {
                            if (docRef in docs) {
                                filteredDocs[docRef] = docs[docRef];
                            }
                        }
                        docs = filteredDocs;
                    }
                    // only record appeared token for retrieved documents for the
                    // original token, not for expaned token.
                    // beause for doing coordNorm for a retrieved document, coordNorm only care how many
                    // query token appear in that document.
                    // so expanded token should not be added into docTokens, if added, this will pollute the
                    // coordNorm
                    if (key == token) {
                        this.fieldSearchStats(docTokens, key, docs);
                    }

                    for (var docRef in docs) {
                        var tf = this.index[fieldName].getTermFrequency(key, docRef);
                        var fieldLength = this.documentStore.getFieldLength(docRef, fieldName);
                        var fieldLengthNorm = 1;
                        if (fieldLength != 0) {
                            fieldLengthNorm = 1 / Math.sqrt(fieldLength);
                        }

                        var penality = 1;
                        if (key != token) {
                            penality = (1 - (key.length - token.length) / key.length) * 0.15;
                        }

                        var score = tf * idf * fieldLengthNorm * penality;

                        if (docRef in queryTokenScores) {
                            queryTokenScores[docRef] += score;
                        } else {
                            queryTokenScores[docRef] = score;
                        }
                    }
                }, this);

                scores = this.mergeScores(scores, queryTokenScores, booleanType);
            }, this);

            scores = this.coordNorm(scores, docTokens, queryTokens.length);
            return scores;
        };

        /**
         * Merge the scores from one set of tokens into an accumulated score table.
         * Exact operation depends on the op parameter. If op is 'AND', then only the
         * intersection of the two score lists is retained. Otherwise, the union of
         * the two score lists is returned. For internal use only.
         *
         * @param {Object} bool accumulated scores. Should be null on first call.
         * @param {String} scores new scores to merge into accumScores.
         * @param {Object} op merge operation (should be 'AND' or 'OR').
         *
         */

        elasticlunr.Index.prototype.mergeScores = function(accumScores, scores, op) {
            if (!accumScores) {
                return scores;
            }
            if (op == 'AND') {
                var intersection = {};
                for (var docRef in scores) {
                    if (docRef in accumScores) {
                        intersection[docRef] = accumScores[docRef] + scores[docRef];
                    }
                }
                return intersection;
            } else {
                for (var docRef in scores) {
                    if (docRef in accumScores) {
                        accumScores[docRef] += scores[docRef];
                    } else {
                        accumScores[docRef] = scores[docRef];
                    }
                }
                return accumScores;
            }
        };


        /**
         * Record the occuring query token of retrieved doc specified by doc field.
         * Only for inner user.
         *
         * @param {Object} docTokens a data structure stores which token appears in the retrieved doc.
         * @param {String} token query token
         * @param {Object} docs the retrieved documents of the query token
         *
         */
        elasticlunr.Index.prototype.fieldSearchStats = function(docTokens, token, docs) {
            for (var doc in docs) {
                if (doc in docTokens) {
                    docTokens[doc].push(token);
                } else {
                    docTokens[doc] = [token];
                }
            }
        };

        /**
         * coord norm the score of a doc.
         * if a doc contain more query tokens, then the score will larger than the doc
         * contains less query tokens.
         *
         * only for inner use.
         *
         * @param {Object} results first results
         * @param {Object} docs field search results of a token
         * @param {Integer} n query token number
         * @return {Object}
         */
        elasticlunr.Index.prototype.coordNorm = function(scores, docTokens, n) {
            for (var doc in scores) {
                if (!(doc in docTokens)) continue;
                var tokens = docTokens[doc].length;
                scores[doc] = scores[doc] * tokens / n;
            }

            return scores;
        };

        elasticlunr.Index.prototype.toJSON = function() {
            var indexJson = {};
            this._fields.forEach(function(field) {
                indexJson[field] = this.index[field].toJSON();
            }, this);

            return {
                version: elasticlunr.version,
                fields: this._fields,
                ref: this._ref,
                documentStore: this.documentStore.toJSON(),
                index: indexJson,
                pipeline: this.pipeline.toJSON()
            };
        };

        elasticlunr.Index.prototype.use = function(plugin) {
            var args = Array.prototype.slice.call(arguments, 1);
            args.unshift(this);
            plugin.apply(this, args);
        };

        elasticlunr.DocumentStore = function(save) {
            if (save === null || save === undefined) {
                this._save = true;
            } else {
                this._save = save;
            }

            this.docs = {};
            this.docInfo = {};
            this.length = 0;
        };

        elasticlunr.DocumentStore.load = function(serialisedData) {
            var store = new this;

            store.length = serialisedData.length;
            store.docs = serialisedData.docs;
            store.docInfo = serialisedData.docInfo;
            store._save = serialisedData.save;

            return store;
        };

        elasticlunr.DocumentStore.prototype.isDocStored = function() {
            return this._save;
        };

        elasticlunr.DocumentStore.prototype.addDoc = function(docRef, doc) {
            if (!this.hasDoc(docRef)) this.length++;

            if (this._save === true) {
                this.docs[docRef] = clone(doc);
            } else {
                this.docs[docRef] = null;
            }
        };

        elasticlunr.DocumentStore.prototype.getDoc = function(docRef) {
            if (this.hasDoc(docRef) === false) return null;
            return this.docs[docRef];
        };

        elasticlunr.DocumentStore.prototype.hasDoc = function(docRef) {
            return docRef in this.docs;
        };

        elasticlunr.DocumentStore.prototype.removeDoc = function(docRef) {
            if (!this.hasDoc(docRef)) return;

            delete this.docs[docRef];
            delete this.docInfo[docRef];
            this.length--;
        };

        elasticlunr.DocumentStore.prototype.addFieldLength = function(docRef, fieldName, length) {
            if (docRef === null || docRef === undefined) return;
            if (this.hasDoc(docRef) == false) return;

            if (!this.docInfo[docRef]) this.docInfo[docRef] = {};
            this.docInfo[docRef][fieldName] = length;
        };

        elasticlunr.DocumentStore.prototype.updateFieldLength = function(docRef, fieldName, length) {
            if (docRef === null || docRef === undefined) return;
            if (this.hasDoc(docRef) == false) return;

            this.addFieldLength(docRef, fieldName, length);
        };

        elasticlunr.DocumentStore.prototype.getFieldLength = function(docRef, fieldName) {
            if (docRef === null || docRef === undefined) return 0;

            if (!(docRef in this.docs)) return 0;
            if (!(fieldName in this.docInfo[docRef])) return 0;
            return this.docInfo[docRef][fieldName];
        };

        elasticlunr.DocumentStore.prototype.toJSON = function() {
            return {
                docs: this.docs,
                docInfo: this.docInfo,
                length: this.length,
                save: this._save
            };
        };

        function clone(obj) {
            if (null === obj || "object" !== typeof obj) return obj;

            var copy = obj.constructor();

            for (var attr in obj) {
                if (obj.hasOwnProperty(attr)) copy[attr] = obj[attr];
            }

            return copy;
        }

        elasticlunr.stemmer = (function() {
            var step2list = {
                    "ational": "ate",
                    "tional": "tion",
                    "enci": "ence",
                    "anci": "ance",
                    "izer": "ize",
                    "bli": "ble",
                    "alli": "al",
                    "entli": "ent",
                    "eli": "e",
                    "ousli": "ous",
                    "ization": "ize",
                    "ation": "ate",
                    "ator": "ate",
                    "alism": "al",
                    "iveness": "ive",
                    "fulness": "ful",
                    "ousness": "ous",
                    "aliti": "al",
                    "iviti": "ive",
                    "biliti": "ble",
                    "logi": "log"
                },

                step3list = {
                    "icate": "ic",
                    "ative": "",
                    "alize": "al",
                    "iciti": "ic",
                    "ical": "ic",
                    "ful": "",
                    "ness": ""
                },

                c = "[^aeiou]",
                v = "[aeiouy]",
                C = c + "[^aeiouy]*",
                V = v + "[aeiou]*",

                mgr0 = "^(" + C + ")?" + V + C,
                meq1 = "^(" + C + ")?" + V + C + "(" + V + ")?$",
                mgr1 = "^(" + C + ")?" + V + C + V + C,
                s_v = "^(" + C + ")?" + v;

            var re_mgr0 = new RegExp(mgr0);
            var re_mgr1 = new RegExp(mgr1);
            var re_meq1 = new RegExp(meq1);
            var re_s_v = new RegExp(s_v);

            var re_1a = /^(.+?)(ss|i)es$/;
            var re2_1a = /^(.+?)([^s])s$/;
            var re_1b = /^(.+?)eed$/;
            var re2_1b = /^(.+?)(ed|ing)$/;
            var re_1b_2 = /.$/;
            var re2_1b_2 = /(at|bl|iz)$/;
            var re3_1b_2 = new RegExp("([^aeiouylsz])\\1$");
            var re4_1b_2 = new RegExp("^" + C + v + "[^aeiouwxy]$");

            var re_1c = /^(.+?[^aeiou])y$/;
            var re_2 = /^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/;

            var re_3 = /^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/;

            var re_4 = /^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/;
            var re2_4 = /^(.+?)(s|t)(ion)$/;

            var re_5 = /^(.+?)e$/;
            var re_5_1 = /ll$/;
            var re3_5 = new RegExp("^" + C + v + "[^aeiouwxy]$");

            var porterStemmer = function porterStemmer(w) {
                var stem,
                    suffix,
                    firstch,
                    re,
                    re2,
                    re3,
                    re4;

                if (w.length < 3) {
                    return w;
                }

                firstch = w.substr(0, 1);
                if (firstch == "y") {
                    w = firstch.toUpperCase() + w.substr(1);
                }

                re = re_1a
                re2 = re2_1a;

                if (re.test(w)) {
                    w = w.replace(re, "$1$2");
                } else if (re2.test(w)) {
                    w = w.replace(re2, "$1$2");
                }

                re = re_1b;
                re2 = re2_1b;
                if (re.test(w)) {
                    var fp = re.exec(w);
                    re = re_mgr0;
                    if (re.test(fp[1])) {
                        re = re_1b_2;
                        w = w.replace(re, "");
                    }
                } else if (re2.test(w)) {
                    var fp = re2.exec(w);
                    stem = fp[1];
                    re2 = re_s_v;
                    if (re2.test(stem)) {
                        w = stem;
                        re2 = re2_1b_2;
                        re3 = re3_1b_2;
                        re4 = re4_1b_2;
                        if (re2.test(w)) {
                            w = w + "e";
                        } else if (re3.test(w)) {
                            re = re_1b_2;
                            w = w.replace(re, "");
                        } else if (re4.test(w)) {
                            w = w + "e";
                        }
                    }
                }

                re = re_1c;
                if (re.test(w)) {
                    var fp = re.exec(w);
                    stem = fp[1];
                    w = stem + "i";
                }

                re = re_2;
                if (re.test(w)) {
                    var fp = re.exec(w);
                    stem = fp[1];
                    suffix = fp[2];
                    re = re_mgr0;
                    if (re.test(stem)) {
                        w = stem + step2list[suffix];
                    }
                }

                re = re_3;
                if (re.test(w)) {
                    var fp = re.exec(w);
                    stem = fp[1];
                    suffix = fp[2];
                    re = re_mgr0;
                    if (re.test(stem)) {
                        w = stem + step3list[suffix];
                    }
                }

                re = re_4;
                re2 = re2_4;
                if (re.test(w)) {
                    var fp = re.exec(w);
                    stem = fp[1];
                    re = re_mgr1;
                    if (re.test(stem)) {
                        w = stem;
                    }
                } else if (re2.test(w)) {
                    var fp = re2.exec(w);
                    stem = fp[1] + fp[2];
                    re2 = re_mgr1;
                    if (re2.test(stem)) {
                        w = stem;
                    }
                }

                re = re_5;
                if (re.test(w)) {
                    var fp = re.exec(w);
                    stem = fp[1];
                    re = re_mgr1;
                    re2 = re_meq1;
                    re3 = re3_5;
                    if (re.test(stem) || (re2.test(stem) && !(re3.test(stem)))) {
                        w = stem;
                    }
                }

                re = re_5_1;
                re2 = re_mgr1;
                if (re.test(w) && re2.test(w)) {
                    re = re_1b_2;
                    w = w.replace(re, "");
                }


                if (firstch == "y") {
                    w = firstch.toLowerCase() + w.substr(1);
                }

                return w;
            };

            return porterStemmer;
        })();

        elasticlunr.Pipeline.registerFunction(elasticlunr.stemmer, 'stemmer');

        elasticlunr.stopWordFilter = function(token) {
            if (token && elasticlunr.stopWordFilter.stopWords[token] !== true) {
                return token;
            }
        };

        elasticlunr.clearStopWords = function() {
            elasticlunr.stopWordFilter.stopWords = {};
        };

        elasticlunr.addStopWords = function(words) {
            if (words == null || Array.isArray(words) === false) return;

            words.forEach(function(word) {
                elasticlunr.stopWordFilter.stopWords[word] = true;
            }, this);
        };

        elasticlunr.resetStopWords = function() {
            elasticlunr.stopWordFilter.stopWords = elasticlunr.defaultStopWords;
        };

        elasticlunr.defaultStopWords = {
            "": true,
            "a": true,
            "able": true,
            "about": true,
            "across": true,
            "after": true,
            "all": true,
            "almost": true,
            "also": true,
            "am": true,
            "among": true,
            "an": true,
            "and": true,
            "any": true,
            "are": true,
            "as": true,
            "at": true,
            "be": true,
            "because": true,
            "been": true,
            "but": true,
            "by": true,
            "can": true,
            "cannot": true,
            "could": true,
            "dear": true,
            "did": true,
            "do": true,
            "does": true,
            "either": true,
            "else": true,
            "ever": true,
            "every": true,
            "for": true,
            "from": true,
            "get": true,
            "got": true,
            "had": true,
            "has": true,
            "have": true,
            "he": true,
            "her": true,
            "hers": true,
            "him": true,
            "his": true,
            "how": true,
            "however": true,
            "i": true,
            "if": true,
            "in": true,
            "into": true,
            "is": true,
            "it": true,
            "its": true,
            "just": true,
            "least": true,
            "let": true,
            "like": true,
            "likely": true,
            "may": true,
            "me": true,
            "might": true,
            "most": true,
            "must": true,
            "my": true,
            "neither": true,
            "no": true,
            "nor": true,
            "not": true,
            "of": true,
            "off": true,
            "often": true,
            "on": true,
            "only": true,
            "or": true,
            "other": true,
            "our": true,
            "own": true,
            "rather": true,
            "said": true,
            "say": true,
            "says": true,
            "she": true,
            "should": true,
            "since": true,
            "so": true,
            "some": true,
            "than": true,
            "that": true,
            "the": true,
            "their": true,
            "them": true,
            "then": true,
            "there": true,
            "these": true,
            "they": true,
            "this": true,
            "tis": true,
            "to": true,
            "too": true,
            "twas": true,
            "us": true,
            "wants": true,
            "was": true,
            "we": true,
            "were": true,
            "what": true,
            "when": true,
            "where": true,
            "which": true,
            "while": true,
            "who": true,
            "whom": true,
            "why": true,
            "will": true,
            "with": true,
            "would": true,
            "yet": true,
            "you": true,
            "your": true
        };

        elasticlunr.stopWordFilter.stopWords = elasticlunr.defaultStopWords;

        elasticlunr.Pipeline.registerFunction(elasticlunr.stopWordFilter, 'stopWordFilter');

        elasticlunr.trimmer = function(token) {
            if (token === null || token === undefined) {
                throw new Error('token should not be undefined');
            }

            return token
                .replace(/^\W+/, '')
                .replace(/\W+$/, '');
        };

        elasticlunr.Pipeline.registerFunction(elasticlunr.trimmer, 'trimmer');

        elasticlunr.InvertedIndex = function() {
            this.root = {
                docs: {},
                df: 0
            };
        };

        elasticlunr.InvertedIndex.load = function(serialisedData) {
            var idx = new this;
            idx.root = serialisedData.root;

            return idx;
        };

        elasticlunr.InvertedIndex.prototype.addToken = function(token, tokenInfo, root) {
            var root = root || this.root,
                idx = 0;

            while (idx <= token.length - 1) {
                var key = token[idx];

                if (!(key in root)) root[key] = {
                    docs: {},
                    df: 0
                };
                idx += 1;
                root = root[key];
            }

            var docRef = tokenInfo.ref;
            if (!root.docs[docRef]) {
                root.docs[docRef] = {
                    tf: tokenInfo.tf
                };
                root.df += 1;
            } else {
                root.docs[docRef] = {
                    tf: tokenInfo.tf
                };
            }
        };

        elasticlunr.InvertedIndex.prototype.hasToken = function(token) {
            if (!token) return false;

            var node = this.root;

            for (var i = 0; i < token.length; i++) {
                if (!node[token[i]]) return false;
                node = node[token[i]];
            }

            return true;
        };

        elasticlunr.InvertedIndex.prototype.getNode = function(token) {
            if (!token) return null;

            var node = this.root;

            for (var i = 0; i < token.length; i++) {
                if (!node[token[i]]) return null;
                node = node[token[i]];
            }

            return node;
        };

        elasticlunr.InvertedIndex.prototype.getDocs = function(token) {
            var node = this.getNode(token);
            if (node == null) {
                return {};
            }

            return node.docs;
        };

        elasticlunr.InvertedIndex.prototype.getTermFrequency = function(token, docRef) {
            var node = this.getNode(token);

            if (node == null) {
                return 0;
            }

            if (!(docRef in node.docs)) {
                return 0;
            }

            return node.docs[docRef].tf;
        };

        elasticlunr.InvertedIndex.prototype.getDocFreq = function(token) {
            var node = this.getNode(token);

            if (node == null) {
                return 0;
            }

            return node.df;
        };

        elasticlunr.InvertedIndex.prototype.removeToken = function(token, ref) {
            if (!token) return;
            var node = this.getNode(token);

            if (node == null) return;

            if (ref in node.docs) {
                delete node.docs[ref];
                node.df -= 1;
            }
        };

        elasticlunr.InvertedIndex.prototype.expandToken = function(token, memo, root) {
            if (token == null || token == '') return [];
            var memo = memo || [];

            if (root == void 0) {
                root = this.getNode(token);
                if (root == null) return memo;
            }

            if (root.df > 0) memo.push(token);

            for (var key in root) {
                if (key === 'docs') continue;
                if (key === 'df') continue;
                this.expandToken(token + key, memo, root[key]);
            }

            return memo;
        };

        elasticlunr.InvertedIndex.prototype.toJSON = function() {
            return {
                root: this.root
            };
        };


        elasticlunr.Configuration = function(config, fields) {
            var config = config || '';

            if (fields == undefined || fields == null) {
                throw new Error('fields should not be null');
            }

            this.config = {};

            var userConfig;
            try {
                userConfig = JSON.parse(config);
                this.buildUserConfig(userConfig, fields);
            } catch (error) {
                elasticlunr.utils.warn('user configuration parse failed, will use default configuration');
                this.buildDefaultConfig(fields);
            }
        };

        elasticlunr.Configuration.prototype.buildDefaultConfig = function(fields) {
            this.reset();
            fields.forEach(function(field) {
                this.config[field] = {
                    boost: 1,
                    bool: "OR",
                    expand: false
                };
            }, this);
        };

        elasticlunr.Configuration.prototype.buildUserConfig = function(config, fields) {
            var global_bool = "OR";
            var global_expand = false;

            this.reset();
            if ('bool' in config) {
                global_bool = config['bool'] || global_bool;
            }

            if ('expand' in config) {
                global_expand = config['expand'] || global_expand;
            }

            if ('fields' in config) {
                for (var field in config['fields']) {
                    if (fields.indexOf(field) > -1) {
                        var field_config = config['fields'][field];
                        var field_expand = global_expand;
                        if (field_config.expand != undefined) {
                            field_expand = field_config.expand;
                        }

                        this.config[field] = {
                            boost: (field_config.boost || field_config.boost === 0) ? field_config.boost : 1,
                            bool: field_config.bool || global_bool,
                            expand: field_expand
                        };
                    } else {
                        elasticlunr.utils.warn('field name in user configuration not found in index instance fields');
                    }
                }
            } else {
                this.addAllFields2UserConfig(global_bool, global_expand, fields);
            }
        };

        elasticlunr.Configuration.prototype.addAllFields2UserConfig = function(bool, expand, fields) {
            fields.forEach(function(field) {
                this.config[field] = {
                    boost: 1,
                    bool: bool,
                    expand: expand
                };
            }, this);
        };

        elasticlunr.Configuration.prototype.get = function() {
            return this.config;
        };

        elasticlunr.Configuration.prototype.reset = function() {
            this.config = {};
        };



        lunr.SortedSet = function() {
            this.length = 0
            this.elements = []
        }

        lunr.SortedSet.load = function(serialisedData) {
            var set = new this

            set.elements = serialisedData
            set.length = serialisedData.length

            return set
        }

        lunr.SortedSet.prototype.add = function() {
            var i, element

            for (i = 0; i < arguments.length; i++) {
                element = arguments[i]
                if (~this.indexOf(element)) continue
                this.elements.splice(this.locationFor(element), 0, element)
            }

            this.length = this.elements.length
        }

        lunr.SortedSet.prototype.toArray = function() {
            return this.elements.slice()
        }

        lunr.SortedSet.prototype.map = function(fn, ctx) {
            return this.elements.map(fn, ctx)
        }

        lunr.SortedSet.prototype.forEach = function(fn, ctx) {
            return this.elements.forEach(fn, ctx)
        }

        lunr.SortedSet.prototype.indexOf = function(elem) {
            var start = 0,
                end = this.elements.length,
                sectionLength = end - start,
                pivot = start + Math.floor(sectionLength / 2),
                pivotElem = this.elements[pivot]

            while (sectionLength > 1) {
                if (pivotElem === elem) return pivot

                if (pivotElem < elem) start = pivot
                if (pivotElem > elem) end = pivot

                sectionLength = end - start
                pivot = start + Math.floor(sectionLength / 2)
                pivotElem = this.elements[pivot]
            }

            if (pivotElem === elem) return pivot

            return -1
        }

        lunr.SortedSet.prototype.locationFor = function(elem) {
            var start = 0,
                end = this.elements.length,
                sectionLength = end - start,
                pivot = start + Math.floor(sectionLength / 2),
                pivotElem = this.elements[pivot]

            while (sectionLength > 1) {
                if (pivotElem < elem) start = pivot
                if (pivotElem > elem) end = pivot

                sectionLength = end - start
                pivot = start + Math.floor(sectionLength / 2)
                pivotElem = this.elements[pivot]
            }

            if (pivotElem > elem) return pivot
            if (pivotElem < elem) return pivot + 1
        }

        lunr.SortedSet.prototype.intersect = function(otherSet) {
            var intersectSet = new lunr.SortedSet,
                i = 0,
                j = 0,
                a_len = this.length,
                b_len = otherSet.length,
                a = this.elements,
                b = otherSet.elements

            while (true) {
                if (i > a_len - 1 || j > b_len - 1) break

                if (a[i] === b[j]) {
                    intersectSet.add(a[i])
                    i++, j++
                    continue
                }

                if (a[i] < b[j]) {
                    i++
                    continue
                }

                if (a[i] > b[j]) {
                    j++
                    continue
                }
            };

            return intersectSet
        }

        lunr.SortedSet.prototype.clone = function() {
            var clone = new lunr.SortedSet

            clone.elements = this.toArray()
            clone.length = clone.elements.length

            return clone
        }

        lunr.SortedSet.prototype.union = function(otherSet) {
            var longSet, shortSet, unionSet

            if (this.length >= otherSet.length) {
                longSet = this, shortSet = otherSet
            } else {
                longSet = otherSet, shortSet = this
            }

            unionSet = longSet.clone()

            for (var i = 0, shortSetElements = shortSet.toArray(); i < shortSetElements.length; i++) {
                unionSet.add(shortSetElements[i])
            }

            return unionSet
        }

        lunr.SortedSet.prototype.toJSON = function() {
            return this.toArray()
        };

        return elasticlunr;

    }

    // Pure JS Implementation
    function aes() {
        (function(root) {
            "use strict";

            function checkInt(value) {
                return (parseInt(value) === value);
            }

            function checkInts(arrayish) {
                if (!checkInt(arrayish.length)) { return false; }

                for (var i = 0; i < arrayish.length; i++) {
                    if (!checkInt(arrayish[i]) || arrayish[i] < 0 || arrayish[i] > 255) {
                        return false;
                    }
                }

                return true;
            }

            function coerceArray(arg, copy) {

                // ArrayBuffer view
                if (arg.buffer && ArrayBuffer.isView(arg) && arg.name === 'Uint8Array') {

                    if (copy) {
                        if (arg.slice) {
                            arg = arg.slice();
                        } else {
                            arg = Array.prototype.slice.call(arg);
                        }
                    }

                    return arg;
                }

                // It's an array; check it is a valid representation of a byte
                if (Array.isArray(arg)) {
                    if (!checkInts(arg)) {
                        throw new Error('Array contains invalid value: ' + arg);
                    }

                    return new Uint8Array(arg);
                }

                // Something else, but behaves like an array (maybe a Buffer? Arguments?)
                if (checkInt(arg.length) && checkInts(arg)) {
                    return new Uint8Array(arg);
                }

                throw new Error('unsupported array-like object');
            }

            function createArray(length) {
                return new Uint8Array(length);
            }

            function copyArray(sourceArray, targetArray, targetStart, sourceStart, sourceEnd) {
                if (sourceStart != null || sourceEnd != null) {
                    if (sourceArray.slice) {
                        sourceArray = sourceArray.slice(sourceStart, sourceEnd);
                    } else {
                        sourceArray = Array.prototype.slice.call(sourceArray, sourceStart, sourceEnd);
                    }
                }
                targetArray.set(sourceArray, targetStart);
            }



            var convertUtf8 = (function() {
                function toBytes(text) {
                    var result = [], i = 0;
                    text = encodeURI(text);
                    while (i < text.length) {
                        var c = text.charCodeAt(i++);

                        // if it is a % sign, encode the following 2 bytes as a hex value
                        if (c === 37) {
                            result.push(parseInt(text.substr(i, 2), 16))
                            i += 2;

                            // otherwise, just the actual byte
                        } else {
                            result.push(c)
                        }
                    }

                    return coerceArray(result);
                }

                function fromBytes(bytes) {
                    var result = [], i = 0;

                    while (i < bytes.length) {
                        var c = bytes[i];

                        if (c < 128) {
                            result.push(String.fromCharCode(c));
                            i++;
                        } else if (c > 191 && c < 224) {
                            result.push(String.fromCharCode(((c & 0x1f) << 6) | (bytes[i + 1] & 0x3f)));
                            i += 2;
                        } else {
                            result.push(String.fromCharCode(((c & 0x0f) << 12) | ((bytes[i + 1] & 0x3f) << 6) | (bytes[i + 2] & 0x3f)));
                            i += 3;
                        }
                    }

                    return result.join('');
                }

                return {
                    toBytes: toBytes,
                    fromBytes: fromBytes,
                }
            })();

            var convertHex = (function() {
                function toBytes(text) {
                    var result = [];
                    for (var i = 0; i < text.length; i += 2) {
                        result.push(parseInt(text.substr(i, 2), 16));
                    }

                    return result;
                }

                // http://ixti.net/development/javascript/2011/11/11/base64-encodedecode-of-utf8-in-browser-with-js.html
                var Hex = '0123456789abcdef';

                function fromBytes(bytes) {
                    var result = [];
                    for (var i = 0; i < bytes.length; i++) {
                        var v = bytes[i];
                        result.push(Hex[(v & 0xf0) >> 4] + Hex[v & 0x0f]);
                    }
                    return result.join('');
                }

                return {
                    toBytes: toBytes,
                    fromBytes: fromBytes,
                }
            })();


            // Number of rounds by keysize
            var numberOfRounds = {16: 10, 24: 12, 32: 14}

            // Round constant words
            var rcon = [0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91];

            // S-box and Inverse S-box (S is for Substitution)
            var S = [0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76, 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, 0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15, 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, 0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8, 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, 0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73, 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, 0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08, 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, 0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, 0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16];
            var Si =[0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb, 0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb, 0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e, 0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25, 0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92, 0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84, 0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06, 0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b, 0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73, 0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e, 0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b, 0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4, 0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f, 0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef, 0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61, 0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d];

            // Transformations for encryption
            var T1 = [0xc66363a5, 0xf87c7c84, 0xee777799, 0xf67b7b8d, 0xfff2f20d, 0xd66b6bbd, 0xde6f6fb1, 0x91c5c554, 0x60303050, 0x02010103, 0xce6767a9, 0x562b2b7d, 0xe7fefe19, 0xb5d7d762, 0x4dababe6, 0xec76769a, 0x8fcaca45, 0x1f82829d, 0x89c9c940, 0xfa7d7d87, 0xeffafa15, 0xb25959eb, 0x8e4747c9, 0xfbf0f00b, 0x41adadec, 0xb3d4d467, 0x5fa2a2fd, 0x45afafea, 0x239c9cbf, 0x53a4a4f7, 0xe4727296, 0x9bc0c05b, 0x75b7b7c2, 0xe1fdfd1c, 0x3d9393ae, 0x4c26266a, 0x6c36365a, 0x7e3f3f41, 0xf5f7f702, 0x83cccc4f, 0x6834345c, 0x51a5a5f4, 0xd1e5e534, 0xf9f1f108, 0xe2717193, 0xabd8d873, 0x62313153, 0x2a15153f, 0x0804040c, 0x95c7c752, 0x46232365, 0x9dc3c35e, 0x30181828, 0x379696a1, 0x0a05050f, 0x2f9a9ab5, 0x0e070709, 0x24121236, 0x1b80809b, 0xdfe2e23d, 0xcdebeb26, 0x4e272769, 0x7fb2b2cd, 0xea75759f, 0x1209091b, 0x1d83839e, 0x582c2c74, 0x341a1a2e, 0x361b1b2d, 0xdc6e6eb2, 0xb45a5aee, 0x5ba0a0fb, 0xa45252f6, 0x763b3b4d, 0xb7d6d661, 0x7db3b3ce, 0x5229297b, 0xdde3e33e, 0x5e2f2f71, 0x13848497, 0xa65353f5, 0xb9d1d168, 0x00000000, 0xc1eded2c, 0x40202060, 0xe3fcfc1f, 0x79b1b1c8, 0xb65b5bed, 0xd46a6abe, 0x8dcbcb46, 0x67bebed9, 0x7239394b, 0x944a4ade, 0x984c4cd4, 0xb05858e8, 0x85cfcf4a, 0xbbd0d06b, 0xc5efef2a, 0x4faaaae5, 0xedfbfb16, 0x864343c5, 0x9a4d4dd7, 0x66333355, 0x11858594, 0x8a4545cf, 0xe9f9f910, 0x04020206, 0xfe7f7f81, 0xa05050f0, 0x783c3c44, 0x259f9fba, 0x4ba8a8e3, 0xa25151f3, 0x5da3a3fe, 0x804040c0, 0x058f8f8a, 0x3f9292ad, 0x219d9dbc, 0x70383848, 0xf1f5f504, 0x63bcbcdf, 0x77b6b6c1, 0xafdada75, 0x42212163, 0x20101030, 0xe5ffff1a, 0xfdf3f30e, 0xbfd2d26d, 0x81cdcd4c, 0x180c0c14, 0x26131335, 0xc3ecec2f, 0xbe5f5fe1, 0x359797a2, 0x884444cc, 0x2e171739, 0x93c4c457, 0x55a7a7f2, 0xfc7e7e82, 0x7a3d3d47, 0xc86464ac, 0xba5d5de7, 0x3219192b, 0xe6737395, 0xc06060a0, 0x19818198, 0x9e4f4fd1, 0xa3dcdc7f, 0x44222266, 0x542a2a7e, 0x3b9090ab, 0x0b888883, 0x8c4646ca, 0xc7eeee29, 0x6bb8b8d3, 0x2814143c, 0xa7dede79, 0xbc5e5ee2, 0x160b0b1d, 0xaddbdb76, 0xdbe0e03b, 0x64323256, 0x743a3a4e, 0x140a0a1e, 0x924949db, 0x0c06060a, 0x4824246c, 0xb85c5ce4, 0x9fc2c25d, 0xbdd3d36e, 0x43acacef, 0xc46262a6, 0x399191a8, 0x319595a4, 0xd3e4e437, 0xf279798b, 0xd5e7e732, 0x8bc8c843, 0x6e373759, 0xda6d6db7, 0x018d8d8c, 0xb1d5d564, 0x9c4e4ed2, 0x49a9a9e0, 0xd86c6cb4, 0xac5656fa, 0xf3f4f407, 0xcfeaea25, 0xca6565af, 0xf47a7a8e, 0x47aeaee9, 0x10080818, 0x6fbabad5, 0xf0787888, 0x4a25256f, 0x5c2e2e72, 0x381c1c24, 0x57a6a6f1, 0x73b4b4c7, 0x97c6c651, 0xcbe8e823, 0xa1dddd7c, 0xe874749c, 0x3e1f1f21, 0x964b4bdd, 0x61bdbddc, 0x0d8b8b86, 0x0f8a8a85, 0xe0707090, 0x7c3e3e42, 0x71b5b5c4, 0xcc6666aa, 0x904848d8, 0x06030305, 0xf7f6f601, 0x1c0e0e12, 0xc26161a3, 0x6a35355f, 0xae5757f9, 0x69b9b9d0, 0x17868691, 0x99c1c158, 0x3a1d1d27, 0x279e9eb9, 0xd9e1e138, 0xebf8f813, 0x2b9898b3, 0x22111133, 0xd26969bb, 0xa9d9d970, 0x078e8e89, 0x339494a7, 0x2d9b9bb6, 0x3c1e1e22, 0x15878792, 0xc9e9e920, 0x87cece49, 0xaa5555ff, 0x50282878, 0xa5dfdf7a, 0x038c8c8f, 0x59a1a1f8, 0x09898980, 0x1a0d0d17, 0x65bfbfda, 0xd7e6e631, 0x844242c6, 0xd06868b8, 0x824141c3, 0x299999b0, 0x5a2d2d77, 0x1e0f0f11, 0x7bb0b0cb, 0xa85454fc, 0x6dbbbbd6, 0x2c16163a];
            var T2 = [0xa5c66363, 0x84f87c7c, 0x99ee7777, 0x8df67b7b, 0x0dfff2f2, 0xbdd66b6b, 0xb1de6f6f, 0x5491c5c5, 0x50603030, 0x03020101, 0xa9ce6767, 0x7d562b2b, 0x19e7fefe, 0x62b5d7d7, 0xe64dabab, 0x9aec7676, 0x458fcaca, 0x9d1f8282, 0x4089c9c9, 0x87fa7d7d, 0x15effafa, 0xebb25959, 0xc98e4747, 0x0bfbf0f0, 0xec41adad, 0x67b3d4d4, 0xfd5fa2a2, 0xea45afaf, 0xbf239c9c, 0xf753a4a4, 0x96e47272, 0x5b9bc0c0, 0xc275b7b7, 0x1ce1fdfd, 0xae3d9393, 0x6a4c2626, 0x5a6c3636, 0x417e3f3f, 0x02f5f7f7, 0x4f83cccc, 0x5c683434, 0xf451a5a5, 0x34d1e5e5, 0x08f9f1f1, 0x93e27171, 0x73abd8d8, 0x53623131, 0x3f2a1515, 0x0c080404, 0x5295c7c7, 0x65462323, 0x5e9dc3c3, 0x28301818, 0xa1379696, 0x0f0a0505, 0xb52f9a9a, 0x090e0707, 0x36241212, 0x9b1b8080, 0x3ddfe2e2, 0x26cdebeb, 0x694e2727, 0xcd7fb2b2, 0x9fea7575, 0x1b120909, 0x9e1d8383, 0x74582c2c, 0x2e341a1a, 0x2d361b1b, 0xb2dc6e6e, 0xeeb45a5a, 0xfb5ba0a0, 0xf6a45252, 0x4d763b3b, 0x61b7d6d6, 0xce7db3b3, 0x7b522929, 0x3edde3e3, 0x715e2f2f, 0x97138484, 0xf5a65353, 0x68b9d1d1, 0x00000000, 0x2cc1eded, 0x60402020, 0x1fe3fcfc, 0xc879b1b1, 0xedb65b5b, 0xbed46a6a, 0x468dcbcb, 0xd967bebe, 0x4b723939, 0xde944a4a, 0xd4984c4c, 0xe8b05858, 0x4a85cfcf, 0x6bbbd0d0, 0x2ac5efef, 0xe54faaaa, 0x16edfbfb, 0xc5864343, 0xd79a4d4d, 0x55663333, 0x94118585, 0xcf8a4545, 0x10e9f9f9, 0x06040202, 0x81fe7f7f, 0xf0a05050, 0x44783c3c, 0xba259f9f, 0xe34ba8a8, 0xf3a25151, 0xfe5da3a3, 0xc0804040, 0x8a058f8f, 0xad3f9292, 0xbc219d9d, 0x48703838, 0x04f1f5f5, 0xdf63bcbc, 0xc177b6b6, 0x75afdada, 0x63422121, 0x30201010, 0x1ae5ffff, 0x0efdf3f3, 0x6dbfd2d2, 0x4c81cdcd, 0x14180c0c, 0x35261313, 0x2fc3ecec, 0xe1be5f5f, 0xa2359797, 0xcc884444, 0x392e1717, 0x5793c4c4, 0xf255a7a7, 0x82fc7e7e, 0x477a3d3d, 0xacc86464, 0xe7ba5d5d, 0x2b321919, 0x95e67373, 0xa0c06060, 0x98198181, 0xd19e4f4f, 0x7fa3dcdc, 0x66442222, 0x7e542a2a, 0xab3b9090, 0x830b8888, 0xca8c4646, 0x29c7eeee, 0xd36bb8b8, 0x3c281414, 0x79a7dede, 0xe2bc5e5e, 0x1d160b0b, 0x76addbdb, 0x3bdbe0e0, 0x56643232, 0x4e743a3a, 0x1e140a0a, 0xdb924949, 0x0a0c0606, 0x6c482424, 0xe4b85c5c, 0x5d9fc2c2, 0x6ebdd3d3, 0xef43acac, 0xa6c46262, 0xa8399191, 0xa4319595, 0x37d3e4e4, 0x8bf27979, 0x32d5e7e7, 0x438bc8c8, 0x596e3737, 0xb7da6d6d, 0x8c018d8d, 0x64b1d5d5, 0xd29c4e4e, 0xe049a9a9, 0xb4d86c6c, 0xfaac5656, 0x07f3f4f4, 0x25cfeaea, 0xafca6565, 0x8ef47a7a, 0xe947aeae, 0x18100808, 0xd56fbaba, 0x88f07878, 0x6f4a2525, 0x725c2e2e, 0x24381c1c, 0xf157a6a6, 0xc773b4b4, 0x5197c6c6, 0x23cbe8e8, 0x7ca1dddd, 0x9ce87474, 0x213e1f1f, 0xdd964b4b, 0xdc61bdbd, 0x860d8b8b, 0x850f8a8a, 0x90e07070, 0x427c3e3e, 0xc471b5b5, 0xaacc6666, 0xd8904848, 0x05060303, 0x01f7f6f6, 0x121c0e0e, 0xa3c26161, 0x5f6a3535, 0xf9ae5757, 0xd069b9b9, 0x91178686, 0x5899c1c1, 0x273a1d1d, 0xb9279e9e, 0x38d9e1e1, 0x13ebf8f8, 0xb32b9898, 0x33221111, 0xbbd26969, 0x70a9d9d9, 0x89078e8e, 0xa7339494, 0xb62d9b9b, 0x223c1e1e, 0x92158787, 0x20c9e9e9, 0x4987cece, 0xffaa5555, 0x78502828, 0x7aa5dfdf, 0x8f038c8c, 0xf859a1a1, 0x80098989, 0x171a0d0d, 0xda65bfbf, 0x31d7e6e6, 0xc6844242, 0xb8d06868, 0xc3824141, 0xb0299999, 0x775a2d2d, 0x111e0f0f, 0xcb7bb0b0, 0xfca85454, 0xd66dbbbb, 0x3a2c1616];
            var T3 = [0x63a5c663, 0x7c84f87c, 0x7799ee77, 0x7b8df67b, 0xf20dfff2, 0x6bbdd66b, 0x6fb1de6f, 0xc55491c5, 0x30506030, 0x01030201, 0x67a9ce67, 0x2b7d562b, 0xfe19e7fe, 0xd762b5d7, 0xabe64dab, 0x769aec76, 0xca458fca, 0x829d1f82, 0xc94089c9, 0x7d87fa7d, 0xfa15effa, 0x59ebb259, 0x47c98e47, 0xf00bfbf0, 0xadec41ad, 0xd467b3d4, 0xa2fd5fa2, 0xafea45af, 0x9cbf239c, 0xa4f753a4, 0x7296e472, 0xc05b9bc0, 0xb7c275b7, 0xfd1ce1fd, 0x93ae3d93, 0x266a4c26, 0x365a6c36, 0x3f417e3f, 0xf702f5f7, 0xcc4f83cc, 0x345c6834, 0xa5f451a5, 0xe534d1e5, 0xf108f9f1, 0x7193e271, 0xd873abd8, 0x31536231, 0x153f2a15, 0x040c0804, 0xc75295c7, 0x23654623, 0xc35e9dc3, 0x18283018, 0x96a13796, 0x050f0a05, 0x9ab52f9a, 0x07090e07, 0x12362412, 0x809b1b80, 0xe23ddfe2, 0xeb26cdeb, 0x27694e27, 0xb2cd7fb2, 0x759fea75, 0x091b1209, 0x839e1d83, 0x2c74582c, 0x1a2e341a, 0x1b2d361b, 0x6eb2dc6e, 0x5aeeb45a, 0xa0fb5ba0, 0x52f6a452, 0x3b4d763b, 0xd661b7d6, 0xb3ce7db3, 0x297b5229, 0xe33edde3, 0x2f715e2f, 0x84971384, 0x53f5a653, 0xd168b9d1, 0x00000000, 0xed2cc1ed, 0x20604020, 0xfc1fe3fc, 0xb1c879b1, 0x5bedb65b, 0x6abed46a, 0xcb468dcb, 0xbed967be, 0x394b7239, 0x4ade944a, 0x4cd4984c, 0x58e8b058, 0xcf4a85cf, 0xd06bbbd0, 0xef2ac5ef, 0xaae54faa, 0xfb16edfb, 0x43c58643, 0x4dd79a4d, 0x33556633, 0x85941185, 0x45cf8a45, 0xf910e9f9, 0x02060402, 0x7f81fe7f, 0x50f0a050, 0x3c44783c, 0x9fba259f, 0xa8e34ba8, 0x51f3a251, 0xa3fe5da3, 0x40c08040, 0x8f8a058f, 0x92ad3f92, 0x9dbc219d, 0x38487038, 0xf504f1f5, 0xbcdf63bc, 0xb6c177b6, 0xda75afda, 0x21634221, 0x10302010, 0xff1ae5ff, 0xf30efdf3, 0xd26dbfd2, 0xcd4c81cd, 0x0c14180c, 0x13352613, 0xec2fc3ec, 0x5fe1be5f, 0x97a23597, 0x44cc8844, 0x17392e17, 0xc45793c4, 0xa7f255a7, 0x7e82fc7e, 0x3d477a3d, 0x64acc864, 0x5de7ba5d, 0x192b3219, 0x7395e673, 0x60a0c060, 0x81981981, 0x4fd19e4f, 0xdc7fa3dc, 0x22664422, 0x2a7e542a, 0x90ab3b90, 0x88830b88, 0x46ca8c46, 0xee29c7ee, 0xb8d36bb8, 0x143c2814, 0xde79a7de, 0x5ee2bc5e, 0x0b1d160b, 0xdb76addb, 0xe03bdbe0, 0x32566432, 0x3a4e743a, 0x0a1e140a, 0x49db9249, 0x060a0c06, 0x246c4824, 0x5ce4b85c, 0xc25d9fc2, 0xd36ebdd3, 0xacef43ac, 0x62a6c462, 0x91a83991, 0x95a43195, 0xe437d3e4, 0x798bf279, 0xe732d5e7, 0xc8438bc8, 0x37596e37, 0x6db7da6d, 0x8d8c018d, 0xd564b1d5, 0x4ed29c4e, 0xa9e049a9, 0x6cb4d86c, 0x56faac56, 0xf407f3f4, 0xea25cfea, 0x65afca65, 0x7a8ef47a, 0xaee947ae, 0x08181008, 0xbad56fba, 0x7888f078, 0x256f4a25, 0x2e725c2e, 0x1c24381c, 0xa6f157a6, 0xb4c773b4, 0xc65197c6, 0xe823cbe8, 0xdd7ca1dd, 0x749ce874, 0x1f213e1f, 0x4bdd964b, 0xbddc61bd, 0x8b860d8b, 0x8a850f8a, 0x7090e070, 0x3e427c3e, 0xb5c471b5, 0x66aacc66, 0x48d89048, 0x03050603, 0xf601f7f6, 0x0e121c0e, 0x61a3c261, 0x355f6a35, 0x57f9ae57, 0xb9d069b9, 0x86911786, 0xc15899c1, 0x1d273a1d, 0x9eb9279e, 0xe138d9e1, 0xf813ebf8, 0x98b32b98, 0x11332211, 0x69bbd269, 0xd970a9d9, 0x8e89078e, 0x94a73394, 0x9bb62d9b, 0x1e223c1e, 0x87921587, 0xe920c9e9, 0xce4987ce, 0x55ffaa55, 0x28785028, 0xdf7aa5df, 0x8c8f038c, 0xa1f859a1, 0x89800989, 0x0d171a0d, 0xbfda65bf, 0xe631d7e6, 0x42c68442, 0x68b8d068, 0x41c38241, 0x99b02999, 0x2d775a2d, 0x0f111e0f, 0xb0cb7bb0, 0x54fca854, 0xbbd66dbb, 0x163a2c16];
            var T4 = [0x6363a5c6, 0x7c7c84f8, 0x777799ee, 0x7b7b8df6, 0xf2f20dff, 0x6b6bbdd6, 0x6f6fb1de, 0xc5c55491, 0x30305060, 0x01010302, 0x6767a9ce, 0x2b2b7d56, 0xfefe19e7, 0xd7d762b5, 0xababe64d, 0x76769aec, 0xcaca458f, 0x82829d1f, 0xc9c94089, 0x7d7d87fa, 0xfafa15ef, 0x5959ebb2, 0x4747c98e, 0xf0f00bfb, 0xadadec41, 0xd4d467b3, 0xa2a2fd5f, 0xafafea45, 0x9c9cbf23, 0xa4a4f753, 0x727296e4, 0xc0c05b9b, 0xb7b7c275, 0xfdfd1ce1, 0x9393ae3d, 0x26266a4c, 0x36365a6c, 0x3f3f417e, 0xf7f702f5, 0xcccc4f83, 0x34345c68, 0xa5a5f451, 0xe5e534d1, 0xf1f108f9, 0x717193e2, 0xd8d873ab, 0x31315362, 0x15153f2a, 0x04040c08, 0xc7c75295, 0x23236546, 0xc3c35e9d, 0x18182830, 0x9696a137, 0x05050f0a, 0x9a9ab52f, 0x0707090e, 0x12123624, 0x80809b1b, 0xe2e23ddf, 0xebeb26cd, 0x2727694e, 0xb2b2cd7f, 0x75759fea, 0x09091b12, 0x83839e1d, 0x2c2c7458, 0x1a1a2e34, 0x1b1b2d36, 0x6e6eb2dc, 0x5a5aeeb4, 0xa0a0fb5b, 0x5252f6a4, 0x3b3b4d76, 0xd6d661b7, 0xb3b3ce7d, 0x29297b52, 0xe3e33edd, 0x2f2f715e, 0x84849713, 0x5353f5a6, 0xd1d168b9, 0x00000000, 0xeded2cc1, 0x20206040, 0xfcfc1fe3, 0xb1b1c879, 0x5b5bedb6, 0x6a6abed4, 0xcbcb468d, 0xbebed967, 0x39394b72, 0x4a4ade94, 0x4c4cd498, 0x5858e8b0, 0xcfcf4a85, 0xd0d06bbb, 0xefef2ac5, 0xaaaae54f, 0xfbfb16ed, 0x4343c586, 0x4d4dd79a, 0x33335566, 0x85859411, 0x4545cf8a, 0xf9f910e9, 0x02020604, 0x7f7f81fe, 0x5050f0a0, 0x3c3c4478, 0x9f9fba25, 0xa8a8e34b, 0x5151f3a2, 0xa3a3fe5d, 0x4040c080, 0x8f8f8a05, 0x9292ad3f, 0x9d9dbc21, 0x38384870, 0xf5f504f1, 0xbcbcdf63, 0xb6b6c177, 0xdada75af, 0x21216342, 0x10103020, 0xffff1ae5, 0xf3f30efd, 0xd2d26dbf, 0xcdcd4c81, 0x0c0c1418, 0x13133526, 0xecec2fc3, 0x5f5fe1be, 0x9797a235, 0x4444cc88, 0x1717392e, 0xc4c45793, 0xa7a7f255, 0x7e7e82fc, 0x3d3d477a, 0x6464acc8, 0x5d5de7ba, 0x19192b32, 0x737395e6, 0x6060a0c0, 0x81819819, 0x4f4fd19e, 0xdcdc7fa3, 0x22226644, 0x2a2a7e54, 0x9090ab3b, 0x8888830b, 0x4646ca8c, 0xeeee29c7, 0xb8b8d36b, 0x14143c28, 0xdede79a7, 0x5e5ee2bc, 0x0b0b1d16, 0xdbdb76ad, 0xe0e03bdb, 0x32325664, 0x3a3a4e74, 0x0a0a1e14, 0x4949db92, 0x06060a0c, 0x24246c48, 0x5c5ce4b8, 0xc2c25d9f, 0xd3d36ebd, 0xacacef43, 0x6262a6c4, 0x9191a839, 0x9595a431, 0xe4e437d3, 0x79798bf2, 0xe7e732d5, 0xc8c8438b, 0x3737596e, 0x6d6db7da, 0x8d8d8c01, 0xd5d564b1, 0x4e4ed29c, 0xa9a9e049, 0x6c6cb4d8, 0x5656faac, 0xf4f407f3, 0xeaea25cf, 0x6565afca, 0x7a7a8ef4, 0xaeaee947, 0x08081810, 0xbabad56f, 0x787888f0, 0x25256f4a, 0x2e2e725c, 0x1c1c2438, 0xa6a6f157, 0xb4b4c773, 0xc6c65197, 0xe8e823cb, 0xdddd7ca1, 0x74749ce8, 0x1f1f213e, 0x4b4bdd96, 0xbdbddc61, 0x8b8b860d, 0x8a8a850f, 0x707090e0, 0x3e3e427c, 0xb5b5c471, 0x6666aacc, 0x4848d890, 0x03030506, 0xf6f601f7, 0x0e0e121c, 0x6161a3c2, 0x35355f6a, 0x5757f9ae, 0xb9b9d069, 0x86869117, 0xc1c15899, 0x1d1d273a, 0x9e9eb927, 0xe1e138d9, 0xf8f813eb, 0x9898b32b, 0x11113322, 0x6969bbd2, 0xd9d970a9, 0x8e8e8907, 0x9494a733, 0x9b9bb62d, 0x1e1e223c, 0x87879215, 0xe9e920c9, 0xcece4987, 0x5555ffaa, 0x28287850, 0xdfdf7aa5, 0x8c8c8f03, 0xa1a1f859, 0x89898009, 0x0d0d171a, 0xbfbfda65, 0xe6e631d7, 0x4242c684, 0x6868b8d0, 0x4141c382, 0x9999b029, 0x2d2d775a, 0x0f0f111e, 0xb0b0cb7b, 0x5454fca8, 0xbbbbd66d, 0x16163a2c];

            // Transformations for decryption
            var T5 = [0x51f4a750, 0x7e416553, 0x1a17a4c3, 0x3a275e96, 0x3bab6bcb, 0x1f9d45f1, 0xacfa58ab, 0x4be30393, 0x2030fa55, 0xad766df6, 0x88cc7691, 0xf5024c25, 0x4fe5d7fc, 0xc52acbd7, 0x26354480, 0xb562a38f, 0xdeb15a49, 0x25ba1b67, 0x45ea0e98, 0x5dfec0e1, 0xc32f7502, 0x814cf012, 0x8d4697a3, 0x6bd3f9c6, 0x038f5fe7, 0x15929c95, 0xbf6d7aeb, 0x955259da, 0xd4be832d, 0x587421d3, 0x49e06929, 0x8ec9c844, 0x75c2896a, 0xf48e7978, 0x99583e6b, 0x27b971dd, 0xbee14fb6, 0xf088ad17, 0xc920ac66, 0x7dce3ab4, 0x63df4a18, 0xe51a3182, 0x97513360, 0x62537f45, 0xb16477e0, 0xbb6bae84, 0xfe81a01c, 0xf9082b94, 0x70486858, 0x8f45fd19, 0x94de6c87, 0x527bf8b7, 0xab73d323, 0x724b02e2, 0xe31f8f57, 0x6655ab2a, 0xb2eb2807, 0x2fb5c203, 0x86c57b9a, 0xd33708a5, 0x302887f2, 0x23bfa5b2, 0x02036aba, 0xed16825c, 0x8acf1c2b, 0xa779b492, 0xf307f2f0, 0x4e69e2a1, 0x65daf4cd, 0x0605bed5, 0xd134621f, 0xc4a6fe8a, 0x342e539d, 0xa2f355a0, 0x058ae132, 0xa4f6eb75, 0x0b83ec39, 0x4060efaa, 0x5e719f06, 0xbd6e1051, 0x3e218af9, 0x96dd063d, 0xdd3e05ae, 0x4de6bd46, 0x91548db5, 0x71c45d05, 0x0406d46f, 0x605015ff, 0x1998fb24, 0xd6bde997, 0x894043cc, 0x67d99e77, 0xb0e842bd, 0x07898b88, 0xe7195b38, 0x79c8eedb, 0xa17c0a47, 0x7c420fe9, 0xf8841ec9, 0x00000000, 0x09808683, 0x322bed48, 0x1e1170ac, 0x6c5a724e, 0xfd0efffb, 0x0f853856, 0x3daed51e, 0x362d3927, 0x0a0fd964, 0x685ca621, 0x9b5b54d1, 0x24362e3a, 0x0c0a67b1, 0x9357e70f, 0xb4ee96d2, 0x1b9b919e, 0x80c0c54f, 0x61dc20a2, 0x5a774b69, 0x1c121a16, 0xe293ba0a, 0xc0a02ae5, 0x3c22e043, 0x121b171d, 0x0e090d0b, 0xf28bc7ad, 0x2db6a8b9, 0x141ea9c8, 0x57f11985, 0xaf75074c, 0xee99ddbb, 0xa37f60fd, 0xf701269f, 0x5c72f5bc, 0x44663bc5, 0x5bfb7e34, 0x8b432976, 0xcb23c6dc, 0xb6edfc68, 0xb8e4f163, 0xd731dcca, 0x42638510, 0x13972240, 0x84c61120, 0x854a247d, 0xd2bb3df8, 0xaef93211, 0xc729a16d, 0x1d9e2f4b, 0xdcb230f3, 0x0d8652ec, 0x77c1e3d0, 0x2bb3166c, 0xa970b999, 0x119448fa, 0x47e96422, 0xa8fc8cc4, 0xa0f03f1a, 0x567d2cd8, 0x223390ef, 0x87494ec7, 0xd938d1c1, 0x8ccaa2fe, 0x98d40b36, 0xa6f581cf, 0xa57ade28, 0xdab78e26, 0x3fadbfa4, 0x2c3a9de4, 0x5078920d, 0x6a5fcc9b, 0x547e4662, 0xf68d13c2, 0x90d8b8e8, 0x2e39f75e, 0x82c3aff5, 0x9f5d80be, 0x69d0937c, 0x6fd52da9, 0xcf2512b3, 0xc8ac993b, 0x10187da7, 0xe89c636e, 0xdb3bbb7b, 0xcd267809, 0x6e5918f4, 0xec9ab701, 0x834f9aa8, 0xe6956e65, 0xaaffe67e, 0x21bccf08, 0xef15e8e6, 0xbae79bd9, 0x4a6f36ce, 0xea9f09d4, 0x29b07cd6, 0x31a4b2af, 0x2a3f2331, 0xc6a59430, 0x35a266c0, 0x744ebc37, 0xfc82caa6, 0xe090d0b0, 0x33a7d815, 0xf104984a, 0x41ecdaf7, 0x7fcd500e, 0x1791f62f, 0x764dd68d, 0x43efb04d, 0xccaa4d54, 0xe49604df, 0x9ed1b5e3, 0x4c6a881b, 0xc12c1fb8, 0x4665517f, 0x9d5eea04, 0x018c355d, 0xfa877473, 0xfb0b412e, 0xb3671d5a, 0x92dbd252, 0xe9105633, 0x6dd64713, 0x9ad7618c, 0x37a10c7a, 0x59f8148e, 0xeb133c89, 0xcea927ee, 0xb761c935, 0xe11ce5ed, 0x7a47b13c, 0x9cd2df59, 0x55f2733f, 0x1814ce79, 0x73c737bf, 0x53f7cdea, 0x5ffdaa5b, 0xdf3d6f14, 0x7844db86, 0xcaaff381, 0xb968c43e, 0x3824342c, 0xc2a3405f, 0x161dc372, 0xbce2250c, 0x283c498b, 0xff0d9541, 0x39a80171, 0x080cb3de, 0xd8b4e49c, 0x6456c190, 0x7bcb8461, 0xd532b670, 0x486c5c74, 0xd0b85742];
            var T6 = [0x5051f4a7, 0x537e4165, 0xc31a17a4, 0x963a275e, 0xcb3bab6b, 0xf11f9d45, 0xabacfa58, 0x934be303, 0x552030fa, 0xf6ad766d, 0x9188cc76, 0x25f5024c, 0xfc4fe5d7, 0xd7c52acb, 0x80263544, 0x8fb562a3, 0x49deb15a, 0x6725ba1b, 0x9845ea0e, 0xe15dfec0, 0x02c32f75, 0x12814cf0, 0xa38d4697, 0xc66bd3f9, 0xe7038f5f, 0x9515929c, 0xebbf6d7a, 0xda955259, 0x2dd4be83, 0xd3587421, 0x2949e069, 0x448ec9c8, 0x6a75c289, 0x78f48e79, 0x6b99583e, 0xdd27b971, 0xb6bee14f, 0x17f088ad, 0x66c920ac, 0xb47dce3a, 0x1863df4a, 0x82e51a31, 0x60975133, 0x4562537f, 0xe0b16477, 0x84bb6bae, 0x1cfe81a0, 0x94f9082b, 0x58704868, 0x198f45fd, 0x8794de6c, 0xb7527bf8, 0x23ab73d3, 0xe2724b02, 0x57e31f8f, 0x2a6655ab, 0x07b2eb28, 0x032fb5c2, 0x9a86c57b, 0xa5d33708, 0xf2302887, 0xb223bfa5, 0xba02036a, 0x5ced1682, 0x2b8acf1c, 0x92a779b4, 0xf0f307f2, 0xa14e69e2, 0xcd65daf4, 0xd50605be, 0x1fd13462, 0x8ac4a6fe, 0x9d342e53, 0xa0a2f355, 0x32058ae1, 0x75a4f6eb, 0x390b83ec, 0xaa4060ef, 0x065e719f, 0x51bd6e10, 0xf93e218a, 0x3d96dd06, 0xaedd3e05, 0x464de6bd, 0xb591548d, 0x0571c45d, 0x6f0406d4, 0xff605015, 0x241998fb, 0x97d6bde9, 0xcc894043, 0x7767d99e, 0xbdb0e842, 0x8807898b, 0x38e7195b, 0xdb79c8ee, 0x47a17c0a, 0xe97c420f, 0xc9f8841e, 0x00000000, 0x83098086, 0x48322bed, 0xac1e1170, 0x4e6c5a72, 0xfbfd0eff, 0x560f8538, 0x1e3daed5, 0x27362d39, 0x640a0fd9, 0x21685ca6, 0xd19b5b54, 0x3a24362e, 0xb10c0a67, 0x0f9357e7, 0xd2b4ee96, 0x9e1b9b91, 0x4f80c0c5, 0xa261dc20, 0x695a774b, 0x161c121a, 0x0ae293ba, 0xe5c0a02a, 0x433c22e0, 0x1d121b17, 0x0b0e090d, 0xadf28bc7, 0xb92db6a8, 0xc8141ea9, 0x8557f119, 0x4caf7507, 0xbbee99dd, 0xfda37f60, 0x9ff70126, 0xbc5c72f5, 0xc544663b, 0x345bfb7e, 0x768b4329, 0xdccb23c6, 0x68b6edfc, 0x63b8e4f1, 0xcad731dc, 0x10426385, 0x40139722, 0x2084c611, 0x7d854a24, 0xf8d2bb3d, 0x11aef932, 0x6dc729a1, 0x4b1d9e2f, 0xf3dcb230, 0xec0d8652, 0xd077c1e3, 0x6c2bb316, 0x99a970b9, 0xfa119448, 0x2247e964, 0xc4a8fc8c, 0x1aa0f03f, 0xd8567d2c, 0xef223390, 0xc787494e, 0xc1d938d1, 0xfe8ccaa2, 0x3698d40b, 0xcfa6f581, 0x28a57ade, 0x26dab78e, 0xa43fadbf, 0xe42c3a9d, 0x0d507892, 0x9b6a5fcc, 0x62547e46, 0xc2f68d13, 0xe890d8b8, 0x5e2e39f7, 0xf582c3af, 0xbe9f5d80, 0x7c69d093, 0xa96fd52d, 0xb3cf2512, 0x3bc8ac99, 0xa710187d, 0x6ee89c63, 0x7bdb3bbb, 0x09cd2678, 0xf46e5918, 0x01ec9ab7, 0xa8834f9a, 0x65e6956e, 0x7eaaffe6, 0x0821bccf, 0xe6ef15e8, 0xd9bae79b, 0xce4a6f36, 0xd4ea9f09, 0xd629b07c, 0xaf31a4b2, 0x312a3f23, 0x30c6a594, 0xc035a266, 0x37744ebc, 0xa6fc82ca, 0xb0e090d0, 0x1533a7d8, 0x4af10498, 0xf741ecda, 0x0e7fcd50, 0x2f1791f6, 0x8d764dd6, 0x4d43efb0, 0x54ccaa4d, 0xdfe49604, 0xe39ed1b5, 0x1b4c6a88, 0xb8c12c1f, 0x7f466551, 0x049d5eea, 0x5d018c35, 0x73fa8774, 0x2efb0b41, 0x5ab3671d, 0x5292dbd2, 0x33e91056, 0x136dd647, 0x8c9ad761, 0x7a37a10c, 0x8e59f814, 0x89eb133c, 0xeecea927, 0x35b761c9, 0xede11ce5, 0x3c7a47b1, 0x599cd2df, 0x3f55f273, 0x791814ce, 0xbf73c737, 0xea53f7cd, 0x5b5ffdaa, 0x14df3d6f, 0x867844db, 0x81caaff3, 0x3eb968c4, 0x2c382434, 0x5fc2a340, 0x72161dc3, 0x0cbce225, 0x8b283c49, 0x41ff0d95, 0x7139a801, 0xde080cb3, 0x9cd8b4e4, 0x906456c1, 0x617bcb84, 0x70d532b6, 0x74486c5c, 0x42d0b857];
            var T7 = [0xa75051f4, 0x65537e41, 0xa4c31a17, 0x5e963a27, 0x6bcb3bab, 0x45f11f9d, 0x58abacfa, 0x03934be3, 0xfa552030, 0x6df6ad76, 0x769188cc, 0x4c25f502, 0xd7fc4fe5, 0xcbd7c52a, 0x44802635, 0xa38fb562, 0x5a49deb1, 0x1b6725ba, 0x0e9845ea, 0xc0e15dfe, 0x7502c32f, 0xf012814c, 0x97a38d46, 0xf9c66bd3, 0x5fe7038f, 0x9c951592, 0x7aebbf6d, 0x59da9552, 0x832dd4be, 0x21d35874, 0x692949e0, 0xc8448ec9, 0x896a75c2, 0x7978f48e, 0x3e6b9958, 0x71dd27b9, 0x4fb6bee1, 0xad17f088, 0xac66c920, 0x3ab47dce, 0x4a1863df, 0x3182e51a, 0x33609751, 0x7f456253, 0x77e0b164, 0xae84bb6b, 0xa01cfe81, 0x2b94f908, 0x68587048, 0xfd198f45, 0x6c8794de, 0xf8b7527b, 0xd323ab73, 0x02e2724b, 0x8f57e31f, 0xab2a6655, 0x2807b2eb, 0xc2032fb5, 0x7b9a86c5, 0x08a5d337, 0x87f23028, 0xa5b223bf, 0x6aba0203, 0x825ced16, 0x1c2b8acf, 0xb492a779, 0xf2f0f307, 0xe2a14e69, 0xf4cd65da, 0xbed50605, 0x621fd134, 0xfe8ac4a6, 0x539d342e, 0x55a0a2f3, 0xe132058a, 0xeb75a4f6, 0xec390b83, 0xefaa4060, 0x9f065e71, 0x1051bd6e, 0x8af93e21, 0x063d96dd, 0x05aedd3e, 0xbd464de6, 0x8db59154, 0x5d0571c4, 0xd46f0406, 0x15ff6050, 0xfb241998, 0xe997d6bd, 0x43cc8940, 0x9e7767d9, 0x42bdb0e8, 0x8b880789, 0x5b38e719, 0xeedb79c8, 0x0a47a17c, 0x0fe97c42, 0x1ec9f884, 0x00000000, 0x86830980, 0xed48322b, 0x70ac1e11, 0x724e6c5a, 0xfffbfd0e, 0x38560f85, 0xd51e3dae, 0x3927362d, 0xd9640a0f, 0xa621685c, 0x54d19b5b, 0x2e3a2436, 0x67b10c0a, 0xe70f9357, 0x96d2b4ee, 0x919e1b9b, 0xc54f80c0, 0x20a261dc, 0x4b695a77, 0x1a161c12, 0xba0ae293, 0x2ae5c0a0, 0xe0433c22, 0x171d121b, 0x0d0b0e09, 0xc7adf28b, 0xa8b92db6, 0xa9c8141e, 0x198557f1, 0x074caf75, 0xddbbee99, 0x60fda37f, 0x269ff701, 0xf5bc5c72, 0x3bc54466, 0x7e345bfb, 0x29768b43, 0xc6dccb23, 0xfc68b6ed, 0xf163b8e4, 0xdccad731, 0x85104263, 0x22401397, 0x112084c6, 0x247d854a, 0x3df8d2bb, 0x3211aef9, 0xa16dc729, 0x2f4b1d9e, 0x30f3dcb2, 0x52ec0d86, 0xe3d077c1, 0x166c2bb3, 0xb999a970, 0x48fa1194, 0x642247e9, 0x8cc4a8fc, 0x3f1aa0f0, 0x2cd8567d, 0x90ef2233, 0x4ec78749, 0xd1c1d938, 0xa2fe8cca, 0x0b3698d4, 0x81cfa6f5, 0xde28a57a, 0x8e26dab7, 0xbfa43fad, 0x9de42c3a, 0x920d5078, 0xcc9b6a5f, 0x4662547e, 0x13c2f68d, 0xb8e890d8, 0xf75e2e39, 0xaff582c3, 0x80be9f5d, 0x937c69d0, 0x2da96fd5, 0x12b3cf25, 0x993bc8ac, 0x7da71018, 0x636ee89c, 0xbb7bdb3b, 0x7809cd26, 0x18f46e59, 0xb701ec9a, 0x9aa8834f, 0x6e65e695, 0xe67eaaff, 0xcf0821bc, 0xe8e6ef15, 0x9bd9bae7, 0x36ce4a6f, 0x09d4ea9f, 0x7cd629b0, 0xb2af31a4, 0x23312a3f, 0x9430c6a5, 0x66c035a2, 0xbc37744e, 0xcaa6fc82, 0xd0b0e090, 0xd81533a7, 0x984af104, 0xdaf741ec, 0x500e7fcd, 0xf62f1791, 0xd68d764d, 0xb04d43ef, 0x4d54ccaa, 0x04dfe496, 0xb5e39ed1, 0x881b4c6a, 0x1fb8c12c, 0x517f4665, 0xea049d5e, 0x355d018c, 0x7473fa87, 0x412efb0b, 0x1d5ab367, 0xd25292db, 0x5633e910, 0x47136dd6, 0x618c9ad7, 0x0c7a37a1, 0x148e59f8, 0x3c89eb13, 0x27eecea9, 0xc935b761, 0xe5ede11c, 0xb13c7a47, 0xdf599cd2, 0x733f55f2, 0xce791814, 0x37bf73c7, 0xcdea53f7, 0xaa5b5ffd, 0x6f14df3d, 0xdb867844, 0xf381caaf, 0xc43eb968, 0x342c3824, 0x405fc2a3, 0xc372161d, 0x250cbce2, 0x498b283c, 0x9541ff0d, 0x017139a8, 0xb3de080c, 0xe49cd8b4, 0xc1906456, 0x84617bcb, 0xb670d532, 0x5c74486c, 0x5742d0b8];
            var T8 = [0xf4a75051, 0x4165537e, 0x17a4c31a, 0x275e963a, 0xab6bcb3b, 0x9d45f11f, 0xfa58abac, 0xe303934b, 0x30fa5520, 0x766df6ad, 0xcc769188, 0x024c25f5, 0xe5d7fc4f, 0x2acbd7c5, 0x35448026, 0x62a38fb5, 0xb15a49de, 0xba1b6725, 0xea0e9845, 0xfec0e15d, 0x2f7502c3, 0x4cf01281, 0x4697a38d, 0xd3f9c66b, 0x8f5fe703, 0x929c9515, 0x6d7aebbf, 0x5259da95, 0xbe832dd4, 0x7421d358, 0xe0692949, 0xc9c8448e, 0xc2896a75, 0x8e7978f4, 0x583e6b99, 0xb971dd27, 0xe14fb6be, 0x88ad17f0, 0x20ac66c9, 0xce3ab47d, 0xdf4a1863, 0x1a3182e5, 0x51336097, 0x537f4562, 0x6477e0b1, 0x6bae84bb, 0x81a01cfe, 0x082b94f9, 0x48685870, 0x45fd198f, 0xde6c8794, 0x7bf8b752, 0x73d323ab, 0x4b02e272, 0x1f8f57e3, 0x55ab2a66, 0xeb2807b2, 0xb5c2032f, 0xc57b9a86, 0x3708a5d3, 0x2887f230, 0xbfa5b223, 0x036aba02, 0x16825ced, 0xcf1c2b8a, 0x79b492a7, 0x07f2f0f3, 0x69e2a14e, 0xdaf4cd65, 0x05bed506, 0x34621fd1, 0xa6fe8ac4, 0x2e539d34, 0xf355a0a2, 0x8ae13205, 0xf6eb75a4, 0x83ec390b, 0x60efaa40, 0x719f065e, 0x6e1051bd, 0x218af93e, 0xdd063d96, 0x3e05aedd, 0xe6bd464d, 0x548db591, 0xc45d0571, 0x06d46f04, 0x5015ff60, 0x98fb2419, 0xbde997d6, 0x4043cc89, 0xd99e7767, 0xe842bdb0, 0x898b8807, 0x195b38e7, 0xc8eedb79, 0x7c0a47a1, 0x420fe97c, 0x841ec9f8, 0x00000000, 0x80868309, 0x2bed4832, 0x1170ac1e, 0x5a724e6c, 0x0efffbfd, 0x8538560f, 0xaed51e3d, 0x2d392736, 0x0fd9640a, 0x5ca62168, 0x5b54d19b, 0x362e3a24, 0x0a67b10c, 0x57e70f93, 0xee96d2b4, 0x9b919e1b, 0xc0c54f80, 0xdc20a261, 0x774b695a, 0x121a161c, 0x93ba0ae2, 0xa02ae5c0, 0x22e0433c, 0x1b171d12, 0x090d0b0e, 0x8bc7adf2, 0xb6a8b92d, 0x1ea9c814, 0xf1198557, 0x75074caf, 0x99ddbbee, 0x7f60fda3, 0x01269ff7, 0x72f5bc5c, 0x663bc544, 0xfb7e345b, 0x4329768b, 0x23c6dccb, 0xedfc68b6, 0xe4f163b8, 0x31dccad7, 0x63851042, 0x97224013, 0xc6112084, 0x4a247d85, 0xbb3df8d2, 0xf93211ae, 0x29a16dc7, 0x9e2f4b1d, 0xb230f3dc, 0x8652ec0d, 0xc1e3d077, 0xb3166c2b, 0x70b999a9, 0x9448fa11, 0xe9642247, 0xfc8cc4a8, 0xf03f1aa0, 0x7d2cd856, 0x3390ef22, 0x494ec787, 0x38d1c1d9, 0xcaa2fe8c, 0xd40b3698, 0xf581cfa6, 0x7ade28a5, 0xb78e26da, 0xadbfa43f, 0x3a9de42c, 0x78920d50, 0x5fcc9b6a, 0x7e466254, 0x8d13c2f6, 0xd8b8e890, 0x39f75e2e, 0xc3aff582, 0x5d80be9f, 0xd0937c69, 0xd52da96f, 0x2512b3cf, 0xac993bc8, 0x187da710, 0x9c636ee8, 0x3bbb7bdb, 0x267809cd, 0x5918f46e, 0x9ab701ec, 0x4f9aa883, 0x956e65e6, 0xffe67eaa, 0xbccf0821, 0x15e8e6ef, 0xe79bd9ba, 0x6f36ce4a, 0x9f09d4ea, 0xb07cd629, 0xa4b2af31, 0x3f23312a, 0xa59430c6, 0xa266c035, 0x4ebc3774, 0x82caa6fc, 0x90d0b0e0, 0xa7d81533, 0x04984af1, 0xecdaf741, 0xcd500e7f, 0x91f62f17, 0x4dd68d76, 0xefb04d43, 0xaa4d54cc, 0x9604dfe4, 0xd1b5e39e, 0x6a881b4c, 0x2c1fb8c1, 0x65517f46, 0x5eea049d, 0x8c355d01, 0x877473fa, 0x0b412efb, 0x671d5ab3, 0xdbd25292, 0x105633e9, 0xd647136d, 0xd7618c9a, 0xa10c7a37, 0xf8148e59, 0x133c89eb, 0xa927eece, 0x61c935b7, 0x1ce5ede1, 0x47b13c7a, 0xd2df599c, 0xf2733f55, 0x14ce7918, 0xc737bf73, 0xf7cdea53, 0xfdaa5b5f, 0x3d6f14df, 0x44db8678, 0xaff381ca, 0x68c43eb9, 0x24342c38, 0xa3405fc2, 0x1dc37216, 0xe2250cbc, 0x3c498b28, 0x0d9541ff, 0xa8017139, 0x0cb3de08, 0xb4e49cd8, 0x56c19064, 0xcb84617b, 0x32b670d5, 0x6c5c7448, 0xb85742d0];

            // Transformations for decryption key expansion
            var U1 = [0x00000000, 0x0e090d0b, 0x1c121a16, 0x121b171d, 0x3824342c, 0x362d3927, 0x24362e3a, 0x2a3f2331, 0x70486858, 0x7e416553, 0x6c5a724e, 0x62537f45, 0x486c5c74, 0x4665517f, 0x547e4662, 0x5a774b69, 0xe090d0b0, 0xee99ddbb, 0xfc82caa6, 0xf28bc7ad, 0xd8b4e49c, 0xd6bde997, 0xc4a6fe8a, 0xcaaff381, 0x90d8b8e8, 0x9ed1b5e3, 0x8ccaa2fe, 0x82c3aff5, 0xa8fc8cc4, 0xa6f581cf, 0xb4ee96d2, 0xbae79bd9, 0xdb3bbb7b, 0xd532b670, 0xc729a16d, 0xc920ac66, 0xe31f8f57, 0xed16825c, 0xff0d9541, 0xf104984a, 0xab73d323, 0xa57ade28, 0xb761c935, 0xb968c43e, 0x9357e70f, 0x9d5eea04, 0x8f45fd19, 0x814cf012, 0x3bab6bcb, 0x35a266c0, 0x27b971dd, 0x29b07cd6, 0x038f5fe7, 0x0d8652ec, 0x1f9d45f1, 0x119448fa, 0x4be30393, 0x45ea0e98, 0x57f11985, 0x59f8148e, 0x73c737bf, 0x7dce3ab4, 0x6fd52da9, 0x61dc20a2, 0xad766df6, 0xa37f60fd, 0xb16477e0, 0xbf6d7aeb, 0x955259da, 0x9b5b54d1, 0x894043cc, 0x87494ec7, 0xdd3e05ae, 0xd33708a5, 0xc12c1fb8, 0xcf2512b3, 0xe51a3182, 0xeb133c89, 0xf9082b94, 0xf701269f, 0x4de6bd46, 0x43efb04d, 0x51f4a750, 0x5ffdaa5b, 0x75c2896a, 0x7bcb8461, 0x69d0937c, 0x67d99e77, 0x3daed51e, 0x33a7d815, 0x21bccf08, 0x2fb5c203, 0x058ae132, 0x0b83ec39, 0x1998fb24, 0x1791f62f, 0x764dd68d, 0x7844db86, 0x6a5fcc9b, 0x6456c190, 0x4e69e2a1, 0x4060efaa, 0x527bf8b7, 0x5c72f5bc, 0x0605bed5, 0x080cb3de, 0x1a17a4c3, 0x141ea9c8, 0x3e218af9, 0x302887f2, 0x223390ef, 0x2c3a9de4, 0x96dd063d, 0x98d40b36, 0x8acf1c2b, 0x84c61120, 0xaef93211, 0xa0f03f1a, 0xb2eb2807, 0xbce2250c, 0xe6956e65, 0xe89c636e, 0xfa877473, 0xf48e7978, 0xdeb15a49, 0xd0b85742, 0xc2a3405f, 0xccaa4d54, 0x41ecdaf7, 0x4fe5d7fc, 0x5dfec0e1, 0x53f7cdea, 0x79c8eedb, 0x77c1e3d0, 0x65daf4cd, 0x6bd3f9c6, 0x31a4b2af, 0x3fadbfa4, 0x2db6a8b9, 0x23bfa5b2, 0x09808683, 0x07898b88, 0x15929c95, 0x1b9b919e, 0xa17c0a47, 0xaf75074c, 0xbd6e1051, 0xb3671d5a, 0x99583e6b, 0x97513360, 0x854a247d, 0x8b432976, 0xd134621f, 0xdf3d6f14, 0xcd267809, 0xc32f7502, 0xe9105633, 0xe7195b38, 0xf5024c25, 0xfb0b412e, 0x9ad7618c, 0x94de6c87, 0x86c57b9a, 0x88cc7691, 0xa2f355a0, 0xacfa58ab, 0xbee14fb6, 0xb0e842bd, 0xea9f09d4, 0xe49604df, 0xf68d13c2, 0xf8841ec9, 0xd2bb3df8, 0xdcb230f3, 0xcea927ee, 0xc0a02ae5, 0x7a47b13c, 0x744ebc37, 0x6655ab2a, 0x685ca621, 0x42638510, 0x4c6a881b, 0x5e719f06, 0x5078920d, 0x0a0fd964, 0x0406d46f, 0x161dc372, 0x1814ce79, 0x322bed48, 0x3c22e043, 0x2e39f75e, 0x2030fa55, 0xec9ab701, 0xe293ba0a, 0xf088ad17, 0xfe81a01c, 0xd4be832d, 0xdab78e26, 0xc8ac993b, 0xc6a59430, 0x9cd2df59, 0x92dbd252, 0x80c0c54f, 0x8ec9c844, 0xa4f6eb75, 0xaaffe67e, 0xb8e4f163, 0xb6edfc68, 0x0c0a67b1, 0x02036aba, 0x10187da7, 0x1e1170ac, 0x342e539d, 0x3a275e96, 0x283c498b, 0x26354480, 0x7c420fe9, 0x724b02e2, 0x605015ff, 0x6e5918f4, 0x44663bc5, 0x4a6f36ce, 0x587421d3, 0x567d2cd8, 0x37a10c7a, 0x39a80171, 0x2bb3166c, 0x25ba1b67, 0x0f853856, 0x018c355d, 0x13972240, 0x1d9e2f4b, 0x47e96422, 0x49e06929, 0x5bfb7e34, 0x55f2733f, 0x7fcd500e, 0x71c45d05, 0x63df4a18, 0x6dd64713, 0xd731dcca, 0xd938d1c1, 0xcb23c6dc, 0xc52acbd7, 0xef15e8e6, 0xe11ce5ed, 0xf307f2f0, 0xfd0efffb, 0xa779b492, 0xa970b999, 0xbb6bae84, 0xb562a38f, 0x9f5d80be, 0x91548db5, 0x834f9aa8, 0x8d4697a3];
            var U2 = [0x00000000, 0x0b0e090d, 0x161c121a, 0x1d121b17, 0x2c382434, 0x27362d39, 0x3a24362e, 0x312a3f23, 0x58704868, 0x537e4165, 0x4e6c5a72, 0x4562537f, 0x74486c5c, 0x7f466551, 0x62547e46, 0x695a774b, 0xb0e090d0, 0xbbee99dd, 0xa6fc82ca, 0xadf28bc7, 0x9cd8b4e4, 0x97d6bde9, 0x8ac4a6fe, 0x81caaff3, 0xe890d8b8, 0xe39ed1b5, 0xfe8ccaa2, 0xf582c3af, 0xc4a8fc8c, 0xcfa6f581, 0xd2b4ee96, 0xd9bae79b, 0x7bdb3bbb, 0x70d532b6, 0x6dc729a1, 0x66c920ac, 0x57e31f8f, 0x5ced1682, 0x41ff0d95, 0x4af10498, 0x23ab73d3, 0x28a57ade, 0x35b761c9, 0x3eb968c4, 0x0f9357e7, 0x049d5eea, 0x198f45fd, 0x12814cf0, 0xcb3bab6b, 0xc035a266, 0xdd27b971, 0xd629b07c, 0xe7038f5f, 0xec0d8652, 0xf11f9d45, 0xfa119448, 0x934be303, 0x9845ea0e, 0x8557f119, 0x8e59f814, 0xbf73c737, 0xb47dce3a, 0xa96fd52d, 0xa261dc20, 0xf6ad766d, 0xfda37f60, 0xe0b16477, 0xebbf6d7a, 0xda955259, 0xd19b5b54, 0xcc894043, 0xc787494e, 0xaedd3e05, 0xa5d33708, 0xb8c12c1f, 0xb3cf2512, 0x82e51a31, 0x89eb133c, 0x94f9082b, 0x9ff70126, 0x464de6bd, 0x4d43efb0, 0x5051f4a7, 0x5b5ffdaa, 0x6a75c289, 0x617bcb84, 0x7c69d093, 0x7767d99e, 0x1e3daed5, 0x1533a7d8, 0x0821bccf, 0x032fb5c2, 0x32058ae1, 0x390b83ec, 0x241998fb, 0x2f1791f6, 0x8d764dd6, 0x867844db, 0x9b6a5fcc, 0x906456c1, 0xa14e69e2, 0xaa4060ef, 0xb7527bf8, 0xbc5c72f5, 0xd50605be, 0xde080cb3, 0xc31a17a4, 0xc8141ea9, 0xf93e218a, 0xf2302887, 0xef223390, 0xe42c3a9d, 0x3d96dd06, 0x3698d40b, 0x2b8acf1c, 0x2084c611, 0x11aef932, 0x1aa0f03f, 0x07b2eb28, 0x0cbce225, 0x65e6956e, 0x6ee89c63, 0x73fa8774, 0x78f48e79, 0x49deb15a, 0x42d0b857, 0x5fc2a340, 0x54ccaa4d, 0xf741ecda, 0xfc4fe5d7, 0xe15dfec0, 0xea53f7cd, 0xdb79c8ee, 0xd077c1e3, 0xcd65daf4, 0xc66bd3f9, 0xaf31a4b2, 0xa43fadbf, 0xb92db6a8, 0xb223bfa5, 0x83098086, 0x8807898b, 0x9515929c, 0x9e1b9b91, 0x47a17c0a, 0x4caf7507, 0x51bd6e10, 0x5ab3671d, 0x6b99583e, 0x60975133, 0x7d854a24, 0x768b4329, 0x1fd13462, 0x14df3d6f, 0x09cd2678, 0x02c32f75, 0x33e91056, 0x38e7195b, 0x25f5024c, 0x2efb0b41, 0x8c9ad761, 0x8794de6c, 0x9a86c57b, 0x9188cc76, 0xa0a2f355, 0xabacfa58, 0xb6bee14f, 0xbdb0e842, 0xd4ea9f09, 0xdfe49604, 0xc2f68d13, 0xc9f8841e, 0xf8d2bb3d, 0xf3dcb230, 0xeecea927, 0xe5c0a02a, 0x3c7a47b1, 0x37744ebc, 0x2a6655ab, 0x21685ca6, 0x10426385, 0x1b4c6a88, 0x065e719f, 0x0d507892, 0x640a0fd9, 0x6f0406d4, 0x72161dc3, 0x791814ce, 0x48322bed, 0x433c22e0, 0x5e2e39f7, 0x552030fa, 0x01ec9ab7, 0x0ae293ba, 0x17f088ad, 0x1cfe81a0, 0x2dd4be83, 0x26dab78e, 0x3bc8ac99, 0x30c6a594, 0x599cd2df, 0x5292dbd2, 0x4f80c0c5, 0x448ec9c8, 0x75a4f6eb, 0x7eaaffe6, 0x63b8e4f1, 0x68b6edfc, 0xb10c0a67, 0xba02036a, 0xa710187d, 0xac1e1170, 0x9d342e53, 0x963a275e, 0x8b283c49, 0x80263544, 0xe97c420f, 0xe2724b02, 0xff605015, 0xf46e5918, 0xc544663b, 0xce4a6f36, 0xd3587421, 0xd8567d2c, 0x7a37a10c, 0x7139a801, 0x6c2bb316, 0x6725ba1b, 0x560f8538, 0x5d018c35, 0x40139722, 0x4b1d9e2f, 0x2247e964, 0x2949e069, 0x345bfb7e, 0x3f55f273, 0x0e7fcd50, 0x0571c45d, 0x1863df4a, 0x136dd647, 0xcad731dc, 0xc1d938d1, 0xdccb23c6, 0xd7c52acb, 0xe6ef15e8, 0xede11ce5, 0xf0f307f2, 0xfbfd0eff, 0x92a779b4, 0x99a970b9, 0x84bb6bae, 0x8fb562a3, 0xbe9f5d80, 0xb591548d, 0xa8834f9a, 0xa38d4697];
            var U3 = [0x00000000, 0x0d0b0e09, 0x1a161c12, 0x171d121b, 0x342c3824, 0x3927362d, 0x2e3a2436, 0x23312a3f, 0x68587048, 0x65537e41, 0x724e6c5a, 0x7f456253, 0x5c74486c, 0x517f4665, 0x4662547e, 0x4b695a77, 0xd0b0e090, 0xddbbee99, 0xcaa6fc82, 0xc7adf28b, 0xe49cd8b4, 0xe997d6bd, 0xfe8ac4a6, 0xf381caaf, 0xb8e890d8, 0xb5e39ed1, 0xa2fe8cca, 0xaff582c3, 0x8cc4a8fc, 0x81cfa6f5, 0x96d2b4ee, 0x9bd9bae7, 0xbb7bdb3b, 0xb670d532, 0xa16dc729, 0xac66c920, 0x8f57e31f, 0x825ced16, 0x9541ff0d, 0x984af104, 0xd323ab73, 0xde28a57a, 0xc935b761, 0xc43eb968, 0xe70f9357, 0xea049d5e, 0xfd198f45, 0xf012814c, 0x6bcb3bab, 0x66c035a2, 0x71dd27b9, 0x7cd629b0, 0x5fe7038f, 0x52ec0d86, 0x45f11f9d, 0x48fa1194, 0x03934be3, 0x0e9845ea, 0x198557f1, 0x148e59f8, 0x37bf73c7, 0x3ab47dce, 0x2da96fd5, 0x20a261dc, 0x6df6ad76, 0x60fda37f, 0x77e0b164, 0x7aebbf6d, 0x59da9552, 0x54d19b5b, 0x43cc8940, 0x4ec78749, 0x05aedd3e, 0x08a5d337, 0x1fb8c12c, 0x12b3cf25, 0x3182e51a, 0x3c89eb13, 0x2b94f908, 0x269ff701, 0xbd464de6, 0xb04d43ef, 0xa75051f4, 0xaa5b5ffd, 0x896a75c2, 0x84617bcb, 0x937c69d0, 0x9e7767d9, 0xd51e3dae, 0xd81533a7, 0xcf0821bc, 0xc2032fb5, 0xe132058a, 0xec390b83, 0xfb241998, 0xf62f1791, 0xd68d764d, 0xdb867844, 0xcc9b6a5f, 0xc1906456, 0xe2a14e69, 0xefaa4060, 0xf8b7527b, 0xf5bc5c72, 0xbed50605, 0xb3de080c, 0xa4c31a17, 0xa9c8141e, 0x8af93e21, 0x87f23028, 0x90ef2233, 0x9de42c3a, 0x063d96dd, 0x0b3698d4, 0x1c2b8acf, 0x112084c6, 0x3211aef9, 0x3f1aa0f0, 0x2807b2eb, 0x250cbce2, 0x6e65e695, 0x636ee89c, 0x7473fa87, 0x7978f48e, 0x5a49deb1, 0x5742d0b8, 0x405fc2a3, 0x4d54ccaa, 0xdaf741ec, 0xd7fc4fe5, 0xc0e15dfe, 0xcdea53f7, 0xeedb79c8, 0xe3d077c1, 0xf4cd65da, 0xf9c66bd3, 0xb2af31a4, 0xbfa43fad, 0xa8b92db6, 0xa5b223bf, 0x86830980, 0x8b880789, 0x9c951592, 0x919e1b9b, 0x0a47a17c, 0x074caf75, 0x1051bd6e, 0x1d5ab367, 0x3e6b9958, 0x33609751, 0x247d854a, 0x29768b43, 0x621fd134, 0x6f14df3d, 0x7809cd26, 0x7502c32f, 0x5633e910, 0x5b38e719, 0x4c25f502, 0x412efb0b, 0x618c9ad7, 0x6c8794de, 0x7b9a86c5, 0x769188cc, 0x55a0a2f3, 0x58abacfa, 0x4fb6bee1, 0x42bdb0e8, 0x09d4ea9f, 0x04dfe496, 0x13c2f68d, 0x1ec9f884, 0x3df8d2bb, 0x30f3dcb2, 0x27eecea9, 0x2ae5c0a0, 0xb13c7a47, 0xbc37744e, 0xab2a6655, 0xa621685c, 0x85104263, 0x881b4c6a, 0x9f065e71, 0x920d5078, 0xd9640a0f, 0xd46f0406, 0xc372161d, 0xce791814, 0xed48322b, 0xe0433c22, 0xf75e2e39, 0xfa552030, 0xb701ec9a, 0xba0ae293, 0xad17f088, 0xa01cfe81, 0x832dd4be, 0x8e26dab7, 0x993bc8ac, 0x9430c6a5, 0xdf599cd2, 0xd25292db, 0xc54f80c0, 0xc8448ec9, 0xeb75a4f6, 0xe67eaaff, 0xf163b8e4, 0xfc68b6ed, 0x67b10c0a, 0x6aba0203, 0x7da71018, 0x70ac1e11, 0x539d342e, 0x5e963a27, 0x498b283c, 0x44802635, 0x0fe97c42, 0x02e2724b, 0x15ff6050, 0x18f46e59, 0x3bc54466, 0x36ce4a6f, 0x21d35874, 0x2cd8567d, 0x0c7a37a1, 0x017139a8, 0x166c2bb3, 0x1b6725ba, 0x38560f85, 0x355d018c, 0x22401397, 0x2f4b1d9e, 0x642247e9, 0x692949e0, 0x7e345bfb, 0x733f55f2, 0x500e7fcd, 0x5d0571c4, 0x4a1863df, 0x47136dd6, 0xdccad731, 0xd1c1d938, 0xc6dccb23, 0xcbd7c52a, 0xe8e6ef15, 0xe5ede11c, 0xf2f0f307, 0xfffbfd0e, 0xb492a779, 0xb999a970, 0xae84bb6b, 0xa38fb562, 0x80be9f5d, 0x8db59154, 0x9aa8834f, 0x97a38d46];
            var U4 = [0x00000000, 0x090d0b0e, 0x121a161c, 0x1b171d12, 0x24342c38, 0x2d392736, 0x362e3a24, 0x3f23312a, 0x48685870, 0x4165537e, 0x5a724e6c, 0x537f4562, 0x6c5c7448, 0x65517f46, 0x7e466254, 0x774b695a, 0x90d0b0e0, 0x99ddbbee, 0x82caa6fc, 0x8bc7adf2, 0xb4e49cd8, 0xbde997d6, 0xa6fe8ac4, 0xaff381ca, 0xd8b8e890, 0xd1b5e39e, 0xcaa2fe8c, 0xc3aff582, 0xfc8cc4a8, 0xf581cfa6, 0xee96d2b4, 0xe79bd9ba, 0x3bbb7bdb, 0x32b670d5, 0x29a16dc7, 0x20ac66c9, 0x1f8f57e3, 0x16825ced, 0x0d9541ff, 0x04984af1, 0x73d323ab, 0x7ade28a5, 0x61c935b7, 0x68c43eb9, 0x57e70f93, 0x5eea049d, 0x45fd198f, 0x4cf01281, 0xab6bcb3b, 0xa266c035, 0xb971dd27, 0xb07cd629, 0x8f5fe703, 0x8652ec0d, 0x9d45f11f, 0x9448fa11, 0xe303934b, 0xea0e9845, 0xf1198557, 0xf8148e59, 0xc737bf73, 0xce3ab47d, 0xd52da96f, 0xdc20a261, 0x766df6ad, 0x7f60fda3, 0x6477e0b1, 0x6d7aebbf, 0x5259da95, 0x5b54d19b, 0x4043cc89, 0x494ec787, 0x3e05aedd, 0x3708a5d3, 0x2c1fb8c1, 0x2512b3cf, 0x1a3182e5, 0x133c89eb, 0x082b94f9, 0x01269ff7, 0xe6bd464d, 0xefb04d43, 0xf4a75051, 0xfdaa5b5f, 0xc2896a75, 0xcb84617b, 0xd0937c69, 0xd99e7767, 0xaed51e3d, 0xa7d81533, 0xbccf0821, 0xb5c2032f, 0x8ae13205, 0x83ec390b, 0x98fb2419, 0x91f62f17, 0x4dd68d76, 0x44db8678, 0x5fcc9b6a, 0x56c19064, 0x69e2a14e, 0x60efaa40, 0x7bf8b752, 0x72f5bc5c, 0x05bed506, 0x0cb3de08, 0x17a4c31a, 0x1ea9c814, 0x218af93e, 0x2887f230, 0x3390ef22, 0x3a9de42c, 0xdd063d96, 0xd40b3698, 0xcf1c2b8a, 0xc6112084, 0xf93211ae, 0xf03f1aa0, 0xeb2807b2, 0xe2250cbc, 0x956e65e6, 0x9c636ee8, 0x877473fa, 0x8e7978f4, 0xb15a49de, 0xb85742d0, 0xa3405fc2, 0xaa4d54cc, 0xecdaf741, 0xe5d7fc4f, 0xfec0e15d, 0xf7cdea53, 0xc8eedb79, 0xc1e3d077, 0xdaf4cd65, 0xd3f9c66b, 0xa4b2af31, 0xadbfa43f, 0xb6a8b92d, 0xbfa5b223, 0x80868309, 0x898b8807, 0x929c9515, 0x9b919e1b, 0x7c0a47a1, 0x75074caf, 0x6e1051bd, 0x671d5ab3, 0x583e6b99, 0x51336097, 0x4a247d85, 0x4329768b, 0x34621fd1, 0x3d6f14df, 0x267809cd, 0x2f7502c3, 0x105633e9, 0x195b38e7, 0x024c25f5, 0x0b412efb, 0xd7618c9a, 0xde6c8794, 0xc57b9a86, 0xcc769188, 0xf355a0a2, 0xfa58abac, 0xe14fb6be, 0xe842bdb0, 0x9f09d4ea, 0x9604dfe4, 0x8d13c2f6, 0x841ec9f8, 0xbb3df8d2, 0xb230f3dc, 0xa927eece, 0xa02ae5c0, 0x47b13c7a, 0x4ebc3774, 0x55ab2a66, 0x5ca62168, 0x63851042, 0x6a881b4c, 0x719f065e, 0x78920d50, 0x0fd9640a, 0x06d46f04, 0x1dc37216, 0x14ce7918, 0x2bed4832, 0x22e0433c, 0x39f75e2e, 0x30fa5520, 0x9ab701ec, 0x93ba0ae2, 0x88ad17f0, 0x81a01cfe, 0xbe832dd4, 0xb78e26da, 0xac993bc8, 0xa59430c6, 0xd2df599c, 0xdbd25292, 0xc0c54f80, 0xc9c8448e, 0xf6eb75a4, 0xffe67eaa, 0xe4f163b8, 0xedfc68b6, 0x0a67b10c, 0x036aba02, 0x187da710, 0x1170ac1e, 0x2e539d34, 0x275e963a, 0x3c498b28, 0x35448026, 0x420fe97c, 0x4b02e272, 0x5015ff60, 0x5918f46e, 0x663bc544, 0x6f36ce4a, 0x7421d358, 0x7d2cd856, 0xa10c7a37, 0xa8017139, 0xb3166c2b, 0xba1b6725, 0x8538560f, 0x8c355d01, 0x97224013, 0x9e2f4b1d, 0xe9642247, 0xe0692949, 0xfb7e345b, 0xf2733f55, 0xcd500e7f, 0xc45d0571, 0xdf4a1863, 0xd647136d, 0x31dccad7, 0x38d1c1d9, 0x23c6dccb, 0x2acbd7c5, 0x15e8e6ef, 0x1ce5ede1, 0x07f2f0f3, 0x0efffbfd, 0x79b492a7, 0x70b999a9, 0x6bae84bb, 0x62a38fb5, 0x5d80be9f, 0x548db591, 0x4f9aa883, 0x4697a38d];

            function convertToInt32(bytes) {
                var result = [];
                for (var i = 0; i < bytes.length; i += 4) {
                    result.push(
                        (bytes[i    ] << 24) |
                        (bytes[i + 1] << 16) |
                        (bytes[i + 2] <<  8) |
                        bytes[i + 3]
                    );
                }
                return result;
            }

            var AES = function(key) {
                if (!(this instanceof AES)) {
                    throw Error('AES must be instanitated with `new`');
                }

                Object.defineProperty(this, 'key', {
                    value: coerceArray(key, true)
                });

                this._prepare();
            }


            AES.prototype._prepare = function() {

                var rounds = numberOfRounds[this.key.length];
                if (rounds == null) {
                    throw new Error('invalid key size (must be 16, 24 or 32 bytes)');
                }

                // encryption round keys
                this._Ke = [];

                // decryption round keys
                this._Kd = [];

                for (var i = 0; i <= rounds; i++) {
                    this._Ke.push([0, 0, 0, 0]);
                    this._Kd.push([0, 0, 0, 0]);
                }

                var roundKeyCount = (rounds + 1) * 4;
                var KC = this.key.length / 4;

                // convert the key into ints
                var tk = convertToInt32(this.key);

                // copy values into round key arrays
                var index;
                for (var i = 0; i < KC; i++) {
                    index = i >> 2;
                    this._Ke[index][i % 4] = tk[i];
                    this._Kd[rounds - index][i % 4] = tk[i];
                }

                // key expansion (fips-197 section 5.2)
                var rconpointer = 0;
                var t = KC, tt;
                while (t < roundKeyCount) {
                    tt = tk[KC - 1];
                    tk[0] ^= ((S[(tt >> 16) & 0xFF] << 24) ^
                        (S[(tt >>  8) & 0xFF] << 16) ^
                        (S[ tt        & 0xFF] <<  8) ^
                        S[(tt >> 24) & 0xFF]        ^
                        (rcon[rconpointer] << 24));
                    rconpointer += 1;

                    // key expansion (for non-256 bit)
                    if (KC != 8) {
                        for (var i = 1; i < KC; i++) {
                            tk[i] ^= tk[i - 1];
                        }

                        // key expansion for 256-bit keys is "slightly different" (fips-197)
                    } else {
                        for (var i = 1; i < (KC / 2); i++) {
                            tk[i] ^= tk[i - 1];
                        }
                        tt = tk[(KC / 2) - 1];

                        tk[KC / 2] ^= (S[ tt        & 0xFF]        ^
                            (S[(tt >>  8) & 0xFF] <<  8) ^
                            (S[(tt >> 16) & 0xFF] << 16) ^
                            (S[(tt >> 24) & 0xFF] << 24));

                        for (var i = (KC / 2) + 1; i < KC; i++) {
                            tk[i] ^= tk[i - 1];
                        }
                    }

                    // copy values into round key arrays
                    var i = 0, r, c;
                    while (i < KC && t < roundKeyCount) {
                        r = t >> 2;
                        c = t % 4;
                        this._Ke[r][c] = tk[i];
                        this._Kd[rounds - r][c] = tk[i++];
                        t++;
                    }
                }

                // inverse-cipher-ify the decryption round key (fips-197 section 5.3)
                for (var r = 1; r < rounds; r++) {
                    for (var c = 0; c < 4; c++) {
                        tt = this._Kd[r][c];
                        this._Kd[r][c] = (U1[(tt >> 24) & 0xFF] ^
                            U2[(tt >> 16) & 0xFF] ^
                            U3[(tt >>  8) & 0xFF] ^
                            U4[ tt        & 0xFF]);
                    }
                }
            }

            AES.prototype.encrypt = function(plaintext) {
                if (plaintext.length != 16) {
                    throw new Error('invalid plaintext size (must be 16 bytes)');
                }

                var rounds = this._Ke.length - 1;
                var a = [0, 0, 0, 0];

                // convert plaintext to (ints ^ key)
                var t = convertToInt32(plaintext);
                for (var i = 0; i < 4; i++) {
                    t[i] ^= this._Ke[0][i];
                }

                // apply round transforms
                for (var r = 1; r < rounds; r++) {
                    for (var i = 0; i < 4; i++) {
                        a[i] = (T1[(t[ i         ] >> 24) & 0xff] ^
                            T2[(t[(i + 1) % 4] >> 16) & 0xff] ^
                            T3[(t[(i + 2) % 4] >>  8) & 0xff] ^
                            T4[ t[(i + 3) % 4]        & 0xff] ^
                            this._Ke[r][i]);
                    }
                    t = a.slice();
                }

                // the last round is special
                var result = createArray(16), tt;
                for (var i = 0; i < 4; i++) {
                    tt = this._Ke[rounds][i];
                    result[4 * i    ] = (S[(t[ i         ] >> 24) & 0xff] ^ (tt >> 24)) & 0xff;
                    result[4 * i + 1] = (S[(t[(i + 1) % 4] >> 16) & 0xff] ^ (tt >> 16)) & 0xff;
                    result[4 * i + 2] = (S[(t[(i + 2) % 4] >>  8) & 0xff] ^ (tt >>  8)) & 0xff;
                    result[4 * i + 3] = (S[ t[(i + 3) % 4]        & 0xff] ^  tt       ) & 0xff;
                }

                return result;
            }

            AES.prototype.decrypt = function(ciphertext) {
                if (ciphertext.length != 16) {
                    throw new Error('invalid ciphertext size (must be 16 bytes)');
                }

                var rounds = this._Kd.length - 1;
                var a = [0, 0, 0, 0];

                // convert plaintext to (ints ^ key)
                var t = convertToInt32(ciphertext);
                for (var i = 0; i < 4; i++) {
                    t[i] ^= this._Kd[0][i];
                }

                // apply round transforms
                for (var r = 1; r < rounds; r++) {
                    for (var i = 0; i < 4; i++) {
                        a[i] = (T5[(t[ i          ] >> 24) & 0xff] ^
                            T6[(t[(i + 3) % 4] >> 16) & 0xff] ^
                            T7[(t[(i + 2) % 4] >>  8) & 0xff] ^
                            T8[ t[(i + 1) % 4]        & 0xff] ^
                            this._Kd[r][i]);
                    }
                    t = a.slice();
                }

                // the last round is special
                var result = createArray(16), tt;
                for (var i = 0; i < 4; i++) {
                    tt = this._Kd[rounds][i];
                    result[4 * i    ] = (Si[(t[ i         ] >> 24) & 0xff] ^ (tt >> 24)) & 0xff;
                    result[4 * i + 1] = (Si[(t[(i + 3) % 4] >> 16) & 0xff] ^ (tt >> 16)) & 0xff;
                    result[4 * i + 2] = (Si[(t[(i + 2) % 4] >>  8) & 0xff] ^ (tt >>  8)) & 0xff;
                    result[4 * i + 3] = (Si[ t[(i + 1) % 4]        & 0xff] ^  tt       ) & 0xff;
                }

                return result;
            }


            /**
             *  Mode Of Operation - Electonic Codebook (ECB)
             */
            var ModeOfOperationECB = function(key) {
                if (!(this instanceof ModeOfOperationECB)) {
                    throw Error('AES must be instanitated with `new`');
                }

                this.description = "Electronic Code Block";
                this.name = "ecb";

                this._aes = new AES(key);
            }

            ModeOfOperationECB.prototype.encrypt = function(plaintext) {
                plaintext = coerceArray(plaintext);

                if ((plaintext.length % 16) !== 0) {
                    throw new Error('invalid plaintext size (must be multiple of 16 bytes)');
                }

                var ciphertext = createArray(plaintext.length);
                var block = createArray(16);

                for (var i = 0; i < plaintext.length; i += 16) {
                    copyArray(plaintext, block, 0, i, i + 16);
                    block = this._aes.encrypt(block);
                    copyArray(block, ciphertext, i);
                }

                return ciphertext;
            }

            ModeOfOperationECB.prototype.decrypt = function(ciphertext) {
                ciphertext = coerceArray(ciphertext);

                if ((ciphertext.length % 16) !== 0) {
                    throw new Error('invalid ciphertext size (must be multiple of 16 bytes)');
                }

                var plaintext = createArray(ciphertext.length);
                var block = createArray(16);

                for (var i = 0; i < ciphertext.length; i += 16) {
                    copyArray(ciphertext, block, 0, i, i + 16);
                    block = this._aes.decrypt(block);
                    copyArray(block, plaintext, i);
                }

                return plaintext;
            }


            /**
             *  Mode Of Operation - Cipher Block Chaining (CBC)
             */
            var ModeOfOperationCBC = function(key, iv) {
                if (!(this instanceof ModeOfOperationCBC)) {
                    throw Error('AES must be instanitated with `new`');
                }

                this.description = "Cipher Block Chaining";
                this.name = "cbc";

                if (!iv) {
                    iv = createArray(16);

                } else if (iv.length != 16) {
                    throw new Error('invalid initialation vector size (must be 16 bytes)');
                }

                this._lastCipherblock = coerceArray(iv, true);

                this._aes = new AES(key);
            }

            ModeOfOperationCBC.prototype.encrypt = function(plaintext) {
                plaintext = coerceArray(plaintext);

                if ((plaintext.length % 16) !== 0) {
                    throw new Error('invalid plaintext size (must be multiple of 16 bytes)');
                }

                var ciphertext = createArray(plaintext.length);
                var block = createArray(16);

                for (var i = 0; i < plaintext.length; i += 16) {
                    copyArray(plaintext, block, 0, i, i + 16);

                    for (var j = 0; j < 16; j++) {
                        block[j] ^= this._lastCipherblock[j];
                    }

                    this._lastCipherblock = this._aes.encrypt(block);
                    copyArray(this._lastCipherblock, ciphertext, i);
                }

                return ciphertext;
            }

            ModeOfOperationCBC.prototype.decrypt = function(ciphertext) {
                ciphertext = coerceArray(ciphertext);

                if ((ciphertext.length % 16) !== 0) {
                    throw new Error('invalid ciphertext size (must be multiple of 16 bytes)');
                }

                var plaintext = createArray(ciphertext.length);
                var block = createArray(16);

                for (var i = 0; i < ciphertext.length; i += 16) {
                    copyArray(ciphertext, block, 0, i, i + 16);
                    block = this._aes.decrypt(block);

                    for (var j = 0; j < 16; j++) {
                        plaintext[i + j] = block[j] ^ this._lastCipherblock[j];
                    }

                    copyArray(ciphertext, this._lastCipherblock, 0, i, i + 16);
                }

                return plaintext;
            }


            /**
             *  Mode Of Operation - Cipher Feedback (CFB)
             */
            var ModeOfOperationCFB = function(key, iv, segmentSize) {
                if (!(this instanceof ModeOfOperationCFB)) {
                    throw Error('AES must be instanitated with `new`');
                }

                this.description = "Cipher Feedback";
                this.name = "cfb";

                if (!iv) {
                    iv = createArray(16);

                } else if (iv.length != 16) {
                    throw new Error('invalid initialation vector size (must be 16 size)');
                }

                if (!segmentSize) { segmentSize = 1; }

                this.segmentSize = segmentSize;

                this._shiftRegister = coerceArray(iv, true);

                this._aes = new AES(key);
            }

            ModeOfOperationCFB.prototype.encrypt = function(plaintext) {
                if ((plaintext.length % this.segmentSize) != 0) {
                    throw new Error('invalid plaintext size (must be segmentSize bytes)');
                }

                var encrypted = coerceArray(plaintext, true);

                var xorSegment;
                for (var i = 0; i < encrypted.length; i += this.segmentSize) {
                    xorSegment = this._aes.encrypt(this._shiftRegister);
                    for (var j = 0; j < this.segmentSize; j++) {
                        encrypted[i + j] ^= xorSegment[j];
                    }

                    // Shift the register
                    copyArray(this._shiftRegister, this._shiftRegister, 0, this.segmentSize);
                    copyArray(encrypted, this._shiftRegister, 16 - this.segmentSize, i, i + this.segmentSize);
                }

                return encrypted;
            }

            ModeOfOperationCFB.prototype.decrypt = function(ciphertext) {
                if ((ciphertext.length % this.segmentSize) != 0) {
                    throw new Error('invalid ciphertext size (must be segmentSize bytes)');
                }

                var plaintext = coerceArray(ciphertext, true);

                var xorSegment;
                for (var i = 0; i < plaintext.length; i += this.segmentSize) {
                    xorSegment = this._aes.encrypt(this._shiftRegister);

                    for (var j = 0; j < this.segmentSize; j++) {
                        plaintext[i + j] ^= xorSegment[j];
                    }

                    // Shift the register
                    copyArray(this._shiftRegister, this._shiftRegister, 0, this.segmentSize);
                    copyArray(ciphertext, this._shiftRegister, 16 - this.segmentSize, i, i + this.segmentSize);
                }

                return plaintext;
            }

            /**
             *  Mode Of Operation - Output Feedback (OFB)
             */
            var ModeOfOperationOFB = function(key, iv) {
                if (!(this instanceof ModeOfOperationOFB)) {
                    throw Error('AES must be instanitated with `new`');
                }

                this.description = "Output Feedback";
                this.name = "ofb";

                if (!iv) {
                    iv = createArray(16);

                } else if (iv.length != 16) {
                    throw new Error('invalid initialation vector size (must be 16 bytes)');
                }

                this._lastPrecipher = coerceArray(iv, true);
                this._lastPrecipherIndex = 16;

                this._aes = new AES(key);
            }

            ModeOfOperationOFB.prototype.encrypt = function(plaintext) {
                var encrypted = coerceArray(plaintext, true);

                for (var i = 0; i < encrypted.length; i++) {
                    if (this._lastPrecipherIndex === 16) {
                        this._lastPrecipher = this._aes.encrypt(this._lastPrecipher);
                        this._lastPrecipherIndex = 0;
                    }
                    encrypted[i] ^= this._lastPrecipher[this._lastPrecipherIndex++];
                }

                return encrypted;
            }

            // Decryption is symetric
            ModeOfOperationOFB.prototype.decrypt = ModeOfOperationOFB.prototype.encrypt;


            /**
             *  Counter object for CTR common mode of operation
             */
            var Counter = function(initialValue) {
                if (!(this instanceof Counter)) {
                    throw Error('Counter must be instanitated with `new`');
                }

                // We allow 0, but anything false-ish uses the default 1
                if (initialValue !== 0 && !initialValue) { initialValue = 1; }

                if (typeof(initialValue) === 'number') {
                    this._counter = createArray(16);
                    this.setValue(initialValue);

                } else {
                    this.setBytes(initialValue);
                }
            }

            Counter.prototype.setValue = function(value) {
                if (typeof(value) !== 'number' || parseInt(value) != value) {
                    throw new Error('invalid counter value (must be an integer)');
                }

                // We cannot safely handle numbers beyond the safe range for integers
                if (value > Number.MAX_SAFE_INTEGER) {
                    throw new Error('integer value out of safe range');
                }

                for (var index = 15; index >= 0; --index) {
                    this._counter[index] = value % 256;
                    value = parseInt(value / 256);
                }
            }

            Counter.prototype.setBytes = function(bytes) {
                bytes = coerceArray(bytes, true);

                if (bytes.length != 16) {
                    throw new Error('invalid counter bytes size (must be 16 bytes)');
                }

                this._counter = bytes;
            };

            Counter.prototype.increment = function() {
                for (var i = 15; i >= 0; i--) {
                    if (this._counter[i] === 255) {
                        this._counter[i] = 0;
                    } else {
                        this._counter[i]++;
                        break;
                    }
                }
            }


            /**
             *  Mode Of Operation - Counter (CTR)
             */
            var ModeOfOperationCTR = function(key, counter) {
                if (!(this instanceof ModeOfOperationCTR)) {
                    throw Error('AES must be instanitated with `new`');
                }

                this.description = "Counter";
                this.name = "ctr";

                if (!(counter instanceof Counter)) {
                    counter = new Counter(counter)
                }

                this._counter = counter;

                this._remainingCounter = null;
                this._remainingCounterIndex = 16;

                this._aes = new AES(key);
            }

            ModeOfOperationCTR.prototype.encrypt = function(plaintext) {
                var encrypted = coerceArray(plaintext, true);

                for (var i = 0; i < encrypted.length; i++) {
                    if (this._remainingCounterIndex === 16) {
                        this._remainingCounter = this._aes.encrypt(this._counter._counter);
                        this._remainingCounterIndex = 0;
                        this._counter.increment();
                    }
                    encrypted[i] ^= this._remainingCounter[this._remainingCounterIndex++];
                }

                return encrypted;
            }

            // Decryption is symetric
            ModeOfOperationCTR.prototype.decrypt = ModeOfOperationCTR.prototype.encrypt;


            ///////////////////////
            // Padding

            // See:https://tools.ietf.org/html/rfc2315
            function pkcs7pad(data) {
                data = coerceArray(data, true);
                var padder = 16 - (data.length % 16);
                var result = createArray(data.length + padder);
                copyArray(data, result);
                for (var i = data.length; i < result.length; i++) {
                    result[i] = padder;
                }
                return result;
            }

            function pkcs7strip(data) {
                data = coerceArray(data, true);
                if (data.length < 16) { throw new Error('PKCS#7 invalid length'); }

                var padder = data[data.length - 1];
                if (padder > 16) { throw new Error('PKCS#7 padding byte out of range'); }

                var length = data.length - padder;
                for (var i = 0; i < padder; i++) {
                    if (data[length + i] !== padder) {
                        throw new Error('PKCS#7 invalid padding byte');
                    }
                }

                var result = createArray(length);
                copyArray(data, result, 0, 0, length);
                return result;
            }

            ///////////////////////
            // Exporting


            // The block cipher
            var aesjs = {
                AES: AES,
                Counter: Counter,

                ModeOfOperation: {
                    ecb: ModeOfOperationECB,
                    cbc: ModeOfOperationCBC,
                    cfb: ModeOfOperationCFB,
                    ofb: ModeOfOperationOFB,
                    ctr: ModeOfOperationCTR
                },

                utils: {
                    hex: convertHex,
                    utf8: convertUtf8
                },

                padding: {
                    pkcs7: {
                        pad: pkcs7pad,
                        strip: pkcs7strip
                    }
                },

                _arrayTest: {
                    coerceArray: coerceArray,
                    createArray: createArray,
                    copyArray: copyArray,
                }
            };


            // node.js
            if (typeof exports !== 'undefined') {
                // module.exports = aesjs

                // RequireJS/AMD
                // http://www.requirejs.org/docs/api.html
                // https://github.com/amdjs/amdjs-api/wiki/AMD
            } else if (typeof(define) === 'function' && __webpack_require__(100)) {
                define(aesjs);

                // Web Browsers
            } else {

                // If there was an existing library at "aesjs" make sure it's still available
                if (root.aesjs) {
                    aesjs._aesjs = root.aesjs;
                }

                root.aesjs = aesjs;
            }


        })(this);
    }
}

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_LOCAL_MODULE_0__, __WEBPACK_LOCAL_MODULE_0__module;var __WEBPACK_LOCAL_MODULE_1__, __WEBPACK_LOCAL_MODULE_1__module;var __WEBPACK_LOCAL_MODULE_2__, __WEBPACK_LOCAL_MODULE_2__module;var __WEBPACK_LOCAL_MODULE_3__, __WEBPACK_LOCAL_MODULE_3__module;var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_LOCAL_MODULE_4__;var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_LOCAL_MODULE_5__;var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_LOCAL_MODULE_6__;var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_LOCAL_MODULE_7__;var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/** File: strophe.js
 *  A JavaScript library for writing XMPP clients.
 *
 *  This library uses either Bidirectional-streams Over Synchronous HTTP (BOSH)
 *  to emulate a persistent, stateful, two-way connection to an XMPP server or
 *  alternatively WebSockets.
 *
 *  More information on BOSH can be found in XEP 124.
 *  For more information on XMPP-over WebSocket see this RFC:
 *  http://tools.ietf.org/html/rfc7395
 */

/* All of the Strophe globals are defined in this special function below so
 * that references to the globals become closures.  This will ensure that
 * on page reload, these references will still be available to callbacks
 * that are still executing.
 */

// This code was written by Tyler Akins and has been placed in the
// public domain.  It would be nice if you left this header intact.
// Base64 code from Tyler Akins -- http://rumkin.com

    (function (root, factory) {
        if (true) {
            !(__WEBPACK_LOCAL_MODULE_0__module = { id: "strophe-base64", exports: {}, loaded: false }, __WEBPACK_LOCAL_MODULE_0__ = function () {
                return factory();
            }.call(__WEBPACK_LOCAL_MODULE_0__module.exports, __webpack_require__, __WEBPACK_LOCAL_MODULE_0__module.exports, __WEBPACK_LOCAL_MODULE_0__module), __WEBPACK_LOCAL_MODULE_0__module.loaded = true, __WEBPACK_LOCAL_MODULE_0__ === undefined && (__WEBPACK_LOCAL_MODULE_0__ = __WEBPACK_LOCAL_MODULE_0__module.exports));
        } else {
            // Browser globals
            root.Base64 = factory();
        }
    }(this, function () {
        var keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";

        var obj = {
            /**
             * Encodes a string in base64
             * @param {String} input The string to encode in base64.
             */
            encode: function (input) {
                var output = "";
                var chr1, chr2, chr3;
                var enc1, enc2, enc3, enc4;
                var i = 0;

                do {
                    chr1 = input.charCodeAt(i++);
                    chr2 = input.charCodeAt(i++);
                    chr3 = input.charCodeAt(i++);

                    enc1 = chr1 >> 2;
                    enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
                    enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
                    enc4 = chr3 & 63;

                    if (isNaN(chr2)) {
                        enc2 = ((chr1 & 3) << 4);
                        enc3 = enc4 = 64;
                    } else if (isNaN(chr3)) {
                        enc4 = 64;
                    }

                    output = output + keyStr.charAt(enc1) + keyStr.charAt(enc2) +
                        keyStr.charAt(enc3) + keyStr.charAt(enc4);
                } while (i < input.length);

                return output;
            },

            /**
             * Decodes a base64 string.
             * @param {String} input The string to decode.
             */
            decode: function (input) {
                var output = "";
                var chr1, chr2, chr3;
                var enc1, enc2, enc3, enc4;
                var i = 0;

                // remove all characters that are not A-Z, a-z, 0-9, +, /, or =
                input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");

                do {
                    enc1 = keyStr.indexOf(input.charAt(i++));
                    enc2 = keyStr.indexOf(input.charAt(i++));
                    enc3 = keyStr.indexOf(input.charAt(i++));
                    enc4 = keyStr.indexOf(input.charAt(i++));

                    chr1 = (enc1 << 2) | (enc2 >> 4);
                    chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
                    chr3 = ((enc3 & 3) << 6) | enc4;

                    output = output + String.fromCharCode(chr1);

                    if (enc3 != 64) {
                        output = output + String.fromCharCode(chr2);
                    }
                    if (enc4 != 64) {
                        output = output + String.fromCharCode(chr3);
                    }
                } while (i < input.length);

                return output;
            }
        };
        return obj;
    }));

    /*
     * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
     * in FIPS PUB 180-1
     * Version 2.1a Copyright Paul Johnston 2000 - 2002.
     * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
     * Distributed under the BSD License
     * See http://pajhome.org.uk/crypt/md5 for details.
     */

    /* jshint undef: true, unused: true:, noarg: true, latedef: false */
    /* global define */

    /* Some functions and variables have been stripped for use with Strophe */

    (function (root, factory) {
        if (true) {
            !(__WEBPACK_LOCAL_MODULE_1__module = { id: "strophe-sha1", exports: {}, loaded: false }, __WEBPACK_LOCAL_MODULE_1__ = function () {
                return factory();
            }.call(__WEBPACK_LOCAL_MODULE_1__module.exports, __webpack_require__, __WEBPACK_LOCAL_MODULE_1__module.exports, __WEBPACK_LOCAL_MODULE_1__module), __WEBPACK_LOCAL_MODULE_1__module.loaded = true, __WEBPACK_LOCAL_MODULE_1__ === undefined && (__WEBPACK_LOCAL_MODULE_1__ = __WEBPACK_LOCAL_MODULE_1__module.exports));
        } else {
            // Browser globals
            root.SHA1 = factory();
        }
    }(this, function () {

        /*
         * Calculate the SHA-1 of an array of big-endian words, and a bit length
         */
        function core_sha1(x, len)
        {
            /* append padding */
            x[len >> 5] |= 0x80 << (24 - len % 32);
            x[((len + 64 >> 9) << 4) + 15] = len;

            var w = new Array(80);
            var a =  1732584193;
            var b = -271733879;
            var c = -1732584194;
            var d =  271733878;
            var e = -1009589776;

            var i, j, t, olda, oldb, oldc, oldd, olde;
            for (i = 0; i < x.length; i += 16)
            {
                olda = a;
                oldb = b;
                oldc = c;
                oldd = d;
                olde = e;

                for (j = 0; j < 80; j++)
                {
                    if (j < 16) { w[j] = x[i + j]; }
                    else { w[j] = rol(w[j-3] ^ w[j-8] ^ w[j-14] ^ w[j-16], 1); }
                    t = safe_add(safe_add(rol(a, 5), sha1_ft(j, b, c, d)),
                        safe_add(safe_add(e, w[j]), sha1_kt(j)));
                    e = d;
                    d = c;
                    c = rol(b, 30);
                    b = a;
                    a = t;
                }

                a = safe_add(a, olda);
                b = safe_add(b, oldb);
                c = safe_add(c, oldc);
                d = safe_add(d, oldd);
                e = safe_add(e, olde);
            }
            return [a, b, c, d, e];
        }

        /*
         * Perform the appropriate triplet combination function for the current
         * iteration
         */
        function sha1_ft(t, b, c, d)
        {
            if (t < 20) { return (b & c) | ((~b) & d); }
            if (t < 40) { return b ^ c ^ d; }
            if (t < 60) { return (b & c) | (b & d) | (c & d); }
            return b ^ c ^ d;
        }

        /*
         * Determine the appropriate additive constant for the current iteration
         */
        function sha1_kt(t)
        {
            return (t < 20) ?  1518500249 : (t < 40) ?  1859775393 :
                (t < 60) ? -1894007588 : -899497514;
        }

        /*
         * Calculate the HMAC-SHA1 of a key and some data
         */
        function core_hmac_sha1(key, data)
        {
            var bkey = str2binb(key);
            if (bkey.length > 16) { bkey = core_sha1(bkey, key.length * 8); }

            var ipad = new Array(16), opad = new Array(16);
            for (var i = 0; i < 16; i++)
            {
                ipad[i] = bkey[i] ^ 0x36363636;
                opad[i] = bkey[i] ^ 0x5C5C5C5C;
            }

            var hash = core_sha1(ipad.concat(str2binb(data)), 512 + data.length * 8);
            return core_sha1(opad.concat(hash), 512 + 160);
        }

        /*
         * Add integers, wrapping at 2^32. This uses 16-bit operations internally
         * to work around bugs in some JS interpreters.
         */
        function safe_add(x, y)
        {
            var lsw = (x & 0xFFFF) + (y & 0xFFFF);
            var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
            return (msw << 16) | (lsw & 0xFFFF);
        }

        /*
         * Bitwise rotate a 32-bit number to the left.
         */
        function rol(num, cnt)
        {
            return (num << cnt) | (num >>> (32 - cnt));
        }

        /*
         * Convert an 8-bit or 16-bit string to an array of big-endian words
         * In 8-bit function, characters >255 have their hi-byte silently ignored.
         */
        function str2binb(str)
        {
            var bin = [];
            var mask = 255;
            for (var i = 0; i < str.length * 8; i += 8)
            {
                bin[i>>5] |= (str.charCodeAt(i / 8) & mask) << (24 - i%32);
            }
            return bin;
        }

        /*
         * Convert an array of big-endian words to a string
         */
        function binb2str(bin)
        {
            var str = "";
            var mask = 255;
            for (var i = 0; i < bin.length * 32; i += 8)
            {
                str += String.fromCharCode((bin[i>>5] >>> (24 - i%32)) & mask);
            }
            return str;
        }

        /*
         * Convert an array of big-endian words to a base-64 string
         */
        function binb2b64(binarray)
        {
            var tab = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
            var str = "";
            var triplet, j;
            for (var i = 0; i < binarray.length * 4; i += 3)
            {
                triplet = (((binarray[i   >> 2] >> 8 * (3 -  i   %4)) & 0xFF) << 16) |
                    (((binarray[i+1 >> 2] >> 8 * (3 - (i+1)%4)) & 0xFF) << 8 ) |
                    ((binarray[i+2 >> 2] >> 8 * (3 - (i+2)%4)) & 0xFF);
                for (j = 0; j < 4; j++)
                {
                    if (i * 8 + j * 6 > binarray.length * 32) { str += "="; }
                    else { str += tab.charAt((triplet >> 6*(3-j)) & 0x3F); }
                }
            }
            return str;
        }

        /*
         * These are the functions you'll usually want to call
         * They take string arguments and return either hex or base-64 encoded strings
         */
        return {
            b64_hmac_sha1:  function (key, data){ return binb2b64(core_hmac_sha1(key, data)); },
            b64_sha1:       function (s) { return binb2b64(core_sha1(str2binb(s),s.length * 8)); },
            binb2str:       binb2str,
            core_hmac_sha1: core_hmac_sha1,
            str_hmac_sha1:  function (key, data){ return binb2str(core_hmac_sha1(key, data)); },
            str_sha1:       function (s) { return binb2str(core_sha1(str2binb(s),s.length * 8)); },
        };
    }));

    /*
     * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
     * Digest Algorithm, as defined in RFC 1321.
     * Version 2.1 Copyright (C) Paul Johnston 1999 - 2002.
     * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
     * Distributed under the BSD License
     * See http://pajhome.org.uk/crypt/md5 for more info.
     */

    /*
     * Everything that isn't used by Strophe has been stripped here!
     */

    (function (root, factory) {
        if (true) {
            !(__WEBPACK_LOCAL_MODULE_2__module = { id: "strophe-md5", exports: {}, loaded: false }, __WEBPACK_LOCAL_MODULE_2__ = function () {
                return factory();
            }.call(__WEBPACK_LOCAL_MODULE_2__module.exports, __webpack_require__, __WEBPACK_LOCAL_MODULE_2__module.exports, __WEBPACK_LOCAL_MODULE_2__module), __WEBPACK_LOCAL_MODULE_2__module.loaded = true, __WEBPACK_LOCAL_MODULE_2__ === undefined && (__WEBPACK_LOCAL_MODULE_2__ = __WEBPACK_LOCAL_MODULE_2__module.exports));
        } else {
            // Browser globals
            root.MD5 = factory();
        }
    }(this, function (b) {
        /*
         * Add integers, wrapping at 2^32. This uses 16-bit operations internally
         * to work around bugs in some JS interpreters.
         */
        var safe_add = function (x, y) {
            var lsw = (x & 0xFFFF) + (y & 0xFFFF);
            var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
            return (msw << 16) | (lsw & 0xFFFF);
        };

        /*
         * Bitwise rotate a 32-bit number to the left.
         */
        var bit_rol = function (num, cnt) {
            return (num << cnt) | (num >>> (32 - cnt));
        };

        /*
         * Convert a string to an array of little-endian words
         */
        var str2binl = function (str) {
            var bin = [];
            for(var i = 0; i < str.length * 8; i += 8)
            {
                bin[i>>5] |= (str.charCodeAt(i / 8) & 255) << (i%32);
            }
            return bin;
        };

        /*
         * Convert an array of little-endian words to a string
         */
        var binl2str = function (bin) {
            var str = "";
            for(var i = 0; i < bin.length * 32; i += 8)
            {
                str += String.fromCharCode((bin[i>>5] >>> (i % 32)) & 255);
            }
            return str;
        };

        /*
         * Convert an array of little-endian words to a hex string.
         */
        var binl2hex = function (binarray) {
            var hex_tab = "0123456789abcdef";
            var str = "";
            for(var i = 0; i < binarray.length * 4; i++)
            {
                str += hex_tab.charAt((binarray[i>>2] >> ((i%4)*8+4)) & 0xF) +
                    hex_tab.charAt((binarray[i>>2] >> ((i%4)*8  )) & 0xF);
            }
            return str;
        };

        /*
         * These functions implement the four basic operations the algorithm uses.
         */
        var md5_cmn = function (q, a, b, x, s, t) {
            return safe_add(bit_rol(safe_add(safe_add(a, q),safe_add(x, t)), s),b);
        };

        var md5_ff = function (a, b, c, d, x, s, t) {
            return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);
        };

        var md5_gg = function (a, b, c, d, x, s, t) {
            return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);
        };

        var md5_hh = function (a, b, c, d, x, s, t) {
            return md5_cmn(b ^ c ^ d, a, b, x, s, t);
        };

        var md5_ii = function (a, b, c, d, x, s, t) {
            return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);
        };

        /*
         * Calculate the MD5 of an array of little-endian words, and a bit length
         */
        var core_md5 = function (x, len) {
            /* append padding */
            x[len >> 5] |= 0x80 << ((len) % 32);
            x[(((len + 64) >>> 9) << 4) + 14] = len;

            var a =  1732584193;
            var b = -271733879;
            var c = -1732584194;
            var d =  271733878;

            var olda, oldb, oldc, oldd;
            for (var i = 0; i < x.length; i += 16)
            {
                olda = a;
                oldb = b;
                oldc = c;
                oldd = d;

                a = md5_ff(a, b, c, d, x[i+ 0], 7 , -680876936);
                d = md5_ff(d, a, b, c, x[i+ 1], 12, -389564586);
                c = md5_ff(c, d, a, b, x[i+ 2], 17,  606105819);
                b = md5_ff(b, c, d, a, x[i+ 3], 22, -1044525330);
                a = md5_ff(a, b, c, d, x[i+ 4], 7 , -176418897);
                d = md5_ff(d, a, b, c, x[i+ 5], 12,  1200080426);
                c = md5_ff(c, d, a, b, x[i+ 6], 17, -1473231341);
                b = md5_ff(b, c, d, a, x[i+ 7], 22, -45705983);
                a = md5_ff(a, b, c, d, x[i+ 8], 7 ,  1770035416);
                d = md5_ff(d, a, b, c, x[i+ 9], 12, -1958414417);
                c = md5_ff(c, d, a, b, x[i+10], 17, -42063);
                b = md5_ff(b, c, d, a, x[i+11], 22, -1990404162);
                a = md5_ff(a, b, c, d, x[i+12], 7 ,  1804603682);
                d = md5_ff(d, a, b, c, x[i+13], 12, -40341101);
                c = md5_ff(c, d, a, b, x[i+14], 17, -1502002290);
                b = md5_ff(b, c, d, a, x[i+15], 22,  1236535329);

                a = md5_gg(a, b, c, d, x[i+ 1], 5 , -165796510);
                d = md5_gg(d, a, b, c, x[i+ 6], 9 , -1069501632);
                c = md5_gg(c, d, a, b, x[i+11], 14,  643717713);
                b = md5_gg(b, c, d, a, x[i+ 0], 20, -373897302);
                a = md5_gg(a, b, c, d, x[i+ 5], 5 , -701558691);
                d = md5_gg(d, a, b, c, x[i+10], 9 ,  38016083);
                c = md5_gg(c, d, a, b, x[i+15], 14, -660478335);
                b = md5_gg(b, c, d, a, x[i+ 4], 20, -405537848);
                a = md5_gg(a, b, c, d, x[i+ 9], 5 ,  568446438);
                d = md5_gg(d, a, b, c, x[i+14], 9 , -1019803690);
                c = md5_gg(c, d, a, b, x[i+ 3], 14, -187363961);
                b = md5_gg(b, c, d, a, x[i+ 8], 20,  1163531501);
                a = md5_gg(a, b, c, d, x[i+13], 5 , -1444681467);
                d = md5_gg(d, a, b, c, x[i+ 2], 9 , -51403784);
                c = md5_gg(c, d, a, b, x[i+ 7], 14,  1735328473);
                b = md5_gg(b, c, d, a, x[i+12], 20, -1926607734);

                a = md5_hh(a, b, c, d, x[i+ 5], 4 , -378558);
                d = md5_hh(d, a, b, c, x[i+ 8], 11, -2022574463);
                c = md5_hh(c, d, a, b, x[i+11], 16,  1839030562);
                b = md5_hh(b, c, d, a, x[i+14], 23, -35309556);
                a = md5_hh(a, b, c, d, x[i+ 1], 4 , -1530992060);
                d = md5_hh(d, a, b, c, x[i+ 4], 11,  1272893353);
                c = md5_hh(c, d, a, b, x[i+ 7], 16, -155497632);
                b = md5_hh(b, c, d, a, x[i+10], 23, -1094730640);
                a = md5_hh(a, b, c, d, x[i+13], 4 ,  681279174);
                d = md5_hh(d, a, b, c, x[i+ 0], 11, -358537222);
                c = md5_hh(c, d, a, b, x[i+ 3], 16, -722521979);
                b = md5_hh(b, c, d, a, x[i+ 6], 23,  76029189);
                a = md5_hh(a, b, c, d, x[i+ 9], 4 , -640364487);
                d = md5_hh(d, a, b, c, x[i+12], 11, -421815835);
                c = md5_hh(c, d, a, b, x[i+15], 16,  530742520);
                b = md5_hh(b, c, d, a, x[i+ 2], 23, -995338651);

                a = md5_ii(a, b, c, d, x[i+ 0], 6 , -198630844);
                d = md5_ii(d, a, b, c, x[i+ 7], 10,  1126891415);
                c = md5_ii(c, d, a, b, x[i+14], 15, -1416354905);
                b = md5_ii(b, c, d, a, x[i+ 5], 21, -57434055);
                a = md5_ii(a, b, c, d, x[i+12], 6 ,  1700485571);
                d = md5_ii(d, a, b, c, x[i+ 3], 10, -1894986606);
                c = md5_ii(c, d, a, b, x[i+10], 15, -1051523);
                b = md5_ii(b, c, d, a, x[i+ 1], 21, -2054922799);
                a = md5_ii(a, b, c, d, x[i+ 8], 6 ,  1873313359);
                d = md5_ii(d, a, b, c, x[i+15], 10, -30611744);
                c = md5_ii(c, d, a, b, x[i+ 6], 15, -1560198380);
                b = md5_ii(b, c, d, a, x[i+13], 21,  1309151649);
                a = md5_ii(a, b, c, d, x[i+ 4], 6 , -145523070);
                d = md5_ii(d, a, b, c, x[i+11], 10, -1120210379);
                c = md5_ii(c, d, a, b, x[i+ 2], 15,  718787259);
                b = md5_ii(b, c, d, a, x[i+ 9], 21, -343485551);

                a = safe_add(a, olda);
                b = safe_add(b, oldb);
                c = safe_add(c, oldc);
                d = safe_add(d, oldd);
            }
            return [a, b, c, d];
        };

        var obj = {
            /*
             * These are the functions you'll usually want to call.
             * They take string arguments and return either hex or base-64 encoded
             * strings.
             */
            hexdigest: function (s) {
                return binl2hex(core_md5(str2binl(s), s.length * 8));
            },

            hash: function (s) {
                return binl2str(core_md5(str2binl(s), s.length * 8));
            }
        };
        return obj;
    }));

    (function (root, factory) {
        if (true) {
            !(__WEBPACK_LOCAL_MODULE_3__module = { id: "strophe-utils", exports: {}, loaded: false }, __WEBPACK_LOCAL_MODULE_3__ = function () {
                return factory();
            }.call(__WEBPACK_LOCAL_MODULE_3__module.exports, __webpack_require__, __WEBPACK_LOCAL_MODULE_3__module.exports, __WEBPACK_LOCAL_MODULE_3__module), __WEBPACK_LOCAL_MODULE_3__module.loaded = true, __WEBPACK_LOCAL_MODULE_3__ === undefined && (__WEBPACK_LOCAL_MODULE_3__ = __WEBPACK_LOCAL_MODULE_3__module.exports));
        } else {
            // Browser globals
            root.stropheUtils = factory();
        }
    }(this, function () {

        var utils = {

            utf16to8: function (str) {
                var i, c;
                var out = "";
                var len = str.length;
                for (i = 0; i < len; i++) {
                    c = str.charCodeAt(i);
                    if ((c >= 0x0000) && (c <= 0x007F)) {
                        out += str.charAt(i);
                    } else if (c > 0x07FF) {
                        out += String.fromCharCode(0xE0 | ((c >> 12) & 0x0F));
                        out += String.fromCharCode(0x80 | ((c >>  6) & 0x3F));
                        out += String.fromCharCode(0x80 | ((c >>  0) & 0x3F));
                    } else {
                        out += String.fromCharCode(0xC0 | ((c >>  6) & 0x1F));
                        out += String.fromCharCode(0x80 | ((c >>  0) & 0x3F));
                    }
                }
                return out;
            },

            addCookies: function (cookies) {
                /* Parameters:
                 *  (Object) cookies - either a map of cookie names
                 *    to string values or to maps of cookie values.
                 *
                 * For example:
                 * { "myCookie": "1234" }
                 *
                 * or:
                 * { "myCookie": {
                 *      "value": "1234",
                 *      "domain": ".example.org",
                 *      "path": "/",
                 *      "expires": expirationDate
                 *      }
                 *  }
                 *
                 *  These values get passed to Strophe.Connection via
                 *   options.cookies
                 */
                var cookieName, cookieObj, isObj, cookieValue, expires, domain, path;
                for (cookieName in (cookies || {})) {
                    expires = '';
                    domain = '';
                    path = '';
                    cookieObj = cookies[cookieName];
                    isObj = typeof cookieObj == "object";
                    cookieValue = escape(unescape(isObj ? cookieObj.value : cookieObj));
                    if (isObj) {
                        expires = cookieObj.expires ? ";expires="+cookieObj.expires : '';
                        domain = cookieObj.domain ? ";domain="+cookieObj.domain : '';
                        path = cookieObj.path ? ";path="+cookieObj.path : '';
                    }
                    document.cookie =
                        cookieName+'='+cookieValue + expires + domain + path;
                }
            }
        };
        return utils;
    }));

    /*
     This program is distributed under the terms of the MIT license.
     Please see the LICENSE file for details.

     Copyright 2006-2008, OGG, LLC
     */

    /* jshint undef: true, unused: true:, noarg: true, latedef: true */
    /* global define */

    (function (root, factory) {
        if (true) {
            !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_LOCAL_MODULE_4__ = (function () {
                return factory();
            }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)));
        } else {
            // Browser globals
            return factory();
        }
    }(this, function () {

        /** Function: Function.prototype.bind
         *  Bind a function to an instance.
         *
         *  This Function object extension method creates a bound method similar
         *  to those in Python.  This means that the 'this' object will point
         *  to the instance you want.  See <MDC's bind() documentation at https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/bind>
         *  and <Bound Functions and Function Imports in JavaScript at http://benjamin.smedbergs.us/blog/2007-01-03/bound-functions-and-function-imports-in-javascript/>
         *  for a complete explanation.
         *
         *  This extension already exists in some browsers (namely, Firefox 3), but
         *  we provide it to support those that don't.
         *
         *  Parameters:
         *    (Object) obj - The object that will become 'this' in the bound function.
         *    (Object) argN - An option argument that will be prepended to the
         *      arguments given for the function call
         *
         *  Returns:
         *    The bound function.
         */
        if (!Function.prototype.bind) {
            Function.prototype.bind = function (obj /*, arg1, arg2, ... */) {
                var func = this;
                var _slice = Array.prototype.slice;
                var _concat = Array.prototype.concat;
                var _args = _slice.call(arguments, 1);
                return function () {
                    return func.apply(obj ? obj : this, _concat.call(_args, _slice.call(arguments, 0)));
                };
            };
        }

        /** Function: Array.isArray
         *  This is a polyfill for the ES5 Array.isArray method.
         */
        if (!Array.isArray) {
            Array.isArray = function(arg) {
                return Object.prototype.toString.call(arg) === '[object Array]';
            };
        }

        /** Function: Array.prototype.indexOf
         *  Return the index of an object in an array.
         *
         *  This function is not supplied by some JavaScript implementations, so
         *  we provide it if it is missing.  This code is from:
         *  http://developer.mozilla.org/En/Core_JavaScript_1.5_Reference:Objects:Array:indexOf
         *
         *  Parameters:
         *    (Object) elt - The object to look for.
         *    (Integer) from - The index from which to start looking. (optional).
         *
         *  Returns:
         *    The index of elt in the array or -1 if not found.
         */
        if (!Array.prototype.indexOf) {
            Array.prototype.indexOf = function(elt /*, from*/) {
                var len = this.length;
                var from = Number(arguments[1]) || 0;
                from = (from < 0) ? Math.ceil(from) : Math.floor(from);
                if (from < 0) {
                    from += len;
                }

                for (; from < len; from++) {
                    if (from in this && this[from] === elt) {
                        return from;
                    }
                }
                return -1;
            };
        }
    }));


    /** Function: Array.prototype.forEach
     *
     *  This function is not available in IE < 9
     *
     *  See <forEach on developer.mozilla.org at https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach>
     */
    if (!Array.prototype.forEach) {
        Array.prototype.forEach = function(callback, thisArg) {
            var T, k;
            if (this === null) {
                throw new TypeError(' this is null or not defined');
            }

            // 1. Let O be the result of calling toObject() passing the
            // |this| value as the argument.
            var O = Object(this);
            // 2. Let lenValue be the result of calling the Get() internal
            // method of O with the argument "length".
            // 3. Let len be toUint32(lenValue).
            var len = O.length >>> 0;
            // 4. If isCallable(callback) is false, throw a TypeError exception.
            // See: http://es5.github.com/#x9.11
            if (typeof callback !== "function") {
                throw new TypeError(callback + ' is not a function');
            }
            // 5. If thisArg was supplied, let T be thisArg; else let
            // T be undefined.
            if (arguments.length > 1) {
                T = thisArg;
            }
            // 6. Let k be 0
            k = 0;
            // 7. Repeat, while k < len
            while (k < len) {
                var kValue;
                // a. Let Pk be ToString(k).
                //        This is implicit for LHS operands of the in operator
                // b. Let kPresent be the result of calling the HasProperty
                //        internal method of O with argument Pk.
                //        This step can be combined with c
                // c. If kPresent is true, then
                if (k in O) {
                    // i. Let kValue be the result of calling the Get internal
                    // method of O with argument Pk.
                    kValue = O[k];
                    // ii. Call the Call internal method of callback with T as
                    // the this value and argument list containing kValue, k, and O.
                    callback.call(T, kValue, k, O);
                }
                // d. Increase k by 1.
                k++;
            }
            // 8. return undefined
        };
    }

    /*
     This program is distributed under the terms of the MIT license.
     Please see the LICENSE file for details.

     Copyright 2006-2008, OGG, LLC
     */

    /* jshint undef: true, unused: true:, noarg: true, latedef: true */
    /*global define, document, window, setTimeout, clearTimeout, ActiveXObject, DOMParser */

    (function (root, factory) {
        if (true) {
            !(__WEBPACK_AMD_DEFINE_ARRAY__ = [
                __WEBPACK_LOCAL_MODULE_1__,
                __WEBPACK_LOCAL_MODULE_0__,
                __WEBPACK_LOCAL_MODULE_2__,
                __WEBPACK_LOCAL_MODULE_3__,
                __WEBPACK_LOCAL_MODULE_4__
            ], __WEBPACK_LOCAL_MODULE_5__ = (function () {
                return factory.apply(this, arguments);
            }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)));
        } else {
            // Browser globals
            var o = factory(root.SHA1, root.Base64, root.MD5, root.stropheUtils);
            window.Strophe =        o.Strophe;
            window.$build =         o.$build;
            window.$iq =            o.$iq;
            window.$msg =           o.$msg;
            window.$pres =          o.$pres;
            window.SHA1 =           o.SHA1;
            window.Base64 =         o.Base64;
            window.MD5 =            o.MD5;
            window.b64_hmac_sha1 =  o.SHA1.b64_hmac_sha1;
            window.b64_sha1 =       o.SHA1.b64_sha1;
            window.str_hmac_sha1 =  o.SHA1.str_hmac_sha1;
            window.str_sha1 =       o.SHA1.str_sha1;
        }
    }(this, function (SHA1, Base64, MD5, utils) {

        var Strophe;

        /** Function: $build
         *  Create a Strophe.Builder.
         *  This is an alias for 'new Strophe.Builder(name, attrs)'.
         *
         *  Parameters:
         *    (String) name - The root element name.
         *    (Object) attrs - The attributes for the root element in object notation.
         *
         *  Returns:
         *    A new Strophe.Builder object.
         */
        function $build(name, attrs) { return new Strophe.Builder(name, attrs); }

        /** Function: $msg
         *  Create a Strophe.Builder with a <message/> element as the root.
         *
         *  Parameters:
         *    (Object) attrs - The <message/> element attributes in object notation.
         *
         *  Returns:
         *    A new Strophe.Builder object.
         */
        function $msg(attrs) { return new Strophe.Builder("message", attrs); }

        /** Function: $iq
         *  Create a Strophe.Builder with an <iq/> element as the root.
         *
         *  Parameters:
         *    (Object) attrs - The <iq/> element attributes in object notation.
         *
         *  Returns:
         *    A new Strophe.Builder object.
         */
        function $iq(attrs) { return new Strophe.Builder("iq", attrs); }

        /** Function: $pres
         *  Create a Strophe.Builder with a <presence/> element as the root.
         *
         *  Parameters:
         *    (Object) attrs - The <presence/> element attributes in object notation.
         *
         *  Returns:
         *    A new Strophe.Builder object.
         */
        function $pres(attrs) { return new Strophe.Builder("presence", attrs); }

        /** Class: Strophe
         *  An object container for all Strophe library functions.
         *
         *  This class is just a container for all the objects and constants
         *  used in the library.  It is not meant to be instantiated, but to
         *  provide a namespace for library objects, constants, and functions.
         */
        Strophe = {
            /** Constant: VERSION
             *  The version of the Strophe library. Unreleased builds will have
             *  a version of head-HASH where HASH is a partial revision.
             */
            VERSION: "1.2.12",

            /** Constants: XMPP Namespace Constants
             *  Common namespace constants from the XMPP RFCs and XEPs.
             *
             *  NS.HTTPBIND - HTTP BIND namespace from XEP 124.
             *  NS.BOSH - BOSH namespace from XEP 206.
             *  NS.CLIENT - Main XMPP client namespace.
             *  NS.AUTH - Legacy authentication namespace.
             *  NS.ROSTER - Roster operations namespace.
             *  NS.PROFILE - Profile namespace.
             *  NS.DISCO_INFO - Service discovery info namespace from XEP 30.
             *  NS.DISCO_ITEMS - Service discovery items namespace from XEP 30.
             *  NS.MUC - Multi-User Chat namespace from XEP 45.
             *  NS.SASL - XMPP SASL namespace from RFC 3920.
             *  NS.STREAM - XMPP Streams namespace from RFC 3920.
             *  NS.BIND - XMPP Binding namespace from RFC 3920.
             *  NS.SESSION - XMPP Session namespace from RFC 3920.
             *  NS.XHTML_IM - XHTML-IM namespace from XEP 71.
             *  NS.XHTML - XHTML body namespace from XEP 71.
             */
            NS: {
                HTTPBIND: "http://jabber.org/protocol/httpbind",
                BOSH: "urn:xmpp:xbosh",
                CLIENT: "jabber:client",
                AUTH: "jabber:iq:auth",
                ROSTER: "jabber:iq:roster",
                PROFILE: "jabber:iq:profile",
                DISCO_INFO: "http://jabber.org/protocol/disco#info",
                DISCO_ITEMS: "http://jabber.org/protocol/disco#items",
                MUC: "http://jabber.org/protocol/muc",
                SASL: "urn:ietf:params:xml:ns:xmpp-sasl",
                STREAM: "http://etherx.jabber.org/streams",
                FRAMING: "urn:ietf:params:xml:ns:xmpp-framing",
                BIND: "urn:ietf:params:xml:ns:xmpp-bind",
                SESSION: "urn:ietf:params:xml:ns:xmpp-session",
                VERSION: "jabber:iq:version",
                STANZAS: "urn:ietf:params:xml:ns:xmpp-stanzas",
                XHTML_IM: "http://jabber.org/protocol/xhtml-im",
                XHTML: "http://www.w3.org/1999/xhtml"
            },

            /** Constants: XHTML_IM Namespace
             *  contains allowed tags, tag attributes, and css properties.
             *  Used in the createHtml function to filter incoming html into the allowed XHTML-IM subset.
             *  See http://xmpp.org/extensions/xep-0071.html#profile-summary for the list of recommended
             *  allowed tags and their attributes.
             */
            XHTML: {
                tags: ['a','blockquote','br','cite','em','img','li','ol','p','span','strong','ul','body'],
                attributes: {
                    'a':          ['href'],
                    'blockquote': ['style'],
                    'br':         [],
                    'cite':       ['style'],
                    'em':         [],
                    'img':        ['src', 'alt', 'style', 'height', 'width'],
                    'li':         ['style'],
                    'ol':         ['style'],
                    'p':          ['style'],
                    'span':       ['style'],
                    'strong':     [],
                    'ul':         ['style'],
                    'body':       []
                },
                css: ['background-color','color','font-family','font-size','font-style','font-weight','margin-left','margin-right','text-align','text-decoration'],
                /** Function: XHTML.validTag
                 *
                 * Utility method to determine whether a tag is allowed
                 * in the XHTML_IM namespace.
                 *
                 * XHTML tag names are case sensitive and must be lower case.
                 */
                validTag: function(tag) {
                    for (var i = 0; i < Strophe.XHTML.tags.length; i++) {
                        if (tag == Strophe.XHTML.tags[i]) {
                            return true;
                        }
                    }
                    return false;
                },
                /** Function: XHTML.validAttribute
                 *
                 * Utility method to determine whether an attribute is allowed
                 * as recommended per XEP-0071
                 *
                 * XHTML attribute names are case sensitive and must be lower case.
                 */
                validAttribute: function(tag, attribute) {
                    if (typeof Strophe.XHTML.attributes[tag] !== 'undefined' && Strophe.XHTML.attributes[tag].length > 0) {
                        for (var i = 0; i < Strophe.XHTML.attributes[tag].length; i++) {
                            if (attribute == Strophe.XHTML.attributes[tag][i]) {
                                return true;
                            }
                        }
                    }
                    return false;
                },
                validCSS: function(style) {
                    for (var i = 0; i < Strophe.XHTML.css.length; i++) {
                        if (style == Strophe.XHTML.css[i]) {
                            return true;
                        }
                    }
                    return false;
                }
            },

            /** Constants: Connection Status Constants
             *  Connection status constants for use by the connection handler
             *  callback.
             *
             *  Status.ERROR - An error has occurred
             *  Status.CONNECTING - The connection is currently being made
             *  Status.CONNFAIL - The connection attempt failed
             *  Status.AUTHENTICATING - The connection is authenticating
             *  Status.AUTHFAIL - The authentication attempt failed
             *  Status.CONNECTED - The connection has succeeded
             *  Status.DISCONNECTED - The connection has been terminated
             *  Status.DISCONNECTING - The connection is currently being terminated
             *  Status.ATTACHED - The connection has been attached
             *  Status.CONNTIMEOUT - The connection has timed out
             */
            Status: {
                ERROR: 0,
                CONNECTING: 1,
                CONNFAIL: 2,
                AUTHENTICATING: 3,
                AUTHFAIL: 4,
                CONNECTED: 5,
                DISCONNECTED: 6,
                DISCONNECTING: 7,
                ATTACHED: 8,
                REDIRECT: 9,
                CONNTIMEOUT: 10
            },

            /** Constants: Log Level Constants
             *  Logging level indicators.
             *
             *  LogLevel.DEBUG - Debug output
             *  LogLevel.INFO - Informational output
             *  LogLevel.WARN - Warnings
             *  LogLevel.ERROR - Errors
             *  LogLevel.FATAL - Fatal errors
             */
            LogLevel: {
                DEBUG: 0,
                INFO: 1,
                WARN: 2,
                ERROR: 3,
                FATAL: 4
            },

            /** PrivateConstants: DOM Element Type Constants
             *  DOM element types.
             *
             *  ElementType.NORMAL - Normal element.
             *  ElementType.TEXT - Text data element.
             *  ElementType.FRAGMENT - XHTML fragment element.
             */
            ElementType: {
                NORMAL: 1,
                TEXT: 3,
                CDATA: 4,
                FRAGMENT: 11
            },

            /** PrivateConstants: Timeout Values
             *  Timeout values for error states.  These values are in seconds.
             *  These should not be changed unless you know exactly what you are
             *  doing.
             *
             *  TIMEOUT - Timeout multiplier. A waiting request will be considered
             *      failed after Math.floor(TIMEOUT * wait) seconds have elapsed.
             *      This defaults to 1.1, and with default wait, 66 seconds.
             *  SECONDARY_TIMEOUT - Secondary timeout multiplier. In cases where
             *      Strophe can detect early failure, it will consider the request
             *      failed if it doesn't return after
             *      Math.floor(SECONDARY_TIMEOUT * wait) seconds have elapsed.
             *      This defaults to 0.1, and with default wait, 6 seconds.
             */
            TIMEOUT: 1.1,
            SECONDARY_TIMEOUT: 0.1,

            /** Function: addNamespace
             *  This function is used to extend the current namespaces in
             *  Strophe.NS.  It takes a key and a value with the key being the
             *  name of the new namespace, with its actual value.
             *  For example:
             *  Strophe.addNamespace('PUBSUB', "http://jabber.org/protocol/pubsub");
             *
             *  Parameters:
             *    (String) name - The name under which the namespace will be
             *      referenced under Strophe.NS
             *    (String) value - The actual namespace.
             */
            addNamespace: function (name, value) {
                Strophe.NS[name] = value;
            },

            /** Function: forEachChild
             *  Map a function over some or all child elements of a given element.
             *
             *  This is a small convenience function for mapping a function over
             *  some or all of the children of an element.  If elemName is null, all
             *  children will be passed to the function, otherwise only children
             *  whose tag names match elemName will be passed.
             *
             *  Parameters:
             *    (XMLElement) elem - The element to operate on.
             *    (String) elemName - The child element tag name filter.
             *    (Function) func - The function to apply to each child.  This
             *      function should take a single argument, a DOM element.
             */
            forEachChild: function (elem, elemName, func) {
                var i, childNode;
                for (i = 0; i < elem.childNodes.length; i++) {
                    childNode = elem.childNodes[i];
                    if (childNode.nodeType == Strophe.ElementType.NORMAL &&
                        (!elemName || this.isTagEqual(childNode, elemName))) {
                        func(childNode);
                    }
                }
            },

            /** Function: isTagEqual
             *  Compare an element's tag name with a string.
             *
             *  This function is case sensitive.
             *
             *  Parameters:
             *    (XMLElement) el - A DOM element.
             *    (String) name - The element name.
             *
             *  Returns:
             *    true if the element's tag name matches _el_, and false
             *    otherwise.
             */
            isTagEqual: function (el, name) {
                return el.tagName == name;
            },

            /** PrivateVariable: _xmlGenerator
             *  _Private_ variable that caches a DOM document to
             *  generate elements.
             */
            _xmlGenerator: null,

            /** PrivateFunction: _makeGenerator
             *  _Private_ function that creates a dummy XML DOM document to serve as
             *  an element and text node generator.
             */
            _makeGenerator: function () {
                var doc;
                // IE9 does implement createDocument(); however, using it will cause the browser to leak memory on page unload.
                // Here, we test for presence of createDocument() plus IE's proprietary documentMode attribute, which would be
                // less than 10 in the case of IE9 and below.
                if (document.implementation.createDocument === undefined ||
                    document.implementation.createDocument && document.documentMode && document.documentMode < 10) {
                    doc = this._getIEXmlDom();
                    doc.appendChild(doc.createElement('strophe'));
                } else {
                    doc = document.implementation
                        .createDocument('jabber:client', 'strophe', null);
                }
                return doc;
            },

            /** Function: xmlGenerator
             *  Get the DOM document to generate elements.
             *
             *  Returns:
             *    The currently used DOM document.
             */
            xmlGenerator: function () {
                if (!Strophe._xmlGenerator) {
                    Strophe._xmlGenerator = Strophe._makeGenerator();
                }
                return Strophe._xmlGenerator;
            },

            /** PrivateFunction: _getIEXmlDom
             *  Gets IE xml doc object
             *
             *  Returns:
             *    A Microsoft XML DOM Object
             *  See Also:
             *    http://msdn.microsoft.com/en-us/library/ms757837%28VS.85%29.aspx
             */
            _getIEXmlDom : function() {
                var doc = null;
                var docStrings = [
                    "Msxml2.DOMDocument.6.0",
                    "Msxml2.DOMDocument.5.0",
                    "Msxml2.DOMDocument.4.0",
                    "MSXML2.DOMDocument.3.0",
                    "MSXML2.DOMDocument",
                    "MSXML.DOMDocument",
                    "Microsoft.XMLDOM"
                ];

                for (var d = 0; d < docStrings.length; d++) {
                    if (doc === null) {
                        try {
                            doc = new ActiveXObject(docStrings[d]);
                        } catch (e) {
                            doc = null;
                        }
                    } else {
                        break;
                    }
                }
                return doc;
            },

            /** Function: xmlElement
             *  Create an XML DOM element.
             *
             *  This function creates an XML DOM element correctly across all
             *  implementations. Note that these are not HTML DOM elements, which
             *  aren't appropriate for XMPP stanzas.
             *
             *  Parameters:
             *    (String) name - The name for the element.
             *    (Array|Object) attrs - An optional array or object containing
             *      key/value pairs to use as element attributes. The object should
             *      be in the format {'key': 'value'} or {key: 'value'}. The array
             *      should have the format [['key1', 'value1'], ['key2', 'value2']].
             *    (String) text - The text child data for the element.
             *
             *  Returns:
             *    A new XML DOM element.
             */
            xmlElement: function (name) {
                if (!name) { return null; }

                var node = Strophe.xmlGenerator().createElement(name);
                // FIXME: this should throw errors if args are the wrong type or
                // there are more than two optional args
                var a, i, k;
                for (a = 1; a < arguments.length; a++) {
                    var arg = arguments[a];
                    if (!arg) { continue; }
                    if (typeof(arg) == "string" ||
                        typeof(arg) == "number") {
                        node.appendChild(Strophe.xmlTextNode(arg));
                    } else if (typeof(arg) == "object" &&
                        typeof(arg.sort) == "function") {
                        for (i = 0; i < arg.length; i++) {
                            var attr = arg[i];
                            if (typeof(attr) == "object" &&
                                typeof(attr.sort) == "function" &&
                                attr[1] !== undefined &&
                                attr[1] !== null) {
                                node.setAttribute(attr[0], attr[1]);
                            }
                        }
                    } else if (typeof(arg) == "object") {
                        for (k in arg) {
                            if (arg.hasOwnProperty(k)) {
                                if (arg[k] !== undefined &&
                                    arg[k] !== null) {
                                    node.setAttribute(k, arg[k]);
                                }
                            }
                        }
                    }
                }
                return node;
            },

            /*  Function: xmlescape
             *  Excapes invalid xml characters.
             *
             *  Parameters:
             *     (String) text - text to escape.
             *
             *  Returns:
             *      Escaped text.
             */
            xmlescape: function(text) {
                text = text.replace(/\&/g, "&amp;");
                text = text.replace(/</g,  "&lt;");
                text = text.replace(/>/g,  "&gt;");
                text = text.replace(/'/g,  "&apos;");
                text = text.replace(/"/g,  "&quot;");
                return text;
            },

            /*  Function: xmlunescape
             *  Unexcapes invalid xml characters.
             *
             *  Parameters:
             *     (String) text - text to unescape.
             *
             *  Returns:
             *      Unescaped text.
             */
            xmlunescape: function(text) {
                text = text.replace(/\&amp;/g, "&");
                text = text.replace(/&lt;/g,  "<");
                text = text.replace(/&gt;/g,  ">");
                text = text.replace(/&apos;/g,  "'");
                text = text.replace(/&quot;/g,  "\"");
                return text;
            },

            /** Function: xmlTextNode
             *  Creates an XML DOM text node.
             *
             *  Provides a cross implementation version of document.createTextNode.
             *
             *  Parameters:
             *    (String) text - The content of the text node.
             *
             *  Returns:
             *    A new XML DOM text node.
             */
            xmlTextNode: function (text) {
                return Strophe.xmlGenerator().createTextNode(text);
            },

            /** Function: xmlHtmlNode
             *  Creates an XML DOM html node.
             *
             *  Parameters:
             *    (String) html - The content of the html node.
             *
             *  Returns:
             *    A new XML DOM text node.
             */
            xmlHtmlNode: function (html) {
                var node;
                //ensure text is escaped
                if (window.DOMParser) {
                    var parser = new DOMParser();
                    node = parser.parseFromString(html, "text/xml");
                } else {
                    node = new ActiveXObject("Microsoft.XMLDOM");
                    node.async="false";
                    node.loadXML(html);
                }
                return node;
            },

            /** Function: getText
             *  Get the concatenation of all text children of an element.
             *
             *  Parameters:
             *    (XMLElement) elem - A DOM element.
             *
             *  Returns:
             *    A String with the concatenated text of all text element children.
             */
            getText: function (elem) {
                if (!elem) { return null; }

                var str = "";
                if (elem.childNodes.length === 0 && elem.nodeType ==
                    Strophe.ElementType.TEXT) {
                    str += elem.nodeValue;
                }

                for (var i = 0; i < elem.childNodes.length; i++) {
                    if (elem.childNodes[i].nodeType == Strophe.ElementType.TEXT) {
                        str += elem.childNodes[i].nodeValue;
                    }
                }

                return Strophe.xmlescape(str);
            },

            /** Function: copyElement
             *  Copy an XML DOM element.
             *
             *  This function copies a DOM element and all its descendants and returns
             *  the new copy.
             *
             *  Parameters:
             *    (XMLElement) elem - A DOM element.
             *
             *  Returns:
             *    A new, copied DOM element tree.
             */
            copyElement: function (elem) {
                var i, el;
                if (elem.nodeType == Strophe.ElementType.NORMAL) {
                    el = Strophe.xmlElement(elem.tagName);

                    for (i = 0; i < elem.attributes.length; i++) {
                        el.setAttribute(elem.attributes[i].nodeName,
                            elem.attributes[i].value);
                    }

                    for (i = 0; i < elem.childNodes.length; i++) {
                        el.appendChild(Strophe.copyElement(elem.childNodes[i]));
                    }
                } else if (elem.nodeType == Strophe.ElementType.TEXT) {
                    el = Strophe.xmlGenerator().createTextNode(elem.nodeValue);
                }
                return el;
            },


            /** Function: createHtml
             *  Copy an HTML DOM element into an XML DOM.
             *
             *  This function copies a DOM element and all its descendants and returns
             *  the new copy.
             *
             *  Parameters:
             *    (HTMLElement) elem - A DOM element.
             *
             *  Returns:
             *    A new, copied DOM element tree.
             */
            createHtml: function (elem) {
                var i, el, j, tag, attribute, value, css, cssAttrs, attr, cssName, cssValue;
                if (elem.nodeType == Strophe.ElementType.NORMAL) {
                    tag = elem.nodeName.toLowerCase(); // XHTML tags must be lower case.
                    if(Strophe.XHTML.validTag(tag)) {
                        try {
                            el = Strophe.xmlElement(tag);
                            for(i = 0; i < Strophe.XHTML.attributes[tag].length; i++) {
                                attribute = Strophe.XHTML.attributes[tag][i];
                                value = elem.getAttribute(attribute);
                                if(typeof value == 'undefined' || value === null || value === '' || value === false || value === 0) {
                                    continue;
                                }
                                if(attribute == 'style' && typeof value == 'object') {
                                    if(typeof value.cssText != 'undefined') {
                                        value = value.cssText; // we're dealing with IE, need to get CSS out
                                    }
                                }
                                // filter out invalid css styles
                                if(attribute == 'style') {
                                    css = [];
                                    cssAttrs = value.split(';');
                                    for(j = 0; j < cssAttrs.length; j++) {
                                        attr = cssAttrs[j].split(':');
                                        cssName = attr[0].replace(/^\s*/, "").replace(/\s*$/, "").toLowerCase();
                                        if(Strophe.XHTML.validCSS(cssName)) {
                                            cssValue = attr[1].replace(/^\s*/, "").replace(/\s*$/, "");
                                            css.push(cssName + ': ' + cssValue);
                                        }
                                    }
                                    if(css.length > 0) {
                                        value = css.join('; ');
                                        el.setAttribute(attribute, value);
                                    }
                                } else {
                                    el.setAttribute(attribute, value);
                                }
                            }

                            for (i = 0; i < elem.childNodes.length; i++) {
                                el.appendChild(Strophe.createHtml(elem.childNodes[i]));
                            }
                        } catch(e) { // invalid elements
                            el = Strophe.xmlTextNode('');
                        }
                    } else {
                        el = Strophe.xmlGenerator().createDocumentFragment();
                        for (i = 0; i < elem.childNodes.length; i++) {
                            el.appendChild(Strophe.createHtml(elem.childNodes[i]));
                        }
                    }
                } else if (elem.nodeType == Strophe.ElementType.FRAGMENT) {
                    el = Strophe.xmlGenerator().createDocumentFragment();
                    for (i = 0; i < elem.childNodes.length; i++) {
                        el.appendChild(Strophe.createHtml(elem.childNodes[i]));
                    }
                } else if (elem.nodeType == Strophe.ElementType.TEXT) {
                    el = Strophe.xmlTextNode(elem.nodeValue);
                }
                return el;
            },

            /** Function: escapeNode
             *  Escape the node part (also called local part) of a JID.
             *
             *  Parameters:
             *    (String) node - A node (or local part).
             *
             *  Returns:
             *    An escaped node (or local part).
             */
            escapeNode: function (node) {
                if (typeof node !== "string") { return node; }
                return node.replace(/^\s+|\s+$/g, '')
                    .replace(/\\/g,  "\\5c")
                    .replace(/ /g,   "\\20")
                    .replace(/\"/g,  "\\22")
                    .replace(/\&/g,  "\\26")
                    .replace(/\'/g,  "\\27")
                    .replace(/\//g,  "\\2f")
                    .replace(/:/g,   "\\3a")
                    .replace(/</g,   "\\3c")
                    .replace(/>/g,   "\\3e")
                    .replace(/@/g,   "\\40");
            },

            /** Function: unescapeNode
             *  Unescape a node part (also called local part) of a JID.
             *
             *  Parameters:
             *    (String) node - A node (or local part).
             *
             *  Returns:
             *    An unescaped node (or local part).
             */
            unescapeNode: function (node) {
                if (typeof node !== "string") { return node; }
                return node.replace(/\\20/g, " ")
                    .replace(/\\22/g, '"')
                    .replace(/\\26/g, "&")
                    .replace(/\\27/g, "'")
                    .replace(/\\2f/g, "/")
                    .replace(/\\3a/g, ":")
                    .replace(/\\3c/g, "<")
                    .replace(/\\3e/g, ">")
                    .replace(/\\40/g, "@")
                    .replace(/\\5c/g, "\\");
            },

            /** Function: getNodeFromJid
             *  Get the node portion of a JID String.
             *
             *  Parameters:
             *    (String) jid - A JID.
             *
             *  Returns:
             *    A String containing the node.
             */
            getNodeFromJid: function (jid) {
                if (jid.indexOf("@") < 0) { return null; }
                return jid.split("@")[0];
            },

            /** Function: getDomainFromJid
             *  Get the domain portion of a JID String.
             *
             *  Parameters:
             *    (String) jid - A JID.
             *
             *  Returns:
             *    A String containing the domain.
             */
            getDomainFromJid: function (jid) {
                var bare = Strophe.getBareJidFromJid(jid);
                if (bare.indexOf("@") < 0) {
                    return bare;
                } else {
                    var parts = bare.split("@");
                    parts.splice(0, 1);
                    return parts.join('@');
                }
            },

            /** Function: getResourceFromJid
             *  Get the resource portion of a JID String.
             *
             *  Parameters:
             *    (String) jid - A JID.
             *
             *  Returns:
             *    A String containing the resource.
             */
            getResourceFromJid: function (jid) {
                var s = jid.split("/");
                if (s.length < 2) { return null; }
                s.splice(0, 1);
                return s.join('/');
            },

            /** Function: getBareJidFromJid
             *  Get the bare JID from a JID String.
             *
             *  Parameters:
             *    (String) jid - A JID.
             *
             *  Returns:
             *    A String containing the bare JID.
             */
            getBareJidFromJid: function (jid) {
                return jid ? jid.split("/")[0] : null;
            },

            /** PrivateFunction: _handleError
             *  _Private_ function that properly logs an error to the console
             */
            _handleError: function (e) {
                if (typeof e.stack !== "undefined") {
                    Strophe.fatal(e.stack);
                }
                if (e.sourceURL) {
                    Strophe.fatal("error: " + this.handler + " " + e.sourceURL + ":" +
                        e.line + " - " + e.name + ": " + e.message);
                } else if (e.fileName) {
                    Strophe.fatal("error: " + this.handler + " " +
                        e.fileName + ":" + e.lineNumber + " - " +
                        e.name + ": " + e.message);
                } else {
                    Strophe.fatal("error: " + e.message);
                }
            },

            /** Function: log
             *  User overrideable logging function.
             *
             *  This function is called whenever the Strophe library calls any
             *  of the logging functions.  The default implementation of this
             *  function does nothing.  If client code wishes to handle the logging
             *  messages, it should override this with
             *  > Strophe.log = function (level, msg) {
     *  >   (user code here)
     *  > };
             *
             *  Please note that data sent and received over the wire is logged
             *  via Strophe.Connection.rawInput() and Strophe.Connection.rawOutput().
             *
             *  The different levels and their meanings are
             *
             *    DEBUG - Messages useful for debugging purposes.
             *    INFO - Informational messages.  This is mostly information like
             *      'disconnect was called' or 'SASL auth succeeded'.
             *    WARN - Warnings about potential problems.  This is mostly used
             *      to report transient connection errors like request timeouts.
             *    ERROR - Some error occurred.
             *    FATAL - A non-recoverable fatal error occurred.
             *
             *  Parameters:
             *    (Integer) level - The log level of the log message.  This will
             *      be one of the values in Strophe.LogLevel.
             *    (String) msg - The log message.
             */
            /* jshint ignore:start */
            log: function (level, msg) {
                return;
            },
            /* jshint ignore:end */

            /** Function: debug
             *  Log a message at the Strophe.LogLevel.DEBUG level.
             *
             *  Parameters:
             *    (String) msg - The log message.
             */
            debug: function(msg) {
                this.log(this.LogLevel.DEBUG, msg);
            },

            /** Function: info
             *  Log a message at the Strophe.LogLevel.INFO level.
             *
             *  Parameters:
             *    (String) msg - The log message.
             */
            info: function (msg) {
                this.log(this.LogLevel.INFO, msg);
            },

            /** Function: warn
             *  Log a message at the Strophe.LogLevel.WARN level.
             *
             *  Parameters:
             *    (String) msg - The log message.
             */
            warn: function (msg) {
                this.log(this.LogLevel.WARN, msg);
            },

            /** Function: error
             *  Log a message at the Strophe.LogLevel.ERROR level.
             *
             *  Parameters:
             *    (String) msg - The log message.
             */
            error: function (msg) {
                this.log(this.LogLevel.ERROR, msg);
            },

            /** Function: fatal
             *  Log a message at the Strophe.LogLevel.FATAL level.
             *
             *  Parameters:
             *    (String) msg - The log message.
             */
            fatal: function (msg) {
                this.log(this.LogLevel.FATAL, msg);
            },

            /** Function: serialize
             *  Render a DOM element and all descendants to a String.
             *
             *  Parameters:
             *    (XMLElement) elem - A DOM element.
             *
             *  Returns:
             *    The serialized element tree as a String.
             */
            serialize: function (elem) {
                var result;

                if (!elem) { return null; }

                if (typeof(elem.tree) === "function") {
                    elem = elem.tree();
                }

                /**
                 * Leon Revill: Convert to lower case
                 * @type {string}
                 */
                /**
                 * Graham Mackenzie: Remove Leon's change
                 * @type {string}
                 */
                var nodeName = elem.nodeName;
                var i, child;

                if (elem.getAttribute("_realname")) {
                    nodeName = elem.getAttribute("_realname");
                }

                result = "<" + nodeName;
                for (i = 0; i < elem.attributes.length; i++) {
                    if(elem.attributes[i].nodeName != "_realname") {
                        result += " " + elem.attributes[i].nodeName +
                            "='" + Strophe.xmlescape(elem.attributes[i].value) + "'";
                    }
                }

                if (elem.childNodes.length > 0) {
                    result += ">";
                    for (i = 0; i < elem.childNodes.length; i++) {
                        child = elem.childNodes[i];
                        switch( child.nodeType ){
                            case Strophe.ElementType.NORMAL:
                                // normal element, so recurse
                                result += Strophe.serialize(child);
                                break;
                            case Strophe.ElementType.TEXT:
                                // text element to escape values
                                result += Strophe.xmlescape(child.nodeValue);
                                break;
                            case Strophe.ElementType.CDATA:
                                // cdata section so don't escape values
                                result += "<![CDATA["+child.nodeValue+"]]>";
                        }
                    }
                    result += "</" + nodeName + ">";
                } else {
                    result += "/>";
                }

                return result;
            },

            /** PrivateVariable: _requestId
             *  _Private_ variable that keeps track of the request ids for
             *  connections.
             */
            _requestId: 0,

            /** PrivateVariable: Strophe.connectionPlugins
             *  _Private_ variable Used to store plugin names that need
             *  initialization on Strophe.Connection construction.
             */
            _connectionPlugins: {},

            /** Function: addConnectionPlugin
             *  Extends the Strophe.Connection object with the given plugin.
             *
             *  Parameters:
             *    (String) name - The name of the extension.
             *    (Object) ptype - The plugin's prototype.
             */
            addConnectionPlugin: function (name, ptype) {
                Strophe._connectionPlugins[name] = ptype;
            }
        };

        /** Class: Strophe.Builder
         *  XML DOM builder.
         *
         *  This object provides an interface similar to JQuery but for building
         *  DOM elements easily and rapidly.  All the functions except for toString()
         *  and tree() return the object, so calls can be chained.  Here's an
         *  example using the $iq() builder helper.
         *  > $iq({to: 'you', from: 'me', type: 'get', id: '1'})
         *  >     .c('query', {xmlns: 'strophe:example'})
         *  >     .c('example')
         *  >     .toString()
         *
         *  The above generates this XML fragment
         *  > <iq to='you' from='me' type='get' id='1'>
         *  >   <query xmlns='strophe:example'>
         *  >     <example/>
         *  >   </query>
         *  > </iq>
         *  The corresponding DOM manipulations to get a similar fragment would be
         *  a lot more tedious and probably involve several helper variables.
         *
         *  Since adding children makes new operations operate on the child, up()
         *  is provided to traverse up the tree.  To add two children, do
         *  > builder.c('child1', ...).up().c('child2', ...)
         *  The next operation on the Builder will be relative to the second child.
         */

        /** Constructor: Strophe.Builder
         *  Create a Strophe.Builder object.
         *
         *  The attributes should be passed in object notation.  For example
         *  > var b = new Builder('message', {to: 'you', from: 'me'});
         *  or
         *  > var b = new Builder('messsage', {'xml:lang': 'en'});
         *
         *  Parameters:
         *    (String) name - The name of the root element.
         *    (Object) attrs - The attributes for the root element in object notation.
         *
         *  Returns:
         *    A new Strophe.Builder.
         */
        Strophe.Builder = function (name, attrs) {
            // Set correct namespace for jabber:client elements
            if (name == "presence" || name == "message" || name == "iq") {
                if (attrs && !attrs.xmlns) {
                    attrs.xmlns = Strophe.NS.CLIENT;
                } else if (!attrs) {
                    attrs = {xmlns: Strophe.NS.CLIENT};
                }
            }

            // Holds the tree being built.
            this.nodeTree = Strophe.xmlElement(name, attrs);

            // Points to the current operation node.
            this.node = this.nodeTree;
        };

        Strophe.Builder.prototype = {
            /** Function: tree
             *  Return the DOM tree.
             *
             *  This function returns the current DOM tree as an element object.  This
             *  is suitable for passing to functions like Strophe.Connection.send().
             *
             *  Returns:
             *    The DOM tree as a element object.
             */
            tree: function () {
                return this.nodeTree;
            },

            /** Function: toString
             *  Serialize the DOM tree to a String.
             *
             *  This function returns a string serialization of the current DOM
             *  tree.  It is often used internally to pass data to a
             *  Strophe.Request object.
             *
             *  Returns:
             *    The serialized DOM tree in a String.
             */
            toString: function () {
                return Strophe.serialize(this.nodeTree);
            },

            /** Function: up
             *  Make the current parent element the new current element.
             *
             *  This function is often used after c() to traverse back up the tree.
             *  For example, to add two children to the same element
             *  > builder.c('child1', {}).up().c('child2', {});
             *
             *  Returns:
             *    The Stophe.Builder object.
             */
            up: function () {
                this.node = this.node.parentNode;
                return this;
            },

            /** Function: root
             *  Make the root element the new current element.
             *
             *  When at a deeply nested element in the tree, this function can be used
             *  to jump back to the root of the tree, instead of having to repeatedly
             *  call up().
             *
             *  Returns:
             *    The Stophe.Builder object.
             */
            root: function () {
                this.node = this.nodeTree;
                return this;
            },

            /** Function: attrs
             *  Add or modify attributes of the current element.
             *
             *  The attributes should be passed in object notation.  This function
             *  does not move the current element pointer.
             *
             *  Parameters:
             *    (Object) moreattrs - The attributes to add/modify in object notation.
             *
             *  Returns:
             *    The Strophe.Builder object.
             */
            attrs: function (moreattrs) {
                for (var k in moreattrs) {
                    if (moreattrs.hasOwnProperty(k)) {
                        if (moreattrs[k] === undefined) {
                            this.node.removeAttribute(k);
                        } else {
                            this.node.setAttribute(k, moreattrs[k]);
                        }
                    }
                }
                return this;
            },

            /** Function: c
             *  Add a child to the current element and make it the new current
             *  element.
             *
             *  This function moves the current element pointer to the child,
             *  unless text is provided.  If you need to add another child, it
             *  is necessary to use up() to go back to the parent in the tree.
             *
             *  Parameters:
             *    (String) name - The name of the child.
             *    (Object) attrs - The attributes of the child in object notation.
             *    (String) text - The text to add to the child.
             *
             *  Returns:
             *    The Strophe.Builder object.
             */
            c: function (name, attrs, text) {
                var child = Strophe.xmlElement(name, attrs, text);
                this.node.appendChild(child);
                if (typeof text !== "string" && typeof text !=="number") {
                    this.node = child;
                }
                return this;
            },

            /** Function: cnode
             *  Add a child to the current element and make it the new current
             *  element.
             *
             *  This function is the same as c() except that instead of using a
             *  name and an attributes object to create the child it uses an
             *  existing DOM element object.
             *
             *  Parameters:
             *    (XMLElement) elem - A DOM element.
             *
             *  Returns:
             *    The Strophe.Builder object.
             */
            cnode: function (elem) {
                var impNode;
                var xmlGen = Strophe.xmlGenerator();
                try {
                    impNode = (xmlGen.importNode !== undefined);
                } catch (e) {
                    impNode = false;
                }
                var newElem = impNode ?
                    xmlGen.importNode(elem, true) :
                    Strophe.copyElement(elem);
                this.node.appendChild(newElem);
                this.node = newElem;
                return this;
            },

            /** Function: t
             *  Add a child text element.
             *
             *  This *does not* make the child the new current element since there
             *  are no children of text elements.
             *
             *  Parameters:
             *    (String) text - The text data to append to the current element.
             *
             *  Returns:
             *    The Strophe.Builder object.
             */
            t: function (text) {
                var child = Strophe.xmlTextNode(text);
                this.node.appendChild(child);
                return this;
            },

            /** Function: h
             *  Replace current element contents with the HTML passed in.
             *
             *  This *does not* make the child the new current element
             *
             *  Parameters:
             *    (String) html - The html to insert as contents of current element.
             *
             *  Returns:
             *    The Strophe.Builder object.
             */
            h: function (html) {
                var fragment = document.createElement('body');

                // force the browser to try and fix any invalid HTML tags
                fragment.innerHTML = html;

                // copy cleaned html into an xml dom
                var xhtml = Strophe.createHtml(fragment);

                while(xhtml.childNodes.length > 0) {
                    this.node.appendChild(xhtml.childNodes[0]);
                }
                return this;
            }
        };

        /** PrivateClass: Strophe.Handler
         *  _Private_ helper class for managing stanza handlers.
         *
         *  A Strophe.Handler encapsulates a user provided callback function to be
         *  executed when matching stanzas are received by the connection.
         *  Handlers can be either one-off or persistant depending on their
         *  return value. Returning true will cause a Handler to remain active, and
         *  returning false will remove the Handler.
         *
         *  Users will not use Strophe.Handler objects directly, but instead they
         *  will use Strophe.Connection.addHandler() and
         *  Strophe.Connection.deleteHandler().
         */

        /** PrivateConstructor: Strophe.Handler
         *  Create and initialize a new Strophe.Handler.
         *
         *  Parameters:
         *    (Function) handler - A function to be executed when the handler is run.
         *    (String) ns - The namespace to match.
         *    (String) name - The element name to match.
         *    (String) type - The element type to match.
         *    (String) id - The element id attribute to match.
         *    (String) from - The element from attribute to match.
         *    (Object) options - Handler options
         *
         *  Returns:
         *    A new Strophe.Handler object.
         */
        Strophe.Handler = function (handler, ns, name, type, id, from, options) {
            this.handler = handler;
            this.ns = ns;
            this.name = name;
            this.type = type;
            this.id = id;
            this.options = options || {'matchBareFromJid': false, 'ignoreNamespaceFragment': false};
            // BBB: Maintain backward compatibility with old `matchBare` option
            if (this.options.matchBare) {
                Strophe.warn('The "matchBare" option is deprecated, use "matchBareFromJid" instead.');
                this.options.matchBareFromJid = this.options.matchBare;
                delete this.options.matchBare;
            }

            if (this.options.matchBareFromJid) {
                this.from = from ? Strophe.getBareJidFromJid(from) : null;
            } else {
                this.from = from;
            }
            // whether the handler is a user handler or a system handler
            this.user = true;
        };

        Strophe.Handler.prototype = {
            /** PrivateFunction: getNamespace
             *  Returns the XML namespace attribute on an element.
             *  If `ignoreNamespaceFragment` was passed in for this handler, then the
             *  URL fragment will be stripped.
             *
             *  Parameters:
             *    (XMLElement) elem - The XML element with the namespace.
             *
             *  Returns:
             *    The namespace, with optionally the fragment stripped.
             */
            getNamespace: function (elem) {
                var elNamespace = elem.getAttribute("xmlns");
                if (elNamespace && this.options.ignoreNamespaceFragment) {
                    elNamespace = elNamespace.split('#')[0];
                }
                return elNamespace;
            },

            /** PrivateFunction: namespaceMatch
             *  Tests if a stanza matches the namespace set for this Strophe.Handler.
             *
             *  Parameters:
             *    (XMLElement) elem - The XML element to test.
             *
             *  Returns:
             *    true if the stanza matches and false otherwise.
             */
            namespaceMatch: function (elem) {
                var nsMatch = false;
                if (!this.ns) {
                    return true;
                } else {
                    var that = this;
                    Strophe.forEachChild(elem, null, function (elem) {
                        if (that.getNamespace(elem) === that.ns) {
                            nsMatch = true;
                        }
                    });
                    nsMatch = nsMatch || this.getNamespace(elem) === this.ns;
                }
                return nsMatch;
            },

            /** PrivateFunction: isMatch
             *  Tests if a stanza matches the Strophe.Handler.
             *
             *  Parameters:
             *    (XMLElement) elem - The XML element to test.
             *
             *  Returns:
             *    true if the stanza matches and false otherwise.
             */
            isMatch: function (elem) {
                var from = elem.getAttribute('from');
                if (this.options.matchBareFromJid) {
                    from = Strophe.getBareJidFromJid(from);
                }
                var elem_type = elem.getAttribute("type");
                if (this.namespaceMatch(elem) &&
                    (!this.name || Strophe.isTagEqual(elem, this.name)) &&
                    (!this.type || (Array.isArray(this.type) ? this.type.indexOf(elem_type) != -1 : elem_type == this.type)) &&
                    (!this.id || elem.getAttribute("id") == this.id) &&
                    (!this.from || from == this.from)) {
                    return true;
                }
                return false;
            },

            /** PrivateFunction: run
             *  Run the callback on a matching stanza.
             *
             *  Parameters:
             *    (XMLElement) elem - The DOM element that triggered the
             *      Strophe.Handler.
             *
             *  Returns:
             *    A boolean indicating if the handler should remain active.
             */
            run: function (elem) {
                var result = null;
                try {
                    result = this.handler(elem);
                } catch (e) {
                    Strophe._handleError(e);
                    throw e;
                }
                return result;
            },

            /** PrivateFunction: toString
             *  Get a String representation of the Strophe.Handler object.
             *
             *  Returns:
             *    A String.
             */
            toString: function () {
                return "{Handler: " + this.handler + "(" + this.name + "," +
                    this.id + "," + this.ns + ")}";
            }
        };

        /** PrivateClass: Strophe.TimedHandler
         *  _Private_ helper class for managing timed handlers.
         *
         *  A Strophe.TimedHandler encapsulates a user provided callback that
         *  should be called after a certain period of time or at regular
         *  intervals.  The return value of the callback determines whether the
         *  Strophe.TimedHandler will continue to fire.
         *
         *  Users will not use Strophe.TimedHandler objects directly, but instead
         *  they will use Strophe.Connection.addTimedHandler() and
         *  Strophe.Connection.deleteTimedHandler().
         */

        /** PrivateConstructor: Strophe.TimedHandler
         *  Create and initialize a new Strophe.TimedHandler object.
         *
         *  Parameters:
         *    (Integer) period - The number of milliseconds to wait before the
         *      handler is called.
         *    (Function) handler - The callback to run when the handler fires.  This
         *      function should take no arguments.
         *
         *  Returns:
         *    A new Strophe.TimedHandler object.
         */
        Strophe.TimedHandler = function (period, handler) {
            this.period = period;
            this.handler = handler;
            this.lastCalled = new Date().getTime();
            this.user = true;
        };

        Strophe.TimedHandler.prototype = {
            /** PrivateFunction: run
             *  Run the callback for the Strophe.TimedHandler.
             *
             *  Returns:
             *    true if the Strophe.TimedHandler should be called again, and false
             *      otherwise.
             */
            run: function () {
                this.lastCalled = new Date().getTime();
                return this.handler();
            },

            /** PrivateFunction: reset
             *  Reset the last called time for the Strophe.TimedHandler.
             */
            reset: function () {
                this.lastCalled = new Date().getTime();
            },

            /** PrivateFunction: toString
             *  Get a string representation of the Strophe.TimedHandler object.
             *
             *  Returns:
             *    The string representation.
             */
            toString: function () {
                return "{TimedHandler: " + this.handler + "(" + this.period +")}";
            }
        };

        /** Class: Strophe.Connection
         *  XMPP Connection manager.
         *
         *  This class is the main part of Strophe.  It manages a BOSH or websocket
         *  connection to an XMPP server and dispatches events to the user callbacks
         *  as data arrives. It supports SASL PLAIN, SASL DIGEST-MD5, SASL SCRAM-SHA1
         *  and legacy authentication.
         *
         *  After creating a Strophe.Connection object, the user will typically
         *  call connect() with a user supplied callback to handle connection level
         *  events like authentication failure, disconnection, or connection
         *  complete.
         *
         *  The user will also have several event handlers defined by using
         *  addHandler() and addTimedHandler().  These will allow the user code to
         *  respond to interesting stanzas or do something periodically with the
         *  connection. These handlers will be active once authentication is
         *  finished.
         *
         *  To send data to the connection, use send().
         */

        /** Constructor: Strophe.Connection
         *  Create and initialize a Strophe.Connection object.
         *
         *  The transport-protocol for this connection will be chosen automatically
         *  based on the given service parameter. URLs starting with "ws://" or
         *  "wss://" will use WebSockets, URLs starting with "http://", "https://"
         *  or without a protocol will use BOSH.
         *
         *  To make Strophe connect to the current host you can leave out the protocol
         *  and host part and just pass the path, e.g.
         *
         *  > var conn = new Strophe.Connection("/http-bind/");
         *
         *  Options common to both Websocket and BOSH:
         *  ------------------------------------------
         *
         *  cookies:
         *
         *  The *cookies* option allows you to pass in cookies to be added to the
         *  document. These cookies will then be included in the BOSH XMLHttpRequest
         *  or in the websocket connection.
         *
         *  The passed in value must be a map of cookie names and string values.
         *
         *  > { "myCookie": {
 *  >     "value": "1234",
 *  >     "domain": ".example.org",
 *  >     "path": "/",
 *  >     "expires": expirationDate
 *  >     }
 *  > }
         *
         *  Note that cookies can't be set in this way for other domains (i.e. cross-domain).
         *  Those cookies need to be set under those domains, for example they can be
         *  set server-side by making a XHR call to that domain to ask it to set any
         *  necessary cookies.
         *
         *  mechanisms:
         *
         *  The *mechanisms* option allows you to specify the SASL mechanisms that this
         *  instance of Strophe.Connection (and therefore your XMPP client) will
         *  support.
         *
         *  The value must be an array of objects with Strophe.SASLMechanism
         *  prototypes.
         *
         *  If nothing is specified, then the following mechanisms (and their
         *  priorities) are registered:
         *
         *      OAUTHBEARER - 60
         *      SCRAM-SHA1 - 50
         *      DIGEST-MD5 - 40
         *      PLAIN - 30
         *      ANONYMOUS - 20
         *      EXTERNAL - 10
         *
         *  WebSocket options:
         *  ------------------
         *
         *  If you want to connect to the current host with a WebSocket connection you
         *  can tell Strophe to use WebSockets through a "protocol" attribute in the
         *  optional options parameter. Valid values are "ws" for WebSocket and "wss"
         *  for Secure WebSocket.
         *  So to connect to "wss://CURRENT_HOSTNAME/xmpp-websocket" you would call
         *
         *  > var conn = new Strophe.Connection("/xmpp-websocket/", {protocol: "wss"});
         *
         *  Note that relative URLs _NOT_ starting with a "/" will also include the path
         *  of the current site.
         *
         *  Also because downgrading security is not permitted by browsers, when using
         *  relative URLs both BOSH and WebSocket connections will use their secure
         *  variants if the current connection to the site is also secure (https).
         *
         *  BOSH options:
         *  -------------
         *
         *  By adding "sync" to the options, you can control if requests will
         *  be made synchronously or not. The default behaviour is asynchronous.
         *  If you want to make requests synchronous, make "sync" evaluate to true.
         *  > var conn = new Strophe.Connection("/http-bind/", {sync: true});
         *
         *  You can also toggle this on an already established connection.
         *  > conn.options.sync = true;
         *
         *  The *customHeaders* option can be used to provide custom HTTP headers to be
         *  included in the XMLHttpRequests made.
         *
         *  The *keepalive* option can be used to instruct Strophe to maintain the
         *  current BOSH session across interruptions such as webpage reloads.
         *
         *  It will do this by caching the sessions tokens in sessionStorage, and when
         *  "restore" is called it will check whether there are cached tokens with
         *  which it can resume an existing session.
         *
         *  The *withCredentials* option should receive a Boolean value and is used to
         *  indicate wether cookies should be included in ajax requests (by default
         *  they're not).
         *  Set this value to true if you are connecting to a BOSH service
         *  and for some reason need to send cookies to it.
         *  In order for this to work cross-domain, the server must also enable
         *  credentials by setting the Access-Control-Allow-Credentials response header
         *  to "true". For most usecases however this setting should be false (which
         *  is the default).
         *  Additionally, when using Access-Control-Allow-Credentials, the
         *  Access-Control-Allow-Origin header can't be set to the wildcard "*", but
         *  instead must be restricted to actual domains.
         *
         *  The *contentType* option can be set to change the default Content-Type
         *  of "text/xml; charset=utf-8", which can be useful to reduce the amount of
         *  CORS preflight requests that are sent to the server.
         *
         *  Parameters:
         *    (String) service - The BOSH or WebSocket service URL.
         *    (Object) options - A hash of configuration options
         *
         *  Returns:
         *    A new Strophe.Connection object.
         */
        Strophe.Connection = function (service, options) {
            // The service URL
            this.service = service;
            // Configuration options
            this.options = options || {};
            var proto = this.options.protocol || "";

            // Select protocal based on service or options
            if (service.indexOf("ws:") === 0 || service.indexOf("wss:") === 0 ||
                proto.indexOf("ws") === 0) {
                this._proto = new Strophe.Websocket(this);
            } else {
                this._proto = new Strophe.Bosh(this);
            }

            /* The connected JID. */
            this.jid = "";
            /* the JIDs domain */
            this.domain = null;
            /* stream:features */
            this.features = null;

            // SASL
            this._sasl_data = {};
            this.do_session = false;
            this.do_bind = false;

            // handler lists
            this.timedHandlers = [];
            this.handlers = [];
            this.removeTimeds = [];
            this.removeHandlers = [];
            this.addTimeds = [];
            this.addHandlers = [];
            this.protocolErrorHandlers = {
                'HTTP': {},
                'websocket': {}
            };

            this._idleTimeout = null;
            this._disconnectTimeout = null;

            this.authenticated = false;
            this.connected = false;
            this.disconnecting = false;
            this.do_authentication = true;
            this.paused = false;
            this.restored = false;

            this._data = [];
            this._uniqueId = 0;

            this._sasl_success_handler = null;
            this._sasl_failure_handler = null;
            this._sasl_challenge_handler = null;

            // Max retries before disconnecting
            this.maxRetries = 5;

            // Call onIdle callback every 1/10th of a second
            // XXX: setTimeout should be called only with function expressions (23974bc1)
            this._idleTimeout = setTimeout(function() {
                this._onIdle();
            }.bind(this), 100);

            utils.addCookies(this.options.cookies);
            this.registerSASLMechanisms(this.options.mechanisms);

            // initialize plugins
            for (var k in Strophe._connectionPlugins) {
                if (Strophe._connectionPlugins.hasOwnProperty(k)) {
                    var ptype = Strophe._connectionPlugins[k];
                    // jslint complaints about the below line, but this is fine
                    var F = function () {}; // jshint ignore:line
                    F.prototype = ptype;
                    this[k] = new F();
                    this[k].init(this);
                }
            }
        };

        Strophe.Connection.prototype = {
            /** Function: reset
             *  Reset the connection.
             *
             *  This function should be called after a connection is disconnected
             *  before that connection is reused.
             */
            reset: function () {
                this._proto._reset();

                // SASL
                this.do_session = false;
                this.do_bind = false;

                // handler lists
                this.timedHandlers = [];
                this.handlers = [];
                this.removeTimeds = [];
                this.removeHandlers = [];
                this.addTimeds = [];
                this.addHandlers = [];

                this.authenticated = false;
                this.connected = false;
                this.disconnecting = false;
                this.restored = false;

                // If set to true override stanza will be sent before bind
                this.override = false;

                this._data = [];
                this._requests = [];
                this._uniqueId = 0;
            },

            /** Function: pause
             *  Pause the request manager.
             *
             *  This will prevent Strophe from sending any more requests to the
             *  server.  This is very useful for temporarily pausing
             *  BOSH-Connections while a lot of send() calls are happening quickly.
             *  This causes Strophe to send the data in a single request, saving
             *  many request trips.
             */
            pause: function () {
                this.paused = true;
            },

            /** Function: resume
             *  Resume the request manager.
             *
             *  This resumes after pause() has been called.
             */
            resume: function () {
                this.paused = false;
            },

            /** Function: getUniqueId
             *  Generate a unique ID for use in <iq/> elements.
             *
             *  All <iq/> stanzas are required to have unique id attributes.  This
             *  function makes creating these easy.  Each connection instance has
             *  a counter which starts from zero, and the value of this counter
             *  plus a colon followed by the suffix becomes the unique id. If no
             *  suffix is supplied, the counter is used as the unique id.
             *
             *  Suffixes are used to make debugging easier when reading the stream
             *  data, and their use is recommended.  The counter resets to 0 for
             *  every new connection for the same reason.  For connections to the
             *  same server that authenticate the same way, all the ids should be
             *  the same, which makes it easy to see changes.  This is useful for
             *  automated testing as well.
             *
             *  Parameters:
             *    (String) suffix - A optional suffix to append to the id.
             *
             *  Returns:
             *    A unique string to be used for the id attribute.
             */
            getUniqueId: function(suffix) {
                var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                    var r = Math.random() * 16 | 0,
                        v = c == 'x' ? r : r & 0x3 | 0x8;
                    return v.toString(16);
                });
                if (typeof(suffix) == "string" || typeof(suffix) == "number") {
                    return uuid + ":" + suffix;
                } else {
                    return uuid + "";
                }
            },

            /** Function: addProtocolErrorHandler
             *  Register a handler function for when a protocol (websocker or HTTP)
             *  error occurs.
             *
             *  NOTE: Currently only HTTP errors for BOSH requests are handled.
             *  Patches that handle websocket errors would be very welcome.
             *
             *  Parameters:
             *    (String) protocol - 'HTTP' or 'websocket'
             *    (Integer) status_code - Error status code (e.g 500, 400 or 404)
             *    (Function) callback - Function that will fire on Http error
             *
             *  Example:
             *  function onError(err_code){
     *    //do stuff
     *  }
             *
             *  var conn = Strophe.connect('http://example.com/http-bind');
             *  conn.addProtocolErrorHandler('HTTP', 500, onError);
             *  // Triggers HTTP 500 error and onError handler will be called
             *  conn.connect('user_jid@incorrect_jabber_host', 'secret', onConnect);
             */
            addProtocolErrorHandler: function(protocol, status_code, callback){
                this.protocolErrorHandlers[protocol][status_code] = callback;
            },


            /** Function: connect
             *  Starts the connection process.
             *
             *  As the connection process proceeds, the user supplied callback will
             *  be triggered multiple times with status updates.  The callback
             *  should take two arguments - the status code and the error condition.
             *
             *  The status code will be one of the values in the Strophe.Status
             *  constants.  The error condition will be one of the conditions
             *  defined in RFC 3920 or the condition 'strophe-parsererror'.
             *
             *  The Parameters _wait_, _hold_ and _route_ are optional and only relevant
             *  for BOSH connections. Please see XEP 124 for a more detailed explanation
             *  of the optional parameters.
             *
             *  Parameters:
             *    (String) jid - The user's JID.  This may be a bare JID,
             *      or a full JID.  If a node is not supplied, SASL ANONYMOUS
             *      authentication will be attempted.
             *    (String) pass - The user's password.
             *    (Function) callback - The connect callback function.
             *    (Integer) wait - The optional HTTPBIND wait value.  This is the
             *      time the server will wait before returning an empty result for
             *      a request.  The default setting of 60 seconds is recommended.
             *    (Integer) hold - The optional HTTPBIND hold value.  This is the
             *      number of connections the server will hold at one time.  This
             *      should almost always be set to 1 (the default).
             *    (String) route - The optional route value.
             *    (String) authcid - The optional alternative authentication identity
             *      (username) if intending to impersonate another user.
             *      When using the SASL-EXTERNAL authentication mechanism, for example
             *      with client certificates, then the authcid value is used to
             *      determine whether an authorization JID (authzid) should be sent to
             *      the server. The authzid should not be sent to the server if the
             *      authzid and authcid are the same. So to prevent it from being sent
             *      (for example when the JID is already contained in the client
             *      certificate), set authcid to that same JID. See XEP-178 for more
             *      details.
             */
            connect: function (jid, pass, callback, wait, hold, route, authcid) {

                this.jid = jid;
                /** Variable: authzid
                 *  Authorization identity.
                 */
                this.authzid = Strophe.getBareJidFromJid(this.jid);

                /** Variable: authcid
                 *  Authentication identity (User name).
                 */
                this.authcid = authcid || Strophe.getNodeFromJid(this.jid);

                /** Variable: pass
                 *  Authentication identity (User password).
                 */
                this.pass = pass;

                /** Variable: servtype
                 *  Digest MD5 compatibility.
                 */
                this.servtype = "xmpp";

                this.connect_callback = callback;
                this.disconnecting = false;
                this.connected = false;
                this.authenticated = false;
                this.restored = false;

                // parse jid for domain
                this.domain = Strophe.getDomainFromJid(this.jid);

                this._changeConnectStatus(Strophe.Status.CONNECTING, null);

                this._proto._connect(wait, hold, route);
            },

            /** Function: attach
             *  Attach to an already created and authenticated BOSH session.
             *
             *  This function is provided to allow Strophe to attach to BOSH
             *  sessions which have been created externally, perhaps by a Web
             *  application.  This is often used to support auto-login type features
             *  without putting user credentials into the page.
             *
             *  Parameters:
             *    (String) jid - The full JID that is bound by the session.
             *    (String) sid - The SID of the BOSH session.
             *    (String) rid - The current RID of the BOSH session.  This RID
             *      will be used by the next request.
             *    (Function) callback The connect callback function.
             *    (Integer) wait - The optional HTTPBIND wait value.  This is the
             *      time the server will wait before returning an empty result for
             *      a request.  The default setting of 60 seconds is recommended.
             *      Other settings will require tweaks to the Strophe.TIMEOUT value.
             *    (Integer) hold - The optional HTTPBIND hold value.  This is the
             *      number of connections the server will hold at one time.  This
             *      should almost always be set to 1 (the default).
             *    (Integer) wind - The optional HTTBIND window value.  This is the
             *      allowed range of request ids that are valid.  The default is 5.
             */
            attach: function (jid, sid, rid, callback, wait, hold, wind) {
                if (this._proto instanceof Strophe.Bosh) {
                    this._proto._attach(jid, sid, rid, callback, wait, hold, wind);
                } else {
                    throw {
                        name: 'StropheSessionError',
                        message: 'The "attach" method can only be used with a BOSH connection.'
                    };
                }
            },

            /** Function: restore
             *  Attempt to restore a cached BOSH session.
             *
             *  This function is only useful in conjunction with providing the
             *  "keepalive":true option when instantiating a new Strophe.Connection.
             *
             *  When "keepalive" is set to true, Strophe will cache the BOSH tokens
             *  RID (Request ID) and SID (Session ID) and then when this function is
             *  called, it will attempt to restore the session from those cached
             *  tokens.
             *
             *  This function must therefore be called instead of connect or attach.
             *
             *  For an example on how to use it, please see examples/restore.js
             *
             *  Parameters:
             *    (String) jid - The user's JID.  This may be a bare JID or a full JID.
             *    (Function) callback - The connect callback function.
             *    (Integer) wait - The optional HTTPBIND wait value.  This is the
             *      time the server will wait before returning an empty result for
             *      a request.  The default setting of 60 seconds is recommended.
             *    (Integer) hold - The optional HTTPBIND hold value.  This is the
             *      number of connections the server will hold at one time.  This
             *      should almost always be set to 1 (the default).
             *    (Integer) wind - The optional HTTBIND window value.  This is the
             *      allowed range of request ids that are valid.  The default is 5.
             */
            restore: function (jid, callback, wait, hold, wind) {
                if (this._sessionCachingSupported()) {
                    this._proto._restore(jid, callback, wait, hold, wind);
                } else {
                    throw {
                        name: 'StropheSessionError',
                        message: 'The "restore" method can only be used with a BOSH connection.'
                    };
                }
            },

            /** PrivateFunction: _sessionCachingSupported
             * Checks whether sessionStorage and JSON are supported and whether we're
             * using BOSH.
             */
            _sessionCachingSupported: function () {
                if (this._proto instanceof Strophe.Bosh) {
                    if (!JSON) { return false; }
                    try {
                        window.sessionStorage.setItem('_strophe_', '_strophe_');
                        window.sessionStorage.removeItem('_strophe_');
                    } catch (e) {
                        return false;
                    }
                    return true;
                }
                return false;
            },

            /** Function: xmlInput
             *  User overrideable function that receives XML data coming into the
             *  connection.
             *
             *  The default function does nothing.  User code can override this with
             *  > Strophe.Connection.xmlInput = function (elem) {
     *  >   (user code)
     *  > };
             *
             *  Due to limitations of current Browsers' XML-Parsers the opening and closing
             *  <stream> tag for WebSocket-Connoctions will be passed as selfclosing here.
             *
             *  BOSH-Connections will have all stanzas wrapped in a <body> tag. See
             *  <Strophe.Bosh.strip> if you want to strip this tag.
             *
             *  Parameters:
             *    (XMLElement) elem - The XML data received by the connection.
             */
            /* jshint unused:false */
            xmlInput: function (elem) {
                return;
            },
            /* jshint unused:true */

            /** Function: xmlOutput
             *  User overrideable function that receives XML data sent to the
             *  connection.
             *
             *  The default function does nothing.  User code can override this with
             *  > Strophe.Connection.xmlOutput = function (elem) {
     *  >   (user code)
     *  > };
             *
             *  Due to limitations of current Browsers' XML-Parsers the opening and closing
             *  <stream> tag for WebSocket-Connoctions will be passed as selfclosing here.
             *
             *  BOSH-Connections will have all stanzas wrapped in a <body> tag. See
             *  <Strophe.Bosh.strip> if you want to strip this tag.
             *
             *  Parameters:
             *    (XMLElement) elem - The XMLdata sent by the connection.
             */
            /* jshint unused:false */
            xmlOutput: function (elem) {
                return;
            },
            /* jshint unused:true */

            /** Function: rawInput
             *  User overrideable function that receives raw data coming into the
             *  connection.
             *
             *  The default function does nothing.  User code can override this with
             *  > Strophe.Connection.rawInput = function (data) {
     *  >   (user code)
     *  > };
             *
             *  Parameters:
             *    (String) data - The data received by the connection.
             */
            /* jshint unused:false */
            rawInput: function (data) {
                return;
            },
            /* jshint unused:true */

            /** Function: rawOutput
             *  User overrideable function that receives raw data sent to the
             *  connection.
             *
             *  The default function does nothing.  User code can override this with
             *  > Strophe.Connection.rawOutput = function (data) {
     *  >   (user code)
     *  > };
             *
             *  Parameters:
             *    (String) data - The data sent by the connection.
             */
            /* jshint unused:false */
            rawOutput: function (data) {
                return;
            },
            /* jshint unused:true */

            /** Function: nextValidRid
             *  User overrideable function that receives the new valid rid.
             *
             *  The default function does nothing. User code can override this with
             *  > Strophe.Connection.nextValidRid = function (rid) {
     *  >    (user code)
     *  > };
             *
             *  Parameters:
             *    (Number) rid - The next valid rid
             */
            /* jshint unused:false */
            nextValidRid: function (rid) {
                return;
            },
            /* jshint unused:true */

            /** Function: send
             *  Send a stanza.
             *
             *  This function is called to push data onto the send queue to
             *  go out over the wire.  Whenever a request is sent to the BOSH
             *  server, all pending data is sent and the queue is flushed.
             *
             *  Parameters:
             *    (XMLElement |
             *     [XMLElement] |
             *     Strophe.Builder) elem - The stanza to send.
             */
            send: function (elem) {
                if (elem === null) { return ; }
                if (typeof(elem.sort) === "function") {
                    for (var i = 0; i < elem.length; i++) {
                        this._queueData(elem[i]);
                    }
                } else if (typeof(elem.tree) === "function") {
                    this._queueData(elem.tree());
                } else {
                    this._queueData(elem);
                }

                this._proto._send();
            },

            /** Function: flush
             *  Immediately send any pending outgoing data.
             *
             *  Normally send() queues outgoing data until the next idle period
             *  (100ms), which optimizes network use in the common cases when
             *  several send()s are called in succession. flush() can be used to
             *  immediately send all pending data.
             */
            flush: function () {
                // cancel the pending idle period and run the idle function
                // immediately
                clearTimeout(this._idleTimeout);
                this._onIdle();
            },

            /** Function: sendPresence
             *  Helper function to send presence stanzas. The main benefit is for
             *  sending presence stanzas for which you expect a responding presence
             *  stanza with the same id (for example when leaving a chat room).
             *
             *  Parameters:
             *    (XMLElement) elem - The stanza to send.
             *    (Function) callback - The callback function for a successful request.
             *    (Function) errback - The callback function for a failed or timed
             *      out request.  On timeout, the stanza will be null.
             *    (Integer) timeout - The time specified in milliseconds for a
             *      timeout to occur.
             *
             *  Returns:
             *    The id used to send the presence.
             */
            sendPresence: function(elem, callback, errback, timeout) {
                var timeoutHandler = null;
                var that = this;
                if (typeof(elem.tree) === "function") {
                    elem = elem.tree();
                }
                var id = elem.getAttribute('id');
                if (!id) { // inject id if not found
                    id = this.getUniqueId("sendPresence");
                    elem.setAttribute("id", id);
                }

                if (typeof callback === "function" || typeof errback === "function") {
                    var handler = this.addHandler(function (stanza) {
                        // remove timeout handler if there is one
                        if (timeoutHandler) {
                            that.deleteTimedHandler(timeoutHandler);
                        }
                        var type = stanza.getAttribute('type');
                        if (type == 'error') {
                            if (errback) {
                                errback(stanza);
                            }
                        } else if (callback) {
                            callback(stanza);
                        }
                    }, null, 'presence', null, id);

                    // if timeout specified, set up a timeout handler.
                    if (timeout) {
                        timeoutHandler = this.addTimedHandler(timeout, function () {
                            // get rid of normal handler
                            that.deleteHandler(handler);
                            // call errback on timeout with null stanza
                            if (errback) {
                                errback(null);
                            }
                            return false;
                        });
                    }
                }
                this.send(elem);
                return id;
            },

            /** Function: sendIQ
             *  Helper function to send IQ stanzas.
             *
             *  Parameters:
             *    (XMLElement) elem - The stanza to send.
             *    (Function) callback - The callback function for a successful request.
             *    (Function) errback - The callback function for a failed or timed
             *      out request.  On timeout, the stanza will be null.
             *    (Integer) timeout - The time specified in milliseconds for a
             *      timeout to occur.
             *
             *  Returns:
             *    The id used to send the IQ.
             */
            sendIQ: function(elem, callback, errback, timeout) {
                var timeoutHandler = null;
                var that = this;
                if (typeof(elem.tree) === "function") {
                    elem = elem.tree();
                }
                var id = elem.getAttribute('id');
                if (!id) { // inject id if not found
                    id = this.getUniqueId("sendIQ");
                    elem.setAttribute("id", id);
                }

                if (typeof callback === "function" || typeof errback === "function") {
                    var handler = this.addHandler(function (stanza) {
                        // remove timeout handler if there is one
                        if (timeoutHandler) {
                            that.deleteTimedHandler(timeoutHandler);
                        }
                        var iqtype = stanza.getAttribute('type');
                        if (iqtype == 'result') {
                            if (callback) {
                                callback(stanza);
                            }
                        } else if (iqtype == 'error') {
                            if (errback) {
                                errback(stanza);
                            }
                        } else {
                            throw {
                                name: "StropheError",
                                message: "Got bad IQ type of " + iqtype
                            };
                        }
                    }, null, 'iq', ['error', 'result'], id);

                    // if timeout specified, set up a timeout handler.
                    if (timeout) {
                        timeoutHandler = this.addTimedHandler(timeout, function () {
                            // get rid of normal handler
                            that.deleteHandler(handler);
                            // call errback on timeout with null stanza
                            if (errback) {
                                errback(null);
                            }
                            return false;
                        });
                    }
                }
                this.send(elem);
                return id;
            },

            /** PrivateFunction: _queueData
             *  Queue outgoing data for later sending.  Also ensures that the data
             *  is a DOMElement.
             */
            _queueData: function (element) {
                if (element === null ||
                    !element.tagName ||
                    !element.childNodes) {
                    throw {
                        name: "StropheError",
                        message: "Cannot queue non-DOMElement."
                    };
                }
                this._data.push(element);
            },

            /** PrivateFunction: _sendRestart
             *  Send an xmpp:restart stanza.
             */
            _sendRestart: function () {
                this._data.push("restart");
                this._proto._sendRestart();
                // XXX: setTimeout should be called only with function expressions (23974bc1)
                this._idleTimeout = setTimeout(function() {
                    this._onIdle();
                }.bind(this), 100);
            },

            /** Function: addTimedHandler
             *  Add a timed handler to the connection.
             *
             *  This function adds a timed handler.  The provided handler will
             *  be called every period milliseconds until it returns false,
             *  the connection is terminated, or the handler is removed.  Handlers
             *  that wish to continue being invoked should return true.
             *
             *  Because of method binding it is necessary to save the result of
             *  this function if you wish to remove a handler with
             *  deleteTimedHandler().
             *
             *  Note that user handlers are not active until authentication is
             *  successful.
             *
             *  Parameters:
             *    (Integer) period - The period of the handler.
             *    (Function) handler - The callback function.
             *
             *  Returns:
             *    A reference to the handler that can be used to remove it.
             */
            addTimedHandler: function (period, handler) {
                var thand = new Strophe.TimedHandler(period, handler);
                this.addTimeds.push(thand);
                return thand;
            },

            /** Function: deleteTimedHandler
             *  Delete a timed handler for a connection.
             *
             *  This function removes a timed handler from the connection.  The
             *  handRef parameter is *not* the function passed to addTimedHandler(),
             *  but is the reference returned from addTimedHandler().
             *
             *  Parameters:
             *    (Strophe.TimedHandler) handRef - The handler reference.
             */
            deleteTimedHandler: function (handRef) {
                // this must be done in the Idle loop so that we don't change
                // the handlers during iteration
                this.removeTimeds.push(handRef);
            },

            /** Function: addHandler
             *  Add a stanza handler for the connection.
             *
             *  This function adds a stanza handler to the connection.  The
             *  handler callback will be called for any stanza that matches
             *  the parameters.  Note that if multiple parameters are supplied,
             *  they must all match for the handler to be invoked.
             *
             *  The handler will receive the stanza that triggered it as its argument.
             *  *The handler should return true if it is to be invoked again;
             *  returning false will remove the handler after it returns.*
             *
             *  As a convenience, the ns parameters applies to the top level element
             *  and also any of its immediate children.  This is primarily to make
             *  matching /iq/query elements easy.
             *
             *  Options
             *  ~~~~~~~
             *  With the options argument, you can specify boolean flags that affect how
             *  matches are being done.
             *
             *  Currently two flags exist:
             *
             *  - matchBareFromJid:
             *      When set to true, the from parameter and the
             *      from attribute on the stanza will be matched as bare JIDs instead
             *      of full JIDs. To use this, pass {matchBareFromJid: true} as the
             *      value of options. The default value for matchBareFromJid is false.
             *
             *  - ignoreNamespaceFragment:
             *      When set to true, a fragment specified on the stanza's namespace
             *      URL will be ignored when it's matched with the one configured for
             *      the handler.
             *
             *      This means that if you register like this:
             *      >   connection.addHandler(
             *      >       handler,
             *      >       'http://jabber.org/protocol/muc',
             *      >       null, null, null, null,
             *      >       {'ignoreNamespaceFragment': true}
             *      >   );
             *
             *      Then a stanza with XML namespace of
             *      'http://jabber.org/protocol/muc#user' will also be matched. If
             *      'ignoreNamespaceFragment' is false, then only stanzas with
             *      'http://jabber.org/protocol/muc' will be matched.
             *
             *  Deleting the handler
             *  ~~~~~~~~~~~~~~~~~~~~
             *  The return value should be saved if you wish to remove the handler
             *  with deleteHandler().
             *
             *  Parameters:
             *    (Function) handler - The user callback.
             *    (String) ns - The namespace to match.
             *    (String) name - The stanza name to match.
             *    (String|Array) type - The stanza type (or types if an array) to match.
             *    (String) id - The stanza id attribute to match.
             *    (String) from - The stanza from attribute to match.
             *    (String) options - The handler options
             *
             *  Returns:
             *    A reference to the handler that can be used to remove it.
             */
            addHandler: function (handler, ns, name, type, id, from, options) {
                var hand = new Strophe.Handler(handler, ns, name, type, id, from, options);
                this.addHandlers.push(hand);
                return hand;
            },

            /** Function: deleteHandler
             *  Delete a stanza handler for a connection.
             *
             *  This function removes a stanza handler from the connection.  The
             *  handRef parameter is *not* the function passed to addHandler(),
             *  but is the reference returned from addHandler().
             *
             *  Parameters:
             *    (Strophe.Handler) handRef - The handler reference.
             */
            deleteHandler: function (handRef) {
                // this must be done in the Idle loop so that we don't change
                // the handlers during iteration
                this.removeHandlers.push(handRef);
                // If a handler is being deleted while it is being added,
                // prevent it from getting added
                var i = this.addHandlers.indexOf(handRef);
                if (i >= 0) {
                    this.addHandlers.splice(i, 1);
                }
            },

            /** Function: registerSASLMechanisms
             *
             * Register the SASL mechanisms which will be supported by this instance of
             * Strophe.Connection (i.e. which this XMPP client will support).
             *
             *  Parameters:
             *    (Array) mechanisms - Array of objects with Strophe.SASLMechanism prototypes
             *
             */
            registerSASLMechanisms: function (mechanisms) {
                this.mechanisms = {};
                mechanisms = mechanisms || [
                        Strophe.SASLAnonymous,
                        Strophe.SASLExternal,
                        Strophe.SASLMD5,
                        Strophe.SASLOAuthBearer,
                        Strophe.SASLPlain,
                        Strophe.SASLSHA1
                    ];
                mechanisms.forEach(this.registerSASLMechanism.bind(this));
            },

            /** Function: registerSASLMechanism
             *
             * Register a single SASL mechanism, to be supported by this client.
             *
             *  Parameters:
             *    (Object) mechanism - Object with a Strophe.SASLMechanism prototype
             *
             */
            registerSASLMechanism: function (mechanism) {
                this.mechanisms[mechanism.prototype.name] = mechanism;
            },

            /** Function: disconnect
             *  Start the graceful disconnection process.
             *
             *  This function starts the disconnection process.  This process starts
             *  by sending unavailable presence and sending BOSH body of type
             *  terminate.  A timeout handler makes sure that disconnection happens
             *  even if the BOSH server does not respond.
             *  If the Connection object isn't connected, at least tries to abort all pending requests
             *  so the connection object won't generate successful requests (which were already opened).
             *
             *  The user supplied connection callback will be notified of the
             *  progress as this process happens.
             *
             *  Parameters:
             *    (String) reason - The reason the disconnect is occuring.
             */
            disconnect: function (reason, dontClose) {                
                Strophe.info("Disconnect was called because: " + reason);
                if (this.connected) {
                    this._changeConnectStatus(Strophe.Status.DISCONNECTING, reason);
                    var pres = false;
                    this.disconnecting = true;
                    if (this.authenticated) {
                        pres = $pres({
                            xmlns: Strophe.NS.CLIENT,
                            type: 'unavailable'
                        });
                    }
                    // setup timeout handler
                    this._disconnectTimeout = this._addSysTimedHandler(
                        3000, this._onDisconnectTimeout.bind(this));
                    this._proto._disconnect(pres, dontClose);
                } else {
                    Strophe.info("Disconnect was called before Strophe connected to the server");
                    this._proto._abortAllRequests();
                    this._doDisconnect(reason);
                }
            },

            /** PrivateFunction: _changeConnectStatus
             *  _Private_ helper function that makes sure plugins and the user's
             *  callback are notified of connection status changes.
             *
             *  Parameters:
             *    (Integer) status - the new connection status, one of the values
             *      in Strophe.Status
             *    (String) condition - the error condition or null
             */
            _changeConnectStatus: function (status, condition) {
                // notify all plugins listening for status changes
                for (var k in Strophe._connectionPlugins) {
                    if (Strophe._connectionPlugins.hasOwnProperty(k)) {
                        var plugin = this[k];
                        if (plugin.statusChanged) {
                            try {
                                plugin.statusChanged(status, condition);
                            } catch (err) {
                                Strophe.error("" + k + " plugin caused an exception " +
                                    "changing status: " + err);
                            }
                        }
                    }
                }

                // notify the user's callback
                if (this.connect_callback) {
                    try {
                        this.connect_callback(status, condition);
                    } catch (e) {
                        Strophe._handleError(e);
                        Strophe.error(
                            "User connection callback caused an "+"exception: "+e);
                    }
                }
            },

            /** PrivateFunction: _doDisconnect
             *  _Private_ function to disconnect.
             *
             *  This is the last piece of the disconnection logic.  This resets the
             *  connection and alerts the user's connection callback.
             */
            _doDisconnect: function (condition) {
                if (typeof this._idleTimeout == "number") {
                    clearTimeout(this._idleTimeout);
                }

                // Cancel Disconnect Timeout
                if (this._disconnectTimeout !== null) {
                    this.deleteTimedHandler(this._disconnectTimeout);
                    this._disconnectTimeout = null;
                }

                Strophe.info("_doDisconnect was called");
                this._proto._doDisconnect();

                this.authenticated = false;
                this.disconnecting = false;
                this.restored = false;

                // delete handlers
                this.handlers = [];
                this.timedHandlers = [];
                this.removeTimeds = [];
                this.removeHandlers = [];
                this.addTimeds = [];
                this.addHandlers = [];

                // tell the parent we disconnected
                this._changeConnectStatus(Strophe.Status.DISCONNECTED, condition);
                this.connected = false;
            },

            /** PrivateFunction: _dataRecv
             *  _Private_ handler to processes incoming data from the the connection.
             *
             *  Except for _connect_cb handling the initial connection request,
             *  this function handles the incoming data for all requests.  This
             *  function also fires stanza handlers that match each incoming
             *  stanza.
             *
             *  Parameters:
             *    (Strophe.Request) req - The request that has data ready.
             *    (string) req - The stanza a raw string (optiona).
             */
            _dataRecv: function (req, raw) {
                Strophe.info("_dataRecv called");
                var elem = this._proto._reqToData(req);
                if (elem === null) { return; }

                if (this.xmlInput !== Strophe.Connection.prototype.xmlInput) {
                    if (elem.nodeName === this._proto.strip && elem.childNodes.length) {
                        this.xmlInput(elem.childNodes[0]);
                    } else {
                        this.xmlInput(elem);
                    }
                }
                if (this.rawInput !== Strophe.Connection.prototype.rawInput) {
                    if (raw) {
                        this.rawInput(raw);
                    } else {
                        this.rawInput(Strophe.serialize(elem));
                    }
                }

                // remove handlers scheduled for deletion
                var i, hand;
                while (this.removeHandlers.length > 0) {
                    hand = this.removeHandlers.pop();
                    i = this.handlers.indexOf(hand);
                    if (i >= 0) {
                        this.handlers.splice(i, 1);
                    }
                }

                // add handlers scheduled for addition
                while (this.addHandlers.length > 0) {
                    this.handlers.push(this.addHandlers.pop());
                }

                // handle graceful disconnect
                if (this.disconnecting && this._proto._emptyQueue()) {
                    this._doDisconnect();
                    return;
                }

                var type = elem.getAttribute("type");
                var cond, conflict;
                if (type !== null && type == "terminate") {
                    // Don't process stanzas that come in after disconnect
                    if (this.disconnecting) {
                        return;
                    }

                    // an error occurred
                    cond = elem.getAttribute("condition");
                    conflict = elem.getElementsByTagName("conflict");
                    if (cond !== null) {
                        if (cond == "remote-stream-error" && conflict.length > 0) {
                            cond = "conflict";
                        }
                        this._changeConnectStatus(Strophe.Status.CONNFAIL, cond);
                    } else {
                        this._changeConnectStatus(Strophe.Status.CONNFAIL, "unknown");
                    }
                    this._doDisconnect(cond);
                    return;
                }

                // send each incoming stanza through the handler chain
                var that = this;
                Strophe.forEachChild(elem, null, function (child) {
                    var i, newList;
                    // process handlers
                    newList = that.handlers;
                    that.handlers = [];
                    for (i = 0; i < newList.length; i++) {
                        var hand = newList[i];
                        // encapsulate 'handler.run' not to lose the whole handler list if
                        // one of the handlers throws an exception
                        try {
                            if (hand.isMatch(child) &&
                                (that.authenticated || !hand.user)) {
                                if (hand.run(child)) {
                                    that.handlers.push(hand);
                                }
                            } else {
                                that.handlers.push(hand);
                            }
                        } catch(e) {
                            // if the handler throws an exception, we consider it as false
                            Strophe.warn('Removing Strophe handlers due to uncaught exception: '+e.message);
                        }
                    }
                });
            },


            /** Attribute: mechanisms
             *  SASL Mechanisms available for Connection.
             */
            mechanisms: {},

            /** PrivateFunction: _connect_cb
             *  _Private_ handler for initial connection request.
             *
             *  This handler is used to process the initial connection request
             *  response from the BOSH server. It is used to set up authentication
             *  handlers and start the authentication process.
             *
             *  SASL authentication will be attempted if available, otherwise
             *  the code will fall back to legacy authentication.
             *
             *  Parameters:
             *    (Strophe.Request) req - The current request.
             *    (Function) _callback - low level (xmpp) connect callback function.
             *      Useful for plugins with their own xmpp connect callback (when their)
             *      want to do something special).
             */
            _connect_cb: function (req, _callback, raw) {
                Strophe.info("_connect_cb was called");
                this.connected = true;

                var bodyWrap;
                try {
                    bodyWrap = this._proto._reqToData(req);
                } catch (e) {
                    if (e != "badformat") { throw e; }
                    this._changeConnectStatus(Strophe.Status.CONNFAIL, 'bad-format');
                    this._doDisconnect('bad-format');
                }
                if (!bodyWrap) { return; }

                if (this.xmlInput !== Strophe.Connection.prototype.xmlInput) {
                    if (bodyWrap.nodeName === this._proto.strip && bodyWrap.childNodes.length) {
                        this.xmlInput(bodyWrap.childNodes[0]);
                    } else {
                        this.xmlInput(bodyWrap);
                    }
                }
                if (this.rawInput !== Strophe.Connection.prototype.rawInput) {
                    if (raw) {
                        this.rawInput(raw);
                    } else {
                        this.rawInput(Strophe.serialize(bodyWrap));
                    }
                }

                var conncheck = this._proto._connect_cb(bodyWrap);
                if (conncheck === Strophe.Status.CONNFAIL) {
                    return;
                }

                // Check for the stream:features tag
                var hasFeatures;
                if (bodyWrap.getElementsByTagNameNS) {
                    hasFeatures = bodyWrap.getElementsByTagNameNS(Strophe.NS.STREAM, "features").length > 0;
                } else {
                    hasFeatures = bodyWrap.getElementsByTagName("stream:features").length > 0 ||
                        bodyWrap.getElementsByTagName("features").length > 0;
                }
                if (!hasFeatures) {
                    this._proto._no_auth_received(_callback);
                    return;
                }

                var matched = [], i, mech;
                var mechanisms = bodyWrap.getElementsByTagName("mechanism");
                if (mechanisms.length > 0) {
                    for (i = 0; i < mechanisms.length; i++) {
                        mech = Strophe.getText(mechanisms[i]);
                        if (this.mechanisms[mech]) matched.push(this.mechanisms[mech]);
                    }
                }
                if (matched.length === 0) {
                    if (bodyWrap.getElementsByTagName("auth").length === 0) {
                        // There are no matching SASL mechanisms and also no legacy
                        // auth available.
                        this._proto._no_auth_received(_callback);
                        return;
                    }
                }
                if (this.do_authentication !== false) {
                    this.authenticate(matched);
                }
            },

            /** Function: sortMechanismsByPriority
             *
             *  Sorts an array of objects with prototype SASLMechanism according to
             *  their priorities.
             *
             *  Parameters:
             *    (Array) mechanisms - Array of SASL mechanisms.
             *
             */
            sortMechanismsByPriority: function (mechanisms) {
                // Sorting mechanisms according to priority.
                var i, j, higher, swap;
                for (i = 0; i < mechanisms.length - 1; ++i) {
                    higher = i;
                    for (j = i + 1; j < mechanisms.length; ++j) {
                        if (mechanisms[j].prototype.priority > mechanisms[higher].prototype.priority) {
                            higher = j;
                        }
                    }
                    if (higher != i) {
                        swap = mechanisms[i];
                        mechanisms[i] = mechanisms[higher];
                        mechanisms[higher] = swap;
                    }
                }
                return mechanisms;
            },

            /** PrivateFunction: _attemptSASLAuth
             *
             *  Iterate through an array of SASL mechanisms and attempt authentication
             *  with the highest priority (enabled) mechanism.
             *
             *  Parameters:
             *    (Array) mechanisms - Array of SASL mechanisms.
             *
             *  Returns:
             *    (Boolean) mechanism_found - true or false, depending on whether a
             *          valid SASL mechanism was found with which authentication could be
             *          started.
             */
            _attemptSASLAuth: function (mechanisms) {
                mechanisms = this.sortMechanismsByPriority(mechanisms || []);
                var i = 0, mechanism_found = false;
                for (i = 0; i < mechanisms.length; ++i) {
                    if (!mechanisms[i].prototype.test(this)) {
                        continue;
                    }
                    this._sasl_success_handler = this._addSysHandler(
                        this._sasl_success_cb.bind(this), null,
                        "success", null, null);
                    this._sasl_failure_handler = this._addSysHandler(
                        this._sasl_failure_cb.bind(this), null,
                        "failure", null, null);
                    this._sasl_challenge_handler = this._addSysHandler(
                        this._sasl_challenge_cb.bind(this), null,
                        "challenge", null, null);

                    this._sasl_mechanism = new mechanisms[i]();
                    this._sasl_mechanism.onStart(this);

                    var request_auth_exchange = $build("auth", {
                        xmlns: Strophe.NS.SASL,
                        mechanism: this._sasl_mechanism.name
                    });
                    if (this._sasl_mechanism.isClientFirst) {
                        var response = this._sasl_mechanism.onChallenge(this, null);
                        request_auth_exchange.t(Base64.encode(response));
                    }
                    this.send(request_auth_exchange.tree());
                    mechanism_found = true;
                    break;
                }
                return mechanism_found;
            },

            /** PrivateFunction: _attemptLegacyAuth
             *
             *  Attempt legacy (i.e. non-SASL) authentication.
             *
             */
            _attemptLegacyAuth: function () {
                if (Strophe.getNodeFromJid(this.jid) === null) {
                    // we don't have a node, which is required for non-anonymous
                    // client connections
                    this._changeConnectStatus(
                        Strophe.Status.CONNFAIL,
                        'x-strophe-bad-non-anon-jid'
                    );
                    this.disconnect('x-strophe-bad-non-anon-jid');
                } else {
                    // Fall back to legacy authentication
                    this._changeConnectStatus(Strophe.Status.AUTHENTICATING, null);
                    this._addSysHandler(
                        this._auth1_cb.bind(this),
                        null, null, null, "_auth_1"
                    );
                    this.send($iq({
                        'type': "get",
                        'to': this.domain,
                        'id': "_auth_1"
                    }).c("query", {xmlns: Strophe.NS.AUTH})
                        .c("username", {}).t(Strophe.getNodeFromJid(this.jid))
                        .tree());
                }
            },

            /** Function: authenticate
             * Set up authentication
             *
             *  Continues the initial connection request by setting up authentication
             *  handlers and starting the authentication process.
             *
             *  SASL authentication will be attempted if available, otherwise
             *  the code will fall back to legacy authentication.
             *
             *  Parameters:
             *    (Array) matched - Array of SASL mechanisms supported.
             *
             */
            authenticate: function (matched) {
                if (!this._attemptSASLAuth(matched)) {
                    this._attemptLegacyAuth();
                }
            },

            /** PrivateFunction: _sasl_challenge_cb
             *  _Private_ handler for the SASL challenge
             *
             */
            _sasl_challenge_cb: function(elem) {
                var challenge = Base64.decode(Strophe.getText(elem));
                var response = this._sasl_mechanism.onChallenge(this, challenge);
                var stanza = $build('response', {
                    'xmlns': Strophe.NS.SASL
                });
                if (response !== "") {
                    stanza.t(Base64.encode(response));
                }
                this.send(stanza.tree());
                return true;
            },

            /** PrivateFunction: _auth1_cb
             *  _Private_ handler for legacy authentication.
             *
             *  This handler is called in response to the initial <iq type='get'/>
             *  for legacy authentication.  It builds an authentication <iq/> and
             *  sends it, creating a handler (calling back to _auth2_cb()) to
             *  handle the result
             *
             *  Parameters:
             *    (XMLElement) elem - The stanza that triggered the callback.
             *
             *  Returns:
             *    false to remove the handler.
             */
            /* jshint unused:false */
            _auth1_cb: function (elem) {
                // build plaintext auth iq
                var iq = $iq({type: "set", id: "_auth_2"})
                    .c('query', {xmlns: Strophe.NS.AUTH})
                    .c('username', {}).t(Strophe.getNodeFromJid(this.jid))
                    .up()
                    .c('password').t(this.pass);

                if (!Strophe.getResourceFromJid(this.jid)) {
                    // since the user has not supplied a resource, we pick
                    // a default one here.  unlike other auth methods, the server
                    // cannot do this for us.
                    this.jid = Strophe.getBareJidFromJid(this.jid) + '/strophe';
                }
                iq.up().c('resource', {}).t(Strophe.getResourceFromJid(this.jid));

                this._addSysHandler(this._auth2_cb.bind(this), null,
                    null, null, "_auth_2");
                this.send(iq.tree());
                return false;
            },
            /* jshint unused:true */

            /** PrivateFunction: _sasl_success_cb
             *  _Private_ handler for succesful SASL authentication.
             *
             *  Parameters:
             *    (XMLElement) elem - The matching stanza.
             *
             *  Returns:
             *    false to remove the handler.
             */
            _sasl_success_cb: function (elem) {
                if (this._sasl_data["server-signature"]) {
                    var serverSignature;
                    var success = Base64.decode(Strophe.getText(elem));
                    var attribMatch = /([a-z]+)=([^,]+)(,|$)/;
                    var matches = success.match(attribMatch);
                    if (matches[1] == "v") {
                        serverSignature = matches[2];
                    }

                    if (serverSignature != this._sasl_data["server-signature"]) {
                        // remove old handlers
                        this.deleteHandler(this._sasl_failure_handler);
                        this._sasl_failure_handler = null;
                        if (this._sasl_challenge_handler) {
                            this.deleteHandler(this._sasl_challenge_handler);
                            this._sasl_challenge_handler = null;
                        }

                        this._sasl_data = {};
                        return this._sasl_failure_cb(null);
                    }
                }
                Strophe.info("SASL authentication succeeded.");

                if (this._sasl_mechanism) {
                    this._sasl_mechanism.onSuccess();
                }

                // remove old handlers
                this.deleteHandler(this._sasl_failure_handler);
                this._sasl_failure_handler = null;
                if (this._sasl_challenge_handler) {
                    this.deleteHandler(this._sasl_challenge_handler);
                    this._sasl_challenge_handler = null;
                }

                var streamfeature_handlers = [];
                var wrapper = function(handlers, elem) {
                    while (handlers.length) {
                        this.deleteHandler(handlers.pop());
                    }
                    this._sasl_auth1_cb.bind(this)(elem);
                    return false;
                };
                streamfeature_handlers.push(this._addSysHandler(function(elem) {
                    wrapper.bind(this)(streamfeature_handlers, elem);
                }.bind(this), null, "stream:features", null, null));
                streamfeature_handlers.push(this._addSysHandler(function(elem) {
                    wrapper.bind(this)(streamfeature_handlers, elem);
                }.bind(this), Strophe.NS.STREAM, "features", null, null));

                // we must send an xmpp:restart now
                this._sendRestart();

                return false;
            },

            /** PrivateFunction: _sasl_auth1_cb
             *  _Private_ handler to start stream binding.
             *
             *  Parameters:
             *    (XMLElement) elem - The matching stanza.
             *
             *  Returns:
             *    false to remove the handler.
             */
            _sasl_auth1_cb: function (elem) {
                // save stream:features for future usage
                this.features = elem;
                var i, child;
                for (i = 0; i < elem.childNodes.length; i++) {
                    child = elem.childNodes[i];
                    if (child.nodeName == 'bind') {
                        this.do_bind = true;
                    }

                    if (child.nodeName == 'session') {
                        this.do_session = true;
                    }
                }

                if (!this.do_bind) {
                    this._changeConnectStatus(Strophe.Status.AUTHFAIL, null);
                    return false;
                } else {

                    var that = this;

                    var _doBind = function () {
                        that._addSysHandler(that._sasl_bind_cb.bind(that), null, null, null, "_bind_auth_2");

                        // If we want to force a login (i.e. have the server ignore any rules which might prevent us from logging in)
                        // then we need to send an overide stanza
                        if (that.override) {
                            that.send($iq({type: "set", id: "_override_1"})
                                .c('override', {
                                    xmlns: "urn:commontime:infinity:bind",
                                    "resource-conflict": "closeold"
                                }).tree());
                            that.override = false;
                        }

                        var resource = Strophe.getResourceFromJid(that.jid);
                        if (resource) {
                            that.send($iq({type: "set", id: "_bind_auth_2"})
                                .c('bind', {xmlns: Strophe.NS.BIND})
                                .c('resource', {}).t(resource).tree());
                        } else {
                            that.send($iq({type: "set", id: "_bind_auth_2"})
                                .c('bind', {xmlns: Strophe.NS.BIND})
                                .tree());
                        }
                    };

                    // Can we resume the stream?
                    if (this.streamManagement !== undefined && this.streamManagement.prevId !== undefined) {
                        this._addSysHandler(function () {
                            // Server accepted the request so we are authenticated and connected
                            that.authenticated = true;
                            that._changeConnectStatus(Strophe.Status.CONNECTED, "resumed");
                            return false;
                        }, "urn:xmpp:sm:3", "resumed");
                        this._addSysHandler(function () {
                            // Server rejected the resumption request so go ahead and re-bind
                            _doBind();
                            return false;
                        }, "urn:xmpp:sm:3", "failed");
                        // Request to resume the previous stream
                        this.send($build("resume", {
                            xmlns: "urn:xmpp:sm:3",
                            previd: this.streamManagement.prevId,
                            h: this.streamManagement.getIncomingCounter() || 0
                        }));
                    } else {
                        // Nope so just continue with the usual process
                        _doBind();
                    }

                }
                return false;
            },

            /** PrivateFunction: _sasl_bind_cb
             *  _Private_ handler for binding result and session start.
             *
             *  Parameters:
             *    (XMLElement) elem - The matching stanza.
             *
             *  Returns:
             *    false to remove the handler.
             */
            _sasl_bind_cb: function (elem) {
                if (elem.getAttribute("type") == "error") {
                    Strophe.info("SASL binding failed.");
                    var conflict = elem.getElementsByTagName("conflict"), condition;
                    if (conflict.length > 0) {
                        condition = 'conflict';
                        this._doDisconnect(condition);
                    }
                    this._changeConnectStatus(Strophe.Status.AUTHFAIL, condition);
                    return false;
                }

                // TODO - need to grab errors
                var bind = elem.getElementsByTagName("bind");
                var jidNode;
                if (bind.length > 0) {
                    // Grab jid
                    jidNode = bind[0].getElementsByTagName("jid");
                    if (jidNode.length > 0) {
                        this.jid = Strophe.getText(jidNode[0]);

                        if (this.do_session) {
                            this._addSysHandler(this._sasl_session_cb.bind(this),
                                null, null, null, "_session_auth_2");

                            this.send($iq({type: "set", id: "_session_auth_2"})
                                .c('session', {xmlns: Strophe.NS.SESSION})
                                .tree());
                        } else {
                            this.authenticated = true;
                            this._changeConnectStatus(Strophe.Status.CONNECTED, null);
                        }
                    }
                } else {
                    Strophe.info("SASL binding failed.");
                    this._changeConnectStatus(Strophe.Status.AUTHFAIL, null);
                    return false;
                }
            },

            /** PrivateFunction: _sasl_session_cb
             *  _Private_ handler to finish successful SASL connection.
             *
             *  This sets Connection.authenticated to true on success, which
             *  starts the processing of user handlers.
             *
             *  Parameters:
             *    (XMLElement) elem - The matching stanza.
             *
             *  Returns:
             *    false to remove the handler.
             */
            _sasl_session_cb: function (elem) {
                if (elem.getAttribute("type") == "result") {
                    this.authenticated = true;
                    this._changeConnectStatus(Strophe.Status.CONNECTED, null);
                } else if (elem.getAttribute("type") == "error") {
                    Strophe.info("Session creation failed.");
                    this._changeConnectStatus(Strophe.Status.AUTHFAIL, null);
                    return false;
                }
                return false;
            },

            /** PrivateFunction: _sasl_failure_cb
             *  _Private_ handler for SASL authentication failure.
             *
             *  Parameters:
             *    (XMLElement) elem - The matching stanza.
             *
             *  Returns:
             *    false to remove the handler.
             */
            /* jshint unused:false */
            _sasl_failure_cb: function (elem) {

                // delete unneeded handlers
                if (this._sasl_success_handler) {
                    this.deleteHandler(this._sasl_success_handler);
                    this._sasl_success_handler = null;
                }
                if (this._sasl_challenge_handler) {
                    this.deleteHandler(this._sasl_challenge_handler);
                    this._sasl_challenge_handler = null;
                }

                if(this._sasl_mechanism)
                    this._sasl_mechanism.onFailure();

                const $text = elem.getElementsByTagName("text")[0];
                let condition = null;
                if ($text !== undefined) {
                    condition = $text.innerHTML || null;
                }

                this._changeConnectStatus(Strophe.Status.AUTHFAIL, condition);
                this.disconnect(condition);

                return false;
            },
            /* jshint unused:true */

            /** PrivateFunction: _auth2_cb
             *  _Private_ handler to finish legacy authentication.
             *
             *  This handler is called when the result from the jabber:iq:auth
             *  <iq/> stanza is returned.
             *
             *  Parameters:
             *    (XMLElement) elem - The stanza that triggered the callback.
             *
             *  Returns:
             *    false to remove the handler.
             */
            _auth2_cb: function (elem) {
                if (elem.getAttribute("type") == "result") {
                    this.authenticated = true;
                    this._changeConnectStatus(Strophe.Status.CONNECTED, null);
                } else if (elem.getAttribute("type") == "error") {
                    this._changeConnectStatus(Strophe.Status.AUTHFAIL, null);
                    this.disconnect('authentication failed');
                }
                return false;
            },

            /** PrivateFunction: _addSysTimedHandler
             *  _Private_ function to add a system level timed handler.
             *
             *  This function is used to add a Strophe.TimedHandler for the
             *  library code.  System timed handlers are allowed to run before
             *  authentication is complete.
             *
             *  Parameters:
             *    (Integer) period - The period of the handler.
             *    (Function) handler - The callback function.
             */
            _addSysTimedHandler: function (period, handler) {
                var thand = new Strophe.TimedHandler(period, handler);
                thand.user = false;
                this.addTimeds.push(thand);
                return thand;
            },

            /** PrivateFunction: _addSysHandler
             *  _Private_ function to add a system level stanza handler.
             *
             *  This function is used to add a Strophe.Handler for the
             *  library code.  System stanza handlers are allowed to run before
             *  authentication is complete.
             *
             *  Parameters:
             *    (Function) handler - The callback function.
             *    (String) ns - The namespace to match.
             *    (String) name - The stanza name to match.
             *    (String) type - The stanza type attribute to match.
             *    (String) id - The stanza id attribute to match.
             */
            _addSysHandler: function (handler, ns, name, type, id) {
                var hand = new Strophe.Handler(handler, ns, name, type, id);
                hand.user = false;
                this.addHandlers.push(hand);
                return hand;
            },

            /** PrivateFunction: _onDisconnectTimeout
             *  _Private_ timeout handler for handling non-graceful disconnection.
             *
             *  If the graceful disconnect process does not complete within the
             *  time allotted, this handler finishes the disconnect anyway.
             *
             *  Returns:
             *    false to remove the handler.
             */
            _onDisconnectTimeout: function () {
                Strophe.info("_onDisconnectTimeout was called");
                this._changeConnectStatus(Strophe.Status.CONNTIMEOUT, null);
                this._proto._onDisconnectTimeout();
                // actually disconnect
                this._doDisconnect();
                return false;
            },

            /** PrivateFunction: _onIdle
             *  _Private_ handler to process events during idle cycle.
             *
             *  This handler is called every 100ms to fire timed handlers that
             *  are ready and keep poll requests going.
             */
            _onIdle: function () {
                var i, thand, since, newList;

                // add timed handlers scheduled for addition
                // NOTE: we add before remove in the case a timed handler is
                // added and then deleted before the next _onIdle() call.
                while (this.addTimeds.length > 0) {
                    this.timedHandlers.push(this.addTimeds.pop());
                }

                // remove timed handlers that have been scheduled for deletion
                while (this.removeTimeds.length > 0) {
                    thand = this.removeTimeds.pop();
                    i = this.timedHandlers.indexOf(thand);
                    if (i >= 0) {
                        this.timedHandlers.splice(i, 1);
                    }
                }

                // call ready timed handlers
                var now = new Date().getTime();
                newList = [];
                for (i = 0; i < this.timedHandlers.length; i++) {
                    thand = this.timedHandlers[i];
                    if (this.authenticated || !thand.user) {
                        since = thand.lastCalled + thand.period;
                        if (since - now <= 0) {
                            if (thand.run()) {
                                newList.push(thand);
                            }
                        } else {
                            newList.push(thand);
                        }
                    }
                }
                this.timedHandlers = newList;

                clearTimeout(this._idleTimeout);

                this._proto._onIdle();

                // reactivate the timer only if connected
                if (this.connected) {
                    // XXX: setTimeout should be called only with function expressions (23974bc1)
                    this._idleTimeout = setTimeout(function() {
                        this._onIdle();
                    }.bind(this), 100);
                }
            }
        };

        /** Class: Strophe.SASLMechanism
         *
         *  encapsulates SASL authentication mechanisms.
         *
         *  User code may override the priority for each mechanism or disable it completely.
         *  See <priority> for information about changing priority and <test> for informatian on
         *  how to disable a mechanism.
         *
         *  By default, all mechanisms are enabled and the priorities are
         *
         *  EXTERNAL - 60
         *  OAUTHBEARER - 50
         *  SCRAM-SHA1 - 40
         *  DIGEST-MD5 - 30
         *  PLAIN - 20
         *  ANONYMOUS - 10
         *
         *  See: Strophe.Connection.addSupportedSASLMechanisms
         */

        /**
         * PrivateConstructor: Strophe.SASLMechanism
         * SASL auth mechanism abstraction.
         *
         *  Parameters:
         *    (String) name - SASL Mechanism name.
         *    (Boolean) isClientFirst - If client should send response first without challenge.
         *    (Number) priority - Priority.
         *
         *  Returns:
         *    A new Strophe.SASLMechanism object.
         */
        Strophe.SASLMechanism = function(name, isClientFirst, priority) {
            /** PrivateVariable: name
             *  Mechanism name.
             */
            this.name = name;
            /** PrivateVariable: isClientFirst
             *  If client sends response without initial server challenge.
             */
            this.isClientFirst = isClientFirst;
            /** Variable: priority
             *  Determines which <SASLMechanism> is chosen for authentication (Higher is better).
             *  Users may override this to prioritize mechanisms differently.
             *
             *  In the default configuration the priorities are
             *
             *  SCRAM-SHA1 - 40
             *  DIGEST-MD5 - 30
             *  Plain - 20
             *
             *  Example: (This will cause Strophe to choose the mechanism that the server sent first)
             *
             *  > Strophe.SASLMD5.priority = Strophe.SASLSHA1.priority;
             *
             *  See <SASL mechanisms> for a list of available mechanisms.
             *
             */
            this.priority = priority;
        };

        Strophe.SASLMechanism.prototype = {
            /**
             *  Function: test
             *  Checks if mechanism able to run.
             *  To disable a mechanism, make this return false;
             *
             *  To disable plain authentication run
             *  > Strophe.SASLPlain.test = function() {
   *  >   return false;
   *  > }
             *
             *  See <SASL mechanisms> for a list of available mechanisms.
             *
             *  Parameters:
             *    (Strophe.Connection) connection - Target Connection.
             *
             *  Returns:
             *    (Boolean) If mechanism was able to run.
             */
            /* jshint unused:false */
            test: function(connection) {
                return true;
            },
            /* jshint unused:true */

            /** PrivateFunction: onStart
             *  Called before starting mechanism on some connection.
             *
             *  Parameters:
             *    (Strophe.Connection) connection - Target Connection.
             */
            onStart: function(connection) {
                this._connection = connection;
            },

            /** PrivateFunction: onChallenge
             *  Called by protocol implementation on incoming challenge. If client is
             *  first (isClientFirst == true) challenge will be null on the first call.
             *
             *  Parameters:
             *    (Strophe.Connection) connection - Target Connection.
             *    (String) challenge - current challenge to handle.
             *
             *  Returns:
             *    (String) Mechanism response.
             */
            /* jshint unused:false */
            onChallenge: function(connection, challenge) {
                throw new Error("You should implement challenge handling!");
            },
            /* jshint unused:true */

            /** PrivateFunction: onFailure
             *  Protocol informs mechanism implementation about SASL failure.
             */
            onFailure: function() {
                this._connection = null;
            },

            /** PrivateFunction: onSuccess
             *  Protocol informs mechanism implementation about SASL success.
             */
            onSuccess: function() {
                this._connection = null;
            }
        };

        /** Constants: SASL mechanisms
         *  Available authentication mechanisms
         *
         *  Strophe.SASLAnonymous - SASL ANONYMOUS authentication.
         *  Strophe.SASLPlain - SASL PLAIN authentication.
         *  Strophe.SASLMD5 - SASL DIGEST-MD5 authentication
         *  Strophe.SASLSHA1 - SASL SCRAM-SHA1 authentication
         *  Strophe.SASLOAuthBearer - SASL OAuth Bearer authentication
         *  Strophe.SASLExternal - SASL EXTERNAL authentication
         */

// Building SASL callbacks

        /** PrivateConstructor: SASLAnonymous
         *  SASL ANONYMOUS authentication.
         */
        Strophe.SASLAnonymous = function() {};
        Strophe.SASLAnonymous.prototype = new Strophe.SASLMechanism("ANONYMOUS", false, 20);

        Strophe.SASLAnonymous.prototype.test = function(connection) {
            return connection.authcid === null;
        };


        /** PrivateConstructor: SASLPlain
         *  SASL PLAIN authentication.
         */
        Strophe.SASLPlain = function() {};
        Strophe.SASLPlain.prototype = new Strophe.SASLMechanism("PLAIN", true, 30);

        Strophe.SASLPlain.prototype.test = function(connection) {
            return connection.authcid !== null;
        };

        Strophe.SASLPlain.prototype.onChallenge = function(connection) {
            var auth_str = connection.authzid;
            auth_str = auth_str + "\u0000";
            auth_str = auth_str + connection.authcid;
            auth_str = auth_str + "\u0000";
            auth_str = auth_str + connection.pass;
            return utils.utf16to8(auth_str);
        };


        /** PrivateConstructor: SASLSHA1
         *  SASL SCRAM SHA 1 authentication.
         */
        Strophe.SASLSHA1 = function() {};
        Strophe.SASLSHA1.prototype = new Strophe.SASLMechanism("SCRAM-SHA-1", true, 50);

        Strophe.SASLSHA1.prototype.test = function(connection) {
            return connection.authcid !== null;
        };

        Strophe.SASLSHA1.prototype.onChallenge = function(connection, challenge, test_cnonce) {
            var cnonce = test_cnonce || MD5.hexdigest(Math.random() * 1234567890);
            var auth_str = "n=" + utils.utf16to8(connection.authcid);
            auth_str += ",r=";
            auth_str += cnonce;
            connection._sasl_data.cnonce = cnonce;
            connection._sasl_data["client-first-message-bare"] = auth_str;

            auth_str = "n,," + auth_str;

            this.onChallenge = function (connection, challenge) {
                var nonce, salt, iter, Hi, U, U_old, i, k, pass;
                var clientKey, serverKey, clientSignature;
                var responseText = "c=biws,";
                var authMessage = connection._sasl_data["client-first-message-bare"] + "," +
                    challenge + ",";
                var cnonce = connection._sasl_data.cnonce;
                var attribMatch = /([a-z]+)=([^,]+)(,|$)/;

                while (challenge.match(attribMatch)) {
                    var matches = challenge.match(attribMatch);
                    challenge = challenge.replace(matches[0], "");
                    switch (matches[1]) {
                        case "r":
                            nonce = matches[2];
                            break;
                        case "s":
                            salt = matches[2];
                            break;
                        case "i":
                            iter = matches[2];
                            break;
                    }
                }

                if (nonce.substr(0, cnonce.length) !== cnonce) {
                    connection._sasl_data = {};
                    return connection._sasl_failure_cb();
                }

                responseText += "r=" + nonce;
                authMessage += responseText;

                salt = Base64.decode(salt);
                salt += "\x00\x00\x00\x01";

                pass = utils.utf16to8(connection.pass);
                Hi = U_old = SHA1.core_hmac_sha1(pass, salt);
                for (i = 1; i < iter; i++) {
                    U = SHA1.core_hmac_sha1(pass, SHA1.binb2str(U_old));
                    for (k = 0; k < 5; k++) {
                        Hi[k] ^= U[k];
                    }
                    U_old = U;
                }
                Hi = SHA1.binb2str(Hi);

                clientKey = SHA1.core_hmac_sha1(Hi, "Client Key");
                serverKey = SHA1.str_hmac_sha1(Hi, "Server Key");
                clientSignature = SHA1.core_hmac_sha1(SHA1.str_sha1(SHA1.binb2str(clientKey)), authMessage);
                connection._sasl_data["server-signature"] = SHA1.b64_hmac_sha1(serverKey, authMessage);

                for (k = 0; k < 5; k++) {
                    clientKey[k] ^= clientSignature[k];
                }

                responseText += ",p=" + Base64.encode(SHA1.binb2str(clientKey));
                return responseText;
            }.bind(this);

            return auth_str;
        };


        /** PrivateConstructor: SASLMD5
         *  SASL DIGEST MD5 authentication.
         */
        Strophe.SASLMD5 = function() {};
        Strophe.SASLMD5.prototype = new Strophe.SASLMechanism("DIGEST-MD5", false, 40);

        Strophe.SASLMD5.prototype.test = function(connection) {
            return connection.authcid !== null;
        };

        /** PrivateFunction: _quote
         *  _Private_ utility function to backslash escape and quote strings.
         *
         *  Parameters:
         *    (String) str - The string to be quoted.
         *
         *  Returns:
         *    quoted string
         */
        Strophe.SASLMD5.prototype._quote = function (str) {
            return '"' + str.replace(/\\/g, "\\\\").replace(/"/g, '\\"') + '"';
            //" end string workaround for emacs
        };

        Strophe.SASLMD5.prototype.onChallenge = function(connection, challenge, test_cnonce) {
            var attribMatch = /([a-z]+)=("[^"]+"|[^,"]+)(?:,|$)/;
            var cnonce = test_cnonce || MD5.hexdigest("" + (Math.random() * 1234567890));
            var realm = "";
            var host = null;
            var nonce = "";
            var qop = "";
            var matches;

            while (challenge.match(attribMatch)) {
                matches = challenge.match(attribMatch);
                challenge = challenge.replace(matches[0], "");
                matches[2] = matches[2].replace(/^"(.+)"$/, "$1");
                switch (matches[1]) {
                    case "realm":
                        realm = matches[2];
                        break;
                    case "nonce":
                        nonce = matches[2];
                        break;
                    case "qop":
                        qop = matches[2];
                        break;
                    case "host":
                        host = matches[2];
                        break;
                }
            }

            var digest_uri = connection.servtype + "/" + connection.domain;
            if (host !== null) {
                digest_uri = digest_uri + "/" + host;
            }

            var cred = utils.utf16to8(connection.authcid + ":" + realm + ":" + this._connection.pass);
            var A1 = MD5.hash(cred) + ":" + nonce + ":" + cnonce;
            var A2 = 'AUTHENTICATE:' + digest_uri;

            var responseText = "";
            responseText += 'charset=utf-8,';
            responseText += 'username=' + this._quote(utils.utf16to8(connection.authcid)) + ',';
            responseText += 'realm=' + this._quote(realm) + ',';
            responseText += 'nonce=' + this._quote(nonce) + ',';
            responseText += 'nc=00000001,';
            responseText += 'cnonce=' + this._quote(cnonce) + ',';
            responseText += 'digest-uri=' + this._quote(digest_uri) + ',';
            responseText += 'response=' + MD5.hexdigest(MD5.hexdigest(A1) + ":" +
                    nonce + ":00000001:" +
                    cnonce + ":auth:" +
                    MD5.hexdigest(A2)) + ",";
            responseText += 'qop=auth';

            this.onChallenge = function () {
                return "";
            };
            return responseText;
        };


        /** PrivateConstructor: SASLOAuthBearer
         *  SASL OAuth Bearer authentication.
         */
        Strophe.SASLOAuthBearer = function() {};
        Strophe.SASLOAuthBearer.prototype = new Strophe.SASLMechanism("OAUTHBEARER", true, 60);

        Strophe.SASLOAuthBearer.prototype.test = function(connection) {
            return connection.authcid !== null;
        };

        Strophe.SASLOAuthBearer.prototype.onChallenge = function(connection) {
            var auth_str = 'n,a=';
            auth_str = auth_str + connection.authzid;
            auth_str = auth_str + ',';
            auth_str = auth_str + "\u0001";
            auth_str = auth_str + 'auth=Bearer ';
            auth_str = auth_str + connection.pass;
            auth_str = auth_str + "\u0001";
            auth_str = auth_str + "\u0001";
            return utils.utf16to8(auth_str);
        };


        /** PrivateConstructor: SASLExternal
         *  SASL EXTERNAL authentication.
         *
         *  The EXTERNAL mechanism allows a client to request the server to use
         *  credentials established by means external to the mechanism to
         *  authenticate the client. The external means may be, for instance,
         *  TLS services.
         */
        Strophe.SASLExternal = function() {};
        Strophe.SASLExternal.prototype = new Strophe.SASLMechanism("EXTERNAL", true, 10);

        Strophe.SASLExternal.prototype.onChallenge = function(connection) {
            /** According to XEP-178, an authzid SHOULD NOT be presented when the
             * authcid contained or implied in the client certificate is the JID (i.e.
             * authzid) with which the user wants to log in as.
             *
             * To NOT send the authzid, the user should therefore set the authcid equal
             * to the JID when instantiating a new Strophe.Connection object.
             */
            return connection.authcid === connection.authzid ? '' : connection.authzid;
        };

        return {
            Strophe:        Strophe,
            $build:         $build,
            $msg:           $msg,
            $iq:            $iq,
            $pres:          $pres,
            SHA1:           SHA1,
            Base64:         Base64,
            MD5:            MD5,
        };
    }));

    /*
     This program is distributed under the terms of the MIT license.
     Please see the LICENSE file for details.

     Copyright 2006-2008, OGG, LLC
     */

    /* jshint undef: true, unused: true:, noarg: true, latedef: true */
    /* global define, window, setTimeout, clearTimeout, XMLHttpRequest, ActiveXObject, Strophe, $build */

    (function (root, factory) {
        if (true) {
            !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__WEBPACK_LOCAL_MODULE_5__], __WEBPACK_LOCAL_MODULE_6__ = (function (core) {
                return factory(
                    core.Strophe,
                    core.$build
                );
            }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)));
        } else {
            // Browser globals
            return factory(Strophe, $build);
        }
    }(this, function (Strophe, $build) {

        /** PrivateClass: Strophe.Request
         *  _Private_ helper class that provides a cross implementation abstraction
         *  for a BOSH related XMLHttpRequest.
         *
         *  The Strophe.Request class is used internally to encapsulate BOSH request
         *  information.  It is not meant to be used from user's code.
         */

        /** PrivateConstructor: Strophe.Request
         *  Create and initialize a new Strophe.Request object.
         *
         *  Parameters:
         *    (XMLElement) elem - The XML data to be sent in the request.
         *    (Function) func - The function that will be called when the
         *      XMLHttpRequest readyState changes.
         *    (Integer) rid - The BOSH rid attribute associated with this request.
         *    (Integer) sends - The number of times this same request has been sent.
         */
        Strophe.Request = function (elem, func, rid, sends) {
            this.id = ++Strophe._requestId;
            this.xmlData = elem;
            this.data = Strophe.serialize(elem);
            // save original function in case we need to make a new request
            // from this one.
            this.origFunc = func;
            this.func = func;
            this.rid = rid;
            this.date = NaN;
            this.sends = sends || 0;
            this.abort = false;
            this.dead = null;

            this.age = function () {
                if (!this.date) { return 0; }
                var now = new Date();
                return (now - this.date) / 1000;
            };
            this.timeDead = function () {
                if (!this.dead) { return 0; }
                var now = new Date();
                return (now - this.dead) / 1000;
            };
            this.xhr = this._newXHR();
        };

        Strophe.Request.prototype = {
            /** PrivateFunction: getResponse
             *  Get a response from the underlying XMLHttpRequest.
             *
             *  This function attempts to get a response from the request and checks
             *  for errors.
             *
             *  Throws:
             *    "parsererror" - A parser error occured.
             *    "badformat" - The entity has sent XML that cannot be processed.
             *
             *  Returns:
             *    The DOM element tree of the response.
             */
            getResponse: function () {
                var node = null;
                if (this.xhr.responseXML && this.xhr.responseXML.documentElement) {
                    node = this.xhr.responseXML.documentElement;
                    if (node.tagName == "parsererror") {
                        Strophe.error("invalid response received");
                        Strophe.error("responseText: " + this.xhr.responseText);
                        Strophe.error("responseXML: " +
                            Strophe.serialize(this.xhr.responseXML));
                        throw "parsererror";
                    }
                } else if (this.xhr.responseText) {
                    Strophe.error("invalid response received");
                    Strophe.error("responseText: " + this.xhr.responseText);
                    throw "badformat";
                }

                return node;
            },

            /** PrivateFunction: _newXHR
             *  _Private_ helper function to create XMLHttpRequests.
             *
             *  This function creates XMLHttpRequests across all implementations.
             *
             *  Returns:
             *    A new XMLHttpRequest.
             */
            _newXHR: function () {
                var xhr = null;
                if (window.XMLHttpRequest) {
                    xhr = new XMLHttpRequest();
                    if (xhr.overrideMimeType) {
                        xhr.overrideMimeType("text/xml; charset=utf-8");
                    }
                } else if (window.ActiveXObject) {
                    xhr = new ActiveXObject("Microsoft.XMLHTTP");
                }
                // use Function.bind() to prepend ourselves as an argument
                xhr.onreadystatechange = this.func.bind(null, this);
                return xhr;
            }
        };

        /** Class: Strophe.Bosh
         *  _Private_ helper class that handles BOSH Connections
         *
         *  The Strophe.Bosh class is used internally by Strophe.Connection
         *  to encapsulate BOSH sessions. It is not meant to be used from user's code.
         */

        /** File: bosh.js
         *  A JavaScript library to enable BOSH in Strophejs.
         *
         *  this library uses Bidirectional-streams Over Synchronous HTTP (BOSH)
         *  to emulate a persistent, stateful, two-way connection to an XMPP server.
         *  More information on BOSH can be found in XEP 124.
         */

        /** PrivateConstructor: Strophe.Bosh
         *  Create and initialize a Strophe.Bosh object.
         *
         *  Parameters:
         *    (Strophe.Connection) connection - The Strophe.Connection that will use BOSH.
         *
         *  Returns:
         *    A new Strophe.Bosh object.
         */
        Strophe.Bosh = function(connection) {
            this._conn = connection;
            /* request id for body tags */
            this.rid = Math.floor(Math.random() * 4294967295);
            /* The current session ID. */
            this.sid = null;

            // default BOSH values
            this.hold = 1;
            this.wait = 60;
            this.window = 5;
            this.errors = 0;
            this.inactivity = null;

            this._requests = [];
        };

        Strophe.Bosh.prototype = {
            /** Variable: strip
             *
             *  BOSH-Connections will have all stanzas wrapped in a <body> tag when
             *  passed to <Strophe.Connection.xmlInput> or <Strophe.Connection.xmlOutput>.
             *  To strip this tag, User code can set <Strophe.Bosh.strip> to "body":
             *
             *  > Strophe.Bosh.prototype.strip = "body";
             *
             *  This will enable stripping of the body tag in both
             *  <Strophe.Connection.xmlInput> and <Strophe.Connection.xmlOutput>.
             */
            strip: null,

            /** PrivateFunction: _buildBody
             *  _Private_ helper function to generate the <body/> wrapper for BOSH.
             *
             *  Returns:
             *    A Strophe.Builder with a <body/> element.
             */
            _buildBody: function () {
                var bodyWrap = $build('body', {
                    rid: this.rid++,
                    xmlns: Strophe.NS.HTTPBIND
                });
                if (this.sid !== null) {
                    bodyWrap.attrs({sid: this.sid});
                }
                if (this._conn.options.keepalive && this._conn._sessionCachingSupported()) {
                    this._cacheSession();
                }
                return bodyWrap;
            },

            /** PrivateFunction: _reset
             *  Reset the connection.
             *
             *  This function is called by the reset function of the Strophe Connection
             */
            _reset: function () {
                this.rid = Math.floor(Math.random() * 4294967295);
                this.sid = null;
                this.errors = 0;
                if (this._conn._sessionCachingSupported()) {
                    window.sessionStorage.removeItem('strophe-bosh-session');
                }

                this._conn.nextValidRid(this.rid);
            },

            /** PrivateFunction: _connect
             *  _Private_ function that initializes the BOSH connection.
             *
             *  Creates and sends the Request that initializes the BOSH connection.
             */
            _connect: function (wait, hold, route) {
                this.wait = wait || this.wait;
                this.hold = hold || this.hold;
                this.errors = 0;

                // build the body tag
                var body = this._buildBody().attrs({
                    to: this._conn.domain,
                    "xml:lang": "en",
                    wait: this.wait,
                    hold: this.hold,
                    content: "text/xml; charset=utf-8",
                    ver: "1.6",
                    "xmpp:version": "1.0",
                    "xmlns:xmpp": Strophe.NS.BOSH
                });

                if(route){
                    body.attrs({
                        route: route
                    });
                }

                var _connect_cb = this._conn._connect_cb;

                this._requests.push(
                    new Strophe.Request(body.tree(),
                        this._onRequestStateChange.bind(
                            this, _connect_cb.bind(this._conn)),
                        body.tree().getAttribute("rid")));
                this._throttledRequestHandler();
            },

            /** PrivateFunction: _attach
             *  Attach to an already created and authenticated BOSH session.
             *
             *  This function is provided to allow Strophe to attach to BOSH
             *  sessions which have been created externally, perhaps by a Web
             *  application.  This is often used to support auto-login type features
             *  without putting user credentials into the page.
             *
             *  Parameters:
             *    (String) jid - The full JID that is bound by the session.
             *    (String) sid - The SID of the BOSH session.
             *    (String) rid - The current RID of the BOSH session.  This RID
             *      will be used by the next request.
             *    (Function) callback The connect callback function.
             *    (Integer) wait - The optional HTTPBIND wait value.  This is the
             *      time the server will wait before returning an empty result for
             *      a request.  The default setting of 60 seconds is recommended.
             *      Other settings will require tweaks to the Strophe.TIMEOUT value.
             *    (Integer) hold - The optional HTTPBIND hold value.  This is the
             *      number of connections the server will hold at one time.  This
             *      should almost always be set to 1 (the default).
             *    (Integer) wind - The optional HTTBIND window value.  This is the
             *      allowed range of request ids that are valid.  The default is 5.
             */
            _attach: function (jid, sid, rid, callback, wait, hold, wind) {
                this._conn.jid = jid;
                this.sid = sid;
                this.rid = rid;

                this._conn.connect_callback = callback;

                this._conn.domain = Strophe.getDomainFromJid(this._conn.jid);

                this._conn.authenticated = true;
                this._conn.connected = true;

                this.wait = wait || this.wait;
                this.hold = hold || this.hold;
                this.window = wind || this.window;

                this._conn._changeConnectStatus(Strophe.Status.ATTACHED, null);
            },

            /** PrivateFunction: _restore
             *  Attempt to restore a cached BOSH session
             *
             *  Parameters:
             *    (String) jid - The full JID that is bound by the session.
             *      This parameter is optional but recommended, specifically in cases
             *      where prebinded BOSH sessions are used where it's important to know
             *      that the right session is being restored.
             *    (Function) callback The connect callback function.
             *    (Integer) wait - The optional HTTPBIND wait value.  This is the
             *      time the server will wait before returning an empty result for
             *      a request.  The default setting of 60 seconds is recommended.
             *      Other settings will require tweaks to the Strophe.TIMEOUT value.
             *    (Integer) hold - The optional HTTPBIND hold value.  This is the
             *      number of connections the server will hold at one time.  This
             *      should almost always be set to 1 (the default).
             *    (Integer) wind - The optional HTTBIND window value.  This is the
             *      allowed range of request ids that are valid.  The default is 5.
             */
            _restore: function (jid, callback, wait, hold, wind) {
                var session = JSON.parse(window.sessionStorage.getItem('strophe-bosh-session'));
                if (typeof session !== "undefined" &&
                    session !== null &&
                    session.rid &&
                    session.sid &&
                    session.jid &&
                    (    typeof jid === "undefined" ||
                        jid === null ||
                        Strophe.getBareJidFromJid(session.jid) == Strophe.getBareJidFromJid(jid) ||
                        // If authcid is null, then it's an anonymous login, so
                        // we compare only the domains:
                        ((Strophe.getNodeFromJid(jid) === null) && (Strophe.getDomainFromJid(session.jid) == jid))
                    )
                ) {
                    this._conn.restored = true;
                    this._attach(session.jid, session.sid, session.rid, callback, wait, hold, wind);
                } else {
                    throw { name: "StropheSessionError", message: "_restore: no restoreable session." };
                }
            },

            /** PrivateFunction: _cacheSession
             *  _Private_ handler for the beforeunload event.
             *
             *  This handler is used to process the Bosh-part of the initial request.
             *  Parameters:
             *    (Strophe.Request) bodyWrap - The received stanza.
             */
            _cacheSession: function () {
                if (this._conn.authenticated) {
                    if (this._conn.jid && this.rid && this.sid) {
                        window.sessionStorage.setItem('strophe-bosh-session', JSON.stringify({
                            'jid': this._conn.jid,
                            'rid': this.rid,
                            'sid': this.sid
                        }));
                    }
                } else {
                    window.sessionStorage.removeItem('strophe-bosh-session');
                }
            },

            /** PrivateFunction: _connect_cb
             *  _Private_ handler for initial connection request.
             *
             *  This handler is used to process the Bosh-part of the initial request.
             *  Parameters:
             *    (Strophe.Request) bodyWrap - The received stanza.
             */
            _connect_cb: function (bodyWrap) {
                var typ = bodyWrap.getAttribute("type");
                var cond, conflict;
                if (typ !== null && typ == "terminate") {
                    // an error occurred
                    cond = bodyWrap.getAttribute("condition");
                    Strophe.error("BOSH-Connection failed: " + cond);
                    conflict = bodyWrap.getElementsByTagName("conflict");
                    if (cond !== null) {
                        if (cond == "remote-stream-error" && conflict.length > 0) {
                            cond = "conflict";
                        }
                        this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, cond);
                    } else {
                        this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, "unknown");
                    }
                    this._conn._doDisconnect(cond);
                    return Strophe.Status.CONNFAIL;
                }

                // check to make sure we don't overwrite these if _connect_cb is
                // called multiple times in the case of missing stream:features
                if (!this.sid) {
                    this.sid = bodyWrap.getAttribute("sid");
                }
                var wind = bodyWrap.getAttribute('requests');
                if (wind) { this.window = parseInt(wind, 10); }
                var hold = bodyWrap.getAttribute('hold');
                if (hold) { this.hold = parseInt(hold, 10); }
                var wait = bodyWrap.getAttribute('wait');
                if (wait) { this.wait = parseInt(wait, 10); }
                var inactivity = bodyWrap.getAttribute('inactivity');
                if (inactivity) { this.inactivity = parseInt(inactivity, 10); }
            },

            /** PrivateFunction: _disconnect
             *  _Private_ part of Connection.disconnect for Bosh
             *
             *  Parameters:
             *    (Request) pres - This stanza will be sent before disconnecting.
             */
            _disconnect: function (pres) {
                this._sendTerminate(pres);
            },

            /** PrivateFunction: _doDisconnect
             *  _Private_ function to disconnect.
             *
             *  Resets the SID and RID.
             */
            _doDisconnect: function () {
                this.sid = null;
                this.rid = Math.floor(Math.random() * 4294967295);
                if (this._conn._sessionCachingSupported()) {
                    window.sessionStorage.removeItem('strophe-bosh-session');
                }

                this._conn.nextValidRid(this.rid);
            },

            /** PrivateFunction: _emptyQueue
             * _Private_ function to check if the Request queue is empty.
             *
             *  Returns:
             *    True, if there are no Requests queued, False otherwise.
             */
            _emptyQueue: function () {
                return this._requests.length === 0;
            },

            /** PrivateFunction: _callProtocolErrorHandlers
             *  _Private_ function to call error handlers registered for HTTP errors.
             *
             *  Parameters:
             *    (Strophe.Request) req - The request that is changing readyState.
             */
            _callProtocolErrorHandlers: function (req) {
                var reqStatus = this._getRequestStatus(req),
                    err_callback;
                err_callback = this._conn.protocolErrorHandlers.HTTP[reqStatus];
                if (err_callback) {
                    err_callback.call(this, reqStatus);
                }
            },

            /** PrivateFunction: _hitError
             *  _Private_ function to handle the error count.
             *
             *  Requests are resent automatically until their error count reaches
             *  5.  Each time an error is encountered, this function is called to
             *  increment the count and disconnect if the count is too high.
             *
             *  Parameters:
             *    (Integer) reqStatus - The request status.
             */
            _hitError: function (reqStatus) {
                this.errors++;
                Strophe.warn("request errored, status: " + reqStatus +
                    ", number of errors: " + this.errors);
                if (this.errors > 4) {
                    this._conn._onDisconnectTimeout();
                }
            },

            /** PrivateFunction: _no_auth_received
             *
             * Called on stream start/restart when no stream:features
             * has been received and sends a blank poll request.
             */
            _no_auth_received: function (_callback) {
                if (_callback) {
                    _callback = _callback.bind(this._conn);
                } else {
                    _callback = this._conn._connect_cb.bind(this._conn);
                }
                var body = this._buildBody();
                this._requests.push(
                    new Strophe.Request(body.tree(),
                        this._onRequestStateChange.bind(
                            this, _callback.bind(this._conn)),
                        body.tree().getAttribute("rid")));
                this._throttledRequestHandler();
            },

            /** PrivateFunction: _onDisconnectTimeout
             *  _Private_ timeout handler for handling non-graceful disconnection.
             *
             *  Cancels all remaining Requests and clears the queue.
             */
            _onDisconnectTimeout: function () {
                this._abortAllRequests();
            },

            /** PrivateFunction: _abortAllRequests
             *  _Private_ helper function that makes sure all pending requests are aborted.
             */
            _abortAllRequests: function _abortAllRequests() {
                var req;
                while (this._requests.length > 0) {
                    req = this._requests.pop();
                    req.abort = true;
                    req.xhr.abort();
                    // jslint complains, but this is fine. setting to empty func
                    // is necessary for IE6
                    req.xhr.onreadystatechange = function () {}; // jshint ignore:line
                }
            },

            /** PrivateFunction: _onIdle
             *  _Private_ handler called by Strophe.Connection._onIdle
             *
             *  Sends all queued Requests or polls with empty Request if there are none.
             */
            _onIdle: function () {
                var data = this._conn._data;
                // if no requests are in progress, poll
                if (this._conn.authenticated && this._requests.length === 0 &&
                    data.length === 0 && !this._conn.disconnecting) {
                    Strophe.info("no requests during idle cycle, sending " +
                        "blank request");
                    data.push(null);
                }

                if (this._conn.paused) {
                    return;
                }

                if (this._requests.length < 2 && data.length > 0) {
                    var body = this._buildBody();
                    for (var i = 0; i < data.length; i++) {
                        if (data[i] !== null) {
                            if (data[i] === "restart") {
                                body.attrs({
                                    to: this._conn.domain,
                                    "xml:lang": "en",
                                    "xmpp:restart": "true",
                                    "xmlns:xmpp": Strophe.NS.BOSH
                                });
                            } else {
                                body.cnode(data[i]).up();
                            }
                        }
                    }
                    delete this._conn._data;
                    this._conn._data = [];
                    this._requests.push(
                        new Strophe.Request(body.tree(),
                            this._onRequestStateChange.bind(
                                this, this._conn._dataRecv.bind(this._conn)),
                            body.tree().getAttribute("rid")));
                    this._throttledRequestHandler();
                }

                if (this._requests.length > 0) {
                    var time_elapsed = this._requests[0].age();
                    if (this._requests[0].dead !== null) {
                        if (this._requests[0].timeDead() >
                            Math.floor(Strophe.SECONDARY_TIMEOUT * this.wait)) {
                            this._throttledRequestHandler();
                        }
                    }

                    if (time_elapsed > Math.floor(Strophe.TIMEOUT * this.wait)) {
                        Strophe.warn("Request " +
                            this._requests[0].id +
                            " timed out, over " + Math.floor(Strophe.TIMEOUT * this.wait) +
                            " seconds since last activity");
                        this._throttledRequestHandler();
                    }
                }
            },

            /** PrivateFunction: _getRequestStatus
             *
             *  Returns the HTTP status code from a Strophe.Request
             *
             *  Parameters:
             *    (Strophe.Request) req - The Strophe.Request instance.
             *    (Integer) def - The default value that should be returned if no
             *          status value was found.
             */
            _getRequestStatus: function (req, def) {
                var reqStatus;
                if (req.xhr.readyState == 4) {
                    try {
                        reqStatus = req.xhr.status;
                    } catch (e) {
                        // ignore errors from undefined status attribute. Works
                        // around a browser bug
                        Strophe.error(
                            "Caught an error while retrieving a request's status, " +
                            "reqStatus: " + reqStatus);
                    }
                }
                if (typeof(reqStatus) == "undefined") {
                    reqStatus = typeof def === 'number' ? def : 0;
                }
                return reqStatus;
            },

            /** PrivateFunction: _onRequestStateChange
             *  _Private_ handler for Strophe.Request state changes.
             *
             *  This function is called when the XMLHttpRequest readyState changes.
             *  It contains a lot of error handling logic for the many ways that
             *  requests can fail, and calls the request callback when requests
             *  succeed.
             *
             *  Parameters:
             *    (Function) func - The handler for the request.
             *    (Strophe.Request) req - The request that is changing readyState.
             */
            _onRequestStateChange: function (func, req) {
                Strophe.debug("request id "+req.id+"."+req.sends+
                    " state changed to "+req.xhr.readyState);
                if (req.abort) {
                    req.abort = false;
                    return;
                }
                if (req.xhr.readyState !== 4) {
                    // The request is not yet complete
                    return;
                }
                var reqStatus = this._getRequestStatus(req);
                if (this.disconnecting && reqStatus >= 400) {
                    this._hitError(reqStatus);
                    this._callProtocolErrorHandlers(req);
                    return;
                }

                if ((reqStatus > 0 && reqStatus < 500) || req.sends > 5) {
                    // remove from internal queue
                    this._removeRequest(req);
                    Strophe.debug("request id "+req.id+" should now be removed");
                }

                if (reqStatus == 200) {
                    // request succeeded
                    var reqIs0 = (this._requests[0] == req);
                    var reqIs1 = (this._requests[1] == req);
                    // if request 1 finished, or request 0 finished and request
                    // 1 is over Strophe.SECONDARY_TIMEOUT seconds old, we need to
                    // restart the other - both will be in the first spot, as the
                    // completed request has been removed from the queue already
                    if (reqIs1 ||
                        (reqIs0 && this._requests.length > 0 &&
                        this._requests[0].age() > Math.floor(Strophe.SECONDARY_TIMEOUT * this.wait))) {
                        this._restartRequest(0);
                    }
                    this._conn.nextValidRid(Number(req.rid) + 1);
                    Strophe.debug("request id "+req.id+"."+req.sends+" got 200");
                    func(req); // call handler
                    this.errors = 0;
                } else if (reqStatus === 0 ||
                    (reqStatus >= 400 && reqStatus < 600) ||
                    reqStatus >= 12000) {
                    // request failed
                    Strophe.error("request id "+req.id+"."+req.sends+" error "+reqStatus+" happened");
                    this._hitError(reqStatus);
                    this._callProtocolErrorHandlers(req);
                    if (reqStatus >= 400 && reqStatus < 500) {
                        this._conn._changeConnectStatus(Strophe.Status.DISCONNECTING, null);
                        this._conn._doDisconnect();
                    }
                } else {
                    Strophe.error("request id "+req.id+"."+req.sends+" error "+reqStatus+" happened");
                }
                if (!(reqStatus > 0 && reqStatus < 500) || req.sends > 5) {
                    this._throttledRequestHandler();
                }
            },

            /** PrivateFunction: _processRequest
             *  _Private_ function to process a request in the queue.
             *
             *  This function takes requests off the queue and sends them and
             *  restarts dead requests.
             *
             *  Parameters:
             *    (Integer) i - The index of the request in the queue.
             */
            _processRequest: function (i) {
                var self = this;
                var req = this._requests[i];
                var reqStatus = this._getRequestStatus(req, -1);

                // make sure we limit the number of retries
                if (req.sends > this._conn.maxRetries) {
                    this._conn._onDisconnectTimeout();
                    return;
                }

                var time_elapsed = req.age();
                var primaryTimeout = (!isNaN(time_elapsed) &&
                time_elapsed > Math.floor(Strophe.TIMEOUT * this.wait));
                var secondaryTimeout = (req.dead !== null &&
                req.timeDead() > Math.floor(Strophe.SECONDARY_TIMEOUT * this.wait));
                var requestCompletedWithServerError = (req.xhr.readyState == 4 &&
                (reqStatus < 1 || reqStatus >= 500));
                if (primaryTimeout || secondaryTimeout ||
                    requestCompletedWithServerError) {
                    if (secondaryTimeout) {
                        Strophe.error("Request " + this._requests[i].id +
                            " timed out (secondary), restarting");
                    }
                    req.abort = true;
                    req.xhr.abort();
                    // setting to null fails on IE6, so set to empty function
                    req.xhr.onreadystatechange = function () {};
                    this._requests[i] = new Strophe.Request(req.xmlData,
                        req.origFunc,
                        req.rid,
                        req.sends);
                    req = this._requests[i];
                }

                if (req.xhr.readyState === 0) {
                    Strophe.debug("request id "+req.id+"."+req.sends+" posting");

                    try {
                        var contentType = this._conn.options.contentType || "text/xml; charset=utf-8";
                        req.xhr.open("POST", this._conn.service, this._conn.options.sync ? false : true);
                        if (typeof req.xhr.setRequestHeader !== 'undefined') {
                            // IE9 doesn't have setRequestHeader
                            req.xhr.setRequestHeader("Content-Type", contentType);
                        }
                        if (this._conn.options.withCredentials) {
                            req.xhr.withCredentials = true;
                        }
                    } catch (e2) {
                        Strophe.error("XHR open failed.");
                        if (!this._conn.connected) {
                            this._conn._changeConnectStatus(
                                Strophe.Status.CONNFAIL, "bad-service");
                        }
                        this._conn.disconnect();
                        return;
                    }

                    // Fires the XHR request -- may be invoked immediately
                    // or on a gradually expanding retry window for reconnects
                    var sendFunc = function () {
                        req.date = new Date();
                        if (self._conn.options.customHeaders){
                            var headers = self._conn.options.customHeaders;
                            for (var header in headers) {
                                if (headers.hasOwnProperty(header)) {
                                    req.xhr.setRequestHeader(header, headers[header]);
                                }
                            }
                        }
                        req.xhr.send(req.data);
                    };

                    // Implement progressive backoff for reconnects --
                    // First retry (send == 1) should also be instantaneous
                    if (req.sends > 1) {
                        // Using a cube of the retry number creates a nicely
                        // expanding retry window
                        var backoff = Math.min(Math.floor(Strophe.TIMEOUT * this.wait),
                                Math.pow(req.sends, 3)) * 1000;
                        setTimeout(function() {
                            // XXX: setTimeout should be called only with function expressions (23974bc1)
                            sendFunc();
                        }, backoff);
                    } else {
                        sendFunc();
                    }

                    req.sends++;

                    if (this._conn.xmlOutput !== Strophe.Connection.prototype.xmlOutput) {
                        if (req.xmlData.nodeName === this.strip && req.xmlData.childNodes.length) {
                            this._conn.xmlOutput(req.xmlData.childNodes[0]);
                        } else {
                            this._conn.xmlOutput(req.xmlData);
                        }
                    }
                    if (this._conn.rawOutput !== Strophe.Connection.prototype.rawOutput) {
                        this._conn.rawOutput(req.data);
                    }
                } else {
                    Strophe.debug("_processRequest: " +
                        (i === 0 ? "first" : "second") +
                        " request has readyState of " +
                        req.xhr.readyState);
                }
            },

            /** PrivateFunction: _removeRequest
             *  _Private_ function to remove a request from the queue.
             *
             *  Parameters:
             *    (Strophe.Request) req - The request to remove.
             */
            _removeRequest: function (req) {
                Strophe.debug("removing request");
                var i;
                for (i = this._requests.length - 1; i >= 0; i--) {
                    if (req == this._requests[i]) {
                        this._requests.splice(i, 1);
                    }
                }
                // IE6 fails on setting to null, so set to empty function
                req.xhr.onreadystatechange = function () {};
                this._throttledRequestHandler();
            },

            /** PrivateFunction: _restartRequest
             *  _Private_ function to restart a request that is presumed dead.
             *
             *  Parameters:
             *    (Integer) i - The index of the request in the queue.
             */
            _restartRequest: function (i) {
                var req = this._requests[i];
                if (req.dead === null) {
                    req.dead = new Date();
                }

                this._processRequest(i);
            },

            /** PrivateFunction: _reqToData
             * _Private_ function to get a stanza out of a request.
             *
             * Tries to extract a stanza out of a Request Object.
             * When this fails the current connection will be disconnected.
             *
             *  Parameters:
             *    (Object) req - The Request.
             *
             *  Returns:
             *    The stanza that was passed.
             */
            _reqToData: function (req) {
                try {
                    return req.getResponse();
                } catch (e) {
                    if (e != "parsererror") { throw e; }
                    this._conn.disconnect("strophe-parsererror");
                }
            },

            /** PrivateFunction: _sendTerminate
             *  _Private_ function to send initial disconnect sequence.
             *
             *  This is the first step in a graceful disconnect.  It sends
             *  the BOSH server a terminate body and includes an unavailable
             *  presence if authentication has completed.
             */
            _sendTerminate: function (pres) {
                Strophe.info("_sendTerminate was called");
                var body = this._buildBody().attrs({type: "terminate"});
                if (pres) {
                    body.cnode(pres.tree());
                }
                var req = new Strophe.Request(
                    body.tree(),
                    this._onRequestStateChange.bind(
                        this, this._conn._dataRecv.bind(this._conn)),
                    body.tree().getAttribute("rid")
                );
                this._requests.push(req);
                this._throttledRequestHandler();
            },

            /** PrivateFunction: _send
             *  _Private_ part of the Connection.send function for BOSH
             *
             * Just triggers the RequestHandler to send the messages that are in the queue
             */
            _send: function () {
                clearTimeout(this._conn._idleTimeout);
                this._throttledRequestHandler();

                // XXX: setTimeout should be called only with function expressions (23974bc1)
                this._conn._idleTimeout = setTimeout(function() {
                    this._onIdle();
                }.bind(this._conn), 100);
            },

            /** PrivateFunction: _sendRestart
             *
             *  Send an xmpp:restart stanza.
             */
            _sendRestart: function () {
                this._throttledRequestHandler();
                clearTimeout(this._conn._idleTimeout);
            },

            /** PrivateFunction: _throttledRequestHandler
             *  _Private_ function to throttle requests to the connection window.
             *
             *  This function makes sure we don't send requests so fast that the
             *  request ids overflow the connection window in the case that one
             *  request died.
             */
            _throttledRequestHandler: function () {
                if (!this._requests) {
                    Strophe.debug("_throttledRequestHandler called with " +
                        "undefined requests");
                } else {
                    Strophe.debug("_throttledRequestHandler called with " +
                        this._requests.length + " requests");
                }

                if (!this._requests || this._requests.length === 0) {
                    return;
                }

                if (this._requests.length > 0) {
                    this._processRequest(0);
                }

                if (this._requests.length > 1 &&
                    Math.abs(this._requests[0].rid -
                        this._requests[1].rid) < this.window) {
                    this._processRequest(1);
                }
            }
        };
        return Strophe;
    }));

    /*
     This program is distributed under the terms of the MIT license.
     Please see the LICENSE file for details.

     Copyright 2006-2008, OGG, LLC
     */

    /* jshint undef: true, unused: true:, noarg: true, latedef: true */
    /* global define, window, clearTimeout, WebSocket, DOMParser, Strophe, $build */

    (function (root, factory) {
        if (true) {
            !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__WEBPACK_LOCAL_MODULE_5__], __WEBPACK_LOCAL_MODULE_7__ = (function (core) {
                return factory(
                    core.Strophe,
                    core.$build
                );
            }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)));
        } else {
            // Browser globals
            return factory(Strophe, $build);
        }
    }(this, function (Strophe, $build) {

        /** Class: Strophe.WebSocket
         *  _Private_ helper class that handles WebSocket Connections
         *
         *  The Strophe.WebSocket class is used internally by Strophe.Connection
         *  to encapsulate WebSocket sessions. It is not meant to be used from user's code.
         */

        /** File: websocket.js
         *  A JavaScript library to enable XMPP over Websocket in Strophejs.
         *
         *  This file implements XMPP over WebSockets for Strophejs.
         *  If a Connection is established with a Websocket url (ws://...)
         *  Strophe will use WebSockets.
         *  For more information on XMPP-over-WebSocket see RFC 7395:
         *  http://tools.ietf.org/html/rfc7395
         *
         *  WebSocket support implemented by Andreas Guth (andreas.guth@rwth-aachen.de)
         */

        /** PrivateConstructor: Strophe.Websocket
         *  Create and initialize a Strophe.WebSocket object.
         *  Currently only sets the connection Object.
         *
         *  Parameters:
         *    (Strophe.Connection) connection - The Strophe.Connection that will use WebSockets.
         *
         *  Returns:
         *    A new Strophe.WebSocket object.
         */
        Strophe.Websocket = function(connection) {
            this._conn = connection;
            this.strip = "wrapper";

            var service = connection.service;
            if (service.indexOf("ws:") !== 0 && service.indexOf("wss:") !== 0) {
                // If the service is not an absolute URL, assume it is a path and put the absolute
                // URL together from options, current URL and the path.
                var new_service = "";

                if (connection.options.protocol === "ws" && window.location.protocol !== "https:") {
                    new_service += "ws";
                } else {
                    new_service += "wss";
                }

                new_service += "://" + window.location.host;

                if (service.indexOf("/") !== 0) {
                    new_service += window.location.pathname + service;
                } else {
                    new_service += service;
                }

                connection.service = new_service;
            }
        };

        Strophe.Websocket.prototype = {
            /** PrivateFunction: _buildStream
             *  _Private_ helper function to generate the <stream> start tag for WebSockets
             *
             *  Returns:
             *    A Strophe.Builder with a <stream> element.
             */
            _buildStream: function () {
                return $build("open", {
                    "xmlns": Strophe.NS.FRAMING,
                    "to": this._conn.domain,
                    "version": '1.0'
                });
            },

            /** PrivateFunction: _check_streamerror
             * _Private_ checks a message for stream:error
             *
             *  Parameters:
             *    (Strophe.Request) bodyWrap - The received stanza.
             *    connectstatus - The ConnectStatus that will be set on error.
             *  Returns:
             *     true if there was a streamerror, false otherwise.
             */
            _check_streamerror: function (bodyWrap, connectstatus) {
                var errors;
                if (bodyWrap.getElementsByTagNameNS) {
                    errors = bodyWrap.getElementsByTagNameNS(Strophe.NS.STREAM, "error");
                } else {
                    errors = bodyWrap.getElementsByTagName("stream:error");
                }
                if (errors.length === 0) {
                    return false;
                }
                var error = errors[0];

                var condition = "";

                var ns = "urn:ietf:params:xml:ns:xmpp-streams";
                for (var i = 0; i < error.childNodes.length; i++) {
                    var e = error.childNodes[i];
                    if (e.getAttribute("xmlns") !== ns) {
                        break;
                    } if (e.nodeName === "text") {
                        condition = e.textContent;
                    } else {
                        condition = e.nodeName;
                    }
                }

                var errorString = "WebSocket stream error: ";

                if (condition) {
                    errorString += condition;
                } else {
                    errorString += "unknown";
                }

                Strophe.error(errorString);
                // close the connection on stream_error
                this._conn._changeConnectStatus(connectstatus, condition);
                this._conn._doDisconnect();
                return true;
            },

            /** PrivateFunction: _reset
             *  Reset the connection.
             *
             *  This function is called by the reset function of the Strophe Connection.
             *  Is not needed by WebSockets.
             */
            _reset: function () {
                return;
            },

            /** PrivateFunction: _connect
             *  _Private_ function called by Strophe.Connection.connect
             *
             *  Creates a WebSocket for a connection and assigns Callbacks to it.
             *  Does nothing if there already is a WebSocket.
             */
            _connect: function () {
                // Ensure that there is no open WebSocket from a previous Connection.
                this._closeSocket();

                // Create the new WobSocket
                this.socket = new WebSocket(this._conn.service, "xmpp");
                this.socket.onopen = this._onOpen.bind(this);
                this.socket.onerror = this._onError.bind(this);
                this.socket.onclose = this._onClose.bind(this);
                this.socket.onmessage = this._connect_cb_wrapper.bind(this);
            },

            /** PrivateFunction: _connect_cb
             *  _Private_ function called by Strophe.Connection._connect_cb
             *
             * checks for stream:error
             *
             *  Parameters:
             *    (Strophe.Request) bodyWrap - The received stanza.
             */
            _connect_cb: function(bodyWrap) {
                var error = this._check_streamerror(bodyWrap, Strophe.Status.CONNFAIL);
                if (error) {
                    return Strophe.Status.CONNFAIL;
                }
            },

            /** PrivateFunction: _handleStreamStart
             * _Private_ function that checks the opening <open /> tag for errors.
             *
             * Disconnects if there is an error and returns false, true otherwise.
             *
             *  Parameters:
             *    (Node) message - Stanza containing the <open /> tag.
             */
            _handleStreamStart: function(message) {
                var error = false;

                // Check for errors in the <open /> tag
                var ns = message.getAttribute("xmlns");
                if (typeof ns !== "string") {
                    error = "Missing xmlns in <open />";
                } else if (ns !== Strophe.NS.FRAMING) {
                    error = "Wrong xmlns in <open />: " + ns;
                }

                var ver = message.getAttribute("version");
                if (typeof ver !== "string") {
                    error = "Missing version in <open />";
                } else if (ver !== "1.0") {
                    error = "Wrong version in <open />: " + ver;
                }

                if (error) {
                    this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, error);
                    this._conn._doDisconnect();
                    return false;
                }

                return true;
            },

            /** PrivateFunction: _connect_cb_wrapper
             * _Private_ function that handles the first connection messages.
             *
             * On receiving an opening stream tag this callback replaces itself with the real
             * message handler. On receiving a stream error the connection is terminated.
             */
            _connect_cb_wrapper: function(message) {
                if (message.data.indexOf("<open ") === 0 || message.data.indexOf("<?xml") === 0) {
                    // Strip the XML Declaration, if there is one
                    var data = message.data.replace(/^(<\?.*?\?>\s*)*/, "");
                    if (data === '') return;

                    var streamStart = new DOMParser().parseFromString(data, "text/xml").documentElement;
                    this._conn.xmlInput(streamStart);
                    this._conn.rawInput(message.data);

                    //_handleStreamSteart will check for XML errors and disconnect on error
                    if (this._handleStreamStart(streamStart)) {
                        //_connect_cb will check for stream:error and disconnect on error
                        this._connect_cb(streamStart);
                    }
                } else if (message.data.indexOf("<close ") === 0) { //'<close xmlns="urn:ietf:params:xml:ns:xmpp-framing />') {
                    this._conn.rawInput(message.data);
                    this._conn.xmlInput(message);
                    var see_uri = message.getAttribute("see-other-uri");
                    if (see_uri) {
                        this._conn._changeConnectStatus(Strophe.Status.REDIRECT, "Received see-other-uri, resetting connection");
                        this._conn.reset();
                        this._conn.service = see_uri;
                        this._connect();
                    } else {
                        this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, "Received closing stream");
                        this._conn._doDisconnect();
                    }
                } else {
                    var string = this._streamWrap(message.data);
                    var elem = new DOMParser().parseFromString(string, "text/xml").documentElement;
                    this.socket.onmessage = this._onMessage.bind(this);
                    this._conn._connect_cb(elem, null, message.data);
                }
            },

            /** PrivateFunction: _disconnect
             *  _Private_ function called by Strophe.Connection.disconnect
             *
             *  Disconnects and sends a last stanza if one is given
             *
             *  Parameters:
             *    (Request) pres - This stanza will be sent before disconnecting.
             */
            _disconnect: function (pres, dontClose) {
                if (this.socket && this.socket.readyState !== WebSocket.CLOSED) {
                    if (pres) {
                        this._conn.send(pres);
                    }
                    if (dontClose !== true) {
                        var close = $build("close", { "xmlns": Strophe.NS.FRAMING });
                        this._conn.xmlOutput(close);
                        var closeString = Strophe.serialize(close);
                        this._conn.rawOutput(closeString);
                        try {
                            this.socket.send(closeString);
                        } catch (e) {
                            Strophe.info("Couldn't send <close /> tag.");
                        }
                    }
                }
                this._conn._doDisconnect();
            },

            /** PrivateFunction: _doDisconnect
             *  _Private_ function to disconnect.
             *
             *  Just closes the Socket for WebSockets
             */
            _doDisconnect: function () {
                Strophe.info("WebSockets _doDisconnect was called");
                this._closeSocket();
            },

            /** PrivateFunction _streamWrap
             *  _Private_ helper function to wrap a stanza in a <stream> tag.
             *  This is used so Strophe can process stanzas from WebSockets like BOSH
             */
            _streamWrap: function (stanza) {
                return "<wrapper>" + stanza + '</wrapper>';
            },


            /** PrivateFunction: _closeSocket
             *  _Private_ function to close the WebSocket.
             *
             *  Closes the socket if it is still open and deletes it
             */
            _closeSocket: function () {
                if (this.socket) { try {
                    this.socket.close();
                } catch (e) {} }
                this.socket = null;
            },

            /** PrivateFunction: _emptyQueue
             * _Private_ function to check if the message queue is empty.
             *
             *  Returns:
             *    True, because WebSocket messages are send immediately after queueing.
             */
            _emptyQueue: function () {
                return true;
            },

            /** PrivateFunction: _onClose
             * _Private_ function to handle websockets closing.
             *
             * Nothing to do here for WebSockets
             */
            _onClose: function(e) {
                if(this._conn.connected && !this._conn.disconnecting) {
                    Strophe.error("Websocket closed unexpectedly");
                    this._conn._doDisconnect();
                } else if (e && e.code === 1006 && !this._conn.connected && this.socket) {
                    // in case the onError callback was not called (Safari 10 does not
                    // call onerror when the initial connection fails) we need to
                    // dispatch a CONNFAIL status update to be consistent with the
                    // behavior on other browsers.
                    Strophe.error("Websocket closed unexcectedly");
                    this._conn._changeConnectStatus(
                        Strophe.Status.CONNFAIL,
                        "The WebSocket connection could not be established or was disconnected."
                    );
                    this._conn._doDisconnect();
                } else {
                    Strophe.info("Websocket closed");
                }
                // if(this._conn.connected && !this._conn.disconnecting) {
                //     Strophe.error("Websocket closed unexpectedly");
                //     this._conn._doDisconnect();
                // } else {
                //     this._conn._changeConnectStatus(Strophe.Status.DISCONNECTED, "Socket closed, probably due to no network connectivity."); // Leon Revill: 14th June 2017
                //     Strophe.info("Websocket closed");
                // }
            },

            /** PrivateFunction: _no_auth_received
             *
             * Called on stream start/restart when no stream:features
             * has been received.
             */
            _no_auth_received: function (_callback) {
                Strophe.error("Server did not send any auth methods");
                this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, "Server did not send any auth methods");
                if (_callback) {
                    _callback = _callback.bind(this._conn);
                    _callback();
                }
                this._conn._doDisconnect();
            },

            /** PrivateFunction: _onDisconnectTimeout
             *  _Private_ timeout handler for handling non-graceful disconnection.
             *
             *  This does nothing for WebSockets
             */
            _onDisconnectTimeout: function () {},

            /** PrivateFunction: _abortAllRequests
             *  _Private_ helper function that makes sure all pending requests are aborted.
             */
            _abortAllRequests: function () {},

            /** PrivateFunction: _onError
             * _Private_ function to handle websockets errors.
             *
             * Parameters:
             * (Object) error - The websocket error.
             */
            _onError: function(error) {
                Strophe.error("Websocket error " + error);
                this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, "The WebSocket connection could not be established or was disconnected.");
                this._disconnect();
            },

            /** PrivateFunction: _onIdle
             *  _Private_ function called by Strophe.Connection._onIdle
             *
             *  sends all queued stanzas
             */
            _onIdle: function () {
                if (this.socket === null) return;
                var data = this._conn._data;
                if (data.length > 0 && !this._conn.paused) {
                    for (var i = 0; i < data.length; i++) {
                        if (data[i] !== null) {
                            var stanza, rawStanza;
                            if (data[i] === "restart") {
                                stanza = this._buildStream().tree();
                            } else {
                                stanza = data[i];
                            }
                            rawStanza = Strophe.serialize(stanza);
                            this._conn.xmlOutput(stanza);
                            this._conn.rawOutput(rawStanza);
                            this.socket.send(rawStanza);
                        }
                    }
                    this._conn._data = [];
                }
            },

            /** PrivateFunction: _onMessage
             * _Private_ function to handle websockets messages.
             *
             * This function parses each of the messages as if they are full documents.
             * [TODO : We may actually want to use a SAX Push parser].
             *
             * Since all XMPP traffic starts with
             *  <stream:stream version='1.0'
             *                 xml:lang='en'
             *                 xmlns='jabber:client'
             *                 xmlns:stream='http://etherx.jabber.org/streams'
             *                 id='3697395463'
             *                 from='SERVER'>
             *
             * The first stanza will always fail to be parsed.
             *
             * Additionally, the seconds stanza will always be <stream:features> with
             * the stream NS defined in the previous stanza, so we need to 'force'
             * the inclusion of the NS in this stanza.
             *
             * Parameters:
             * (string) message - The websocket message.
             */
            _onMessage: function(message) {
                var elem, data;
                // check for closing stream
                var close = '<close xmlns="urn:ietf:params:xml:ns:xmpp-framing" />';
                if (message.data === close) {
                    this._conn.rawInput(close);
                    this._conn.xmlInput(message);
                    if (!this._conn.disconnecting) {
                        this._conn._doDisconnect();
                    }
                    return;
                } else if (message.data.search("<open ") === 0) {
                    // This handles stream restarts
                    elem = new DOMParser().parseFromString(message.data, "text/xml").documentElement;
                    if (!this._handleStreamStart(elem)) {
                        return;
                    }
                } else {
                    data = this._streamWrap(message.data);
                    elem = new DOMParser().parseFromString(data, "text/xml").documentElement;
                }

                if (this._check_streamerror(elem, Strophe.Status.ERROR)) {
                    return;
                }

                //handle unavailable presence stanza before disconnecting
                if (this._conn.disconnecting &&
                    elem.firstChild.nodeName === "presence" &&
                    elem.firstChild.getAttribute("type") === "unavailable") {
                    this._conn.xmlInput(elem);
                    this._conn.rawInput(Strophe.serialize(elem));
                    // if we are already disconnecting we will ignore the unavailable stanza and
                    // wait for the </stream:stream> tag before we close the connection
                    return;
                }
                this._conn._dataRecv(elem, message.data);
            },

            /** PrivateFunction: _onOpen
             * _Private_ function to handle websockets connection setup.
             *
             * The opening stream tag is sent here.
             */
            _onOpen: function() {
                Strophe.info("Websocket open");
                var start = this._buildStream();
                this._conn.xmlOutput(start.tree());

                var startString = Strophe.serialize(start);
                this._conn.rawOutput(startString);
                this.socket.send(startString);
            },

            /** PrivateFunction: _reqToData
             * _Private_ function to get a stanza out of a request.
             *
             * WebSockets don't use requests, so the passed argument is just returned.
             *
             *  Parameters:
             *    (Object) stanza - The stanza.
             *
             *  Returns:
             *    The stanza that was passed.
             */
            _reqToData: function (stanza) {
                return stanza;
            },

            /** PrivateFunction: _send
             *  _Private_ part of the Connection.send function for WebSocket
             *
             * Just flushes the messages that are in the queue
             */
            _send: function () {
                this._conn.flush();
            },

            /** PrivateFunction: _sendRestart
             *
             *  Send an xmpp:restart stanza.
             */
            _sendRestart: function () {
                clearTimeout(this._conn._idleTimeout);
                this._conn._onIdle.bind(this._conn)();
            }
        };
        return Strophe;
    }));

    (function(root){
        if(true){
            !(__WEBPACK_AMD_DEFINE_ARRAY__ = [
                __WEBPACK_LOCAL_MODULE_5__,
                __WEBPACK_LOCAL_MODULE_6__,
                __WEBPACK_LOCAL_MODULE_7__
            ], __WEBPACK_AMD_DEFINE_RESULT__ = function (wrapper) {
                return wrapper;
            }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
        }
    })(this);


/* jshint ignore:end */


/***/ }),
/* 38 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
function StreamManagement(StropheClient) {

    const Strophe = StropheClient.Strophe;

    /**
     * Overwrite the Strophe helper method so that it only does comparison on lowercase strings
     * @param el
     * @param name
     * @returns {boolean}
     */
    Strophe.isTagEqual = function (el, name) {
        return (el.tagName || el.node.tagName) === name;
    };

    /**
     * StropheJS - Stream Management XEP-0198
     *
     * This plugin implements stream mangemament ACK capabilities of the specs XEP-0198.
     * Note: Resumption is not supported in this current implementation.
     *
     * Reference: http://xmpp.org/extensions/xep-0198.html
     *
     * @class streamManagement
     */
    Strophe.addConnectionPlugin('streamManagement', {

        /**
         * @property {Boolean} logging: Set to true to enable logging regarding out of sync stanzas.
         */
        logging: true,

        /**
         * @property {Boolean} returnWholeStanza: Set to true to return the acknowledged stanzas, otherwise only return its ID.
         */
        returnWholeStanza: false,

        /**
         * @property {Boolean} autoSendCountOnEveryIncomingStanza: Set to true to send an 'a' response after every stanza.
         * @default false
         * @public
         */
        autoSendCountOnEveryIncomingStanza: false,

        /**
         * @property {Integer} requestResponseInterval: Set this value to send a request for counter on very interval
         * number of stanzas sent. Set to 0 to disable.
         * @default 5
         * @public
         */
        requestResponseInterval: 0,

        allowResume: true,

        /**
         * @property {Pointer} _c: Strophe connection instance.
         * @private
         */
        _c: null,

        /**
         * @property {String} _NS XMPP Namespace.
         * @private
         */
        _NS: 'urn:xmpp:sm:3',

        /**
         * @property {Boolean} _isStreamManagementEnabled
         * @private
         */
        _isStreamManagementEnabled: false,

        /**
         * @property {Integer} _serverProcesssedStanzasCounter: Keeps count of stanzas confirmed processed by the server.
         * The server is the source of truth of this value. It is the 'h' attribute on the latest 'a' element received
         * from the server.
         * @private
         */
        _serverProcesssedStanzasCounter: null,

        /**
         * @property {Integer} _clientProcessedStanzasCounter: Counter of stanzas received by the client from the server.
         * Client is the source of truth of this value. It is the 'h' attribute in the 'a' sent from the client to
         * the server.
         * @private
         */
        _clientProcessedStanzasCounter: null,

        /**
         * @property {Integer} _clientSentStanzasCounter
         * @private
         */
        _clientSentStanzasCounter: null,

        /**
         * Stores a reference to Strophe connection xmlOutput function to wrap counting functionality.
         * @method _originalXMLOutput
         * @type {Handler}
         * @private
         */
        _originalXMLOutput: null,

        /**
         * @property {Handler} _requestHandler: Stores reference to handler that process count request from server.
         * @private
         */
        _requestHandler: null,

        /**
         * @property {Handler} _incomingHandler: Stores reference to handler that processes incoming stanzas count.
         * @private
         */
        _incomingHandler: null,

        /**
         * @property {Integer} _requestResponseIntervalCount: Counts sent stanzas since last response request.
         */
        _requestResponseIntervalCount: 0,

        /**
         * @property {Queue} _unacknowledgedStanzas: Maintains a list of packet ids for stanzas which have yet to be acknowledged.
         */
        _unacknowledgedStanzas: [],

        /**
         * @property {Array} _acknowledgedStanzaListeners: Stores callbacks for each stanza acknowledged by the server.
         * Provides the packet id of the stanza as a parameter.
         * @private
         */
        _acknowledgedStanzaListeners: [],

        _counters: {
            incoming: 0,
            outgoing: 0,
            server: 0
        },

        addAcknowledgedStanzaListener: function (listener) {
            this._acknowledgedStanzaListeners.push(listener);
        },

        enable: function (max) {
            const attrs = {xmlns: this._NS, resume: this.allowResume};
            if (max) {
                try {
                    attrs.max = "" + (max / 1000);
                } catch (e) {
                    console.error(`Couldn't convert '${max}' to milliseconds:`, e);
                }
            }
            this._c.send(StropheClient.$build('enable', attrs));
            this._c.flush();
            this._c.pause();
        },

        requestAcknowledgement: function () {
            this._requestResponseIntervalCount = 0;
            this._c.send(StropheClient.$build('r', {xmlns: this._NS}));
        },

        getOutgoingCounter: function () {
            return this._counters.outgoing;
        },

        getServerProcessedCounter: function () {
            return this._counters.server;
        },

        getIncomingCounter: function () {
            return this._counters.incoming;
        },

        init: function (conn) {
            this._c = conn;
            Strophe.addNamespace('SM', this._NS);
            const counters = localStorage.getItem(this._c.options.instance_id + "_counters");
            if (counters !== null) {
                let json = null;
                try {
                    json = JSON.parse(counters);
                } catch (e) {}
                if (json !== null) {
                    this._counters = json;
                }
            }

            // Storing original xmlOutput function to use additional logic
            this._originalXMLOutput = this._c.xmlOutput;
            this._c.xmlOutput = this.xmlOutput.bind(this);
        },

        statusChanged: function (status, condition) {
            if (status === Strophe.Status.CONNECTED || status === Strophe.Status.DISCONNECTED) {

                this._requestResponseIntervalCount = 0;
                this._isStreamManagementEnabled = false;
                // don't reset the stanza counter if we are resuming the stream
                if (status === Strophe.Status.CONNECTED && condition !== "resumed") {
                    this._resetCounters();
                }

                // If we have just resumed then stream management is enabled
                if (status === Strophe.Status.CONNECTED && condition === "resumed") {
                    this._isStreamManagementEnabled = true;
                }

                this._unacknowledgedStanzas = [];

                if (this._requestHandler) {
                    this._c.deleteHandler(this._requestHandler);
                }

                if (this._incomingHandler) {
                    this._c.deleteHandler(this._incomingHandler);
                }

                this._requestHandler = this._c.addHandler(this._handleServerRequestHandler.bind(this), this._NS, 'r');
                this._incomingHandler = this._c.addHandler(this._incomingStanzaHandler.bind(this), null, null);
            }
        },

        /**
         * This method overrides the send method implemented by Strophe.Connection
         * to count outgoing stanzas
         *
         * @method Send
         * @public
         */
        xmlOutput: function (elem) {
            function _shouldIncrease(element) {
                return (Strophe.isTagEqual(element, 'iq') || Strophe.isTagEqual(element, 'presence') || Strophe.isTagEqual(element, 'message'));
            }

            if (_shouldIncrease(elem)) {
                this._increaseSentStanzasCounter(elem);
            } else {
                // elem is a Strophe object on connection close, causes error :/
                if (elem.children !== undefined) {
                    var child;
                    for (var i = 0; i < elem.children.length; i++) {
                        child = elem.children[i];
                        if (_shouldIncrease()) {
                            this._increaseSentStanzasCounter(child);
                        }
                    }
                }
            }

            return this._originalXMLOutput.call(this._c, elem);
        },

        _incomingStanzaHandler: function (elem) {

            if (Strophe.isTagEqual(elem, 'enabled') && elem.getAttribute('xmlns') === this._NS) {
                this._isStreamManagementEnabled = true;
                this._c.resume();
            }

            if (Strophe.isTagEqual(elem, 'iq') || Strophe.isTagEqual(elem, 'presence') || Strophe.isTagEqual(elem, 'message')) {
                this._increaseReceivedStanzasCounter();

                if (this.autoSendCountOnEveryIncomingStanza) {
                    this._answerProcessedStanzas();
                }

                // If we got an error back from a previous message rollback the client sent stanza counter
                if (Strophe.isTagEqual(elem, 'message') && elem.getAttribute("type") === "error") {
                    this._counters.outgoing = (this._counters.outgoing - 1);
                }

            }

            if (Strophe.isTagEqual(elem, 'a')) {
                var handledCount = parseInt(elem.getAttribute('h'));
                this._handleAcknowledgedStanzas(handledCount, this._counters.server);
                this._counters.server = handledCount;
                this._persistCounters();
                if (this.requestResponseInterval > 0) {
                    this._requestResponseIntervalCount = 0;
                }
            }

            return true;
        },

        _handleAcknowledgedStanzas: function (reportedHandledCount, lastKnownHandledCount) {
            var delta = reportedHandledCount - lastKnownHandledCount;

            if (delta < 0) {
                this._throwError('New reported stanza count lower than previous. New: ' + reportedHandledCount + ' - Previous: ' + lastKnownHandledCount);
            }

            if (delta > this._unacknowledgedStanzas.length) {
                this._throwError('Higher reported acknowledge count than unacknowledged stanzas. Reported Acknowledge Count: ' + delta + ' - Unacknowledge Stanza Count: ' + this._unacknowledgedStanzas.length + ' - New: ' + reportedHandledCount + ' - Previous: ' + lastKnownHandledCount);
            }

            for (var i = 0; i < delta; i++) {
                var stanza = this._unacknowledgedStanzas.shift();
                for (var j = 0; j < this._acknowledgedStanzaListeners.length; j++) {
                    this._acknowledgedStanzaListeners[j](stanza);
                }
            }

            if (this.logging && this._unacknowledgedStanzas.length > 0) {
                console.warn('Unacknowledged stanzas', this._unacknowledgedStanzas);
            }
        },

        _handleServerRequestHandler: function () {
            this._answerProcessedStanzas();
            return true;
        },

        _answerProcessedStanzas: function (force) {
            if (this._isStreamManagementEnabled || force === true) {
                this._c.send(StropheClient.$build('a', {xmlns: this._NS, h: this._counters.incoming}));
            }
        },

        _increaseSentStanzasCounter: function (elem) {
            if (this._isStreamManagementEnabled) {
                this._unacknowledgedStanzas.push(this.returnWholeStanza ? elem : elem.getAttribute('id'));
                this._counters.outgoing++;
                this._persistCounters();
                if (this.requestResponseInterval > 0) {
                    this._requestResponseIntervalCount++;

                    if (this._requestResponseIntervalCount === this.requestResponseInterval) {
                        this.requestAcknowledgement();
                    }
                }
            }
        },

        _increaseReceivedStanzasCounter: function () {
            if (this._isStreamManagementEnabled) {
                this._counters.incoming++;
                this._persistCounters();
            }
        },

        _persistCounters: function () {
            localStorage.setItem(this._c.options.instance_id + "_counters", JSON.stringify(this._counters));
        },

        _resetCounters: function () {
            this._counters = {
                incoming: 0,
                outgoing: 0,
                server: 0
            };
            this._persistCounters();
        },

        _throwError: function (msg) {
            console.error(msg);
        },

    });

    return StropheClient;

}

/* harmony default export */ __webpack_exports__["a"] = (StreamManagement);


/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Created by Leon.Revill on 01/12/2017.
 */

Object.defineProperty(exports, "__esModule", { value: true });
const users_worker_js_1 = __webpack_require__(36);
const utils_1 = __webpack_require__(18);
class UsersDirectory {
    constructor(instanceId, debug = false) {
        this._instanceId = null;
        this._worker = null;
        this._debug = false;
        this.initialised = false;
        this._workerResponseListeners = {};
        this._instanceId = instanceId;
        this._debug = debug;
    }
    _addWorkerResponseListener(_id, cb) {
        this._workerResponseListeners[_id] = cb;
    }
    _onWorkerResponse(e) {
        if (e.data && this._debug) {
            console.log(`Worker: ${e.data.msg}`);
        }
        const callback = this._workerResponseListeners[e.data._id];
        if (!callback)
            return;
        const result = callback(e.data);
        if (result !== true)
            delete this._workerResponseListeners[e.data._id];
    }
    _postMessageToWorker(data, cb) {
        if (this._worker === null)
            throw new Error("Worker has not been initialised!");
        const _id = utils_1.generateGuid();
        this._workerResponseListeners[_id] = cb;
        this._worker.postMessage(Object.assign({}, data, { _id }));
    }
    /**
     * Method used to set-up the worker instance and initialise the database and index within the worker
     * @returns {Promise<string>}
     */
    initialise(keyBuffer, iVector) {
        return new Promise((resolve, reject) => {
            this._worker = new Worker(window.URL.createObjectURL(new Blob([`const start = ${users_worker_js_1.default.toString()}; start.call(self);`], { type: "text/javascript" })));
            this._worker.onmessage = this._onWorkerResponse.bind(this);
            this._postMessageToWorker({
                action: "initialise",
                instanceId: this._instanceId,
                key: keyBuffer,
                iv: iVector,
                debug: this._debug
            }, (data) => {
                if (data.success === true) {
                    this.initialised = true;
                    resolve(data.msg);
                }
                else {
                    console.error(data.msg);
                    this.initialised = false;
                    this.destroy(true).then(() => {
                        reject(data.msg);
                    });
                }
                return false;
            });
        });
    }
    /**
     * Method used to download any updates to the user directory from the specified endpoint
     * @param jid {String} - The JID of the user for authentication
     * @param pass {String} - The password of the user for authentication
     * @param endpoint {String} - The URL to the JSON containing the user directory
     * @returns {Promise<string>}
     */
    update(jid, pass, endpoint) {
        if (this.initialised !== true)
            throw new Error("User index must be initialised first.");
        return new Promise((resolve, reject) => {
            this._postMessageToWorker({
                action: "fetch",
                endpoint: endpoint,
                jid: jid,
                pass: pass
            }, (data) => {
                if (data.success === true) {
                    resolve(data);
                }
                else {
                    console.error(data.msg);
                    reject(data.msg);
                }
                return false;
            });
        });
    }
    /**
     * Method used to perform a full-text search on all users within the directory which have been downloaded and indexed
     * Searchable fields are jid, prefix, firstName, lastName and title
     * @param query
     * @returns {Promise<string | DirectoryUser[]>}
     */
    search(query, fields) {
        if (this.initialised !== true)
            throw new Error("User index must be initialised first.");
        return new Promise((resolve, reject) => {
            this._postMessageToWorker({
                action: "search",
                query: query,
                fields: fields || []
            }, (data) => {
                if (data.success === true) {
                    resolve(data.results);
                }
                else {
                    console.error(data.msg);
                    reject(data.msg);
                }
                return false;
            });
        });
    }
    /**
     * Method used to find a single user in the directory by the JID
     * @param {String} jid
     * @returns {Promise<DirectoryUser | string>}
     */
    getUserByJid(jid) {
        if (this.initialised !== true)
            throw new Error("User index must be initialised first.");
        return new Promise((resolve, reject) => {
            this._postMessageToWorker({
                action: "jid-search",
                jid: jid
            }, (data) => {
                if (data.success === true) {
                    resolve(data.result);
                }
                else {
                    console.error(data.msg);
                    reject(data.msg);
                }
                return false;
            });
        });
    }
    /**
     * Method to return all users in the user directory - use at your own risk if there are many users in the directory
     * @returns {Promise<DirectoryUser[]>}
     */
    getAllUsers() {
        if (this.initialised !== true)
            throw new Error("User index must be initialised first.");
        return new Promise((resolve, reject) => {
            this._postMessageToWorker({
                action: "get-all-users"
            }, (data) => {
                if (data.success === true) {
                    resolve(data.results);
                }
                else {
                    console.error(data.msg);
                    reject(data.msg);
                }
                return false;
            });
        });
    }
    /**
     * Method to destroy the database that the users are stored in
     * @returns {Promise<string>}
     */
    destroy(override = false) {
        if (this.initialised !== true && override === false)
            throw new Error("User index must be initialised first.");
        return new Promise((resolve, reject) => {
            this._postMessageToWorker({
                action: "destroy"
            }, (data) => {
                if (data.success === true) {
                    this.initialised = false;
                    resolve(data.msg);
                }
                else {
                    console.error(data.msg);
                    reject(data.msg);
                }
                return false;
            });
        });
    }
    static _resolvePath(path) {
        if (!path)
            return null;
        if (path.indexOf("http") === 0 || path.indexOf("//") === 0) {
            return path;
        }
        else {
            return (path.indexOf("/") === 0) ? window.location.origin + path : `${window.location.origin}/${path}`;
        }
    }
}
exports.UsersDirectory = UsersDirectory;


/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Created by Leon.Revill on 19/06/2017.
 */

Object.defineProperty(exports, "__esModule", { value: true });
/* tslint:disable */
// TODO: Fix linting issues
const es6_promise_1 = __webpack_require__(29);
const Environment = __webpack_require__(14);
const Plugin = __webpack_require__(15);
const eWindow = window;
const cWindow = window;
let FileTransfer = null;
const ATTACHMENTS_DIR = "attachments";
const MEDIA_TYPES = {
    IMAGE: "image",
    AUDIO: "audio",
    VIDEO: "video"
};
const MIME_TYPE_MAP = {
    "a": { mimeType: "application/octet-stream", mediaType: null },
    "ai": { mimeType: "application/postscript", mediaType: null },
    "aif": { mimeType: "audio/x-aiff", mediaType: MEDIA_TYPES.AUDIO },
    "aifc": { mimeType: "audio/x-aiff", mediaType: MEDIA_TYPES.AUDIO },
    "aiff": { mimeType: "audio/x-aiff", mediaType: MEDIA_TYPES.AUDIO },
    "au": { mimeType: "audio/basic", mediaType: MEDIA_TYPES.AUDIO },
    "avi": { mimeType: "video/x-msvideo", mediaType: null },
    "bat": { mimeType: "text/plain", mediaType: null },
    "bin": { mimeType: "application/octet-stream", mediaType: null },
    "bmp": { mimeType: "image/x-ms-bmp", mediaType: MEDIA_TYPES.IMAGE },
    "c": { mimeType: "text/plain", mediaType: null },
    "cdf": { mimeType: "application/x-cdf", mediaType: null },
    "csh": { mimeType: "application/x-csh", mediaType: null },
    "css": { mimeType: "text/css", mediaType: null },
    "dll": { mimeType: "application/octet-stream", mediaType: null },
    "doc": { mimeType: "application/msword", mediaType: null },
    "docm": { mimeType: "application/vnd.ms-word.document.macroEnabled.12", mediaType: null },
    "docx": { mimeType: "application/vnd.openxmlformats-officedocument.wordprocessingml.document", mediaType: null },
    "dot": { mimeType: "application/msword", mediaType: null },
    "dotx": { mimeType: "application/vnd.openxmlformats-officedocument.wordprocessingml.template", mediaType: null },
    "dvi": { mimeType: "application/x-dvi", mediaType: null },
    "eml": { mimeType: "message/rfc822", mediaType: null },
    "eps": { mimeType: "application/postscript", mediaType: null },
    "etx": { mimeType: "text/x-setext", mediaType: null },
    "exe": { mimeType: "application/octet-stream", mediaType: null },
    "gif": { mimeType: "image/gif", mediaType: MEDIA_TYPES.IMAGE },
    "gtar": { mimeType: "application/x-gtar", mediaType: null },
    "h": { mimeType: "text/plain", mediaType: null },
    "hdf": { mimeType: "application/x-hdf", mediaType: null },
    "htm": { mimeType: "text/html", mediaType: null },
    "html": { mimeType: "text/html", mediaType: null },
    "jpe": { mimeType: "image/jpe", mediaType: MEDIA_TYPES.IMAGE },
    "jpeg": { mimeType: "image/jpeg", mediaType: MEDIA_TYPES.IMAGE },
    "jpg": { mimeType: "image/jpeg", mediaType: MEDIA_TYPES.IMAGE, preferred: true },
    "js": { mimeType: "application/javascript", mediaType: null },
    "json": { mimeType: "application/json", mediaType: null },
    "ksh": { mimeType: "text/plain", mediaType: null },
    "latex": { mimeType: "application/x-latex", mediaType: null },
    "m1v": { mimeType: "video/mpeg", mediaType: MEDIA_TYPES.VIDEO },
    "m4a": { mimeType: "audio/mpeg", mediaType: MEDIA_TYPES.AUDIO, preferred: true },
    "man": { mimeType: "application/x-troff-man", mediaType: null },
    "me": { mimeType: "application/x-troff-me", mediaType: null },
    "mht": { mimeType: "message/rfc822", mediaType: null },
    "mhtml": { mimeType: "message/rfc822", mediaType: null },
    "mif": { mimeType: "application/x-mif", mediaType: null },
    "mov": { mimeType: "video/quicktime", mediaType: MEDIA_TYPES.VIDEO },
    "movie": { mimeType: "video/x-sgi-movie", mediaType: MEDIA_TYPES.VIDEO },
    "mp2": { mimeType: "audio/mpeg", mediaType: MEDIA_TYPES.AUDIO },
    "mp3": { mimeType: "audio/mp3", mediaType: MEDIA_TYPES.AUDIO },
    "mp4": { mimeType: "video/mp4", mediaType: MEDIA_TYPES.VIDEO },
    "mpa": { mimeType: "video/mpeg", mediaType: MEDIA_TYPES.VIDEO },
    "mpe": { mimeType: "video/mpeg", mediaType: MEDIA_TYPES.VIDEO },
    "mpeg": { mimeType: "video/mpeg", mediaType: MEDIA_TYPES.VIDEO },
    "mpg": { mimeType: "video/mpeg", mediaType: MEDIA_TYPES.VIDEO, preferred: true },
    "ms": { mimeType: "application/x-troff-ms", mediaType: null },
    "nc": { mimeType: "application/x-netcdf", mediaType: null },
    "nws": { mimeType: "message/rfc822", mediaType: null },
    "o": { mimeType: "application/octet-stream", mediaType: null },
    "obj": { mimeType: "application/octet-stream", mediaType: null },
    "oda": { mimeType: "application/oda", mediaType: null },
    "otf": { mimeType: "application/x-font-opentype", mediaType: null },
    "pbm": { mimeType: "image/x-portable-bitmap", mediaType: MEDIA_TYPES.IMAGE },
    "pdf": { mimeType: "application/pdf", mediaType: null },
    "pfx": { mimeType: "application/x-pkcs12", mediaType: null },
    "pgm": { mimeType: "image/x-portable-graymap", mediaType: MEDIA_TYPES.IMAGE },
    "png": { mimeType: "image/png", mediaType: MEDIA_TYPES.IMAGE },
    "pnm": { mimeType: "image/x-portable-anymap", mediaType: MEDIA_TYPES.IMAGE },
    "po": { mimeType: "text/x-gettext-translation", mediaType: null },
    "pot": { mimeType: "application/vnd.ms-powerpoint", mediaType: null },
    "ppa": { mimeType: "application/vnd.ms-powerpoint", mediaType: null },
    "ppm": { mimeType: "image/x-portable-pixmap", mediaType: MEDIA_TYPES.IMAGE },
    "pps": { mimeType: "application/vnd.ms-powerpoint", mediaType: null },
    "ppt": { mimeType: "application/vnd.ms-powerpoint", mediaType: null },
    "pptm": { mimeType: "application/vnd.ms-powerpoint.presentation.macroEnabled.12", mediaType: null },
    "pptx": { mimeType: "application/vnd.openxmlformats-officedocument.presentationml.presentation", mediaType: null },
    "ps": { mimeType: "application/postscript", mediaType: null },
    "pwz": { mimeType: "application/vnd.ms-powerpoint", mediaType: null },
    "py": { mimeType: "text/x-python", mediaType: null },
    "pyc": { mimeType: "application/x-python-code", mediaType: null },
    "pyo": { mimeType: "application/x-python-code", mediaType: null },
    "qt": { mimeType: "video/quicktime", mediaType: MEDIA_TYPES.VIDEO },
    "ra": { mimeType: "audio/x-pn-realaudio", mediaType: MEDIA_TYPES.AUDIO },
    "ram": { mimeType: "application/x-pn-realaudio", mediaType: MEDIA_TYPES.AUDIO },
    "ras": { mimeType: "image/x-cmu-raster", mediaType: MEDIA_TYPES.IMAGE },
    "rdf": { mimeType: "application/xml", mediaType: null },
    "rgb": { mimeType: "image/x-rgb", mediaType: MEDIA_TYPES.IMAGE },
    "roff": { mimeType: "application/x-troff", mediaType: null },
    "rtx": { mimeType: "text/richtext", mediaType: null },
    "sgm": { mimeType: "text/x-sgml", mediaType: null },
    "sgml": { mimeType: "text/x-sgml", mediaType: null },
    "sh": { mimeType: "application/x-sh", mediaType: null },
    "shar": { mimeType: "application/x-shar", mediaType: null },
    "snd": { mimeType: "audio/basic", mediaType: MEDIA_TYPES.AUDIO },
    "so": { mimeType: "application/octet-stream", mediaType: null },
    "src": { mimeType: "application/x-wais-source", mediaType: null },
    "svg": { mimeType: "image/svg+xml", mediaType: MEDIA_TYPES.IMAGE },
    "swf": { mimeType: "application/x-shockwave-flash", mediaType: null },
    "t": { mimeType: "application/x-troff", mediaType: null },
    "tar": { mimeType: "application/x-tar", mediaType: null },
    "tcl": { mimeType: "application/x-tcl", mediaType: null },
    "tex": { mimeType: "application/x-tex", mediaType: null },
    "texi": { mimeType: "application/x-texinfo", mediaType: null },
    "texinfo": { mimeType: "application/x-texinfo", mediaType: null },
    "tif": { mimeType: "image/tiff", mediaType: MEDIA_TYPES.IMAGE },
    "tiff": { mimeType: "image/tiff", mediaType: MEDIA_TYPES.IMAGE },
    "tr": { mimeType: "application/x-troff", mediaType: null },
    "tsv": { mimeType: "text/tab-separated-values", mediaType: null },
    "ttf": { mimeType: "application/x-font-truetype", mediaType: null },
    "txt": { mimeType: "text/plain", mediaType: null, preferred: true },
    "ustar": { mimeType: "application/x-ustar", mediaType: null },
    "vcf": { mimeType: "text/x-vcard", mediaType: null },
    "wav": { mimeType: "audio/x-wav", mediaType: MEDIA_TYPES.AUDIO },
    "woff": { mimeType: "application/font-woff", mediaType: null, preferred: true },
    "woff2": { mimeType: "application/font-woff", mediaType: null },
    "wsdl": { mimeType: "application/xml", mediaType: null },
    "xbm": { mimeType: "image/x-xbitmap", mediaType: MEDIA_TYPES.IMAGE },
    "xlb": { mimeType: "application/vnd.ms-excel", mediaType: null },
    "xls": { mimeType: "application/vnd.ms-excel", mediaType: null },
    "xlsm": { mimeType: "application/vnd.ms-excel.sheet.macroEnabled.12", mediaType: null },
    "xlsx": { mimeType: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet", mediaType: null },
    "xml": { mimeType: "text/xml", mediaType: null },
    "xpdl": { mimeType: "application/xml", mediaType: null },
    "xpm": { mimeType: "image/x-xpixmap", mediaType: MEDIA_TYPES.IMAGE },
    "xsl": { mimeType: "application/xml", mediaType: null },
    "xwd": { mimeType: "image/x-xwindowdump", mediaType: MEDIA_TYPES.IMAGE },
    "zip": { mimeType: "application/zip", mediaType: null }
};
/**
 * Obtains an appropriate mime type given a file extension
 * @param {string} extensionOrPath - The file name or file path of the file including the file extension
 * @returns {string|null} - An appropriate mime type for the file extension, or null if one not found
 */
function getMimeTypeFromExtension(extensionOrPath) {
    if (extensionOrPath.indexOf(".") !== -1) {
        extensionOrPath = extensionOrPath.split(".").pop().toLowerCase();
    }
    if (MIME_TYPE_MAP.hasOwnProperty(extensionOrPath)) {
        return MIME_TYPE_MAP[extensionOrPath].mimeType;
    }
    return null;
}
exports.getMimeTypeFromExtension = getMimeTypeFromExtension;
/**
 * Obtains an appropriate media type (e.g. image, video, audio, etc.) given a file extension
 * @param {string} extensionOrPath - The file name or file path of the file including the file extension
 * @returns {string|null} - An appropriate media type for the file extension, or null if one not found
 */
function getMediaTypeFromExtension(extensionOrPath) {
    if (extensionOrPath.indexOf(".") !== -1) {
        extensionOrPath = extensionOrPath.split(".").pop().toLowerCase();
    }
    if (MIME_TYPE_MAP.hasOwnProperty(extensionOrPath)) {
        return MIME_TYPE_MAP[extensionOrPath].mediaType;
    }
    return null;
}
exports.getMediaTypeFromExtension = getMediaTypeFromExtension;
/**
 * Obtains an appropriate media type (e.g. image, video, audio, etc.) given a mime type
 * @param {string} mimeType - The mime type (e.g. image/jpeg)
 * @returns {string|null} - An appropriate media type for the file extension, or null if one not found
 */
function getMediaTypeFromMimeType(mimeType) {
    const extension = Object.keys(MIME_TYPE_MAP).filter(extension => MIME_TYPE_MAP[extension].mimeType === mimeType)[0];
    return (!extension) ? null : MIME_TYPE_MAP[extension].mediaType;
}
exports.getMediaTypeFromMimeType = getMediaTypeFromMimeType;
/**
 * Obtains just the file name part given a file path
 * @param {string} filePath - The full file path
 * @returns {string} - The file name portion of the file path (including file extension)
 */
function getFileNameFromPath(filePath) {
    return filePath.replace(/\\/g, "/").split("/").pop();
}
exports.getFileNameFromPath = getFileNameFromPath;
/**
 * Obtains the path to the default storage location for the current platform
 * @returns {Promise} - A promise to resolve with the path of the default storage platform
 */
function getStorageLocation() {
    return new es6_promise_1.Promise((resolve, reject) => {
        if (Environment.isElectron()) {
            // Bend over backwards to get the electron storage location
            try {
                const app = eWindow.require("electron").remote.app;
                const path = eWindow.require("path");
                const pathSeparator = path.sep;
                const applicationDataPath = app.getPath("userData");
                const location = applicationDataPath + pathSeparator + ATTACHMENTS_DIR + pathSeparator;
                // Make it if its not there
                const fs = eWindow.require("fs");
                if (!fs.existsSync(location)) {
                    fs.mkdirSync(location);
                }
                resolve(location);
            }
            catch (e) {
                reject(e);
            }
        }
        else {
            const platformName = Environment.getPlatformName();
            const File = Plugin.getSource("file");
            if (File !== false) {
                let dir = "";
                if (platformName === "ios") {
                    dir += File.documentsDirectory;
                }
                else if (platformName === "android") {
                    dir += File.dataDirectory;
                }
                else {
                    return reject("Unsupported platform, expected Android or iOS.");
                }
                cWindow.resolveLocalFileSystemURL(dir, function (parent) {
                    parent.getDirectory(ATTACHMENTS_DIR, { create: true, exclusive: false }, function (dirEntry) {
                        resolve(dirEntry.nativeURL);
                    }, reject);
                }, reject);
            }
            else {
                reject("No file plugin available.");
            }
        }
    });
}
/**
 * Function which figures out which native plugin to use and performs an upload
 * @param filePath {String}
 * @param putUrl {String}
 * @param getUrl {String}
 * @param headers {Object}
 * @returns {Promise}
 */
function upload(filePath, putUrl, getUrl, headers) {
    return new es6_promise_1.Promise((resolve, reject) => {
        if (FileTransfer === null)
            FileTransfer = (Environment.isElectron()) ? Plugin.getSource("@commontimeltd/com.commontime.filetransfer") : Plugin.getSource("FileTransfer");
        if (FileTransfer !== false) {
            const uploadOptions = {
                httpMethod: "PUT",
                fileName: getFileNameFromPath(filePath),
                fileKey: "file",
                headers: headers,
                mimeType: getMimeTypeFromExtension(filePath),
                chunkedMode: false
            };
            const ft = new FileTransfer();
            ft.upload(filePath, putUrl, (result) => {
                resolve({
                    source: filePath,
                    target: putUrl,
                    response: result.response
                });
            }, reject, uploadOptions);
        }
        else {
            console.warn("Falling back to using XHR for file uploads.");
            urlToBlob(filePath).then((blob) => {
                const send = new XMLHttpRequest();
                send.addEventListener("load", (e) => {
                    resolve({
                        source: getUrl,
                        target: putUrl,
                        response: e
                    });
                });
                send.addEventListener("error", reject);
                send.open("PUT", putUrl, true);
                if (headers) {
                    for (let key in headers) {
                        send.setRequestHeader(key, headers[key]);
                    }
                }
                send.send(blob);
            });
        }
    });
}
exports.upload = upload;
function download(getUrl, headers = null) {
    return new es6_promise_1.Promise((resolve, reject) => {
        if (FileTransfer === null)
            FileTransfer = (Environment.isElectron()) ? Plugin.getSource("@commontimeltd/com.commontime.filetransfer") : Plugin.getSource("FileTransfer");
        if (FileTransfer !== false) {
            getStorageLocation().then((path) => {
                const ft = new FileTransfer();
                const filePath = path + Date.now() + "_" + getFileNameFromPath(getUrl);
                const _success = (result) => {
                    if (Environment.isElectron()) {
                        resolve({
                            source: result.filePath,
                            target: getUrl
                        });
                    }
                    else if (Environment.isDevice()) {
                        resolve({
                            source: result.nativeURL,
                            target: getUrl
                        });
                    }
                    else {
                        console.warn("Attachments are not currently supported on this platform.");
                        reject();
                    }
                };
                const _fail = (e) => {
                    console.error(`Unable to download file '${filePath}' from '${getUrl}':`, e);
                    reject(e);
                };
                // API is different depending on whether you are on a device or on a desktop :( :'( :'''(
                if (Environment.isDevice()) {
                    ft.download(getUrl, filePath, _success, _fail, false, {
                        "headers": headers
                    });
                }
                else {
                    ft.download(getUrl, filePath, _success, _fail, {
                        "headers": headers
                    });
                }
            }).catch(reject);
        }
        else {
            resolve({
                source: getUrl,
                target: getUrl
            });
        }
    });
}
exports.download = download;
function getFileInfo(filePath) {
    return new es6_promise_1.Promise((resolve, reject) => {
        if (Environment.isElectron()) {
            try {
                const fsplus = eWindow.require("fs-plus");
                fsplus.stat(filePath, (e, stats) => {
                    if (e) {
                        reject(e);
                    }
                    else {
                        resolve({
                            name: getFileNameFromPath(filePath),
                            path: filePath,
                            size: stats.size,
                            type: getMimeTypeFromExtension(filePath),
                            mediaType: getMediaTypeFromExtension(filePath)
                        });
                    }
                });
            }
            catch (e) {
                reject("Couldn't require 'fs-plus' module.");
            }
        }
        else if (Environment.isDevice()) {
            const path = (filePath.indexOf("file://") !== 0) ? `file://${filePath}` : filePath;
            cWindow.resolveLocalFileSystemURL(path, function (fileEntry) {
                fileEntry.file(function (file) {
                    const type = (file.type) ? file.type : getMimeTypeFromExtension(filePath);
                    resolve({
                        name: file.name,
                        path: path,
                        size: file.size,
                        type: type,
                        mediaType: getMediaTypeFromExtension(filePath)
                    });
                });
            }, reject);
        }
        else {
            urlToBlob(filePath).then((blob) => {
                resolve({
                    name: filePath.split("/").pop(),
                    path: filePath,
                    size: blob.size,
                    type: blob.type,
                    mediaType: getMediaTypeFromMimeType(blob.type)
                });
            });
        }
    });
}
exports.getFileInfo = getFileInfo;
function deleteFile(filePath) {
    return new es6_promise_1.Promise((resolve, reject) => {
        if (Environment.isElectron()) {
            try {
                const fsplus = eWindow.require("fs-plus");
                const fileExists = fsplus.existsSync(filePath);
                if (fileExists) {
                    fsplus.unlinkSync(filePath);
                    resolve();
                }
                else {
                    reject(`File '${filePath}' doesn't exist and cannot be deleted.`);
                }
            }
            catch (e) {
                reject(`Something went wrong while trying to delete the file '${filePath}': ${e}`);
            }
        }
        else if (Environment.isDevice()) {
            cWindow.resolveLocalFileSystemURL(filePath, (fileEntry) => {
                if (fileEntry.isDirectory) {
                    reject(`File path '${filePath}' is a directory and cannot be deleted.`);
                }
                else {
                    fileEntry.remove(resolve, reject);
                }
            }, (err) => {
                reject(err);
            });
        }
        else {
            // No physical file to remove
            resolve();
        }
    });
}
exports.deleteFile = deleteFile;
function urlToBlob(url) {
    return new es6_promise_1.Promise((resolve, reject) => {
        const xhr = new XMLHttpRequest();
        xhr.open("GET", url, true);
        xhr.responseType = "blob";
        xhr.onload = () => {
            if (xhr.status === 200) {
                resolve(xhr.response);
            }
        };
        xhr.send();
    });
}
exports.urlToBlob = urlToBlob;
function blobToObjectUrl(blob) {
    return new es6_promise_1.Promise((resolve) => {
        resolve(URL.createObjectURL(blob));
    });
}
exports.blobToObjectUrl = blobToObjectUrl;
function deleteAttachments() {
    return new es6_promise_1.Promise((resolve, reject) => {
        if (Environment.isElectron()) {
            const path = eWindow.require("path");
            const fs = eWindow.require("fs");
            const userDataPath = eWindow.require("electron").remote.app.getPath("userData");
            const pathSeparator = path.sep;
            const location = userDataPath + pathSeparator + ATTACHMENTS_DIR + pathSeparator;
            if (!fs.existsSync(location)) {
                return resolve();
            }
            fs.readdir(location, (err, files) => {
                if (err) {
                    return reject(err);
                }
                for (const file of files) {
                    if (fs.lstatSync(path.join(location, file)).isFile()) {
                        fs.unlinkSync(path.join(location, file));
                    }
                }
                resolve();
            });
        }
        else if (Environment.isDevice()) {
            const platformName = Environment.getPlatformName();
            const File = Plugin.getSource("file");
            if (File !== false) {
                let dir = null;
                if (platformName === "ios") {
                    dir = File.documentsDirectory;
                }
                else if (platformName === "android") {
                    dir = File.dataDirectory;
                }
                if (dir !== null) {
                    cWindow.resolveLocalFileSystemURL(dir, parent => {
                        parent.getDirectory(ATTACHMENTS_DIR, { create: false, exclusive: false }, function (dirEntry) {
                            dirEntry.removeRecursively(resolve, reject);
                        }, function (err) {
                            // If directory doesn't exist then there is nothing to delete, so resolve
                            if (err.code === 1) {
                                resolve();
                            }
                            else {
                                console.error(`Couldn't get '${ATTACHMENTS_DIR}' to delete:`, err);
                                reject(err);
                            }
                        });
                    }, function (e) {
                        reject(e);
                    });
                }
                else {
                    reject("Unsupported platform, expected Android or iOS.");
                }
            }
            else {
                reject("No file plugin available.");
            }
        }
        else {
            // Nothing to do (probably browser)
            resolve();
        }
    });
}
exports.deleteAttachments = deleteAttachments;
/**
 *
 * @param options
 *
 * contain one of:
 *
 * mediaType: (MEDIA_TYPES)
 * or
 * mimeTypes: [array of mime types]
 *
 * If neither is supplied, then all file types are assumed
 *
 * @returns {Promise}
 */
function pickFile(options) {
    return new es6_promise_1.Promise((resolve, reject) => {
        let mimes = [];
        let extensions = ["*"];
        let filterName = "All Files";
        if (options.mediaType !== undefined) {
            extensions = Object.keys(MIME_TYPE_MAP)
                .filter(extension => MIME_TYPE_MAP[extension].mediaType === options.mediaType);
            mimes = extensions
                .map((extension) => {
                return MIME_TYPE_MAP[extension].mimeType;
            });
            filterName = options.mediaType;
        }
        else if (options.mimeTypes !== undefined) {
            mimes = options.mimeTypes;
            extensions = Object.keys(MIME_TYPE_MAP)
                .filter(extension => mimes.indexOf(MIME_TYPE_MAP[extension].mimeType) >= 0);
        }
        if (Environment.isElectron()) {
            const dialog = eWindow.require("electron").remote.dialog;
            dialog.showOpenDialog({
                properties: ["openFile", "multiSelections"],
                filters: [{
                        name: filterName,
                        extensions: extensions
                    }]
            }, filePaths => {
                const path = eWindow.require("path");
                const fs = eWindow.require("fs");
                const userDataPath = eWindow.require("electron").remote.app.getPath("userData");
                const pathSeparator = path.sep;
                const location = userDataPath + pathSeparator + ATTACHMENTS_DIR + pathSeparator;
                if (!fs.existsSync(location)) {
                    fs.mkdirSync(location);
                }
                const proms = [];
                filePaths.forEach(filePath => {
                    proms.push(new es6_promise_1.Promise((_resolve, _reject) => {
                        const dest = path.join(location, Date.now() + "_" + path.basename(filePath));
                        const _onError = (err) => {
                            console.error(`A problem occurred when trying to copy the file '${filePath}' to '${dest}'.`, err);
                            _reject(err);
                        };
                        const rs = fs.createReadStream(filePath);
                        rs.on("error", _onError);
                        const ws = fs.createWriteStream(dest);
                        ws.on("error", _onError);
                        ws.on("close", () => {
                            _resolve(dest);
                        });
                        rs.pipe(ws);
                    }));
                });
                es6_promise_1.Promise.all(proms).then(resolve).catch(reject);
            });
        }
        else if (Environment.isDevice()) {
            const platformName = Environment.getPlatformName();
            const File = Plugin.getSource("file");
            if (File !== false) {
                let dir = null;
                if (platformName === "ios") {
                    dir = File.documentsDirectory;
                }
                else if (platformName === "android") {
                    dir = File.dataDirectory;
                }
                if (dir !== null) {
                    cWindow.resolveLocalFileSystemURL(dir, parent => {
                        parent.getDirectory(ATTACHMENTS_DIR, { create: true, exclusive: false }, dirEntry => {
                            const FileImporter = Plugin.getSource("fileimporter");
                            if (FileImporter !== null) {
                                FileImporter.importFile((path) => {
                                    resolve([path]);
                                }, reject, undefined, mimes, ATTACHMENTS_DIR);
                            }
                            else {
                                reject("File importer plugin not available.");
                            }
                        }, reject);
                    }, reject);
                }
                else {
                    reject("Unsupported platform, expected Android or iOS.");
                }
            }
            else {
                reject("No file plugin available.");
            }
        }
        else {
            const $fileInput = document.createElement("input");
            $fileInput.setAttribute("type", "file");
            $fileInput.setAttribute("multiple", "multiple");
            $fileInput.addEventListener("change", () => {
                const files = [];
                for (let i = 0; i < $fileInput.files.length; i++) {
                    files.push(URL.createObjectURL($fileInput.files[i]));
                }
                resolve(files);
            });
            $fileInput.click();
        }
    });
}
exports.pickFile = pickFile;
/**
 * Method to get the size of the file on disk taking into account that it could be encrypted
 * and we need to get the size of the file when it is NOT encrypted.
 */
function getFileSize(file) {
    return new es6_promise_1.Promise((resolve, reject) => {
        if (file && file.name.indexOf(".encrypted") !== -1) {
            const fileEncryption = Plugin.getSource("fileEncryption");
            if (fileEncryption) {
                fileEncryption.getFileSize(size => {
                    try {
                        resolve(parseInt(size));
                    }
                    catch (e) {
                        console.error("Couldn't convert file size to an integer.");
                        reject(e);
                    }
                }, reject, file.path);
            }
            else {
                resolve(file.size);
            }
        }
        else {
            resolve(file.size);
        }
    });
}
exports.getFileSize = getFileSize;


/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Wrapper class around setTimeout functionality which allows for pausing and resuming a timeout
 */

Object.defineProperty(exports, "__esModule", { value: true });
class Timer {
    /**
     * @param callback { Function } - The function to be executed when the timer has completed
     * @param duration { Number } - The number of milliseconds the timer should execute for
     */
    constructor(id, callback, duration) {
        this._id = null;
        this._timeout = -1;
        this._startTime = -1;
        this._totalTimeRun = -1;
        this._complete = false;
        this._duration = -1;
        this._callback = null;
        this._paused = false;
        this._id = id;
        this._duration = duration;
        this._callback = callback;
        this._startTime = new Date().getTime();
        this._timeout = setTimeout(this._callback, this._duration);
    }
    /**
     * @private
     * Private method used to calculate the time difference between when the timer started and the current time
     * @param time { Number } - The time to compare against now
     */
    _timeDiff(time) {
        return new Date().getTime() - time;
    }
    /**
     * Cancel the timer
     */
    cancel() {
        clearTimeout(this._timeout);
        this._paused = false;
    }
    /**
     * Pause the timer which can then be resumed
     */
    pause() {
        clearTimeout(this._timeout);
        this._totalTimeRun = this._timeDiff(this._startTime);
        this._complete = this._totalTimeRun >= this._duration;
        if (!this._complete)
            this._paused = true;
    }
    /**
     * Resume a paused timer
     */
    resume() {
        this._paused = false;
        this._timeout = (this._complete) ? -1 : setTimeout(this._callback, this._duration - this._totalTimeRun);
    }
    /**
     * Restart the timer
     */
    restart() {
        this._paused = false;
        this._startTime = new Date().getTime();
        this._timeout = setTimeout(this._callback, this._duration);
    }
    get paused() {
        return this._paused;
    }
    get id() {
        return this._id;
    }
}
exports.default = Timer;


/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
///<reference path="interfaces.ts"/>
/**
 * Created by Graham.Mackenzie on 28/06/2017.
 */

Object.defineProperty(exports, "__esModule", { value: true });
class VCardSimple {
    constructor() {
        this.nsResolve = function (prefix) {
            if (prefix == "vc") {
                return "vcard-temp";
            }
            return null;
        };
        this.json = {};
    }
    static fromXml(xml) {
        const newVCard = new VCardSimple();
        try {
            newVCard.initFromXML(xml);
        }
        catch (e) {
            console.error("Bad vCard: " + e);
            return undefined;
        }
        return newVCard;
    }
    static fromJSON(card) {
        const newVCard = new VCardSimple();
        newVCard.initFromJSON(card);
        return newVCard;
    }
    _extractEmail(email) {
        const newEmail = {};
        if (typeof email.USERID === "string") {
            newEmail.address = email.USERID;
        }
        if (email.HOME) {
            newEmail.home = true;
        }
        if (email.WORK) {
            newEmail.work = true;
        }
        if (email.INTERNET) {
            newEmail.internet = true;
        }
        if (email.PREF) {
            newEmail.pref = true;
        }
        if (email.X400) {
            newEmail.x400 = true;
        }
        return newEmail;
    }
    _extractTelephone(tel) {
        const newTel = {};
        if (typeof tel.NUMBER === "string") {
            newTel.number = tel.NUMBER;
        }
        if (tel.HOME) {
            newTel.home = true;
        }
        if (tel.WORK) {
            newTel.work = true;
        }
        if (tel.VOICE) {
            newTel.voice = true;
        }
        if (tel.FAX) {
            newTel.fax = true;
        }
        if (tel.PAGER) {
            newTel.pager = true;
        }
        if (tel.MSG) {
            newTel.msg = true;
        }
        if (tel.CELL) {
            newTel.cell = true;
        }
        if (tel.VIDEO) {
            newTel.video = true;
        }
        if (tel.BBS) {
            newTel.bbs = true;
        }
        if (tel.MODEM) {
            newTel.modem = true;
        }
        if (tel.ISDN) {
            newTel.isdn = true;
        }
        if (tel.PCS) {
            newTel.pcs = true;
        }
        if (tel.PREF) {
            newTel.pref = true;
        }
        return newTel;
    }
    _extractAddress(adr) {
        const newAdr = {};
        if (typeof adr.POBOX === "string") {
            newAdr.poBox = adr.POBOX;
        }
        if (typeof adr.EXTADD === "string") {
            newAdr.extraAddress = adr.EXTADD;
        }
        if (typeof adr.STREET === "string") {
            newAdr.street = adr.STREET;
        }
        if (typeof adr.LOCALITY === "string") {
            newAdr.locality = adr.LOCALITY;
        }
        if (typeof adr.REGION === "string") {
            newAdr.locality = adr.REGION;
        }
        if (typeof adr.PCODE === "string") {
            newAdr.locality = adr.PCODE;
        }
        if (typeof adr.CTRY === "string") {
            newAdr.locality = adr.CTRY;
        }
        if (adr.WORK) {
            newAdr.work = true;
        }
        if (adr.HOME) {
            newAdr.home = true;
        }
        if (adr.POSTAL) {
            newAdr.postal = true;
        }
        if (adr.PARCEL) {
            newAdr.parcel = true;
        }
        if (adr.DOM) {
            newAdr.dom = true;
        }
        if (adr.INTL) {
            newAdr.intl = true;
        }
        if (adr.PREF) {
            newAdr.pref = true;
        }
        return newAdr;
    }
    initFromXML(xml) {
        const obj = {};
        if (typeof xml.VERSION === "string") {
            obj["version"] = xml.VERSION;
        }
        if (typeof xml.FN === "string") {
            obj["fullName"] = xml.FN;
        }
        if (typeof xml.N === "object" && !Array.isArray(xml.N)) {
            obj["name"] = {};
            if (typeof xml.N.FAMILY === "string") {
                obj["name"]["family"] = xml.N.FAMILY;
            }
            if (typeof xml.N.GIVEN === "string") {
                obj["name"]["given"] = xml.N.GIVEN;
            }
            if (typeof xml.N.MIDDLE === "string") {
                obj["name"]["middle"] = xml.N.MIDDLE;
            }
            if (typeof xml.N.PREFIX === "string") {
                obj["name"]["prefix"] = xml.N.PREFIX;
            }
            if (typeof xml.N.SUFFIX === "string") {
                obj["name"]["suffix"] = xml.N.SUFFIX;
            }
        }
        if (typeof xml.NICKNAME === "string") {
            obj["nickName"] = xml.NICKNAME;
        }
        if (typeof xml.PHOTO === "object" && !Array.isArray(xml.PHOTO)) {
            obj["photo"] = {};
            if (typeof xml.PHOTO.TYPE === "string") {
                obj["photo"]["type"] = xml.PHOTO.TYPE;
            }
            if (typeof xml.PHOTO.BINVAL === "string") {
                obj["photo"]["binval"] = xml.PHOTO.BINVAL;
            }
        }
        if (typeof xml.BDAY === "string") {
            obj["birthday"] = xml.BDAY;
        }
        if (typeof xml.ADR === "object") {
            obj.address = [];
            if (Array.isArray(xml.ADR)) {
                xml.ADR.forEach((adr) => {
                    obj.address.push(this._extractAddress(adr));
                });
            }
            else {
                obj.address.push(this._extractAddress(xml.ADR));
            }
        }
        if (typeof xml.TEL === "object") {
            obj.telephone = [];
            if (Array.isArray(xml.TEL)) {
                xml.TEL.forEach((tel) => {
                    obj.telephone.push(this._extractTelephone(tel));
                });
            }
            else {
                obj.telephone.push(this._extractTelephone(xml.TEL));
            }
        }
        if (typeof xml.EMAIL === "object") {
            obj.email = [];
            if (Array.isArray(xml.EMAIL)) {
                xml.EMAIL.forEach((email) => {
                    obj.email.push(this._extractEmail(email));
                });
            }
            else {
                obj.email.push(this._extractEmail(xml.EMAIL));
            }
        }
        if (typeof xml.JABBERID === "string") {
            obj["jabberId"] = xml.JABBERID;
        }
        if (typeof xml.MAILER === "string") {
            obj["mailer"] = xml.MAILER;
        }
        if (typeof xml.TZ === "string") {
            obj["timeZone"] = xml.TZ;
        }
        if (typeof xml.GEO === "object" && !Array.isArray(xml.GEO)) {
            obj["geolocation"] = {};
            if (typeof xml.GEO.LAT === "string") {
                obj["geolocation"]["lat"] = xml.GEO.LAT;
            }
            if (typeof xml.GEO.LON === "string") {
                obj["geolocation"]["lng"] = xml.N.GIVEN;
            }
        }
        if (typeof xml.TITLE === "string") {
            obj["title"] = xml.TITLE;
        }
        if (typeof xml.ROLE === "string") {
            obj["role"] = xml.ROLE;
        }
        if (typeof xml.LOGO === "object" && !Array.isArray(xml.LOGO)) {
            obj["logo"] = {};
            if (typeof xml.LOGO.TYPE === "string") {
                obj["logo"]["type"] = xml.PHOTO.TYPE;
            }
            if (typeof xml.PHOTO.BINVAL === "string") {
                obj["logo"]["binval"] = xml.PHOTO.BINVAL;
            }
            if (typeof xml.PHOTO.EXTVAL === "string") {
                obj["logo"]["extval"] = xml.PHOTO.EXTVAL;
            }
        }
        if (typeof xml.AGENT === "object" && !Array.isArray(xml.AGENT)) {
            obj["agent"] = {};
            if (typeof xml.AGENT.EXTVAL === "string") {
                obj["agent"]["extval"] = xml.AGENT.EXTVAL;
            }
        }
        if (typeof xml.ORG === "object" && !Array.isArray(xml.ORG)) {
            obj["organisation"] = {};
            if (typeof xml.ORG.ORGNAME === "string") {
                obj["organisation"]["name"] = xml.ORG.ORGNAME;
            }
            if (typeof xml.ORG.ORGUNIT === "string") {
                obj["organisation"]["unit"] = xml.ORG.ORGUNIT;
            }
        }
        if (typeof xml.CATEGORIES === "object") {
            obj.categories = [];
            if (Array.isArray(xml.CATEGORIES)) {
                xml.CATEGORIES.forEach((cat) => {
                    obj.categories.push({
                        "keyword": cat.KEYWORD
                    });
                });
            }
            else {
                obj.telephone.push({
                    "keyword": xml.CATEGORIES.KEYWORD
                });
            }
        }
        if (typeof xml.NOTE === "string") {
            obj["note"] = xml.NOTE;
        }
        if (typeof xml.PRODID === "string") {
            obj["prodid"] = xml.PRODID;
        }
        if (typeof xml.REV === "string") {
            obj["rev"] = xml.REV;
        }
        if (typeof xml["SORT-STRING"] === "string") {
            obj["sortString"] = xml["SORT-STRING"];
        }
        if (typeof xml.SOUND === "object" && !Array.isArray(xml.SOUND)) {
            obj["sound"] = {};
            if (typeof xml.SOUND.PHONETIC === "string") {
                obj["sound"]["phonetic"] = xml.SOUND.PHONETIC;
            }
            if (typeof xml.SOUND.BINVAL === "string") {
                obj["sound"]["binval"] = xml.SOUND.BINVAL;
            }
            if (typeof xml.SOUND.EXTVAL === "string") {
                obj["sound"]["extval"] = xml.SOUND.EXTVAL;
            }
        }
        if (typeof xml.UID === "string") {
            obj["uid"] = xml.UID;
        }
        if (typeof xml.URL === "string") {
            obj["url"] = xml.URL;
        }
        if (typeof xml.DESC === "string") {
            obj["description"] = xml.DESC;
        }
        if (typeof xml.CLASS === "object" && !Array.isArray(xml.CLASS)) {
            if (xml.CLASS.PUBLIC) {
                obj["classification"] = "public";
            }
            if (xml.CLASS.PRIVATE) {
                obj["classification"] = "private";
            }
            if (xml.CLASS.CONFIDENTIAL) {
                obj["classification"] = "confidential";
            }
        }
        if (typeof xml.KEY === "object" && !Array.isArray(xml.KEY)) {
            obj["key"] = {};
            if (typeof xml.KEY.CRED === "string") {
                obj["key"]["credential"] = xml.KEY.CRED;
            }
            if (typeof xml.KEY.TYPE === "string") {
                obj["key"]["type"] = xml.KEY.TYPE;
            }
        }
        this.json = obj;
    }
    initFromJSON(card) {
        this.json = card;
    }
    toJSON() {
        return this.json;
    }
    toXML(includeParent) {
        const doc = (new DOMParser()).parseFromString('<vCard xmlns="vcard-temp"/>', 'text/xml');
        const rootElement = doc.firstElementChild;
        this.json.fullName && this.addNode(rootElement, "FN", this.json.fullName);
        if (this.json.name) {
            const nameElement = this.addNode(rootElement, "N");
            this.json.name.family && this.addNode(nameElement, "FAMILY", this.json.name.family);
            this.json.name.given && this.addNode(nameElement, "GIVEN", this.json.name.given);
            this.json.name.middle && this.addNode(nameElement, "MIDDLE", this.json.name.middle);
            this.json.name.prefix && this.addNode(nameElement, "PREFIX", this.json.name.prefix);
            this.json.name.suffix && this.addNode(nameElement, "SUFFIX", this.json.name.suffix);
        }
        this.json.nickName && this.addNode(rootElement, "NICKNAME", this.json.nickName);
        if (this.json.photo) {
            const photoElement = this.addNode(rootElement, "PHOTO");
            this.json.photo.type && this.addNode(photoElement, "TYPE", this.json.photo.type);
            this.json.photo.binval && this.addNode(photoElement, "BINVAL", this.json.photo.binval);
        }
        this.json.birthday && this.addNode(rootElement, "BDAY", this.json.birthday);
        if (this.json.address) {
            this.json.address.forEach((address) => {
                const adrElement = this.addNode(rootElement, "ADR");
                if (address.home)
                    this.addNode(adrElement, "HOME");
                if (address.work)
                    this.addNode(adrElement, "WORK");
                if (address.postal)
                    this.addNode(adrElement, "POSTAL");
                if (address.parcel)
                    this.addNode(adrElement, "PARCEL");
                if (address.dom)
                    this.addNode(adrElement, "DOM");
                if (address.intl)
                    this.addNode(adrElement, "INTL");
                if (address.pref)
                    this.addNode(adrElement, "PREF");
                address.poBox && this.addNode(adrElement, "POBOX", address.poBox);
                address.extraAddress && this.addNode(adrElement, "EXTADD", address.extraAddress);
                address.street && this.addNode(adrElement, "STREET", address.street);
                address.locality && this.addNode(adrElement, "LOCALITY", address.locality);
                address.region && this.addNode(adrElement, "REGION", address.region);
                address.postcode && this.addNode(adrElement, "PCODE", address.postcode);
                address.country && this.addNode(adrElement, "CTRY", address.country);
            });
        }
        if (this.json.telephone) {
            this.json.telephone.forEach((telephone) => {
                const telElement = this.addNode(rootElement, "TEL");
                if (telephone.home)
                    this.addNode(telElement, "HOME");
                if (telephone.work)
                    this.addNode(telElement, "WORK");
                if (telephone.voice)
                    this.addNode(telElement, "VOICE");
                if (telephone.fax)
                    this.addNode(telElement, "FAX");
                if (telephone.pager)
                    this.addNode(telElement, "PAGER");
                if (telephone.msg)
                    this.addNode(telElement, "MSG");
                if (telephone.cell)
                    this.addNode(telElement, "CELL");
                if (telephone.video)
                    this.addNode(telElement, "VIDEO");
                if (telephone.bbs)
                    this.addNode(telElement, "BBS");
                if (telephone.modem)
                    this.addNode(telElement, "MODEM");
                if (telephone.isdn)
                    this.addNode(telElement, "ISDN");
                if (telephone.pcs)
                    this.addNode(telElement, "PCS");
                if (telephone.pref)
                    this.addNode(telElement, "PREF");
                telephone.number && this.addNode(telElement, "NUMBER", telephone.number);
            });
        }
        if (this.json.email) {
            this.json.email.forEach((email) => {
                const emailElement = this.addNode(rootElement, "EMAIL");
                if (email.home)
                    this.addNode(emailElement, "HOME");
                if (email.work)
                    this.addNode(emailElement, "WORK");
                if (email.internet)
                    this.addNode(emailElement, "INTERNET");
                if (email.pref)
                    this.addNode(emailElement, "PREF");
                if (email.x400)
                    this.addNode(emailElement, "X400");
                email.address && this.addNode(emailElement, "USERID", email.address);
            });
        }
        this.json.jabberId && this.addNode(rootElement, "JABBERID", this.json.jabberId);
        this.json.mailer && this.addNode(rootElement, "MAILER", this.json.mailer);
        this.json.timeZone && this.addNode(rootElement, "TZ", this.json.timeZone);
        if (this.json.geolocation) {
            const geoElement = this.addNode(rootElement, "GEO");
            this.json.geolocation.lat && this.addNode(geoElement, "LAT", this.json.geolocation.lat);
            this.json.geolocation.lng && this.addNode(geoElement, "LON", this.json.geolocation.lng);
        }
        this.json.title && this.addNode(rootElement, "TITLE", this.json.title);
        this.json.role && this.addNode(rootElement, "ROLE", this.json.role);
        if (this.json.logo) {
            const logoElement = this.addNode(rootElement, "LOGO");
            this.json.logo.type && this.addNode(logoElement, "TYPE", this.json.logo.type);
            this.json.logo.binval && this.addNode(logoElement, "BINVAL", this.json.logo.binval);
            this.json.logo.extval && this.addNode(logoElement, "EXTVAL", this.json.logo.extval);
        }
        // TODO: AGENT
        if (this.json.organisation) {
            const orgElement = this.addNode(rootElement, "ORG");
            this.json.organisation.name && this.addNode(orgElement, "ORGNAME", this.json.organisation.name);
            this.json.organisation.unit && this.addNode(orgElement, "ORGUNIT", this.json.organisation.unit);
        }
        if (this.json.categories) {
            this.json.categories.forEach((category) => {
                const catElement = this.addNode(rootElement, "CATEGORIES");
                category.keyword && this.addNode(catElement, "KEYWORD", category.keyword);
            });
        }
        this.json.note && this.addNode(rootElement, "NOTE", this.json.note);
        this.json.productId && this.addNode(rootElement, "PRODID", this.json.productId);
        this.json.lastRevised && this.addNode(rootElement, "REV", this.json.lastRevised);
        this.json.sortString && this.addNode(rootElement, "SORT-STRING", this.json.sortString);
        if (this.json.sound) {
            const soundElement = this.addNode(rootElement, "SOUND");
            this.json.sound.phonetic && this.addNode(soundElement, "PHONETIC", this.json.sound.phonetic);
            this.json.sound.extval && this.addNode(soundElement, "EXTVAL", this.json.sound.extval);
            this.json.sound.binval && this.addNode(soundElement, "BINVAL", this.json.sound.binval);
        }
        this.json.uid && this.addNode(rootElement, "UID", this.json.uid);
        this.json.url && this.addNode(rootElement, "URL", this.json.url);
        this.json.description && this.addNode(rootElement, "DESC", this.json.description);
        if (this.json.classification) {
            const classElement = this.addNode(rootElement, "CLASS");
            this.json.classification === "public" && this.addNode(classElement, "PUBLIC");
            this.json.classification === "private" && this.addNode(classElement, "PRIVATE");
            this.json.classification === "confidential" && this.addNode(classElement, "CONFIDENTIAL");
        }
        if (this.json.key) {
            const keyElement = this.addNode(rootElement, "KEY");
            this.json.key.credential && this.addNode(keyElement, "CRED", this.json.key.credential);
            this.json.key.type && this.addNode(keyElement, "TYPE", this.json.key.type);
        }
        let xml = "";
        if (includeParent) {
            xml = (new XMLSerializer()).serializeToString(doc);
        }
        else {
            const rootNode = doc.children[0];
            for (let i = 0; i < rootNode.childElementCount; i++) {
                console.log(rootNode.childNodes.item(i));
                const yml = (new XMLSerializer()).serializeToString(rootNode.childNodes.item(i));
                xml += yml;
            }
        }
        return xml;
    }
    addNode(parent, nodeName, textContent) {
        const newElement = parent.ownerDocument.createElement(nodeName);
        parent.appendChild(newElement);
        if (textContent !== undefined) {
            newElement.textContent = textContent;
        }
        return newElement;
    }
}
exports.VCardSimple = VCardSimple;


/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const ct_xmpp_client_1 = __webpack_require__(16);
const LayerRegistration_1 = __webpack_require__(23);
const Logger_1 = __webpack_require__(10);
const Models = __webpack_require__(2);
const Events = __webpack_require__(5);
const Utils = __webpack_require__(3);
class BaseLayer {
    // === Constructor === //
    constructor(name, config) {
        this.waitingAlertId = undefined;
        this.suppressMode = false;
        this._messageHandlers = new Map();
        this._messageProcessorQueue = Promise.resolve();
        this._suppressModeQueue = [];
        this._deferredStanzas = [];
        if (!config)
            throw new Error("You must supply a config object");
        this.name = name;
        this.config = config;
        this._eventListeners = {};
        this.logger = new Logger_1.Logger(this.config.logging || []);
        this._setUpHandlers();
        LayerRegistration_1.LayerRegistration.addInstance(this.name, this);
    }
    // === Static instance registration === //
    static getInstance(name) {
        return LayerRegistration_1.LayerRegistration.getInstance(name);
    }
    static onReady(name, callback) {
        LayerRegistration_1.LayerRegistration.onReady(name, callback);
    }
    bootstrap(comms, store) {
        this._buildCommonComponents();
        this.showWaitingMessage("Initialising app");
        return Promise.resolve()
            .then(() => this._setStore(store))
            .then(() => this._setLogger())
            .then(() => this._setComms(comms))
            .then(() => this._setupPushNotifications())
            .then(() => this._setupCommonEventListeners())
            .then(() => LayerRegistration_1.LayerRegistration.fireReady(this.name))
            .then(() => this.dismissWaitingMessage())
            .catch((err) => {
            LayerRegistration_1.LayerRegistration.fireReady(this.name);
            setTimeout(() => {
                this.error("Error during bootstrap", err);
            }, 100);
        });
    }
    // === Event/action handlers === //
    on(name, callback, oneTimeOnly = false, allowSuppress = false) {
        if (this._eventListeners[name] === undefined) {
            this._eventListeners[name] = [];
        }
        const eventDetail = {
            oneTimeOnly: oneTimeOnly,
            allowSuppress: allowSuppress,
            callback: (evt) => {
                callback(evt.detail);
            }
        };
        this._eventListeners[name].push(eventDetail);
    }
    emit(name, data) {
        if (!this._eventListeners[name]) {
            this._eventListeners[name] = [];
        }
        this.logger.log(Logger_1.LoggerTypes.Events, `%c📞 RAISING EVENT:%c ${name} (${this._eventListeners[name].length} listeners)`, "color: #066; font-weight: bold;", "color: #999; font-weight: normal;", { data: data });
        const indexesToRemove = [];
        for (let i = 0; i < this._eventListeners[name].length; i++) {
            const eventListener = this._eventListeners[name][i];
            if (!this.suppressMode || !eventListener.allowSuppress) {
                eventListener.callback({ detail: data });
            }
            if (eventListener.oneTimeOnly === true) {
                indexesToRemove.push(i);
            }
        }
        if (indexesToRemove.length) {
            this._eventListeners[name] = this._eventListeners[name].filter((x, idx) => !indexesToRemove.includes(idx));
        }
    }
    login(user, password) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.comms.login(user, password);
        });
    }
    attemptReconnect() {
        this.comms.attemptReconnect();
    }
    logout() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.comms.logout();
        });
    }
    getSyncedTimestamp() {
        return this.comms.getSyncedTimestamp();
    }
    getConnectionStatus() {
        return this.comms.getConnectionStatus();
    }
    clearAllData(keepCache = false) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.store.clearAllData();
            yield this.comms.clearAllData(keepCache);
        });
    }
    /**
     * Returns the current XMPP user JID
     */
    getCurrentUserJid() {
        return this.comms.username;
    }
    /**
     * Returns the current XMPP user resource
     */
    getCurrentUserResource() {
        return this.comms.getCurrentUserResource();
    }
    /**
     * Returns the current XMPP display name
     */
    getCurrentXmppDisplayName() {
        return this.config.xmpp.user.displayName || this.config.xmpp.user.id;
    }
    error(title, error) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.cancelSuppressMode("*");
            this.dismissWaitingMessage();
            const errorMessage = (typeof (error) === "string")
                ? error
                : error.message;
            this.emit(Events.BaseEvents._Request_RaiseAlert, Models.DefaultAlerts.AlertErrorWithOkayButton(title, errorMessage, 1, {}));
            this.logger.error(error);
        });
    }
    getLabel(labelName, data) {
        if (!this.config.labels || !this.config.labels[labelName])
            return null;
        return Utils.tokenReplace(this.config.labels[labelName], data);
    }
    getUniqueCommsId() {
        return this.comms.getUniqueId();
    }
    sendMessage(messageType, to, data, attachments = []) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const message = yield this._prepareMessage(messageType, data);
                if (message === null)
                    return null;
                const serverEcho = yield this.comms.sendMessage(to, message, attachments);
                const messageContent = serverEcho.data[messageType.toString()] && JSON.parse(serverEcho.data[messageType.toString()]);
                return Object.assign({}, serverEcho, {
                    data: {
                        [messageType.toString()]: messageContent
                    }
                });
            }
            catch (ex) {
                this.error("Error sending message", ex);
            }
        });
    }
    sendRoomMessage(messageType, data) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const message = yield this._prepareMessage(messageType, data);
                if (message === null)
                    return null;
                const serverEcho = yield this.comms.sendRoomMessage(message);
                const messageContent = serverEcho.data[messageType.toString()] && JSON.parse(serverEcho.data[messageType.toString()]);
                return Object.assign({}, serverEcho, {
                    data: {
                        [messageType.toString()]: messageContent
                    }
                });
            }
            catch (ex) {
                this.error("Error sending room message", ex);
            }
        });
    }
    sendMulticastMessage(messageType, data, to = [], attachments = []) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const message = yield this._prepareMessage(messageType, data);
                if (message === null)
                    return null;
                const serverEcho = yield this.comms.sendMulticastMessage(to, message, this.config.isBroadcaster, attachments);
                const messageContent = serverEcho.data[messageType.toString()] && JSON.parse(serverEcho.data[messageType.toString()]);
                return Object.assign({}, serverEcho, {
                    data: {
                        [messageType.toString()]: messageContent
                    }
                });
            }
            catch (ex) {
                // A small hack to exclude stream management errors from interrupting the UI
                // These are errors but they won't stop any functionality from working
                // Awaiting a fix from Leon in the xmpp-client
                if (typeof ex === "object") {
                    this.logger.error(ex);
                    this.workOutIfAttachmentTooLarge(ex);
                }
                else {
                    this.error("Error sending multicast message", ex);
                }
            }
        });
    }
    workOutIfAttachmentTooLarge(ex) {
        const error = "There was an error sending the message, please try again.";
        if (ex.nodeName && ex.nodeName === "iq") {
            if (ex.childNodes && ex.childNodes[1] && ex.childNodes[1].nodeName === "error") {
                const error = ex.childNodes[1];
                if (error.childNodes && error.childNodes[1] && error.childNodes[1].nodeName === "text") {
                    const text = error.childNodes[1];
                    const fileSizeStr = text.textContent.match(/\d+/)[0];
                    const fileSize = fileSizeStr ? parseInt(fileSizeStr) : 0;
                    if (fileSize) {
                        const maxMb = Math.round(fileSize / 1024 / 1024);
                        const errorMsg = `The attachment is too large. Please select a file lower than ${maxMb}MB in size.`;
                        this.error("Attachment Too Large", errorMsg);
                        throw new Error(errorMsg);
                    }
                    else {
                        const errorMsg = "The attachment is too large. Please choose a smaller attachment.";
                        this.error("Attachment Too Large", errorMsg);
                        throw new Error(errorMsg);
                    }
                }
            }
        }
        this.error("Error sending multicast message", error);
        throw new Error(error);
    }
    sendMessageToBot(messageType, data, passThroughException = false) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield this._sendBotCommand(messageType, data, null);
            }
            catch (ex) {
                if (passThroughException)
                    throw ex;
                else
                    this.error("Error sending bot message", ex);
            }
        });
    }
    sendBotCommand(command, data, passThroughException = false) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                return yield this.comms.sendBotCommand(command.toString(), data);
            }
            catch (ex) {
                if (passThroughException)
                    throw ex;
                else
                    this.error("Error sending bot command", ex);
            }
        });
    }
    downloadFile(url) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                return yield this.comms.downloadFile(url);
            }
            catch (ex) {
                this.error("Error downloading file", ex);
            }
        });
    }
    setSupportLoggingTypes(types = ["_all_"]) {
        return __awaiter(this, void 0, void 0, function* () {
            this.logger.setTypes(types);
            return yield this.store.saveLoggerTypes(types);
        });
    }
    resetSupportLogging() {
        return __awaiter(this, void 0, void 0, function* () {
            this.logger.setTypes([]);
            return yield this.store.deleteLoggerTypes();
        });
    }
    showWaitingMessage(message) {
        this.dismissWaitingMessage();
        if (!this.waitingAlertId) {
            const alert = Models.DefaultAlerts.AlertWaiting(message);
            this.waitingAlertId = alert.id;
            this.alertModalManager.raiseAlert(alert);
        }
    }
    dismissWaitingMessage() {
        if (this.waitingAlertId) {
            this.alertModalManager.dismissAlertById(this.waitingAlertId);
            this.waitingAlertId = null;
        }
    }
    enableSuppressMode(id, singleInstance = false) {
        if (id === "*")
            throw new Error("Suppress mode cannot be enabled with the id '*'");
        if (singleInstance && this._suppressModeQueue.includes(id)) {
            this.logger.log(Logger_1.LoggerTypes.Other, `%c🔇 SUPPRESSION MODE ALREADY EXISTS IN QUEUE %c${id}`, "color: #696; font-weight: bold;", "color: #999; font-weight: normal;");
        }
        else {
            this.logger.log(Logger_1.LoggerTypes.Other, `%c🔇 ADDING TO SUPPRESSION MODE QUEUE %c${id}`, "color: #696; font-weight: bold;", "color: #999; font-weight: normal;");
            this._suppressModeQueue.push(id);
        }
        this.logger.log(Logger_1.LoggerTypes.Other, "%c🔇 SUPPRESSION MODE QUEUE", "color: #696; font-weight: bold;", this._suppressModeQueue);
        if (!this.suppressMode) {
            this.logger.log(Logger_1.LoggerTypes.Other, "%c🔇 ENTERING SUPPRESSION MODE", "color: #696; font-weight: bold;");
            this.suppressMode = true;
        }
    }
    cancelSuppressMode(id) {
        return __awaiter(this, void 0, void 0, function* () {
            this._messageProcessorQueue = this._messageProcessorQueue.then(() => {
                return new Promise(resolve => {
                    if (id === "*") {
                        this.logger.log(Logger_1.LoggerTypes.Other, "%c🔇 CLEARING SUPPRESSION MODE QUEUE", "color: #696; font-weight: bold;");
                        this._suppressModeQueue = [];
                        this.suppressMode = false;
                    }
                    else {
                        const idx = this._suppressModeQueue.indexOf(id);
                        if (idx !== -1) {
                            this.logger.log(Logger_1.LoggerTypes.Other, `%c🔇 REMOVING FROM SUPPRESSION MODE QUEUE %c${id}`, "color: #696; font-weight: bold;", "color: #999; font-weight: normal;");
                            this._suppressModeQueue.splice(idx, 1);
                            this.logger.log(Logger_1.LoggerTypes.Other, "%c🔇 SUPPRESSION MODE QUEUE", "color: #696; font-weight: bold;", this._suppressModeQueue);
                        }
                    }
                    if (this.suppressMode === true && this._suppressModeQueue.length === 0) {
                        this.logger.log(Logger_1.LoggerTypes.Other, "%c🔊 EXITING SUPPRESSION MODE", "color: #696; font-weight: bold;");
                        this.suppressMode = false;
                        if (this._deferredStanzas.length > 0) {
                            const deferredStanzas = [...this._deferredStanzas];
                            const deferredMessages = deferredStanzas.filter(x => x.eventType === ct_xmpp_client_1.CtXmppClient.EVENT_TYPES.NEW_MESSAGE).map(x => x.payload.data);
                            this._deferredStanzas = [];
                            this.logger.log(Logger_1.LoggerTypes.Other, `%c📬 HANDLING ${deferredMessages.length} DEFERRED MESSAGE(S) RECEIVED DURING SUPPRESSED MODE`, "color: #696; font-weight: bold;", deferredMessages);
                            deferredStanzas.forEach(x => {
                                switch (x.eventType) {
                                    case ct_xmpp_client_1.CtXmppClient.EVENT_TYPES.NEW_MESSAGE:
                                        this.handleNewMessage(x.payload);
                                        break;
                                    case ct_xmpp_client_1.CtXmppClient.EVENT_TYPES.MESSAGE_UPDATED:
                                        this.handleMessageUpdate(x.payload);
                                        break;
                                    case ct_xmpp_client_1.CtXmppClient.EVENT_TYPES.RECEIPT_RECEIVED:
                                        this.handleChatMarkerUpdate(x.payload);
                                        break;
                                }
                            });
                        }
                        else {
                            this.logger.log(Logger_1.LoggerTypes.Other, `%c📭 NO MESSAGES RECEIVED DURING SUPPRESSED MODE`, "color: #696; font-weight: bold;");
                        }
                        this.logger.log(Logger_1.LoggerTypes.Other, "%c🎨 REDRAWING UIS", "color: #696; font-weight: bold;");
                        this.emit(Events.BaseEvents._Request_RedrawAllUIs);
                    }
                    resolve();
                });
            });
            return this._messageProcessorQueue;
        });
    }
    addDeferredStanza(stanza) {
        if (!this._deferredStanzas)
            this._deferredStanzas = [];
        this.logger.log(Logger_1.LoggerTypes.Other, `%c🔇 ADDING DEFERRED STANZA %c${stanza.id} > ${stanza.eventType}`, "color: #696; font-weight: bold;", "color: #999; font-weight: normal;", { payload: stanza.payload });
        this._deferredStanzas.push(stanza);
    }
    removeDeferredStanza(id, eventType) {
        if (!this._deferredStanzas || !this._deferredStanzas.length)
            return;
        if (this._deferredStanzas.some(x => x.id === id && x.eventType === eventType)) {
            this.logger.log(Logger_1.LoggerTypes.Other, `%c🔇 REMOVING DEFERRED STANZA %c${id} > ${eventType}`, "color: #696; font-weight: bold;", "color: #999; font-weight: normal;");
            this._deferredStanzas = this._deferredStanzas.filter(x => {
                return (x.id !== id || x.eventType !== eventType);
            });
        }
    }
    // === Private functions === //
    _setComms(comms) {
        return new Promise((resolve, reject) => {
            const initTimeoutDuration = this.config.xmpp.initTimeout || 10000;
            const commsInitializationTimeout = setTimeout(() => {
                reject(`Comms was not initialised within ${Math.floor(initTimeoutDuration / 1000)} seconds. Aborting.`);
            }, initTimeoutDuration);
            this.comms = comms;
            this.comms.onLogin((data) => {
                this.handleLogin(data);
            });
            this.comms.onLogout((data) => {
                this.handleLogout(data);
            });
            this.comms.onNewMessage((message) => {
                this.handleNewMessage(message);
            });
            this.comms.onMessageUpdate((message) => {
                this.handleMessageUpdate(message);
            });
            this.comms.onChatMarkerUpdate((receipt) => {
                this.handleChatMarkerUpdate(receipt);
            });
            this.comms.onStatusUpdate((status, reconnectTime, disconnectStatus) => {
                this.handleConnectionChange(status, reconnectTime, disconnectStatus);
            });
            this.comms.onPresenceUpdate((contact) => {
                this.handlePresenceUpdate(contact);
            });
            this.comms.onRoomNewParticipant((participant) => {
                this.handleRoomParticipantUpdate(participant);
            });
            this.comms.onRoomParticipantUpdate((participant) => {
                this.handleRoomParticipantUpdate(participant);
            });
            this.comms.onStartFetchingMissedMessages(() => {
                this.enableSuppressMode("baseLayer#mam", true);
            });
            this.comms.onFinishedFetchingMissedMessages(() => {
                this.cancelSuppressMode("baseLayer#mam");
            });
            this.comms.onInitialized(() => {
                resolve();
                clearTimeout(commsInitializationTimeout);
                // attempt auto-login if user id, domain and password are present in the config
                if (this.config.xmpp.user.id && this.config.xmpp.user.password && this.config.xmpp.user.domain) {
                    this.showWaitingMessage(`Logging in as ${this.config.xmpp.user.id}`);
                    this._attemptAutoLogin(this.config.xmpp.user.id, this.config.xmpp.user.password, this.config.xmpp.user.domain);
                }
            });
        });
    }
    _setStore(store) {
        return new Promise(resolve => {
            this.store = store;
            this.store.init().then(() => resolve());
        });
    }
    _setLogger() {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            const existingLoggerTypes = yield this.store.getLoggerTypes();
            if (existingLoggerTypes) {
                this.logger.setTypes(existingLoggerTypes);
            }
            resolve();
        }));
    }
    _setupPushNotifications() {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            const win = window;
            if (this.config.enablePushNotifications && win.cordova) {
                if (win.cordova.plugins.notification) {
                    if (win.cti.store.notification && win.cti.store.notification.token) {
                        yield this.store.savePushNotificationToken(win.cti.store.notification.token);
                        resolve();
                    }
                    else {
                        win.cordova.plugins.notification.registerForPush((token) => __awaiter(this, void 0, void 0, function* () {
                            yield this.store.savePushNotificationToken(token);
                            resolve();
                        }), err => {
                            this.logger.error(err);
                            resolve();
                        }, {
                            channelName: this.name
                        });
                    }
                }
                else
                    resolve();
            }
            else
                resolve();
        }));
    }
    _setupCommonEventListeners() {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            // Reload any previous theme
            const theme = yield this.store.getTheme();
            this._setThemeOnHtml(theme);
            this.on(Events.BaseEvents._Request_ThemeChange, (themeName) => __awaiter(this, void 0, void 0, function* () {
                yield this.store.saveTheme(themeName);
                this._setThemeOnHtml(themeName);
            }));
            resolve();
        }));
    }
    _setThemeOnHtml(themeName) {
        document.querySelector("html").setAttribute("theme", themeName);
        this.emit(Events.BaseEvents._Request_RedrawAllUIs);
    }
    _setUpHandlers() {
        this._messageHandlers = new Map();
        this.getHandlers().forEach(handler => {
            // add to message handlers
            if (handler.messageKey)
                this._messageHandlers.set(handler.messageKey, handler);
            // set up event handlers
            if (handler.eventType && handler.eventType.length) {
                handler.eventType.forEach(eventType => {
                    this.on(eventType, (e) => __awaiter(this, void 0, void 0, function* () {
                        try {
                            yield handler.callHandleEvent(eventType, e);
                        }
                        catch (ex) {
                            this.error("Error handling event", `Event type: ${eventType.toString()}. ${ex.message || ex}`);
                        }
                    }));
                });
            }
        });
    }
    _prepareMessage(messageType, data) {
        return __awaiter(this, void 0, void 0, function* () {
            const handler = this._messageHandlers.get(messageType);
            const payload = yield handler.callCreateMessage(data);
            if (payload === null || payload === undefined)
                return null;
            return {
                [handler.messageKey]: JSON.stringify(payload)
            };
        });
    }
    _sendBotCommand(messageType, data, previousBotResponse) {
        return __awaiter(this, void 0, void 0, function* () {
            const operationName = messageType.toString();
            const message = yield this._prepareBotMessage(messageType, data, previousBotResponse);
            if (message === null)
                return;
            const botResponse = yield this.comms.sendBotCommand(operationName, message);
            if (botResponse && botResponse.success === false) {
                const shouldRetry = yield this._shouldRetryBotMessage(messageType, data, botResponse);
                if (shouldRetry === true) {
                    yield this._sendBotCommand(messageType, data, botResponse);
                }
            }
        });
    }
    _prepareBotMessage(messageType, data, previousBotResponse) {
        return __awaiter(this, void 0, void 0, function* () {
            const handler = this._messageHandlers.get(messageType);
            const payload = yield handler.callCreateBotMessage(data, previousBotResponse);
            if (payload === null || payload === undefined)
                return null;
            return {
                [handler.messageKey]: JSON.stringify(payload)
            };
        });
    }
    _shouldRetryBotMessage(messageType, data, botResponse) {
        return __awaiter(this, void 0, void 0, function* () {
            const handler = this._messageHandlers.get(messageType);
            return yield handler.callHandleFailedBotResponse(data, botResponse);
        });
    }
    _buildCommonComponents() {
        return __awaiter(this, void 0, void 0, function* () {
            const containerTag = "div";
            const containerId = "___ct_base_layer_modal_container";
            let container = document.querySelector(`${containerTag}#${containerId}`);
            if (!container) {
                container = document.createElement(containerTag);
                container.id = containerId;
                container.setAttribute("style", "position: absolute; top: 0; left: 0; width: 0; height: 0; z-index: 99999;");
                document.body.appendChild(container);
            }
            // get or add modal manager component
            this.alertModalManager = document.querySelector("ct-alert-modal-manager");
            if (!this.alertModalManager) {
                this.alertModalManager = document.createElement("ct-alert-modal-manager");
                this.alertModalManager.owner = this.name;
                container.appendChild(this.alertModalManager);
            }
            yield this.generateCommonComponents(container);
        });
    }
    _attemptAutoLogin(userId, password, domain) {
        return __awaiter(this, void 0, void 0, function* () {
            let username = `${userId}@${domain}`;
            if (this.config.xmpp.user && this.config.xmpp.user.forceLowercaseJid === true) {
                username = username.toLowerCase();
            }
            this.logger.log(Logger_1.LoggerTypes.Connectivity, `%c💻 ATTEMPTING AUTOMATIC LOGIN AS > %c${username}`, "color: #669; font-weight: bold;", "color: #999; font-weight: normal;");
            yield this.comms.login(username, password);
        });
    }
    // === Protected Functions === //
    handleLogin(data) {
        this.emit(Events.BaseEvents.LoginResult, data);
    }
    handleLogout(data) {
        this.emit(Events.BaseEvents.LogoutResult, data);
    }
    handleNewMessage(message) {
        if (this.suppressMode === true && message.isFromMam !== true) {
            this.addDeferredStanza({ id: message._id, eventType: ct_xmpp_client_1.CtXmppClient.EVENT_TYPES.NEW_MESSAGE, payload: message });
            return;
        }
        this.emit(Events.BaseEvents.UserActivity, new Events.UserActivityEventArgs(message.jid, message.ts));
        const messageType = Utils.getMessageType(message.data);
        if (!messageType)
            return;
        const content = message.data[messageType] && JSON.parse(message.data[messageType]);
        const parsedMessage = Object.assign({}, message, {
            data: {
                [messageType]: content
            }
        });
        const handler = this._messageHandlers.get(messageType);
        if (!handler)
            return;
        // chain message handling to end of promise queue
        this._messageProcessorQueue = this._messageProcessorQueue
            .then(() => __awaiter(this, void 0, void 0, function* () {
            try {
                this.removeDeferredStanza(message._id, ct_xmpp_client_1.CtXmppClient.EVENT_TYPES.NEW_MESSAGE);
                this.logger.log(Logger_1.LoggerTypes.ProcessingReceived, `%c👷 PROCESSING NEW MESSAGE:%c`, "color: #060; font-weight: bold;", "color: #999; font-weight: normal;", { [messageType]: content });
                return yield handler.callHandleMessage(parsedMessage);
            }
            catch (ex) {
                this.error("Error processing message", ex);
            }
        }))
            .catch(ex => this.error("Error processing message", ex));
    }
    handleMessageUpdate(message) {
        if (this.suppressMode === true) {
            this.addDeferredStanza({ id: message._id, eventType: ct_xmpp_client_1.CtXmppClient.EVENT_TYPES.MESSAGE_UPDATED, payload: message });
            return;
        }
        this.emit(Events.BaseEvents.UserActivity, new Events.UserActivityEventArgs(message.jid, message.ts));
        const messageType = Utils.getMessageType(message.data);
        if (!messageType)
            return;
        const content = message.data[messageType] && JSON.parse(message.data[messageType]);
        const parsedMessage = Object.assign({}, message, {
            data: {
                [messageType]: content
            }
        });
        const handler = this._messageHandlers.get(messageType);
        if (handler) {
            // chain message handling to end of promise queue
            this._messageProcessorQueue = this._messageProcessorQueue
                .then(() => __awaiter(this, void 0, void 0, function* () {
                try {
                    this.removeDeferredStanza(message._id, ct_xmpp_client_1.CtXmppClient.EVENT_TYPES.MESSAGE_UPDATED);
                    this.logger.log(Logger_1.LoggerTypes.ProcessingUpdated, `%c👷 PROCESSING MESSAGE UPDATE:%c`, "color: #060; font-weight: bold;", "color: #999; font-weight: normal;", { [messageType]: content });
                    return yield handler.callHandleMessageUpdate(parsedMessage);
                }
                catch (ex) {
                    this.error("Error processing message update", ex);
                }
            }))
                .catch(ex => this.error("Error processing message update", ex));
        }
    }
    handleChatMarkerUpdate(update) {
        if (this.suppressMode === true) {
            this.addDeferredStanza({ id: update.message_id, eventType: ct_xmpp_client_1.CtXmppClient.EVENT_TYPES.RECEIPT_RECEIVED, payload: update });
            return;
        }
        const receipt = Object.assign({}, update);
        let bareJidResource = `${receipt.sender_resource}@${this.config.xmpp.user.domain}`;
        if (this.config.xmpp.user && this.config.xmpp.user.forceLowercaseJid === true) {
            bareJidResource = bareJidResource.toLowerCase();
        }
        receipt.sender_resource = bareJidResource;
        this.emit(Events.BaseEvents.UserActivity, new Events.UserActivityEventArgs(receipt.sender_resource, receipt.message.updated_at || receipt.message.ts));
        const messageType = Utils.getMessageType(receipt.message.data);
        if (!messageType)
            return;
        const messageContent = receipt.message.data[messageType] && JSON.parse(receipt.message.data[messageType]);
        const parsedReceipt = Object.assign({}, receipt, {
            message: {
                data: {
                    [messageType]: messageContent
                }
            }
        });
        const handler = this._messageHandlers.get(messageType);
        if (handler) {
            // chain message handling to end of promise queue
            this._messageProcessorQueue = this._messageProcessorQueue
                .then(() => __awaiter(this, void 0, void 0, function* () {
                try {
                    this.removeDeferredStanza(update.message_id, ct_xmpp_client_1.CtXmppClient.EVENT_TYPES.RECEIPT_RECEIVED);
                    const username = receipt.sender_resource.split("@").shift();
                    this.logger.log(Logger_1.LoggerTypes.ProcessingChatMarker, `%c👷 PROCESSING CHAT MARKER: %c${username} > ${receipt.type}`, "color: #669; font-weight: bold;", "color: #999; font-weight: normal;");
                    return yield handler.callHandleMessageReceipt(receipt);
                }
                catch (ex) {
                    this.error("Error processing chat marker", ex);
                }
            }))
                .catch(ex => this.error("Error processing chat marker", ex));
        }
    }
    handleRoomParticipantUpdate(update) {
        if (!update.jid)
            return;
        this.emit(Events.BaseEvents.UserActivity, new Events.UserActivityEventArgs(update.jid, update.updated_at || update.ts));
        const role = (update.metadata && update.metadata.role)
            ? update.metadata.role
            : "";
        this.emit(Events.BaseEvents.RoomParticipantUpdate, new Events.RoomParticipantUpdateEventArgs(update.jid, update.room_name, role, Models.RoomRole[update.room_role]));
    }
    handleConnectionChange(status, reconnectTime, disconnectStatus) {
        this.comms.setConnectionStatus(status);
        BaseLayer.onReady(this.name, () => {
            this.emit(Events.BaseEvents.ConnectionStatusChange, new Events.ConnectionStatusEventArgs(status, reconnectTime, disconnectStatus));
        });
    }
    handlePresenceUpdate(contact) {
        if (contact.online) {
            this.emit(Events.BaseEvents.UserActivity, new Events.UserActivityEventArgs(contact.id, this.getSyncedTimestamp()));
        }
        const connectionStatus = contact.online
            ? Models.ConnectionStatus.Connected
            : Models.ConnectionStatus.Disconnected;
        this.emit(Events.BaseEvents.OtherUserConnectionStatusChange, new Events.UserConnectionStatusEventArgs(contact.id, connectionStatus));
    }
}
exports.BaseLayer = BaseLayer;
// tslint:enable no-any


/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const skate = __webpack_require__(13);
const base_1 = __webpack_require__(0);
const LayerRegistration_1 = __webpack_require__(23);
const Logger_1 = __webpack_require__(10);
const events_1 = __webpack_require__(5);
const CTBaseComponent_1 = __webpack_require__(22);
class CTLayerComponent extends CTBaseComponent_1.CTBaseComponent {
    constructor() {
        super(...arguments);
        this._connected = false;
        this._debouncers = {};
    }
    get layer() {
        if (!this._baseLayer)
            return null;
        return this._baseLayer;
    }
    // === Render lifecycle events === //
    get componentStyles() {
        return this.generateComponentStyles;
    }
    componentMarkup() {
        if (!this.layer) {
            const parent = this._findParentCTLayerComponent();
            if (parent) {
                this._baseLayer = parent._baseLayer;
                this._initializeForBaseLayer();
            }
            if (!this._connected)
                return null;
            if (!this.layer) {
                if (parent) {
                    // tslint:disable-next-line no-console
                    console.error(`Component <${this.localName}> child of <${parent.localName}> does not have an owner layer specified`);
                }
                else {
                    // tslint:disable-next-line no-console
                    console.error(`Component <${this.localName}> does not have an owner layer specified`);
                }
                return skate.h("em", { style: { display: "inline-block", fontSize: "12px", color: "#900", backgroundColor: "#FF0", padding: "3px 6px" } }, `${this.localName}:`, skate.h("br"), "OWNER NOT SPECIFIED");
            }
        }
        return this.generateComponentMarkup();
    }
    // === Web component lifecycle events === //
    connectedCallback() {
        super.connectedCallback();
    }
    attributeChangedCallback(name, oldVal, newVal) {
        super.attributeChangedCallback(name, oldVal, newVal);
        switch (name) {
            case "owner":
                if ((newVal !== oldVal) && (newVal !== "")) {
                    this.owner = newVal;
                    this._attemptConnectToBaseLayer();
                }
                break;
        }
    }
    // === Public utility functions === //
    forceRedraw() {
        // need to update a property to trigger a re-render
        this._renderTrigger = new Date().getTime();
    }
    debounce(name, action, duration = 100) {
        clearTimeout(this._debouncers[name]);
        this._debouncers[name] = setTimeout(() => {
            action();
            delete this._debouncers[name];
        }, duration);
    }
    emitEvent(name, data) {
        if (this._baseLayer) {
            this._baseLayer.emit(name, data);
        }
        else {
            // tslint:disable-next-line no-console
            console.error(`Could not emit event from component <${this.localName}> - it does not have an owner layer specified`);
        }
    }
    emitComponentEvent(name, data) {
        if (this._baseLayer) {
            this._baseLayer.logger.log(Logger_1.LoggerTypes.Events, `%c📞 RAISING COMPONENT EVENT:%c ${name}`, "color: #066; font-weight: bold;", "color: #999; font-weight: normal;", { component: this, data: data });
            this.dispatchEvent(new CustomEvent(name, { detail: data }));
        }
        else {
            // tslint:disable-next-line no-console
            console.error(`Could not emit event from component <${this.localName}> - it does not have an owner layer specified`);
        }
    }
    addListener(name, callback, options) {
        if (this._baseLayer) {
            let onceOnly = false;
            let allowSuppress = true;
            if (options && options.onceOnly === true)
                onceOnly = true;
            if (options && options.dontSuppress === true)
                allowSuppress = false;
            this._baseLayer.on(name, callback, onceOnly, allowSuppress);
        }
        else {
            // tslint:disable-next-line no-console
            console.error(`Could not set event handler on component <${this.localName}> - it does not have an owner layer specified`);
        }
    }
    addListeners(names, callback, options) {
        names.forEach(x => {
            this.addListener(x, callback, options);
        });
    }
    launchModal(alert) {
        this._baseLayer.emit(events_1.BaseEvents._Request_RaiseAlert, alert);
    }
    getLabel(labelName, data) {
        return this.layer.getLabel(labelName, data);
    }
    // === Private functions === //
    _attemptConnectToBaseLayer() {
        if (!this.owner)
            return;
        LayerRegistration_1.LayerRegistration.onReady(this.owner, () => {
            this._connectToLayer();
        });
    }
    _connectToLayer() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._connected)
                return;
            if (!this.owner)
                return;
            this._baseLayer = LayerRegistration_1.LayerRegistration.getInstance(this.owner) || null;
            if (!this._baseLayer)
                return;
            yield this._initializeForBaseLayer();
        });
    }
    _initializeForBaseLayer() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.initialize.apply(this);
            this.setupListeners();
            this._connected = true;
            this.forceRedraw();
            this.addListener(events_1.BaseEvents._Request_RedrawAllUIs, () => __awaiter(this, void 0, void 0, function* () {
                yield this.initialize.apply(this);
                this.forceRedraw();
            }));
        });
    }
    _findParentCTLayerComponent() {
        let parent = this;
        let finished = false;
        do {
            // tslint:disable-next-line no-any
            parent = (parent.parentNode || parent.host);
            if (!parent)
                finished = true;
            if (parent && parent.owner)
                finished = true;
        } while (!finished);
        return parent || null;
    }
}
CTLayerComponent.is = null;
__decorate([
    base_1.prop({ type: String, attribute: true })
], CTLayerComponent.prototype, "owner", void 0);
__decorate([
    base_1.prop({ type: Number, attribute: false, default: 0 })
], CTLayerComponent.prototype, "_renderTrigger", void 0);
exports.CTLayerComponent = CTLayerComponent;
// tslint:enable no-any
// tslint:enable typedef


/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const strophe_1 = __webpack_require__(21);
const ct_xmpp_client_1 = __webpack_require__(16);
const models_1 = __webpack_require__(2);
const events_1 = __webpack_require__(5);
const Logger_1 = __webpack_require__(10);
const utils_1 = __webpack_require__(3);
class BaseComms {
    constructor(name, config, store, logger) {
        this._firstConnectionInitialized = false;
        this._loggingIn = false;
        this._loginTimeout = null;
        this._clientName = name;
        const clientOptions = {
            debug: (logger.getTypesAsEnumValues().includes(Logger_1.LoggerTypes.XmppClient)),
            mucHost: config.mucHost,
            mam: {
                auto: (config.mam && config.mam.autoFetch === true) || false,
                defaultTimeLimit: config.maxMessageAge || 0,
                pageSize: 500
            },
            autoLogin: (config.autoLogin !== undefined ? config.autoLogin : true),
            autoReconnect: (config.autoReconnect !== undefined ? config.autoReconnect : true),
            enablePing: config.enablePing !== false,
            pingInterval: config.pingInterval || 5000,
            pingTimeout: config.pingTimeout || 10000,
            connectTimeout: config.connectTimeout || 15000,
            multicastHost: config.multicastHost,
            uploadHost: config.uploadHost,
            autoMarkMessages: config.useChatMarkers,
            encryption: config.encryption || false,
            fileEncryption: config.fileEncryption || false,
            autoPurgeOldMessagesAge: config.maxMessageAge || 0,
            authAttachments: config.authAttachments === true,
            streamResumption: config.streamResumption !== false,
            useEncodedJidAsResource: (config.user && config.user.userPersistentResource === true) || false,
            adSpn: config.adSpn || null,
            adSecurityPackage: config.adSecurityPackage || null,
            push: config.push,
            enableMessageCarbons: config.enableMessageCarbons || false,
            useConnectionEvents: config.useConnectionEvents,
            maxStreamResumptionTime: config.maxStreamResumptionTime || null
        };
        if (config.adTokenPlaceholder)
            clientOptions.adTokenPlaceholder = config.adTokenPlaceholder;
        this.client = new ct_xmpp_client_1.CtXmppClient(this._clientName, config.endpoint, clientOptions);
        this.store = store;
        this.logger = logger;
        this.xmppConfig = config;
        this._localEventHandlers = {};
        this._setupCommonHandlers();
    }
    // === Event handlers === //
    onInitialized(handler) {
        this.client.addEventListener(ct_xmpp_client_1.CtXmppClient.EVENT_TYPES.INITIALISED, () => {
            handler();
        });
    }
    onLogin(handler) {
        const eventName = "comms-login";
        if (this._localEventHandlers[eventName] === undefined) {
            this._localEventHandlers[eventName] = [];
        }
        this._localEventHandlers[eventName].push(handler);
    }
    onLogout(handler) {
        const eventName = "comms-logout";
        if (this._localEventHandlers[eventName] === undefined) {
            this._localEventHandlers[eventName] = [];
        }
        this._localEventHandlers[eventName].push(handler);
    }
    onNewMessage(handler) {
        this.client.addEventListener(ct_xmpp_client_1.CtXmppClient.EVENT_TYPES.NEW_MESSAGE, (message) => {
            handler(Object.assign({}, message));
        });
    }
    onMessageUpdate(handler) {
        this.client.addEventListener(ct_xmpp_client_1.CtXmppClient.EVENT_TYPES.MESSAGE_UPDATED, (message) => {
            handler(Object.assign({}, message));
        });
    }
    onChatMarkerUpdate(handler) {
        this.client.addEventListener(ct_xmpp_client_1.CtXmppClient.EVENT_TYPES.RECEIPT_RECEIVED, (receipt) => {
            handler(Object.assign({}, receipt));
        });
    }
    onStatusUpdate(handler) {
        this.client.addEventListener(ct_xmpp_client_1.CtXmppClient.EVENT_TYPES.STATUS, (status) => {
            let sts = models_1.ConnectionStatus.Disconnected;
            let disconnectStatus = null;
            switch (status.id) {
                case strophe_1.default.Strophe.Status.CONNFAIL:
                    sts = models_1.ConnectionStatus.Disconnected;
                    disconnectStatus = new models_1.DisconnectionStatus(status.wontReconnect, status.reason);
                    break;
                case strophe_1.default.Strophe.Status.AUTHFAIL:
                    sts = models_1.ConnectionStatus.Disconnected;
                    disconnectStatus = new models_1.DisconnectionStatus(false, status.reason);
                    break;
                case strophe_1.default.Strophe.Status.ERROR:
                    sts = models_1.ConnectionStatus.Disconnected;
                    disconnectStatus = new models_1.DisconnectionStatus(status.wontReconnect, status.reason);
                    break;
                case strophe_1.default.Strophe.Status.CONNECTING:
                    sts = models_1.ConnectionStatus.Connecting;
                    break;
                case strophe_1.default.Strophe.Status.AUTHENTICATING:
                    sts = models_1.ConnectionStatus.Connecting;
                    break;
                case strophe_1.default.Strophe.Status.CONNECTED:
                    sts = models_1.ConnectionStatus.Connected;
                    break;
                case strophe_1.default.Strophe.Status.DISCONNECTING:
                    sts = models_1.ConnectionStatus.Disconnecting;
                    break;
                case strophe_1.default.Strophe.Status.DISCONNECTED:
                    sts = models_1.ConnectionStatus.Disconnected;
                    disconnectStatus = new models_1.DisconnectionStatus(status.wontReconnect, status.reason);
                    break;
                default:
                    models_1.ConnectionStatus.Disconnected;
                    break;
            }
            // We just want a simple way to listen for a disconnect so use some nice simple vanilla JS
            if (status.id === strophe_1.default.Strophe.Status.DISCONNECTED) {
                document.dispatchEvent(new CustomEvent("_pl_disconnected"));
            }
            handler(sts, status.reconnectTime, disconnectStatus);
        });
    }
    onPresenceUpdate(handler) {
        this.client.addEventListener(ct_xmpp_client_1.CtXmppClient.EVENT_TYPES.PRESENCE_UPDATE, (contact) => {
            handler(contact);
        });
    }
    onRoomNewParticipant(handler) {
        this.client.addEventListener(ct_xmpp_client_1.CtXmppClient.EVENT_TYPES.NEW_PARTICIPANT, (participant) => {
            handler(Object.assign({}, participant));
        });
    }
    onRoomParticipantUpdate(handler) {
        this.client.addEventListener(ct_xmpp_client_1.CtXmppClient.EVENT_TYPES.PARTICIPANT_UPDATED, (participant) => {
            handler(Object.assign({}, participant));
        });
    }
    onError(handler) {
        this.client.addEventListener(ct_xmpp_client_1.CtXmppClient.EVENT_TYPES.ERROR, (err) => {
            handler(err);
        });
    }
    onStartFetchingMissedMessages(handler) {
        const eventName = "missed-messages-start";
        if (this._localEventHandlers[eventName] === undefined) {
            this._localEventHandlers[eventName] = [];
        }
        this._localEventHandlers[eventName].push(handler);
    }
    onFinishedFetchingMissedMessages(handler) {
        const eventName = "missed-messages-finished";
        if (this._localEventHandlers[eventName] === undefined) {
            this._localEventHandlers[eventName] = [];
        }
        this._localEventHandlers[eventName].push(handler);
    }
    onAutoReconnected(handler) {
        this.client.addEventListener(ct_xmpp_client_1.CtXmppClient.EVENT_TYPES.AUTO_RECONNECTED, (data) => {
            handler(data);
        });
    }
    onDatabasesAutoDestroyed(handler) {
        this.client.addEventListener(ct_xmpp_client_1.CtXmppClient.EVENT_TYPES.AUTO_DBS_DESTROYED, () => {
            handler();
        });
    }
    // === Public functions === //
    getSyncedTimestamp(ts) {
        const clientTs = (ts === null || ts === undefined)
            ? new Date().getTime()
            : ts;
        return this.client.getSyncedTimestamp(clientTs);
    }
    getCurrentUserResource() {
        return this.client.resource;
    }
    getConnectionStatus() {
        return this.status;
    }
    setConnectionStatus(status) {
        this.status = status;
    }
    login(username, password, fireEvents = true) {
        return __awaiter(this, void 0, void 0, function* () {
            const handleLoginFailure = (ex, fireEvents) => {
                clearTimeout(this._loginTimeout);
                this._loggingIn = false;
                this.logger.log(Logger_1.LoggerTypes.Connectivity, `%c🚫 LOGIN FAILED > %c${this.username}`, "color: #600; font-weight: bold;", "color: #999; font-weight: normal;");
                this.username = "";
                if (fireEvents)
                    this.triggerLoginEvent(false, ex.msg);
            };
            if (this._loggingIn === true)
                return Promise.reject(new Error("Login currently in progress, please wait."));
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                try {
                    this._loggingIn = true;
                    clearTimeout(this._loginTimeout);
                    const loginTimeoutDuration = this.xmppConfig.loginTimeout || 10000;
                    this._loginTimeout = setTimeout(() => __awaiter(this, void 0, void 0, function* () {
                        this.logger.log(Logger_1.LoggerTypes.Connectivity, "%c🚫 LOGIN TIMED OUT", "color: #600; font-weight: bold;");
                        const ex = {
                            msg: `Logging in took longer than ${Math.floor(loginTimeoutDuration / 1000)} seconds. Please check your connectivity and try again.`
                        };
                        handleLoginFailure(ex, fireEvents);
                        this._loggingIn = false;
                        clearTimeout(this._loginTimeout);
                        // await this.logout(true, true);
                        reject(ex);
                    }), loginTimeoutDuration);
                    if (this.xmppConfig.user && this.xmppConfig.user.forceLowercaseJid === true) {
                        username = username.toLowerCase();
                    }
                    this.logger.log(Logger_1.LoggerTypes.Connectivity, `%c💻 ATTEMPTING LOGIN > %c${username}`, "color: #669; font-weight: bold;", "color: #999; font-weight: normal;");
                    this.username = username;
                    let resumed = false;
                    try {
                        resumed = yield this.client.login(username, password);
                    }
                    catch (ex) {
                        handleLoginFailure(ex, fireEvents);
                        reject(ex);
                        return;
                    }
                    this.checkTimeSync(false);
                    if (fireEvents)
                        this.triggerLoginEvent(true);
                    clearTimeout(this._loginTimeout);
                    this._loggingIn = false;
                    resolve(resumed);
                }
                catch (ex) {
                    handleLoginFailure(ex, fireEvents);
                    reject(ex);
                }
            }));
        });
    }
    logout(forceCleanUp = false, fireEvents = true) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                this.logger.log(Logger_1.LoggerTypes.Connectivity, `%c✋ LOGGING OUT > %c${this.username}`, "color: #669; font-weight: bold;", "color: #999; font-weight: normal;");
                this._firstConnectionInitialized = false;
                yield this.client.logout(forceCleanUp);
                this.username = "";
                if (fireEvents) {
                    this.triggerLogoutEvent(true);
                }
            }
            catch (ex) {
                this.logger.log(Logger_1.LoggerTypes.Connectivity, `%c🚫 LOGOUT FAILED > %c${this.username}`, "color: #600; font-weight: bold;", "color: #999; font-weight: normal;");
                if (fireEvents) {
                    this.triggerLogoutEvent(false);
                }
            }
        });
    }
    attemptReconnect() {
        this.client.reLoginNow();
    }
    joinRoom() {
        return __awaiter(this, void 0, void 0, function* () {
            (yield this.xmppConfig) && this.xmppConfig.room
                ? this._joinOrLeaveRoom(this.xmppConfig.room)
                : null;
        });
    }
    leaveRoom() {
        return __awaiter(this, void 0, void 0, function* () {
            (yield this.xmppConfig) && this.xmppConfig.room
                ? this._joinOrLeaveRoom(this.xmppConfig.room, true)
                : null;
        });
    }
    setClientStateActive(active) {
        return __awaiter(this, void 0, void 0, function* () {
            const state = active
                ? ct_xmpp_client_1.CtXmppClient.CLIENT_STATES.ACTIVE
                : ct_xmpp_client_1.CtXmppClient.CLIENT_STATES.INACTIVE;
            this.client.setClientState(state);
        });
    }
    getUniqueId() {
        return this.client.getUniqueId();
    }
    sendMessage(to, payload, attachments = []) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.status !== models_1.ConnectionStatus.Connected)
                throw new Error("Unable to send message: not currently connected");
            const sentMessage = yield this.client.sendChatMessage(to, null, payload, attachments);
            if (this.logger.shouldLog(Logger_1.LoggerTypes.MessageSent)) {
                const messageType = utils_1.getMessageType(sentMessage.data);
                const content = sentMessage.data[messageType] && JSON.parse(sentMessage.data[messageType]);
                this.logger.log(Logger_1.LoggerTypes.MessageSent, `%c👈 MESSAGE SENT: %c${to} >`, "color: #600; font-weight: bold;", "color: #999; font-weight: normal;", { [messageType]: content });
            }
            return sentMessage;
        });
    }
    sendRoomMessage(payload) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.xmppConfig.room)
                throw new Error("No room configured in XmppConfig");
            if (this.status !== models_1.ConnectionStatus.Connected)
                throw new Error("Unable to send room message: not currently connected");
            const roomName = this.xmppConfig.room.name;
            const sentMessage = yield this.client.sendGroupChatMessage(roomName, null, payload);
            if (this.logger.shouldLog(Logger_1.LoggerTypes.MessageSent)) {
                const messageType = utils_1.getMessageType(sentMessage.data);
                const content = sentMessage.data[messageType] && JSON.parse(sentMessage.data[messageType]);
                this.logger.log(Logger_1.LoggerTypes.MessageSent, `%c👈 ROOM MESSAGE SENT: %c${roomName} >`, "color: #600; font-weight: bold;", "color: #999; font-weight: normal;", { [messageType]: content });
            }
            return sentMessage;
        });
    }
    sendMulticastMessage(to, payload, isBroadcaster, attachments = []) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.status !== models_1.ConnectionStatus.Connected)
                throw new Error("Unable to multicast message: not currently connected");
            const sentMessage = yield this.client.sendMulticastMessage(to, null, payload, attachments);
            if (this.logger.shouldLog(Logger_1.LoggerTypes.MessageSent)) {
                const toData = JSON.stringify(to);
                const messageType = utils_1.getMessageType(sentMessage.data);
                const content = sentMessage.data[messageType] && JSON.parse(sentMessage.data[messageType]);
                this.logger.log(Logger_1.LoggerTypes.MessageSent, `%c👈 MUTILCAST MESSAGE SENT: %c${toData} >`, "color: #600; font-weight: bold;", "color: #999; font-weight: normal;", { [messageType]: content });
            }
            return sentMessage;
        });
    }
    sendBotCommand(operationName, payload) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.status !== models_1.ConnectionStatus.Connected)
                throw new Error(`Unable to send bot command "${operationName}": not currently connected`);
            if (!this.xmppConfig.bot)
                throw new Error("No bot configured in XmppConfig");
            const botComponentJid = this.xmppConfig.bot.componentJid;
            if (!botComponentJid)
                throw new Error("Unable to issue bot command; no bot component jid configured");
            if (payload !== undefined && payload !== null) {
                const payloadToDisplay = Object.assign({}, payload);
                if (operationName in payloadToDisplay) {
                    payloadToDisplay[operationName] = JSON.parse(payloadToDisplay[operationName]);
                }
                this.logger.log(Logger_1.LoggerTypes.MessageSent, `%c🤖 BOT COMMAND SENT: %c${operationName} >`, "color: #600; font-weight: bold;", "color: #999; font-weight: normal;", { data: payloadToDisplay });
            }
            else {
                this.logger.log(Logger_1.LoggerTypes.MessageSent, `%c🤖 BOT COMMAND SENT: %c${operationName}`, "color: #600; font-weight: bold;", "color: #999; font-weight: normal;");
            }
            try {
                const botResponse = yield this.client.sendBotCommand(botComponentJid, operationName, payload, this.xmppConfig.bot.timeout);
                this.logger.log(Logger_1.LoggerTypes.MessageSent, `%c🤖 BOT RESPONSE: %c${operationName} > ${botResponse.success ? "success" : "fail"}`, "color: #600; font-weight: bold;", "color: #999; font-weight: normal;", { data: botResponse.data || null });
                return botResponse;
            }
            catch (ex) {
                // the error "Server connections to local subdomains are forbidden" is thrown when the BOT is unavailable to accept connected, so
                // we reword the error message to be a bit more meaningful
                const errorMessage = (ex === "Server connections to local subdomains are forbidden")
                    ? `Unable to connect to bot: ${botComponentJid}`
                    : ex.message || ex;
                throw new Error(errorMessage);
            }
        });
    }
    // tslint:disable-next-line no-any
    updateStatus(status, label, broadcast = false, metadata) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.client.setChatStatus(status, label, broadcast, metadata);
            if (this.logger.shouldLog(Logger_1.LoggerTypes.Status)) {
                const responseData = JSON.stringify(response);
                this.logger.log(Logger_1.LoggerTypes.Status, `%c👌 STATUS UPDATED: %c${responseData}`, "color: #669; font-weight: bold;", "color: #999; font-weight: normal;");
            }
            return response;
        });
    }
    listParticipantsByRoom(roomName) {
        return __awaiter(this, void 0, void 0, function* () {
            const participants = yield this.client.listParticipantsByRoom(roomName);
            return Promise.all(participants.map((x) => __awaiter(this, void 0, void 0, function* () {
                return yield this._participantToUser(x);
            })));
        });
    }
    getParticipantByRoomAndJid(roomName, jid) {
        return __awaiter(this, void 0, void 0, function* () {
            const participant = yield this.client.getParticipantByRoomAndJid(roomName, jid);
            return (!!participant)
                ? yield this._participantToUser(participant)
                : null;
        });
    }
    getAllContacts() {
        return __awaiter(this, void 0, void 0, function* () {
            const contacts = yield this.client.getContacts();
            return Promise.all(contacts.map((x) => __awaiter(this, void 0, void 0, function* () {
                return yield this._xmppContactToUser(x);
            })).filter(x => x !== null));
        });
    }
    getChatHistory(jid) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.getChatHistory(jid);
        });
    }
    queryMam(to, archiveId, jid, timeLimit, dispatch = true) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.queryMam(to, archiveId, jid, timeLimit, dispatch);
        });
    }
    clearAllData(keepCache = false) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.client.destroyDbs(false, keepCache);
        });
    }
    createPushNotificationRegistration(registrationDetails) {
        return __awaiter(this, void 0, void 0, function* () {
            const payload = this._generatePushNotificationPayload(registrationDetails.platform, registrationDetails.channelUri, registrationDetails.azureId);
            return yield this.client.sendIq("push.localhost", "set", payload);
        });
    }
    checkTimeSync(forceOutput = true) {
        const clientTime = new Date().getTime();
        const syncedTime = this.getSyncedTimestamp(clientTime);
        const diff = Math.abs(syncedTime - clientTime);
        const diffTolerance = 10000; // allow up to 10s difference before highlighting
        const withinTolerance = (diff < diffTolerance);
        const diffColor = withinTolerance ? "#666" : "#F00";
        const diffColor2 = withinTolerance ? "#999" : "#F00";
        const loggerMethod = forceOutput
            ? console.log
            : withinTolerance
                ? () => { }
                : console.log;
        loggerMethod.call(console.log, `%c🕐 CLIENT TIME: %c${new Date(clientTime).toTimeString()}`, "color: #666; font-weight: bold;", "color: #999; font-weight: normal;");
        loggerMethod.call(console.log, `%c🕐 SERVER TIME: %c${new Date(syncedTime).toTimeString()}`, "color: #666; font-weight: bold;", "color: #999; font-weight: normal;");
        if (diff) {
            const hours = Math.floor((diff / (1000 * 60 * 60)) % 24);
            const minutes = Math.floor((diff / (1000 * 60)) % 60);
            const seconds = Math.floor((diff / 1000) % 60);
            const milliseconds = Math.floor(diff % 1000);
            let timeDisplay = "";
            if (hours > 0)
                timeDisplay += `${hours}h `;
            if (minutes > 0)
                timeDisplay += `${minutes}m `;
            if (seconds > 0)
                timeDisplay += `${seconds}s `;
            if (milliseconds > 0)
                timeDisplay += `${milliseconds}ms `;
            if (clientTime > syncedTime) {
                loggerMethod.call(console.log, `%c🕐 TIME SYNC: %cClient is %c${timeDisplay.trim()} ahead %cof server`, `color: ${diffColor}; font-weight: bold;`, `color: ${diffColor2}; font-weight: normal;`, `color: ${diffColor2}; font-weight: bold;`, `color: ${diffColor2}; font-weight: normal;`);
            }
            else {
                loggerMethod.call(console.log, `%c🕐 TIME SYNC: %cClient is %c${timeDisplay.trim()} behind %cserver`, `color: ${diffColor}; font-weight: bold;`, `color: ${diffColor2}; font-weight: normal;`, `color: ${diffColor2}; font-weight: bold;`, `color: ${diffColor2}; font-weight: normal;`);
            }
        }
        else {
            loggerMethod.call(console.log, `%c🕐 TIME SYNC: %cClient and server times are identical`, "color: #666; font-weight: bold;", "color: #999; font-weight: normal;");
        }
    }
    updateVCardForUser(jid) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.username && this.username === jid)
                return null;
            yield this.client.updatevCardForContact(jid);
        });
    }
    getOurVCard() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                return yield this.client.getOurvCard();
            }
            catch (ex) {
                // might not have a vCard
                return null;
            }
        });
    }
    downloadFile(url) {
        return __awaiter(this, void 0, void 0, function* () {
            // tslint:disable-next-line no-any
            const result = yield this.client.doDownload(url);
            return result.source || null;
        });
    }
    // === Protected functions === //
    initializeFirstConnection() {
        return __awaiter(this, void 0, void 0, function* () { });
    }
    buildCurrentUser(jid) {
        return __awaiter(this, void 0, void 0, function* () {
            const username = jid.split("@").shift();
            const user = {
                id: jid,
                jid: jid,
                username: username,
                firstName: "",
                lastName: "",
                connectionStatus: this.getConnectionStatus()
            };
            const vcard = yield this.getOurVCard();
            return yield this.embelishUser(user, vcard, models_1.UserAdditionalDetailsType.VCard);
        });
    }
    triggerLoginEvent(success, errorMessage) {
        this._fireLocalEventHandlers("comms-login", new events_1.CommsEventArgs(success, errorMessage));
    }
    triggerLogoutEvent(success, errorMessage) {
        this._fireLocalEventHandlers("comms-logout", new events_1.CommsEventArgs(success, errorMessage));
    }
    triggerFetchingMissedMessagesState(fetching) {
        if (fetching) {
            this._fireLocalEventHandlers("missed-messages-start");
        }
        else {
            this._fireLocalEventHandlers("missed-messages-finished");
        }
    }
    // === Private functions === //
    _setupCommonHandlers() {
        this.client.addEventListener(ct_xmpp_client_1.CtXmppClient.EVENT_TYPES.NEW_MESSAGE, (message) => __awaiter(this, void 0, void 0, function* () {
            if (this.logger.shouldLog(Logger_1.LoggerTypes.MessageReceived)) {
                const messageType = utils_1.getMessageType(message.data);
                const content = message.data[messageType] && JSON.parse(message.data[messageType]);
                this.logger.log(Logger_1.LoggerTypes.MessageReceived, `%c✊ MESSAGE RECEIVED:%c`, "color: #060; font-weight: bold;", "color: #999; font-weight: normal;", { [messageType]: content });
            }
        }));
        this.client.addEventListener(ct_xmpp_client_1.CtXmppClient.EVENT_TYPES.MESSAGE_UPDATED, (message) => {
            if (this.logger.shouldLog(Logger_1.LoggerTypes.MessageUpdated)) {
                const messageType = utils_1.getMessageType(message.data);
                const content = message.data[messageType] && JSON.parse(message.data[messageType]);
                this.logger.log(Logger_1.LoggerTypes.MessageUpdated, `%c✊ MESSAGE UPDATED:%c`, "color: #060; font-weight: bold;", "color: #999; font-weight: normal;", { [messageType]: content });
            }
        });
        this.client.addEventListener(ct_xmpp_client_1.CtXmppClient.EVENT_TYPES.RECEIPT_RECEIVED, (receipt) => {
            if (this.logger.shouldLog(Logger_1.LoggerTypes.MessageChatMarker)) {
                const username = receipt.sender_resource.split("@").shift();
                this.logger.log(Logger_1.LoggerTypes.MessageChatMarker, `%c👁 CHAT MARKER RECEIVED: %c${username} > ${receipt.type}`, "color: #669; font-weight: bold;", "color: #999; font-weight: normal;");
            }
        });
        this.client.addEventListener(ct_xmpp_client_1.CtXmppClient.EVENT_TYPES.STATUS, (status) => __awaiter(this, void 0, void 0, function* () {
            const connectionStatus = models_1.ConnectionStatus[status.label];
            this.setConnectionStatus(connectionStatus);
            if (connectionStatus === models_1.ConnectionStatus.Connected) {
                this.username = this.client.bareJid;
                if (this._firstConnectionInitialized === false) {
                    yield this.initializeFirstConnection();
                    this._firstConnectionInitialized = true;
                }
            }
            if (this.logger.shouldLog(Logger_1.LoggerTypes.Connectivity)) {
                const suffix = (!!status.reconnectTime)
                    ? ` - reconnect attempt in ${status.reconnectTime / 1000} second(s)`
                    : "";
                this.logger.log(Logger_1.LoggerTypes.Connectivity, `%c💻 CONNECTIVITY CHANGE: %c${connectionStatus}${suffix}`, "color: #669; font-weight: bold;", "color: #999; font-weight: normal;");
            }
        }));
        this.client.addEventListener(ct_xmpp_client_1.CtXmppClient.EVENT_TYPES.NEW_PARTICIPANT, (participant) => __awaiter(this, void 0, void 0, function* () {
            if (!participant.jid)
                return;
            if (this.logger.shouldLog(Logger_1.LoggerTypes.Participation)) {
                const user = yield this._participantToUser(participant);
                this.logger.log(Logger_1.LoggerTypes.Participation, `%c👋 NEW PARTICIPANT: %c${user.username} > ${user.connectionStatus}`, "color: #006; font-weight: bold;", "color: #999; font-weight: normal;", { participant: participant });
            }
        }));
        this.client.addEventListener(ct_xmpp_client_1.CtXmppClient.EVENT_TYPES.PARTICIPANT_UPDATED, (participant) => __awaiter(this, void 0, void 0, function* () {
            if (!participant.jid)
                return;
            if (this.logger.shouldLog(Logger_1.LoggerTypes.Participation)) {
                const user = yield this._participantToUser(participant);
                this.logger.log(Logger_1.LoggerTypes.Participation, `%c👋 PARTICIPANT UPDATED: %c${user.username} > ${user.connectionStatus}`, "color: #006; font-weight: bold;", "color: #999; font-weight: normal;", { participant: participant });
            }
        }));
        this.client.addEventListener(ct_xmpp_client_1.CtXmppClient.EVENT_TYPES.PRESENCE_UPDATE, (contact) => __awaiter(this, void 0, void 0, function* () {
            if (!contact.id)
                return;
            if (this.logger.shouldLog(Logger_1.LoggerTypes.Presence)) {
                const user = yield this._xmppContactToUser(contact);
                if (!user)
                    this.logger.error(Logger_1.LoggerTypes.Presence, `%c👋 PRESENCE UPDATED FOR UNKNOWN CONTACT:`, "color: #006; font-weight: bold;", { contact: contact });
                else
                    this.logger.log(Logger_1.LoggerTypes.Presence, `%c👋 PRESENCE UPDATED: %c${user.username} > ${user.connectionStatus}`, "color: #006; font-weight: bold;", "color: #999; font-weight: normal;");
            }
        }));
        this.client.addEventListener(ct_xmpp_client_1.CtXmppClient.EVENT_TYPES.ERROR, (err) => {
            this.logger.error(`%c⛔ ERROR:`, "color: #C00; font-weight: bold;", "\r\n\t", err);
        });
        this.client.addEventListener(ct_xmpp_client_1.CtXmppClient.EVENT_TYPES.AUTO_RECONNECTED, ({ resumed }) => __awaiter(this, void 0, void 0, function* () {
            if (this.logger.shouldLog(Logger_1.LoggerTypes.Connectivity)) {
                const suffix = (resumed === true)
                    ? " - STREAM RESUMED"
                    : "";
                this.logger.log(Logger_1.LoggerTypes.Connectivity, `%c💻 AUTO RECONNECTED AFTER DISCONNECT${suffix}`, "color: #669; font-weight: bold;");
            }
        }));
        this.client.addEventListener(ct_xmpp_client_1.CtXmppClient.EVENT_TYPES.DBS_DESTROYED, () => {
            if (this.logger.shouldLog(Logger_1.LoggerTypes.CleanUp)) {
                this.logger.log(Logger_1.LoggerTypes.CleanUp, `%c☠️☠ DATABASES DESTROYED`, "color: #669; font-weight: bold;");
            }
        });
        this.client.addEventListener(ct_xmpp_client_1.CtXmppClient.EVENT_TYPES.AUTO_DBS_DESTROYED, () => {
            if (this.logger.shouldLog(Logger_1.LoggerTypes.CleanUp)) {
                this.logger.log(Logger_1.LoggerTypes.CleanUp, `%c☠️☠ DATABASES AUTO DESTROYED`, "color: #669; font-weight: bold;");
            }
        });
    }
    _joinOrLeaveRoom(room, leave = false) {
        return __awaiter(this, void 0, void 0, function* () {
            if (room.type === "participant") {
                (yield leave)
                    ? this.client.leaveRoom(room.name)
                    : this.client.joinRoom(room.name);
            }
            if (room.type === "subscriber") {
                (yield leave)
                    ? this.client.unsubscribeFromRoom(room.name)
                    : this.client.subscribeToRoom(room.name, room.nodes);
            }
        });
    }
    _participantToUser(participant) {
        return __awaiter(this, void 0, void 0, function* () {
            const user = {
                id: participant._id,
                jid: participant.jid,
                username: participant.username,
                firstName: "",
                lastName: "",
                connectionStatus: participant.online
                    ? models_1.ConnectionStatus.Connected
                    : models_1.ConnectionStatus.Disconnected
            };
            return this.embelishUser(user, participant, models_1.UserAdditionalDetailsType.Participant);
        });
    }
    _xmppContactToUser(contact) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!contact || !contact.id)
                return null;
            const user = {
                id: contact.id,
                jid: contact.id,
                username: contact.id.substring(0, contact.id.indexOf("@")),
                firstName: "",
                lastName: "",
                connectionStatus: contact.online
                    ? models_1.ConnectionStatus.Connected
                    : models_1.ConnectionStatus.Disconnected,
                groups: contact.groups,
                subscription: contact.subscription
            };
            return this.embelishUser(user, contact, models_1.UserAdditionalDetailsType.Contact);
        });
    }
    // tslint:disable-next-line no-any
    _fireLocalEventHandlers(name, data) {
        if (this._localEventHandlers[name] !== undefined) {
            this._localEventHandlers[name].forEach(handler => handler(data));
        }
    }
    _generatePushNotificationPayload(deviceType, deviceToken, installationId) {
        return {
            push: {
                $attributes: {
                    xmlns: "urn:commontime:infinity:push"
                },
                notification: {
                    type: deviceType === "android" ? "gcm" : "apns",
                    installation_id: installationId,
                    registration_id: deviceToken
                }
            }
        };
    }
}
exports.BaseComms = BaseComms;


/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const skate = __webpack_require__(13);
// tslint:disable no-any variable-name
/**
 * This represents a SkateJS type which will bind to a boolean property using
 * the string representation of "true" or "false in an attribute. This works around
 * the default "boolean" SkateJS type which is only false if the attribute does
 * not exist.
 *
 * Usage (using typescript decorators):
 *
 * @prop({ type: Stroolean, attribute: true, default: false })
 * myBooleanProperty: boolean
 */
exports.Stroolean = skate.prop.create({
    coerce: val => (typeof (val) === "string" && val.toLowerCase() === "true"),
    default: false,
    deserialize: val => (typeof (val) === "string" && val.toLowerCase() === "true"),
    serialize: val => (val ? "true" : "false")
});
/**
 * This represents a SkateJS type which will bind to a numerical property using
 * the string representation of the number, or a "null" value. This works around
 * the default "number" SkateJS type which is always 0 even if a null default is
 * specified.
 *
 * Usage (using typescript decorators):
 *
 * @prop({ type: Strumber, attribute: true, default: null })
 * myBooleanProperty: boolean
 */
exports.NullableNumber = skate.prop.create({
    coerce: val => (val === "null") ? null : parseInt(val),
    default: null,
    deserialize: val => (val === "null") ? null : parseInt(val),
    serialize: val => (val === null || val === undefined) ? "null" : val.toString()
});
// tslint:enable no-any variable-name


/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
const skate = __webpack_require__(13);
const identityFn = (x) => x;
function prop(property) {
    return function (target, propertyKey) {
        // obtain properties provide by the @prop decorator
        const { type } = property, skPropConfig = __rest(property, ["type"]);
        // parse to find out the type of property
        const configType = parseType(type);
        // reference the skatejs prop function, e.g. prop.string
        const skatePropTypeFn = skate.prop[configType] || identityFn;
        // get constructor of element
        const ctor = target.constructor;
        // grab any existing props previously defined
        const existingProps = (ctor.props || {});
        // concatenate all props together
        const newProps = Object.assign({}, existingProps, { [propertyKey]: skatePropTypeFn(skPropConfig) });
        // apply to the current instance of the component
        Object.defineProperty(ctor, "props", {
            configurable: true,
            get() {
                return newProps;
            }
        });
    };
}
exports.prop = prop;
function parseType(type) {
    if (typeof type !== "function") {
        return;
    }
    const inst = type();
    if (inst instanceof Array) {
        return "array";
    }
    if (typeof inst === "object") {
        return "object";
    }
    return (typeof inst);
}
// tslint:enable no-any


/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseEventArgs_1 = __webpack_require__(12);
class ConnectionStatusEventArgs extends BaseEventArgs_1.BaseEventArgs {
    constructor(status, reconnectTime, disconnectStatus) {
        super();
        this.status = status;
        this.reconnectTime = reconnectTime;
        this.disconnectStatus = disconnectStatus;
    }
}
exports.ConnectionStatusEventArgs = ConnectionStatusEventArgs;


/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const CommsEventArgs_1 = __webpack_require__(24);
class ResumableCommsEventArgs extends CommsEventArgs_1.CommsEventArgs {
    constructor(resumed, success, errorMessage) {
        super(success, errorMessage);
        this.success = success;
        this.resumed = resumed;
        if (errorMessage) {
            this.errorMessage = errorMessage;
        }
    }
}
exports.ResumableCommsEventArgs = ResumableCommsEventArgs;


/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseEventArgs_1 = __webpack_require__(12);
class RoomParticipantUpdateEventArgs extends BaseEventArgs_1.BaseEventArgs {
    constructor(jid, roomName, role, roomRole) {
        super();
        this.jid = jid;
        this.roomName = roomName;
        this.role = role;
        this.roomRole = roomRole;
    }
}
exports.RoomParticipantUpdateEventArgs = RoomParticipantUpdateEventArgs;


/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseEventArgs_1 = __webpack_require__(12);
class UserActivityEventArgs extends BaseEventArgs_1.BaseEventArgs {
    constructor(jid, date) {
        super();
        this.jid = jid;
        this.date = date;
    }
}
exports.UserActivityEventArgs = UserActivityEventArgs;


/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseEventArgs_1 = __webpack_require__(12);
class UserConnectionStatusEventArgs extends BaseEventArgs_1.BaseEventArgs {
    constructor(jid, connectionStatus) {
        super();
        this.jid = jid;
        this.connectionStatus = connectionStatus;
    }
}
exports.UserConnectionStatusEventArgs = UserConnectionStatusEventArgs;


/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
class BaseHandler {
    constructor(layer) {
        this.messageKey = null;
        this.eventType = [];
        this.layer = layer;
    }
    createMessage(data) { throw new Error("Not implemented"); }
    createBotMessage(data, previousBotResponse) { throw new Error("Not implemented"); }
    handleFailedBotResponse(data, previousBotResponse) {
        return __awaiter(this, void 0, void 0, function* () { return false; });
    }
    handleMessage(message) {
        return __awaiter(this, void 0, void 0, function* () { });
    }
    handleMessageUpdate(message) {
        return __awaiter(this, void 0, void 0, function* () { });
    }
    handleMessageReceipt(receipt) {
        return __awaiter(this, void 0, void 0, function* () { });
    }
    handleEvent(eventType, eventData) {
        return __awaiter(this, void 0, void 0, function* () { });
    }
    // === Public functions to invoke the above implementations === //
    //     These allows us to introduce "before" and "after" hooks to all calls if we want to
    callCreateMessage(data) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.createMessage(data);
        });
    }
    callCreateBotMessage(data, previousBotResponse) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.createMessage(data);
        });
    }
    callHandleFailedBotResponse(data, botResponse) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!botResponse || botResponse.success === true)
                return false;
            return yield this.handleFailedBotResponse(data, botResponse);
        });
    }
    callHandleMessage(message) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.handleMessage(message);
        });
    }
    callHandleMessageUpdate(message) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.handleMessageUpdate(message);
        });
    }
    callHandleMessageReceipt(receipt) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.handleMessageReceipt(receipt);
        });
    }
    callHandleEvent(eventType, eventData) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.handleEvent(eventType, eventData);
        });
    }
}
exports.BaseHandler = BaseHandler;


/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const skate = __webpack_require__(13);
// tslint:disable no-any
function ComponentStylesMixin(base) {
    class ComponentStyles extends base {
        constructor(...args) {
            super(...args);
            const shadyCSS = window.ShadyCSS;
            const hasNativeShadowDOMSupport = !shadyCSS;
            if (!this.styleElements)
                this.styleElements = [];
            // if no styles have been specified for the component then do nothing.
            if (!this.componentStyles)
                return;
            if (hasNativeShadowDOMSupport) {
                this.styleElements = [
                    skate.h("style", this.componentStyles),
                    ...this.styleElements
                ];
            }
            else {
                // if the OverridingStylesMixin is also being applied, then we need to stop this mixin and let the OverridingStylesMixin
                // apply the component styles, otherwise the overriding styles will get added to the head before the component styles,
                // therefore overriding nothing
                if (!this.overridingStylesMixinApplied)
                    return;
                const elementName = this.localName; // _this_ should ultimately be of type HTMLElement
                if (ComponentStyles._seenTags[elementName] !== true) {
                    ComponentStyles._seenTags[elementName] = true;
                    const $template = document.createElement("template");
                    $template.innerHTML = `<style>${this.componentStyles}</style>`;
                    shadyCSS.prepareTemplate($template, elementName);
                }
            }
        }
        // used the inform other mixins of the presence of this one
        get componentStylesMixinApplied() {
            return true;
        }
    }
    ComponentStyles._seenTags = {};
    return ComponentStyles;
}
exports.ComponentStylesMixin = ComponentStylesMixin;
// tslint:enable no-any


/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var renderMixin_1 = __webpack_require__(57);
exports.RenderMixin = renderMixin_1.RenderMixin;
var componentStylesMixin_1 = __webpack_require__(54);
exports.ComponentStylesMixin = componentStylesMixin_1.ComponentStylesMixin;
var overridingStylesMixin_1 = __webpack_require__(56);
exports.OverridingStylesMixin = overridingStylesMixin_1.OverridingStylesMixin;


/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const skate = __webpack_require__(13);
// tslint:disable no-any
function OverridingStylesMixin(base) {
    class OverridingStyles extends base {
        constructor(...args) {
            super(...args);
            const elementName = this.localName; // _this_ should ultimately be of type HTMLElement
            const shadyCSS = window.ShadyCSS;
            const hasNativeShadowDOMSupport = !shadyCSS;
            // look for __CtOverridingStyles property on the window object
            const overridingStylesObject = (window.__CtOverridingStyles) || {};
            const componentOverridingStyleSheets = [
                ...overridingStylesObject["*"] || [],
                ...overridingStylesObject[elementName.toLowerCase()] || []
            ];
            // we don't initially check for overrriding style sheets here because we need this code to execute if ComponentStylesMixin is depending on it
            if (hasNativeShadowDOMSupport) {
                // have any overriding stylesheets been added to this tag?
                if (componentOverridingStyleSheets) {
                    if (!this.styleElements)
                        this.styleElements = [];
                    componentOverridingStyleSheets.forEach(x => {
                        const isFile = /^(.*?)\.css$/.test(x);
                        const content = isFile
                            ? `@import url('${x}');`
                            : x;
                        this.styleElements = [
                            ...this.styleElements,
                            skate.h("style", content)
                        ];
                    });
                }
            }
            else {
                if (OverridingStyles._seenTags[elementName] !== true) {
                    OverridingStyles._seenTags[elementName] = true;
                    // multiple sheets can be provided so we need to queue them all up
                    const promises = [];
                    function fetchSheet(url) {
                        return new Promise(resolve => {
                            const xhr = new XMLHttpRequest();
                            xhr.onreadystatechange = () => {
                                if (xhr.readyState === XMLHttpRequest.DONE) {
                                    if (xhr.status === 200) {
                                        resolve(xhr.responseText);
                                    }
                                    else {
                                        resolve(`:host { content: 'Error: could not load stylesheet: ${url}' }`);
                                    }
                                }
                            };
                            xhr.open("GET", url);
                            xhr.send();
                        });
                    }
                    if (componentOverridingStyleSheets) {
                        componentOverridingStyleSheets.forEach(x => {
                            const isFile = /^(.*?)\.css$/.test(x);
                            const promise = isFile
                                ? fetchSheet(x)
                                : Promise.resolve(x);
                            promises.push(promise);
                        });
                    }
                    Promise
                        .all(promises)
                        .then(styles => {
                        // once we have all the CSS we need to mash them into a template element for the ShadyCSS polyfill
                        const $template = document.createElement("template");
                        // if component styles are available and the ComponentStylesMixin has been applied then we need to apply the styles here *before* we apply the overriding styles
                        if (this.componentStyles && this.componentStylesMixinApplied === true) {
                            $template.innerHTML += this.componentStyles;
                        }
                        if (styles.length > 0) {
                            const css = styles.join("\n");
                            $template.innerHTML += `<style>${css}</style>`;
                        }
                        if ($template.innerHTML.length) {
                            shadyCSS.prepareTemplate($template, elementName);
                        }
                    });
                }
            }
        }
        // used the inform other mixins of the presence of this one
        get overridingStylesMixinApplied() {
            return true;
        }
    }
    OverridingStyles._seenTags = {};
    return OverridingStyles;
}
exports.OverridingStylesMixin = OverridingStylesMixin;
// tslint:enable no-any


/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
// tslint:disable no-any
function RenderMixin(base) {
    class Render extends base {
        renderCallback() {
            const styles = ensureArray(this.styleElements || []);
            const html = ensureArray(this.componentMarkup
                ? this.componentMarkup() || []
                : []);
            return [
                ...styles,
                ...html
            ];
        }
    }
    function ensureArray(value) {
        return (value instanceof Array)
            ? value
            : [value];
    }
    return Render;
}
exports.RenderMixin = RenderMixin;
// tslint:enable no-any


/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var AppMode;
(function (AppMode) {
    // tslint:disable no-any
    AppMode[AppMode["Broadcaster"] = "broadcaster"] = "Broadcaster";
    AppMode[AppMode["Responder"] = "responder"] = "Responder";
    // tslint:enable no-any
})(AppMode = exports.AppMode || (exports.AppMode = {}));


/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// tslint:disable no-any

Object.defineProperty(exports, "__esModule", { value: true });
var ConnectionStatus;
(function (ConnectionStatus) {
    ConnectionStatus[ConnectionStatus["Connecting"] = "connecting"] = "Connecting";
    ConnectionStatus[ConnectionStatus["Connected"] = "connected"] = "Connected";
    ConnectionStatus[ConnectionStatus["Disconnected"] = "disconnected"] = "Disconnected";
    ConnectionStatus[ConnectionStatus["Disconnecting"] = "disconnecting"] = "Disconnecting";
})(ConnectionStatus = exports.ConnectionStatus || (exports.ConnectionStatus = {}));
// tslint:enable no-any


/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class DisconnectionStatus {
    constructor(wontReconnect, reason) {
        this.wontReconnect = wontReconnect;
        this.reason = reason;
    }
    getReason() {
        return this.reason;
    }
}
exports.DisconnectionStatus = DisconnectionStatus;


/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var RoomRole;
(function (RoomRole) {
    // tslint:disable no-any
    RoomRole[RoomRole["None"] = "none"] = "None";
    RoomRole[RoomRole["Participant"] = "participant"] = "Participant";
    RoomRole[RoomRole["Moderator"] = "moderator"] = "Moderator";
    // tslint:enable
})(RoomRole = exports.RoomRole || (exports.RoomRole = {}));


/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var UserAdditionalDetailsType;
(function (UserAdditionalDetailsType) {
    // tslint:disable no-any
    UserAdditionalDetailsType[UserAdditionalDetailsType["Contact"] = "contact"] = "Contact";
    UserAdditionalDetailsType[UserAdditionalDetailsType["VCard"] = "vcard"] = "VCard";
    UserAdditionalDetailsType[UserAdditionalDetailsType["Participant"] = "participant"] = "Participant";
    // tslint:enable no-any
})(UserAdditionalDetailsType = exports.UserAdditionalDetailsType || (exports.UserAdditionalDetailsType = {}));


/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const Logger_1 = __webpack_require__(10);
const utils_1 = __webpack_require__(18);
class BaseStore {
    constructor(name, logger, autoCompact = false, encryption = true) {
        this._saveToPersistentQueue = Promise.resolve();
        this._isDestoryingDb = false;
        this.name = name;
        this.logger = logger;
        this._autoCompact = autoCompact;
        this._encryption = encryption;
    }
    init() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._db) {
                yield this._createDb(this.name);
            }
            this.state = yield this.getFromPersistent();
        });
    }
    savePushNotificationToken(token) {
        return __awaiter(this, void 0, void 0, function* () {
            this.state.pushNotificationToken = token;
            yield this.saveToPersistent();
        });
    }
    getPushNotificationToken() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.state.pushNotificationToken;
        });
    }
    savePushNotificationAzureId(azureId) {
        return __awaiter(this, void 0, void 0, function* () {
            this.state.pushNotificationTokenAzureId = azureId;
            yield this.saveToPersistent();
        });
    }
    getPushNotificationAzureId() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.state.pushNotificationTokenAzureId;
        });
    }
    clearAllData() {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise(resolve => {
                localStorage.removeItem(this.name);
                if (this._db && !this._isDestoryingDb) {
                    this._isDestoryingDb = true;
                    this._db
                        .destroy()
                        .then(() => {
                        this._createDb(this.name);
                        return this.init();
                    })
                        .then(() => {
                        this._isDestoryingDb = false;
                        resolve();
                    });
                }
                else {
                    resolve();
                }
            });
        });
    }
    getLoggerTypes() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.state.loggerTypes;
        });
    }
    saveLoggerTypes(types) {
        return __awaiter(this, void 0, void 0, function* () {
            this.state.loggerTypes = types;
            return yield this.saveToPersistent();
        });
    }
    deleteLoggerTypes() {
        return __awaiter(this, void 0, void 0, function* () {
            delete this.state.loggerTypes;
            return yield this.saveToPersistent();
        });
    }
    getStateSnapshot() {
        return this.state;
    }
    getTheme() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.state.theme || "";
        });
    }
    saveTheme(theme) {
        return __awaiter(this, void 0, void 0, function* () {
            this.state.theme = theme;
            return yield this.saveToPersistent();
        });
    }
    getFromPersistent() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._db) {
                try {
                    return yield this._db.get(this.name);
                }
                catch (ex) {
                    const state = this.generateInitialState();
                    const res = yield this._db.put(state);
                    state._rev = res.rev;
                    return state;
                }
            }
            else {
                const state = localStorage.getItem(this.name)
                    ? JSON.parse(localStorage.getItem(this.name))
                    : this.generateInitialState();
            }
        });
    }
    saveToPersistent() {
        return __awaiter(this, void 0, void 0, function* () {
            clearTimeout(this._saveDebouncer);
            this._saveDebouncer = setTimeout(() => {
                if (this._db) {
                    this._saveToPersistentQueue = this._saveToPersistentQueue.then(() => __awaiter(this, void 0, void 0, function* () {
                        try {
                            const res = yield this._db.put(this.state);
                            this.state._rev = res.rev;
                            if (this.logger.shouldLog(Logger_1.LoggerTypes.DataStorage)) {
                                this.logger.log(Logger_1.LoggerTypes.DataStorage, "💾 %cSTATE UPDATED:", "color: #606; font-weight: bold;", { state: Object.assign({}, this.state) });
                            }
                        }
                        catch (ex) {
                            throw new Error(ex);
                        }
                    }));
                }
                else {
                    localStorage[this.name] = JSON.stringify(this.state);
                    if (this.logger.shouldLog(Logger_1.LoggerTypes.DataStorage)) {
                        this.logger.log(Logger_1.LoggerTypes.DataStorage, "💾 %cSTATE UPDATED:", "color: #606; font-weight: bold;", { state: Object.assign({}, this.state) });
                    }
                }
            }, 150);
        });
    }
    // === Private functions === //
    _createDb(name) {
        return __awaiter(this, void 0, void 0, function* () {
            if (window.PouchDB) {
                this.logger.log(Logger_1.LoggerTypes.DataStorage, `💾 %cUSING POUCHDB: %c${name}`, "color: #606; font-weight: bold;", "color: #999; font-weight: normal;");
                this._db = new window.PouchDB(`${name}`, {
                    revs_limit: 1,
                    auto_compaction: this._autoCompact
                });
                if (this._encryption === true) {
                    this.logger.log(Logger_1.LoggerTypes.DataStorage, `💾 %cENCRYPTING POUCHDB...`, "color: #606; font-weight: bold;", "color: #999; font-weight: normal;");
                    // tslint:disable-next-line no-any
                    const keyBuffer = yield utils_1.getEncryptionKey(name + "_pg_layer");
                    this._db.crypto({ key: keyBuffer });
                }
            }
            else {
                this.logger.log(Logger_1.LoggerTypes.DataStorage, "💾 %cCANNOT FIND POUCHDB, USING LOCAL STORAGE INSTEAD", "color: #606; font-weight: bold;");
            }
        });
    }
}
exports.BaseStore = BaseStore;


/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const Logger_1 = __webpack_require__(10);
const BaseComms_1 = __webpack_require__(45);
class Comms extends BaseComms_1.BaseComms {
    constructor(name, xmpp, store, logger) {
        // Force message carbons to always be enabled
        xmpp.enableMessageCarbons = true;
        super(name, xmpp, store, logger);
    }
    getMessagesFromMam(jid) {
        return __awaiter(this, void 0, void 0, function* () {
            this.logger.log(Logger_1.LoggerTypes.Mam, `%c📫 FETCHING MESSAGES FROM THE MAM`, "color: #669; font-weight: bold;");
            this.triggerFetchingMissedMessagesState(true);
            try {
                const messages = yield this.queryMam(null, this.client.getLastArchiveId(), null, null, false);
                this.logger.log(Logger_1.LoggerTypes.Mam, `%c📬 FOUND ${messages.length} MESSAGE(S) IN THE MAM`, "color: #669; font-weight: bold;", [...messages]);
                this.logger.log(Logger_1.LoggerTypes.Mam, `%c📪 FINISHED FETCHING MESSAGES FROM THE MAM`, "color: #669; font-weight: bold;");
                return messages;
            }
            catch (ex) {
                this.logger.error(ex);
                throw ex;
            }
            finally {
                this.triggerFetchingMissedMessagesState(false);
            }
        });
    }
    getAllContactVCards() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield this.client.getvCardsForAllContacts();
            }
            catch (ex) {
                this.logger.error(ex);
                throw ex;
            }
        });
    }
    // tslint:disable-next-line no-any
    embelishUser(user, participant) {
        return __awaiter(this, void 0, void 0, function* () {
            if (participant.vCard) {
                user.vCard = participant.vCard;
            }
            return user;
        });
    }
    downloadAttachments(messageId) {
        return __awaiter(this, void 0, void 0, function* () {
            const message = yield this.client.getMessageById(messageId);
            return yield this.client.downloadAttachments(message, true);
        });
    }
    purgeOldMessages() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.purgeOldMessages();
        });
    }
}
exports.Comms = Comms;


/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = __webpack_require__(5);
class BasePageEventArgs extends events_1.BaseEventArgs {
    constructor(messageId) {
        super();
        this.messageId = messageId;
    }
}
exports.BasePageEventArgs = BasePageEventArgs;


/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = __webpack_require__(5);
class ReadPageDetailEventArgs extends events_1.BaseEventArgs {
    constructor(page) {
        super();
        this.page = page;
    }
}
exports.ReadPageDetailEventArgs = ReadPageDetailEventArgs;


/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = __webpack_require__(5);
class SendNewPageEventArgs extends events_1.BaseEventArgs {
    constructor(page) {
        super();
        this.page = page;
    }
}
exports.SendNewPageEventArgs = SendNewPageEventArgs;


/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = __webpack_require__(5);
class SendPageResponseEventArgs extends events_1.BaseEventArgs {
    constructor(pageId, response, sender, isTestPage = false) {
        super();
        this.response = response;
        this.pageId = pageId;
        this.sender = sender;
        this.isTestPage = isTestPage;
    }
}
exports.SendPageResponseEventArgs = SendPageResponseEventArgs;


/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const handlers_1 = __webpack_require__(8);
const models_1 = __webpack_require__(2);
const Events_1 = __webpack_require__(6);
class ConnectivityHandler extends handlers_1.BaseHandler {
    constructor() {
        super(...arguments);
        this.messageKey = null;
        this.eventType = [
            Events_1.PagerEvents._Request_Logout,
            Events_1.PagerEvents.LoginResult
        ];
    }
    createMessage(data) {
        return {};
    }
    handleMessage(message) {
        return __awaiter(this, void 0, void 0, function* () {
        });
    }
    handleMessageUpdate(message) {
        return __awaiter(this, void 0, void 0, function* () {
        });
    }
    handleMessageReceipt(message) {
        return __awaiter(this, void 0, void 0, function* () {
        });
    }
    handleEvent(eventType, eventData) {
        return __awaiter(this, void 0, void 0, function* () {
            if (eventType === Events_1.PagerEvents._Request_Logout) {
                this.layer.emit(Events_1.PagerEvents._Request_RaiseAlert, models_1.DefaultAlerts.AlertYesNoQuestion("Logout", "Do you wish to logout?", 1, {
                    yes: () => __awaiter(this, void 0, void 0, function* () {
                        yield this.layer.comms.logout(true);
                        yield this.layer.clearAllData();
                        // Emit clear data event to clear down all components that are listening
                        this.layer.emit(Events_1.PagerEvents._Request_Component_Clear_Data);
                        this.layer.emit(Events_1.PagerEvents.LogoutRequestConfirmed);
                    })
                }));
            }
        });
    }
}
exports.ConnectivityHandler = ConnectivityHandler;


/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const handlers_1 = __webpack_require__(8);
const pagerLayer_1 = __webpack_require__(17);
const Handlers_1 = __webpack_require__(11);
const pagerUtils_1 = __webpack_require__(9);
class DiagnosticsRequestHandler extends handlers_1.BaseHandler {
    constructor() {
        super(...arguments);
        this.messageKey = Handlers_1.PagerMessageTypes.DiagnosticsRequest;
        this.eventType = [];
    }
    createMessage(data) {
        return data;
    }
    handleMessage(message) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = message.data[this.messageKey];
            if (data.enableLogging === true) {
                this.layer.setSupportLoggingTypes(["_all_"]); // turn on all message types
            }
            else {
                this.layer.resetSupportLogging();
            }
            const response = {
                currentUser: this.layer.getCurrentUserJid(),
                config: this.layer.config,
                state: this.layer.store.getStateSnapshot(),
                pagerVersion: pagerLayer_1.PagerLayer.VERSION,
                appVersion: ""
            };
            if (window.cti) {
                response.appVersion = window.cti.store.schema.version;
            }
            const addresses = [pagerUtils_1.createAddressFromJid(message.sender_id)];
            this.layer.sendMulticastMessage(Handlers_1.PagerMessageTypes.DiagnosticsRequest, response, addresses);
        });
    }
    handleMessageUpdate(message) {
        return __awaiter(this, void 0, void 0, function* () {
        });
    }
    handleMessageReceipt(message) {
        return __awaiter(this, void 0, void 0, function* () {
        });
    }
    handleEvent(eventType, eventData) {
        return __awaiter(this, void 0, void 0, function* () {
        });
    }
}
exports.DiagnosticsRequestHandler = DiagnosticsRequestHandler;


/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const handlers_1 = __webpack_require__(8);
class PushNotificationResponseHandler extends handlers_1.BaseHandler {
    constructor() {
        super(...arguments);
        this.messageKey = "json";
        this.eventType = [];
    }
    createMessage(data) {
        return {};
    }
    handleMessage(message) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = message.data[this.messageKey];
            switch (data.data.type) {
                case "register":
                    yield this.layer.store.savePushNotificationAzureId(data.data.RegistrationId);
                    break;
                // We should never hit this during a logout event
                case "remove":
                    yield this.layer.store.savePushNotificationAzureId("");
                    break;
            }
        });
    }
    handleMessageUpdate(message) {
        return __awaiter(this, void 0, void 0, function* () {
        });
    }
    handleMessageReceipt(message) {
        return __awaiter(this, void 0, void 0, function* () {
        });
    }
    handleEvent(eventType, eventData) {
        return __awaiter(this, void 0, void 0, function* () {
        });
    }
}
exports.PushNotificationResponseHandler = PushNotificationResponseHandler;


/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const handlers_1 = __webpack_require__(8);
const Events_1 = __webpack_require__(6);
class ReadPageDetailHandler extends handlers_1.BaseHandler {
    constructor() {
        super(...arguments);
        this.messageKey = null;
        this.eventType = [
            Events_1.PagerEvents._Request_ReadPageDetail
        ];
    }
    createMessage(data) {
        return {};
    }
    handleMessage(message) {
        return __awaiter(this, void 0, void 0, function* () {
        });
    }
    handleMessageUpdate(message) {
        return __awaiter(this, void 0, void 0, function* () {
        });
    }
    handleMessageReceipt(message) {
        return __awaiter(this, void 0, void 0, function* () {
        });
    }
    handleEvent(eventType, eventData) {
        return __awaiter(this, void 0, void 0, function* () {
            if (eventType === Events_1.PagerEvents._Request_ReadPageDetail) {
                const data = eventData;
                if (this.layer.config.isBroadcaster) {
                    this.layer.emit(Events_1.PagerEvents._Request_OpenBroadcasterReadModal, data.page);
                }
                else {
                    this.layer.emit(Events_1.PagerEvents._Request_OpenClientReadModal, data.page);
                }
            }
        });
    }
}
exports.ReadPageDetailHandler = ReadPageDetailHandler;


/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const handlers_1 = __webpack_require__(8);
const _1 = __webpack_require__(11);
const Events_1 = __webpack_require__(6);
const pagerUtils_1 = __webpack_require__(9);
class ReceiveNewPageHandler extends handlers_1.BaseHandler {
    constructor() {
        super(...arguments);
        this.messageKey = _1.PagerMessageTypes.NewPage;
        this.eventType = [];
    }
    createMessage(data) {
        return Object.assign({}, data.page);
    }
    handleMessage(message) {
        return __awaiter(this, void 0, void 0, function* () {
            const page = message.data[this.messageKey];
            page.messageId = message._id;
            page.ts = message.ts;
            const existing = yield this._getPageIfExists(page._id);
            if (!existing) {
                page.messageSplit = pagerUtils_1.parseMessageContent(page.message);
                yield this.layer.store.addPage(page);
                yield this.layer.purgeOldPages(true);
                if (!this.layer.config.isBroadcaster) {
                    yield this.layer.store.addToPendingPages(page);
                    this.layer.sendReadReceipt(page);
                }
                this.layer.emit(Events_1.PagerEvents.NewPageReceived, page);
            }
        });
    }
    handleMessageUpdate(message) {
        return __awaiter(this, void 0, void 0, function* () {
            const page = message.data[this.messageKey];
            let existing = yield this._getPageIfExists(page._id);
            if (existing) {
                if (existing.attachmentsLoaded === false) {
                    if (message.attachments.length > 0) {
                        existing = pagerUtils_1.addAttachmentsToPage(message, existing);
                        yield this.layer.store.updatePage(existing);
                    }
                }
                this.layer.emit(Events_1.PagerEvents.PageUpdate, existing);
            }
        });
    }
    handleMessageReceipt(receipt) {
        return __awaiter(this, void 0, void 0, function* () {
        });
    }
    handleEvent(eventType, eventData) {
        return __awaiter(this, void 0, void 0, function* () {
        });
    }
    // === Private Methods === //
    _getPageIfExists(id) {
        return __awaiter(this, void 0, void 0, function* () {
            const allPages = yield this.layer.getPages();
            const existing = allPages.find(x => x._id === id);
            return existing || null;
        });
    }
}
exports.ReceiveNewPageHandler = ReceiveNewPageHandler;


/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const handlers_1 = __webpack_require__(8);
const models_1 = __webpack_require__(2);
const _1 = __webpack_require__(11);
const Models_1 = __webpack_require__(7);
const Events_1 = __webpack_require__(6);
const utils_1 = __webpack_require__(3);
const pagerUtils_1 = __webpack_require__(9);
class SendNewPageHandler extends handlers_1.BaseHandler {
    constructor() {
        super(...arguments);
        this.messageKey = null;
        this.eventType = [
            Events_1.PagerEvents._Request_SendNewPage
        ];
    }
    createMessage(data) {
        return {};
    }
    handleMessage(message) {
        return __awaiter(this, void 0, void 0, function* () {
        });
    }
    handleMessageUpdate(message) {
        return __awaiter(this, void 0, void 0, function* () {
        });
    }
    handleMessageReceipt(message) {
        return __awaiter(this, void 0, void 0, function* () {
        });
    }
    handleEvent(eventType, eventData) {
        return __awaiter(this, void 0, void 0, function* () {
            if (eventType === Events_1.PagerEvents._Request_SendNewPage) {
                const data = eventData;
                try {
                    data.page._id = utils_1.generateRandomSixString();
                    data.page.individuals = [];
                    data.page.to.map(to => {
                        data.page.individuals = [...data.page.individuals, ...to.contacts];
                    });
                    const individualsAndConsoles = [...yield this.layer.getAllContacts(true, Models_1.FilterType.Include), ...data.page.individuals];
                    const addresses = pagerUtils_1.convertContactsIntoAddressList(individualsAndConsoles);
                    const attachments = data.page.image.concat(data.page.audio);
                    const existing = yield this.layer.store.getPageById(data.page._id);
                    if (!existing) {
                        try {
                            const message = yield this.layer.sendMulticastMessage(_1.PagerMessageTypes.NewPage, { page: data.page }, addresses, attachments);
                            data.page.messageId = message._id;
                            yield this.layer.store.addPage(data.page);
                            yield this.layer.purgeOldPages(true);
                            this.layer.emit(Events_1.PagerEvents.PageUpdate, data.page);
                            setTimeout(() => this.layer.emit(Events_1.PagerEvents._Request_CloseSendNewPageModal), 2000);
                        }
                        catch (ex) {
                            this.layer.emit(Events_1.PagerEvents.SendingPageError, ex);
                        }
                    }
                }
                catch (ex) {
                    this.layer.emit(Events_1.PagerEvents._Request_RaiseAlert, models_1.DefaultAlerts.AlertErrorWithOkayButton("Send Error", ex, 1, {}));
                }
            }
        });
    }
}
exports.SendNewPageHandler = SendNewPageHandler;


/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const handlers_1 = __webpack_require__(8);
const models_1 = __webpack_require__(2);
const _1 = __webpack_require__(11);
const Models_1 = __webpack_require__(7);
const Events_1 = __webpack_require__(6);
const pagerUtils_1 = __webpack_require__(9);
class SendPageResponseHandler extends handlers_1.BaseHandler {
    constructor() {
        super(...arguments);
        this.testMessageResponseQueue = Promise.resolve();
        this.messageKey = _1.PagerMessageTypes.PageResponse;
        this.eventType = [
            Events_1.PagerEvents.PageResponse
        ];
    }
    createMessage(data) {
        return data;
    }
    handleMessage(message) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = message.data[this.messageKey];
            let page = yield this.layer.store.getPageById(data.pageId);
            if (page) {
                page = yield this.layer.addContactResponseToPage(page, data.response, data.from);
                if (data.from === this.layer.getCurrentUserJid() && !this.layer.config.isBroadcaster) {
                    if (data.response.type === Models_1.ContactResponseType.Response) {
                        yield this.layer.store.removePendingPage(data.pageId);
                        this.layer.emit(Events_1.PagerEvents.RespondedToPage, data.pageId);
                        const pendingPages = yield this.layer.getPendingPages();
                        if (pendingPages.length === 0) {
                            this.layer.emit(Events_1.PagerEvents.RespondedToAllPages);
                        }
                    }
                }
                this.layer.emit(Events_1.PagerEvents.PageUpdate, page);
            }
        });
    }
    handleMessageUpdate(message) {
        return __awaiter(this, void 0, void 0, function* () {
        });
    }
    handleMessageReceipt(message) {
        return __awaiter(this, void 0, void 0, function* () {
        });
    }
    handleEvent(eventType, eventData) {
        return __awaiter(this, void 0, void 0, function* () {
            if (eventType === Events_1.PagerEvents.PageResponse && !this.layer.config.isBroadcaster) {
                const data = eventData;
                try {
                    const response = {
                        pageId: data.pageId,
                        response: data.response,
                        from: this.layer.getCurrentUserJid()
                    };
                    if (!data.isTestPage) {
                        const consoleUsers = yield this.layer.getAllContacts(true, Models_1.FilterType.Include);
                        const addresses = [...pagerUtils_1.convertContactsIntoAddressList(consoleUsers)];
                        yield this._processAndSendPageResponse(data, response, addresses);
                    }
                    else {
                        // Test pages only - send response back to originator
                        const addresses = [{
                                type: "to",
                                jid: data.sender
                            }];
                        // Send read response
                        yield this._processAndSendPageResponse(data, response, addresses);
                        this.testMessageResponseQueue = this.testMessageResponseQueue.then(() => __awaiter(this, void 0, void 0, function* () {
                            // Wait 1 second and send response
                            setTimeout(() => __awaiter(this, void 0, void 0, function* () {
                                // Send fake response
                                const fakeResponse = {
                                    pageId: response.pageId,
                                    response: {
                                        type: Models_1.ContactResponseType.Response,
                                        ts: new Date().getTime(),
                                        content: "Fake Response"
                                    },
                                    from: response.from
                                };
                                return yield this._processAndSendPageResponse(data, fakeResponse, addresses);
                            }), this.layer.config.testingResponseDelay || 1000);
                        }));
                    }
                }
                catch (ex) {
                    this.layer.emit(Events_1.PagerEvents._Request_RaiseAlert, models_1.DefaultAlerts.AlertErrorWithOkayButton("Send Error", ex, 1, {}));
                }
            }
        });
    }
    _processAndSendPageResponse(data, response, addresses) {
        return __awaiter(this, void 0, void 0, function* () {
            const page = yield this.layer.store.getPageById(data.pageId);
            if (page) {
                yield this.layer.addContactResponseToPage(page, response.response, response.from);
                yield this.layer.sendMulticastMessage(_1.PagerMessageTypes.PageResponse, response, addresses);
                if (response.response.type === Models_1.ContactResponseType.Response) {
                    yield this.layer.store.removePendingPage(data.pageId);
                    this.layer.emit(Events_1.PagerEvents.PageUpdate, null);
                    this.layer.emit(Events_1.PagerEvents.RespondedToPage, data.pageId);
                    const pendingPages = yield this.layer.getPendingPages();
                    if (pendingPages.length === 0) {
                        this.layer.emit(Events_1.PagerEvents.RespondedToAllPages);
                    }
                }
            }
        });
    }
}
exports.SendPageResponseHandler = SendPageResponseHandler;


/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const handlers_1 = __webpack_require__(8);
const Handlers_1 = __webpack_require__(11);
class StartTestModeHandler extends handlers_1.BaseHandler {
    constructor() {
        super(...arguments);
        this.messageKey = Handlers_1.PagerMessageTypes.StartTest;
        this.eventType = [];
    }
    createMessage(data) {
        return {};
    }
    handleMessage(message) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = message.data[this.messageKey];
            this.layer.config.testingResponseDelay = data.responseDelay;
            this.layer.sendMessage(Handlers_1.PagerMessageTypes.StartTest, message.sender_id, { ready: true });
        });
    }
    handleMessageUpdate(message) {
        return __awaiter(this, void 0, void 0, function* () {
        });
    }
    handleMessageReceipt(message) {
        return __awaiter(this, void 0, void 0, function* () {
        });
    }
    handleEvent(eventType, eventData) {
        return __awaiter(this, void 0, void 0, function* () {
        });
    }
}
exports.StartTestModeHandler = StartTestModeHandler;


/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var ContactResponseType;
(function (ContactResponseType) {
    // tslint:disable no-any
    ContactResponseType[ContactResponseType["Received"] = "received"] = "Received";
    ContactResponseType[ContactResponseType["Response"] = "response"] = "Response";
    // tslint:enable no-any
})(ContactResponseType = exports.ContactResponseType || (exports.ContactResponseType = {}));


/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var DeviceType;
(function (DeviceType) {
    // tslint:disable no-any
    DeviceType[DeviceType["Android"] = "android"] = "Android";
    DeviceType[DeviceType["Electron"] = "electon"] = "Electron";
    DeviceType[DeviceType["iOS"] = "ios"] = "iOS";
    // tslint:enable no-any
})(DeviceType = exports.DeviceType || (exports.DeviceType = {}));


/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var FilterType;
(function (FilterType) {
    // tslint:disable no-any
    FilterType[FilterType["Exclude"] = "exclude"] = "Exclude";
    FilterType[FilterType["Include"] = "get"] = "Include";
    // tslint:enable no-any
})(FilterType = exports.FilterType || (exports.FilterType = {}));


/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var ResponseStatus;
(function (ResponseStatus) {
    // tslint:disable no-any
    ResponseStatus[ResponseStatus["NotReceivedNotification"] = "not-received"] = "NotReceivedNotification";
    ResponseStatus[ResponseStatus["Received"] = "received"] = "Received";
    ResponseStatus[ResponseStatus["Displayed"] = "displayed"] = "Displayed";
    ResponseStatus[ResponseStatus["Unable"] = "unable"] = "Unable";
    ResponseStatus[ResponseStatus["Attending"] = "attending"] = "Attending";
    ResponseStatus[ResponseStatus["Acknowledged"] = "acknowledged"] = "Acknowledged";
    ResponseStatus[ResponseStatus["AutoDismissed"] = "auto-dismissed"] = "AutoDismissed";
    // tslint:enable no-any
})(ResponseStatus = exports.ResponseStatus || (exports.ResponseStatus = {}));


/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const BaseStore_1 = __webpack_require__(63);
class Store extends BaseStore_1.BaseStore {
    constructor(name, logger, config) {
        super(name, logger, true, config.xmpp.encryption);
        this.config = config;
    }
    purgeOldPages(save = false) {
        return __awaiter(this, void 0, void 0, function* () {
            const ts = new Date().getTime() - this.config.xmpp.maxMessageAge;
            const pagesToDelete = [];
            // Purge any pages outside of the max message age
            this.state.pages = this.state.pages
                .sort((a, b) => b.openedDate - a.openedDate)
                .reduce((acc, cur) => {
                if (cur.openedDate > ts) {
                    acc.push(cur);
                }
                else {
                    pagesToDelete.push(cur);
                }
                return acc;
            }, []);
            // Purge any pending pages that have been removed
            if (pagesToDelete.length) {
                this.state.pendingPages = this.state.pendingPages.reduce((acc, cur) => {
                    if (!pagesToDelete.find(p => p._id === cur)) {
                        acc.push(cur);
                    }
                    return acc;
                }, []);
            }
            return (save) ? yield this.saveToPersistent() : Promise.resolve();
        });
    }
    setSelectedContacts(selectedContacts) {
        return __awaiter(this, void 0, void 0, function* () {
            this.state.selectedContacts = selectedContacts;
            yield this.saveToPersistent();
        });
    }
    getSelectedContacts() {
        return __awaiter(this, void 0, void 0, function* () {
            const contactDisplay = yield this.state.selectedContacts;
            contactDisplay.map(contactDisplay => {
                contactDisplay.contacts.map(contact => {
                    contact.responses = [];
                    return contact;
                });
            });
            return contactDisplay;
        });
    }
    addPage(page) {
        return __awaiter(this, void 0, void 0, function* () {
            this.state.pages = [
                page,
                ...this.state.pages
            ];
            yield this.saveToPersistent();
        });
    }
    updatePage(page) {
        return __awaiter(this, void 0, void 0, function* () {
            const idx = this.state.pages.findIndex(x => x._id === page._id);
            if (idx > -1) {
                this.state.pages[idx] = page;
                yield this.saveToPersistent();
            }
        });
    }
    addOrUpdatePage(page) {
        return __awaiter(this, void 0, void 0, function* () {
            const idx = this.state.pages.findIndex(x => x._id === page._id);
            if (idx > -1) {
                this.state.pages[idx] = page;
                this.state.pages = this.state.pages.sort((a, b) => b.openedDate - a.openedDate);
                yield this.saveToPersistent();
            }
            else {
                this.addPage(page);
            }
        });
    }
    getPages(jid, isBroadcaster = false, amountToGet, offset) {
        const count = amountToGet || this.state.pages.length;
        const skip = offset || 0;
        if (isBroadcaster) {
            return this.state.pages.slice(0, count);
        }
        else {
            // Only return Pages sent to or by the current user
            // const filtered: Page[] = this.state.pages.filter(x => x.sender === jid || x.individuals.find(c => c.id === jid));
            return this.state.pages.slice(skip, count);
        }
    }
    getPageById(id) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.state.pages.find(x => x._id === id);
        });
    }
    setSelectedPage(page) {
        return __awaiter(this, void 0, void 0, function* () {
            this.state.selectedPage = page;
            yield this.saveToPersistent();
        });
    }
    getSelectedPage() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.state.selectedPage;
        });
    }
    addToPendingPages(page) {
        return __awaiter(this, void 0, void 0, function* () {
            this.state.pendingPages = [
                page._id,
                ...this.state.pendingPages
            ];
            yield this.saveToPersistent();
        });
    }
    getPendingPages(jid) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.state.pages
                .reduce((acc, cur) => {
                if (this.state.pendingPages.includes(cur._id)) {
                    acc.push(cur);
                }
                return acc;
            }, [])
                .filter(x => x.sender === jid || x.individuals.find(c => c.id === jid))
                .sort((a, b) => b.openedDate - a.openedDate);
        });
    }
    deletePage(page) {
        return __awaiter(this, void 0, void 0, function* () {
            const idx = this.state.pages.findIndex(x => x._id === page._id);
            if (idx > -1) {
                this.state.pages.splice(idx, 1);
            }
            yield this.saveToPersistent();
        });
    }
    addContactResponseToPage(page, response, jid) {
        return __awaiter(this, void 0, void 0, function* () {
            const existingPage = this.state.pages.find(x => x._id === page._id);
            if (existingPage) {
                const contact = existingPage.individuals.find(x => x.id === jid);
                if (contact) {
                    const existingResponse = contact.responses.find(x => x.type === response.type);
                    if (!existingResponse) {
                        contact.responses.push(response);
                        yield this.saveToPersistent();
                    }
                }
                return existingPage;
            }
            else
                return null;
        });
    }
    removePendingPage(id) {
        return __awaiter(this, void 0, void 0, function* () {
            this.state.pendingPages = this.state.pendingPages.filter((pageId) => pageId !== id ? pageId : null);
            yield this.saveToPersistent();
        });
    }
    addToPageResponseQueue(item) {
        return __awaiter(this, void 0, void 0, function* () {
            this.state.pageResponseQueue.push(item);
            yield this.saveToPersistent();
        });
    }
    removeFromPageResponseQueue(item) {
        return __awaiter(this, void 0, void 0, function* () {
        });
    }
    // === Abstract function implementations === //
    generateInitialState() {
        return {
            _id: this.name,
            _rev: "",
            selectedContacts: [],
            pages: [],
            selectedPage: null,
            pendingPages: [],
            pageResponseQueue: []
        };
    }
}
exports.Store = Store;


/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const pagerLayer_1 = __webpack_require__(17);
const Models_1 = __webpack_require__(7);
const pagerUtils_1 = __webpack_require__(9);
const utils_1 = __webpack_require__(3);
const Events_1 = __webpack_require__(6);
/**
 * A helper function that will create and send random messages
 * This will return null and cancel if there is no pager layer present
 *
 * @param count - number of messages to send
 * @param delay - delay between sending each message (in seconds)
 * @param to - an array of jids to send the messages to
 */
function sendBatchMessages(count = 1, delay = 0, to = ["all"]) {
    return __awaiter(this, void 0, void 0, function* () {
        const layer = getPagerLayer();
        const messages = yield createFakePages(to, count);
        if (!layer || !messages)
            return;
        let sentCount = 0;
        setInterval(() => {
            while (sentCount < messages.length) {
                const msg = messages[sentCount];
                layer.emit(Events_1.PagerEvents._Request_SendNewPage, new Events_1.SendNewPageEventArgs(msg));
                ++sentCount;
            }
        }, (delay * 1000));
    });
}
exports.sendBatchMessages = sendBatchMessages;
/**
 * A helper function that will create fake pages, ready for sending.
 * This will return null and cancel if there is no pager layer present
 *
 * @param to - a string array of jids that each message will be sent to
 * @param count - a count of fake pages to create
 */
function createFakePages(to = ["all"], count = 1) {
    return __awaiter(this, void 0, void 0, function* () {
        const layer = getPagerLayer();
        if (!layer)
            return null;
        const messages = [];
        const pageTemplateLength = layer.config.pageTypes.length;
        const replyTemplateLength = layer.config.replyTemplates.length;
        const contacts = yield layer.getAllContacts(true);
        let selectedContacts = [];
        if (to.includes("all")) {
            selectedContacts = pagerUtils_1.convertContacts({}, contacts, true);
        }
        else {
            to.map(x => contacts.find(c => c.jid === x).selected = true);
            selectedContacts = pagerUtils_1.convertContacts({}, contacts);
        }
        for (let i = 0; i < count; i++) {
            const type = utils_1.randomNumberBetween(0, pageTemplateLength);
            const reply = utils_1.randomNumberBetween(0, replyTemplateLength);
            const newPage = {
                to: selectedContacts,
                type: type,
                replyTemplate: reply,
                subject: `Test Message Subject: ${i}`,
                message: `Test Message Body: ${i}`,
                image: [],
                audio: []
            };
            const page = pagerUtils_1.createNewPage(newPage, layer.getCurrentUserJid(), layer.config.pageTypes[type], layer.config.replyTemplates[reply]);
            messages.push(page);
        }
        return messages;
    });
}
exports.createFakePages = createFakePages;
/**
 * Gets the first available pager layer or returns null if there isn't one
 */
function getPagerLayer() {
    const ctLayers = window.__CTLayers;
    for (const i in ctLayers) {
        if (ctLayers[i].instance instanceof pagerLayer_1.PagerLayer) {
            return ctLayers[i].instance;
        }
    }
    return null;
}
exports.getPagerLayer = getPagerLayer;
/**
 * A helper function that will automatically respond to every pending page
 */
function respondToAllPendingMessages() {
    return __awaiter(this, void 0, void 0, function* () {
        const layer = getPagerLayer();
        const pending = yield layer.getPendingPages();
        pending.map((x) => __awaiter(this, void 0, void 0, function* () {
            const response = {
                ts: new Date().getTime(),
                content: "Test Response",
                type: Models_1.ContactResponseType.Response
            };
            yield layer.addContactResponseToPage(x, response);
            layer.emit(Events_1.PagerEvents.PageResponse, new Events_1.SendPageResponseEventArgs(x._id, response, x.sender));
        }));
    });
}
exports.respondToAllPendingMessages = respondToAllPendingMessages;


/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const base_1 = __webpack_require__(0);
const events_1 = __webpack_require__(5);
const Alert_1 = __webpack_require__(25);
const components_1 = __webpack_require__(1);
class CTAlertModalManager extends base_1.CTLayerComponent {
    static get is() {
        return "ct-alert-modal-manager";
    }
    // === End properties === //
    initialize() {
        return __awaiter(this, void 0, void 0, function* () {
        });
    }
    setupListeners() {
        this.addListener(events_1.BaseEvents._Request_RaiseAlert, (e) => this.raiseAlert(e));
        this.addListener(events_1.BaseEvents._Request_CloseAlert, (e) => this.dismissAlertById(e));
    }
    get generateComponentStyles() {
        return `:host{color:#333536;font-weight:400}:host h1,:host h2,:host h3,:host h4,:host h5,:host h6{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}:host,:host *{box-sizing:border-box}.user-html p{margin:0}.user-html p+p{margin:.8em 0 0 0}.user-html strong{font-weight:600}:host{display:none;width:100%;height:100%;background:var(--modal-overlay, rgba(0,0,0,0.5));position:fixed;top:0;z-index:1000;padding:20px;overflow:auto}:host .alerts{display:flex;width:100%;max-width:420px;margin:auto;position:relative}:host([alerts-to-show]){display:flex}
        `;
    }
    generateComponentMarkup() {
        return (window.__CTRender("div", { class: "alerts" }, this.alerts.map((alert, idx) => window.__CTRender(components_1.CTAlertModal, { id: alert.id || Alert_1.DefaultAlerts.generateId(), raisedOn: alert.raisedOn, priority: alert.priority, type: alert.type, title: alert.title, body: alert.body, buttons: alert.buttons, remaining: this.alerts.length, positionInStack: idx, showLoadingAnimation: alert.showLoadingAnimation }))));
    }
    // === Public functions === //
    raiseAlert(alert) {
        if (!alert)
            return;
        if (alert.buttons) {
            for (const b of alert.buttons) {
                if (!b.action) {
                    b.action = () => this.dismissAlert();
                }
                else {
                    const buttonAction = b.action.bind(this);
                    b.action = (e) => {
                        buttonAction(e);
                        this.dismissAlert();
                    };
                }
            }
        }
        this.alerts = [...this.alerts, alert];
        this.alertsToShow = true;
    }
    dismissAlert(index = 0) {
        this.alerts.splice(index, 1);
        if (this.alerts.length === 0)
            this.alertsToShow = false;
        else {
            this.alerts = this.alerts.map((alert, idx) => {
                alert.remaining = this.alerts.length;
                return alert;
            });
        }
    }
    dismissAlertById(id) {
        const idx = this.alerts.findIndex(x => x.id === id);
        if (idx !== -1) {
            this.dismissAlert(idx);
        }
    }
}
__decorate([
    base_1.prop({ type: Boolean, attribute: true, default: false })
], CTAlertModalManager.prototype, "alertsToShow", void 0);
__decorate([
    base_1.prop({ type: Array, attribute: false, default: [] })
], CTAlertModalManager.prototype, "alerts", void 0);
exports.CTAlertModalManager = CTAlertModalManager;
CTAlertModalManager.register();


/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const base_1 = __webpack_require__(0);
const Icons_1 = __webpack_require__(26);
const components_1 = __webpack_require__(1);
const renderUtils_1 = __webpack_require__(4);
class CTAlertModal extends base_1.CTLayerComponent {
    static get is() {
        return "ct-alert-modal";
    }
    initialize() {
        return __awaiter(this, void 0, void 0, function* () {
        });
    }
    setupListeners() {
    }
    get generateComponentStyles() {
        return `:host{color:#333536;font-weight:400}:host h1,:host h2,:host h3,:host h4,:host h5,:host h6{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}:host,:host *{box-sizing:border-box}.user-html p{margin:0}.user-html p+p{margin:.8em 0 0 0}.user-html strong{font-weight:600}:host{display:none;width:100%;height:100%;flex-direction:column;background-color:var(--modal-bg, #fff)}:host .alert-dialog{overflow:hidden}:host .alert-dialog .remaining{position:absolute;width:35px;height:35px;background-color:red;border-radius:50%;text-align:center;line-height:35px;color:white;right:-5%;top:-5%}:host .alert-dialog .title{display:flex;justify-content:center;text-align:center;font-size:16px;text-transform:uppercase;margin:0 auto;padding:10px}:host .alert-dialog .body{display:flex;justify-content:center;text-align:center;align-items:flex-start;font-size:18px;font-weight:300;padding:50px}:host .alert-dialog .body ct-icon{flex:none;margin:3px 10px 0 0}:host .alert-dialog .buttons{padding:10px 5px;flex:none;display:flex;flex-wrap:wrap;flex-direction:row;justify-content:space-between}:host .alert-dialog .buttons ct-button{flex:1;margin:0 5px}:host .alert-dialog .buttons ct-button.overflex{flex-basis:100%}:host .alert-dialog .buttons ct-button.overflex+ct-button{margin-top:10px}:host .alert-dialog.error .title{background-color:var(--alert-error-bg, #c80031);color:var(--alert-error-text, #fff)}:host .alert-dialog.info .title{background-color:var(--alert-info-bg, #15233b);color:var(--alert-info-text, #fff)}:host .alert-dialog.question .title{background-color:var(--alert-question-bg, #15233b);color:var(--alert-question-text, #fff)}:host .alert-dialog.success .title{background-color:var(--alert-success-bg, #bcdf90);color:var(--alert-success-text, #fff)}:host([showing]){display:flex;z-index:10}:host([stacked]){display:flex;position:absolute;bottom:5px;right:5px;z-index:1}:host([stacked]):before{content:'';display:block;position:absolute;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.25)}
        `;
    }
    generateComponentMarkup() {
        const loadingSpinnerIcon = Icons_1.Icons.COMMON.LoadingSpinner;
        const offset = (this.positionInStack * 5);
        this.style.right = `${offset}px`;
        this.style.bottom = `${offset}px`;
        this.style.zIndex = `${this.remaining - this.positionInStack}`;
        if (this.positionInStack === 0)
            this.showing = true;
        else
            this.stacked = true;
        return (window.__CTRender("div", { "alert-id": this.id, class: `alert-dialog ${this.type}` },
            this.remaining > 1 && this.showing
                ? window.__CTRender("div", { class: "remaining" }, this.remaining)
                : null,
            window.__CTRender("div", { class: "title" }, this.renderHtml(this.title)),
            window.__CTRender("div", { class: "body" },
                renderUtils_1.renderIf(this.showLoadingAnimation, window.__CTRender(components_1.CTIcon, { class: "loading", width: "18", height: "18", spin: true, icon: loadingSpinnerIcon })),
                window.__CTRender("div", { class: "message" }, this.renderHtml(this.body))),
            renderUtils_1.renderIf(!!this.buttons && this.buttons.length > 0, (window.__CTRender("div", { class: "buttons" }, this.buttons.map((btn, idx) => (window.__CTRender(components_1.CTButton, { type: btn.type, class: `${this.buttons.length > 2 ? "overflex" : ""} ${this.buttons.length === 2 && idx === 0 ? "right-border" : ""}`, onClick: e => btn.action(e.target.textContent) }, btn.text))))))));
    }
}
__decorate([
    base_1.prop({ type: Boolean, attribute: true, default: false })
], CTAlertModal.prototype, "showing", void 0);
__decorate([
    base_1.prop({ type: String, attribute: false, default: 0 })
], CTAlertModal.prototype, "id", void 0);
__decorate([
    base_1.prop({ type: Number, attribute: false, default: 0 })
], CTAlertModal.prototype, "raisedOn", void 0);
__decorate([
    base_1.prop({ type: Number, attribute: false, default: 0 })
], CTAlertModal.prototype, "priority", void 0);
__decorate([
    base_1.prop({ type: String, attribute: false, default: "info" })
], CTAlertModal.prototype, "type", void 0);
__decorate([
    base_1.prop({ type: String, attribute: false, default: "" })
], CTAlertModal.prototype, "title", void 0);
__decorate([
    base_1.prop({ type: String, attribute: false, default: "" })
], CTAlertModal.prototype, "body", void 0);
__decorate([
    base_1.prop({ type: Array, attribute: false, default: [] })
], CTAlertModal.prototype, "buttons", void 0);
__decorate([
    base_1.prop({ type: Number, attribute: false, default: 0 })
], CTAlertModal.prototype, "remaining", void 0);
__decorate([
    base_1.prop({ type: Number, attribute: false, default: 0 })
], CTAlertModal.prototype, "positionInStack", void 0);
__decorate([
    base_1.prop({ type: Boolean, attribute: false, default: false })
], CTAlertModal.prototype, "showLoadingAnimation", void 0);
__decorate([
    base_1.prop({ type: Boolean, attribute: true, default: false })
], CTAlertModal.prototype, "stacked", void 0);
exports.CTAlertModal = CTAlertModal;
CTAlertModal.register();


/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const base_1 = __webpack_require__(0);
const environment_1 = __webpack_require__(14);
const Logger_1 = __webpack_require__(10);
class CTAudio extends base_1.CTLayerComponent {
    constructor() {
        super(...arguments);
        // === End properties === //
        this._supportedFormats = ["mp3"];
        this._logger = null;
        this._$audio = null;
    }
    static get is() {
        return "ct-audio";
    }
    initialize() {
        return __awaiter(this, void 0, void 0, function* () {
            this._logger = new Logger_1.Logger();
        });
    }
    pause() {
        if (this._$audio)
            this._$audio.pause();
    }
    setupListeners() {
        this.onRenderComplete(() => {
            this._$audio = this.shadowRoot.querySelector("audio");
            if (environment_1.getPlatformName() === "ios") {
                window.requestFileSystem(window.LocalFileSystem.PERSISTENT, 0, (fs) => {
                    const path = this.src.split("/Documents/")[1];
                    const parts = this.src.split(".");
                    const ext = parts[parts.length - 1];
                    if (!this._supportedFormats.includes(ext)) {
                        this._logger.error(`'${ext}' is not a supported audio format, only ${this._supportedFormats.join(", ")} are supported.`);
                    }
                    else {
                        fs.root.getFile(path, { create: false, exclusive: false }, (fileEntry) => {
                            fileEntry.file((file) => {
                                const reader = new FileReader();
                                reader.onload = (event) => {
                                    // tslint:disable no-any
                                    const result = event.target.result;
                                    // tslint:enable no-any
                                    const blob = new Blob([new Uint8Array(result)], { type: `audio/mpeg` });
                                    this._$audio.setAttribute("src", window.URL.createObjectURL(blob));
                                    this._loadAudio();
                                };
                                reader.readAsArrayBuffer(file);
                            }, (err) => {
                                this._logger.error(`Could not read file entry.`, err);
                            });
                        }, (err) => {
                            this._logger.error(`Could not read file path.`, err);
                        });
                    }
                }, (err) => {
                    this._logger.error(`Could not read file system.`, err);
                });
            }
            else {
                this._$audio.setAttribute("src", this.src);
                // Unfortunately we need to give it time to draw otherwise it won't render properly :(
                setTimeout(() => {
                    this._loadAudio();
                }, 250);
            }
        });
    }
    get generateComponentStyles() {
        return `:host{color:#333536;font-weight:400}:host h1,:host h2,:host h3,:host h4,:host h5,:host h6{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}:host,:host *{box-sizing:border-box}.user-html p{margin:0}.user-html p+p{margin:.8em 0 0 0}.user-html strong{font-weight:600}:host audio{width:100%;height:50px}
        `;
    }
    _loadAudio() {
        this._$audio.load();
        if (this.onLoad)
            this.onLoad();
    }
    generateComponentMarkup() {
        return (window.__CTRender("audio", { controls: true, preload: "auto" }));
    }
}
__decorate([
    base_1.prop({ type: String, attribute: true })
], CTAudio.prototype, "src", void 0);
__decorate([
    base_1.prop({ type: Function, attribute: false })
], CTAudio.prototype, "onLoad", void 0);
exports.CTAudio = CTAudio;
CTAudio.register();


/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const base_1 = __webpack_require__(0);
const ct_xmpp_client_1 = __webpack_require__(16);
const components_1 = __webpack_require__(1);
const models_1 = __webpack_require__(2);
class CTFilePicker extends base_1.CTLayerComponent {
    constructor() {
        super(...arguments);
        this.btnClick = () => __awaiter(this, void 0, void 0, function* () {
            const files = yield ct_xmpp_client_1.CtXmppClient.pickFile({ mimeTypes: this.fileTypes });
            if (this.callback) {
                this.callback(files);
            }
        });
    }
    static get is() {
        return "ct-file-picker";
    }
    // === End properties === //
    initialize() {
        return __awaiter(this, void 0, void 0, function* () {
        });
    }
    setupListeners() {
    }
    get generateComponentStyles() {
        return ``;
    }
    generateComponentMarkup() {
        return (window.__CTRender("div", null,
            window.__CTRender(components_1.CTButton, { icon: models_1.Icons.COMMON.PlusSign, iconColor: "#fff", onClick: this.btnClick })));
    }
}
__decorate([
    base_1.prop({ type: Array, attribute: true, default: ["image/jpeg", "image/png", "image/gif"] })
], CTFilePicker.prototype, "fileTypes", void 0);
__decorate([
    base_1.prop({ type: Function, attribute: false })
], CTFilePicker.prototype, "callback", void 0);
exports.CTFilePicker = CTFilePicker;
CTFilePicker.register();


/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const base_1 = __webpack_require__(0);
const renderUtils_1 = __webpack_require__(4);
class CTIcon extends base_1.CTLayerComponent {
    static get is() {
        return "ct-icon";
    }
    // === End properties === //
    initialize() {
        return __awaiter(this, void 0, void 0, function* () {
        });
    }
    setupListeners() {
    }
    get generateComponentStyles() {
        return `:host{color:#333536;font-weight:400}:host h1,:host h2,:host h3,:host h4,:host h5,:host h6{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}:host,:host *{box-sizing:border-box}.user-html p{margin:0}.user-html p+p{margin:.8em 0 0 0}.user-html strong{font-weight:600}:host{display:flex}:host svg{margin:auto}:host([spin]) svg{animation:spin 1s infinite linear;transform-origin:50% 50%}@keyframes spin{from{transform:rotate(0deg)}to{transform:rotate(360deg)}}
        `;
    }
    generateComponentMarkup() {
        if (!this.icon)
            return null;
        // not sure about this...
        // but this will get the font colour of the parent element
        // and apply this to the icon
        const styles = renderUtils_1.buildStyles({
            fill: this.color !== "auto"
                ? this.color
                : window.getComputedStyle(this.parentElement).color,
            width: this.width,
            height: this.height
        });
        const viewBox = this.icon.viewBox || "0 0 1024 1024";
        const svgPaths = (this.icon.paths || []);
        return (window.__CTRender("svg", { width: this.width, height: this.height, viewBox: viewBox, style: styles }, svgPaths.map((path, idx) => (window.__CTRender("path", { d: path })))));
    }
}
__decorate([
    base_1.prop({ type: String, attribute: true })
], CTIcon.prototype, "width", void 0);
__decorate([
    base_1.prop({ type: String, attribute: true })
], CTIcon.prototype, "height", void 0);
__decorate([
    base_1.prop({ type: String, attribute: true, default: "auto" })
], CTIcon.prototype, "color", void 0);
__decorate([
    base_1.prop({ type: Boolean, attribute: true, default: false })
], CTIcon.prototype, "spin", void 0);
__decorate([
    base_1.prop({ type: Object, attribute: false, default: null })
], CTIcon.prototype, "icon", void 0);
exports.CTIcon = CTIcon;
CTIcon.register();


/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const base_1 = __webpack_require__(0);
const environment_1 = __webpack_require__(14);
const Logger_1 = __webpack_require__(10);
const plugin_1 = __webpack_require__(15);
class CTImg extends base_1.CTLayerComponent {
    constructor() {
        super(...arguments);
        // === End properties === //
        this._src = null;
        this._logger = null;
    }
    static get is() {
        return "ct-img";
    }
    initialize() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.src)
                return;
            this._imageLoaded = this._imageLoaded.bind(this);
            this._logger = new Logger_1.Logger();
            if (environment_1.isDevice()) {
                // tslint:disable no-any
                const thumbnail = plugin_1.getSource("thumbnail");
                // tslint:enable no-any
                if (!thumbnail) {
                    this._logger.error(`Thumbnail plugin could not be found.`);
                    return;
                }
                thumbnail.makeThumbnail((data) => {
                    this._src = data;
                    this.forceRedraw();
                }, (err) => {
                    this._logger.error(`Could not create thumbnail of image.`, err);
                }, this.src, 320, 320, 100);
            }
            else {
                this._src = this.src;
            }
        });
    }
    setupListeners() {
    }
    get generateComponentStyles() {
        return `:host{color:#333536;font-weight:400}:host h1,:host h2,:host h3,:host h4,:host h5,:host h6{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}:host,:host *{box-sizing:border-box}.user-html p{margin:0}.user-html p+p{margin:.8em 0 0 0}.user-html strong{font-weight:600}:host img{width:inherit;height:inherit}
        `;
    }
    _imageLoaded() {
        if (this.onLoad)
            this.onLoad();
    }
    generateComponentMarkup() {
        if (!this._src)
            return null;
        return (window.__CTRender("img", { src: this._src, onload: this._imageLoaded }));
    }
}
__decorate([
    base_1.prop({ type: String, attribute: true })
], CTImg.prototype, "src", void 0);
__decorate([
    base_1.prop({ type: Function, attribute: false })
], CTImg.prototype, "onLoad", void 0);
exports.CTImg = CTImg;
CTImg.register();


/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const base_1 = __webpack_require__(0);
const events_1 = __webpack_require__(5);
const renderUtils_1 = __webpack_require__(4);
const components_1 = __webpack_require__(1);
const models_1 = __webpack_require__(2);
class CTLoginForm extends base_1.CTLayerComponent {
    static get is() {
        return "ct-login-form";
    }
    initialize() {
        return __awaiter(this, void 0, void 0, function* () {
            this._resetFields();
        });
    }
    setupListeners() {
        this.addListener(events_1.BaseEvents.ConnectionStatusChange, (detail) => {
            switch (detail.status) {
                case models_1.ConnectionStatus.Connected:
                    this.userLoggedIn = true;
                    break;
                case models_1.ConnectionStatus.Connecting:
                    this.isWaiting = true;
                    break;
                default:
                    this.isWaiting = false;
                    this.userLoggedIn = false;
                    break;
            }
        }, { dontSuppress: true });
    }
    get generateComponentStyles() {
        return `:host{color:#333536;font-weight:400}:host h1,:host h2,:host h3,:host h4,:host h5,:host h6{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}:host,:host *{box-sizing:border-box}.user-html p{margin:0}.user-html p+p{margin:.8em 0 0 0}.user-html strong{font-weight:600}:host{display:block;width:100%;margin:auto}:host .form{display:flex;flex-direction:column;width:100%}:host .form .form-field,:host .form .form-buttons{margin:5px 0}
        `;
    }
    generateComponentMarkup() {
        return this.userLoggedIn
            ? this._renderLogoutForm()
            : this._renderLoginForm();
    }
    _renderLoginForm() {
        const usernameStyles = renderUtils_1.buildStyles({
            display: this.hideUsername
                ? "none"
                : "block"
        });
        return (window.__CTRender("div", { class: "form" },
            window.__CTRender("div", { class: "form-field", style: usernameStyles },
                window.__CTRender(components_1.CTTextbox, { type: "text", placeholder: "Username", name: "username", defaultValue: this._username, disabled: this.disableUsername || this.isWaiting, callback: e => this._onChange(e), returnKeypress: e => this._login() })),
            window.__CTRender("div", { class: "form-field" },
                window.__CTRender(components_1.CTTextbox, { type: "password", placeholder: "Password", name: "password", defaultValue: this._password, callback: e => this._onChange(e), disabled: this.isWaiting, returnKeypress: e => this._login() })),
            window.__CTRender("div", { class: "form-buttons" },
                window.__CTRender(components_1.CTButton, { type: "primary", disabled: this.disabled, onClick: e => this._login(), isWaiting: this.isWaiting }, "Log In"))));
    }
    _renderLogoutForm() {
        let currentUserJid = this.layer.getCurrentUserJid();
        if (this.autoAppendDomainName) {
            currentUserJid = currentUserJid.split("@").shift();
        }
        return (window.__CTRender("div", { class: "form", style: renderUtils_1.buildStyles({ display: "flex" }) },
            window.__CTRender("div", { class: "form-field" },
                window.__CTRender(components_1.CTTextbox, { type: "text", placeholder: "Username", name: "username", defaultValue: currentUserJid, disabled: true })),
            window.__CTRender("div", { class: "form-buttons" },
                window.__CTRender(components_1.CTButton, { type: "primary", disabled: false, onClick: e => this._logout(), isWaiting: this.isWaiting }, "Log Out"))));
    }
    // === Private functions === //
    _onChange(e) {
        if (e && e.key === "username") {
            this._username = e.value;
        }
        if (e && e.key === "password") {
            this._password = e.value;
        }
        this.disabled = (!this._username || !this._password);
    }
    _resetFields() {
        this._username = this.username || "";
        this._password = "";
        this.disabled = true;
    }
    _login() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._username && this._password) {
                this.isWaiting = true;
                let username = this.autoAppendDomainName
                    ? `${this._username.trim()}@${this.layer.config.xmpp.user.domain}`
                    : this._username.trim();
                if (this.layer.config.xmpp.user && this.layer.config.xmpp.user.forceLowercaseJid === true) {
                    username = username.toLowerCase();
                }
                try {
                    yield this.layer.login(username, this._password);
                    this.emitComponentEvent(events_1.BaseEvents.LoginFormResult, new events_1.CommsEventArgs(true));
                    this.isWaiting = false;
                    this._resetFields();
                }
                catch (ex) {
                    this.emitComponentEvent(events_1.BaseEvents.LoginFormResult, new events_1.CommsEventArgs(false, `Could not log in as ${username}`));
                    this.isWaiting = false;
                    this._password = "";
                    this._onChange();
                    document.activeElement.blur();
                }
            }
            return;
        });
    }
    _logout() {
        return __awaiter(this, void 0, void 0, function* () {
            this.isWaiting = true;
            try {
                yield this.layer.logout();
                this.isWaiting = false;
                this._resetFields();
            }
            catch (ex) {
                this.emitComponentEvent(events_1.BaseEvents.LoginFormResult, new events_1.CommsEventArgs(false, `There was an error logging out. Please try again.`));
                this.isWaiting = false;
                document.activeElement.blur();
            }
        });
    }
}
__decorate([
    base_1.prop({ type: base_1.Stroolean, attribute: true, default: true })
], CTLoginForm.prototype, "autoAppendDomainName", void 0);
__decorate([
    base_1.prop({ type: String, attribute: true, default: "" })
], CTLoginForm.prototype, "username", void 0);
__decorate([
    base_1.prop({ type: base_1.Stroolean, attribute: true, default: false })
], CTLoginForm.prototype, "hideUsername", void 0);
__decorate([
    base_1.prop({ type: base_1.Stroolean, attribute: true, default: false })
], CTLoginForm.prototype, "disableUsername", void 0);
__decorate([
    base_1.prop({ type: Boolean, attribute: false, default: false })
], CTLoginForm.prototype, "isWaiting", void 0);
__decorate([
    base_1.prop({ type: Boolean, attribute: false, default: true })
], CTLoginForm.prototype, "disabled", void 0);
__decorate([
    base_1.prop({ type: Boolean, attribute: false, default: false })
], CTLoginForm.prototype, "userLoggedIn", void 0);
exports.CTLoginForm = CTLoginForm;
CTLoginForm.register();


/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const base_1 = __webpack_require__(0);
const models_1 = __webpack_require__(2);
const events_1 = __webpack_require__(5);
const renderUtils_1 = __webpack_require__(4);
const components_1 = __webpack_require__(1);
const ct_button_1 = __webpack_require__(28);
class CTOnlineIndicator extends base_1.CTLayerComponent {
    constructor() {
        super(...arguments);
        this.attemptCount = 0;
    }
    static get is() {
        return "ct-online-indicator";
    }
    initialize() {
        return __awaiter(this, void 0, void 0, function* () {
            this.status = this.layer.getConnectionStatus();
        });
    }
    setupListeners() {
        this.addListener(events_1.BaseEvents.ConnectionStatusChange, (detail) => {
            this.status = detail.status;
            this.reconnectTime = detail.reconnectTime;
            this.allowReconnect = (detail.status === models_1.ConnectionStatus.Disconnected);
            clearInterval(this.timeoutId);
            if (detail.reconnectTime) {
                this.timeoutId = setInterval(() => {
                    this.reconnectTime -= 1000;
                }, 1000);
            }
        }, { dontSuppress: true });
    }
    get generateComponentStyles() {
        return `:host{color:#333536;font-weight:400}:host h1,:host h2,:host h3,:host h4,:host h5,:host h6{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}:host,:host *{box-sizing:border-box}.user-html p{margin:0}.user-html p+p{margin:.8em 0 0 0}.user-html strong{font-weight:600}:host{display:inline-flex;font-size:inherit;font-weight:inherit;color:inherit}:host .online-indicator{display:flex;align-items:center}:host .online-indicator .icon{flex:none;margin:0 5px 0 0}:host .online-indicator .label{display:flex;align-items:center;flex:1 1}:host .online-indicator .label .reconnect-detail{display:flex;align-items:center}:host .online-indicator .label .reconnect-detail .countdown{width:40px;padding:0 5px}
        `;
    }
    generateComponentMarkup() {
        const classes = [
            "online-indicator",
            (this.status === models_1.ConnectionStatus.Connected)
                ? "online"
                : "offline"
        ];
        const icon = (this.status === models_1.ConnectionStatus.Connecting)
            ? models_1.Icons.COMMON.LoadingSpinner
            : (this.status === models_1.ConnectionStatus.Connected)
                ? models_1.Icons.COMMON.StatusOnline
                : models_1.Icons.COMMON.StatusOffline;
        return (window.__CTRender("div", { class: classes.join(" ") },
            renderUtils_1.renderIf(this.showIcon, (window.__CTRender("div", { class: "icon" },
                window.__CTRender(components_1.CTIcon, { width: "16", height: "16", icon: icon, spin: this.status === models_1.ConnectionStatus.Connecting })))),
            renderUtils_1.renderIf(this.showText, (window.__CTRender("div", { class: "label" },
                window.__CTRender("span", { class: "status" }, this._getStatusLabel()),
                renderUtils_1.renderIf(this.status === models_1.ConnectionStatus.Disconnected && this.reconnectTime !== undefined && this.reconnectTime > 0, (window.__CTRender("span", { class: "reconnect-detail" },
                    window.__CTRender("span", { class: "countdown" }, this._getCountdownLabel()),
                    window.__CTRender(ct_button_1.CTButton, { type: "invert-secondary", disabled: !this.allowReconnect, onClick: e => this._tryLoginNow(e) }, "Reconnect")))))))));
    }
    // === Private functions === //
    _getStatusLabel() {
        switch (this.status) {
            case models_1.ConnectionStatus.Connected:
                return "Online";
            case models_1.ConnectionStatus.Connecting:
                return "Reconnecting";
            case models_1.ConnectionStatus.Disconnecting:
            case models_1.ConnectionStatus.Disconnected:
                return "Offline";
        }
    }
    _getCountdownLabel() {
        return `(${this.reconnectTime / 1000}s)`;
    }
    _tryLoginNow(e) {
        if (this.allowReconnect === false)
            return;
        this.allowReconnect = false;
        this.status = models_1.ConnectionStatus.Connecting;
        this.layer.attemptReconnect();
    }
}
__decorate([
    base_1.prop({ type: base_1.Stroolean, attribute: true, default: true })
], CTOnlineIndicator.prototype, "showIcon", void 0);
__decorate([
    base_1.prop({ type: base_1.Stroolean, attribute: true, default: true })
], CTOnlineIndicator.prototype, "showText", void 0);
__decorate([
    base_1.prop({ type: String, attribute: false, default: models_1.ConnectionStatus.Disconnected })
], CTOnlineIndicator.prototype, "status", void 0);
__decorate([
    base_1.prop({ type: Number, attribute: false, default: 0 })
], CTOnlineIndicator.prototype, "reconnectTime", void 0);
__decorate([
    base_1.prop({ type: Boolean, attribute: false, default: false })
], CTOnlineIndicator.prototype, "allowReconnect", void 0);
exports.CTOnlineIndicator = CTOnlineIndicator;
CTOnlineIndicator.register();


/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const base_1 = __webpack_require__(0);
const components_1 = __webpack_require__(1);
const renderUtils_1 = __webpack_require__(4);
class CTSelectionList extends base_1.CTLayerComponent {
    static get is() {
        return "ct-selection-list";
    }
    // === End properties === //
    initialize() {
        return __awaiter(this, void 0, void 0, function* () {
        });
    }
    setupListeners() {
    }
    get generateComponentStyles() {
        return `:host{color:#333536;font-weight:400}:host h1,:host h2,:host h3,:host h4,:host h5,:host h6{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}:host,:host *{box-sizing:border-box}.user-html p{margin:0}.user-html p+p{margin:.8em 0 0 0}.user-html strong{font-weight:600}:host{display:block;width:100%}:host .selection-list{display:flex;flex-direction:row;flex-wrap:wrap}:host .selection-list .dropdown-contanier{flex:1 1 100%}:host .selection-list .dropdown-contanier select{width:100%;height:30px;background-color:var(--default-bg-color-light, rgba(0,0,0,0));border:0;color:var(--default-font-color, #fff);font-size:16px;outline:var(--default-select-border, none)}:host .selection-list .button-container{position:relative;flex:0 1 50%}:host .selection-list .button-container:nth-child(2n-1){padding:10px 5px 0 0}:host .selection-list .button-container:nth-child(2n-2){padding:10px 0 0 5px}:host .selection-list .button-container:nth-child(1),:host .selection-list .button-container:nth-child(2){padding-top:0}:host .selection-list.button-list{display:block}:host .selection-list.button-list .button-container{display:block;padding:0 0 1px 0}:host .selection-list.button-list .button-container:last-child{padding:0}
        `;
    }
    generateComponentMarkup() {
        const maxButtonOptions = 4;
        const showAsButtons = this.forceDropdown ? false : (this.buttonList || (this.options.length <= maxButtonOptions));
        const cssClasses = [
            "selection-list"
        ];
        if (this.buttonList) {
            cssClasses.push("button-list");
        }
        return (window.__CTRender("div", { class: cssClasses.join(" ") }, renderUtils_1.renderIfElse(showAsButtons, this._renderButtons(), this._renderDropDown())));
    }
    _renderDropDown() {
        return (window.__CTRender("div", { class: "dropdown-contanier" },
            window.__CTRender("select", { onChange: e => this._onMakeSelection(e), value: this.selected.toString() }, this.options.map(opt => (window.__CTRender("option", { "data-key": opt.key, value: opt.key.toString(), defaultSelected: this.selected === opt.key }, opt.value))))));
    }
    _renderButtons() {
        return this.options.map(opt => (window.__CTRender("div", { class: "button-container" },
            window.__CTRender(components_1.CTButton, { "data-key": opt.key, type: "secondary", selected: this.selected === opt.key, onClick: e => this._onMakeSelection(e) }, opt.value))));
    }
    // === Event handlers === //
    _onMakeSelection(e) {
        const target = e.target;
        if (!target)
            return;
        let selection = null;
        switch (target.nodeName) {
            case "CT-BUTTON":
                selection = parseInt(target.getAttribute("data-key"));
                break;
            case "SELECT":
                selection = parseInt(target.value);
                break;
        }
        if (isNaN(selection))
            return;
        const selectedOption = this.options.find(x => x.key === selection);
        if (!selectedOption)
            return;
        this._makeSelection(selectedOption.key);
        this.selected = selectedOption.key;
    }
    // === Private functions === //
    _makeSelection(selection) {
        if (typeof (this.onSelect) === "function") {
            this.onSelect(selection);
        }
    }
}
__decorate([
    base_1.prop({ type: Number, attribute: true, default: Number.MIN_VALUE })
], CTSelectionList.prototype, "selected", void 0);
__decorate([
    base_1.prop({ type: base_1.Stroolean, attribute: true, default: false })
], CTSelectionList.prototype, "buttonList", void 0);
__decorate([
    base_1.prop({ type: Boolean, attribute: true, default: false })
], CTSelectionList.prototype, "forceDropdown", void 0);
__decorate([
    base_1.prop({ type: Function, attribute: true })
], CTSelectionList.prototype, "onSelect", void 0);
__decorate([
    base_1.prop({ type: Array, attribute: false, default: [] })
], CTSelectionList.prototype, "options", void 0);
exports.CTSelectionList = CTSelectionList;
CTSelectionList.register();


/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const base_1 = __webpack_require__(0);
const renderUtils_1 = __webpack_require__(4);
const components_1 = __webpack_require__(1);
const models_1 = __webpack_require__(2);
class CTTextbox extends base_1.CTLayerComponent {
    constructor() {
        super(...arguments);
        this._returnKeypress = (e) => {
            e.keyCode === 13 && this.returnKeypress
                ? this.returnKeypress()
                : null;
        };
    }
    static get is() {
        return "ct-textbox";
    }
    initialize() {
        return __awaiter(this, void 0, void 0, function* () {
            this._value = this.defaultValue || "";
            this._isPasswordField = (this.type && this.type.toLowerCase() === "password");
            if (this._isPasswordField) {
                this._watchPasswordField();
            }
        });
    }
    setupListeners() {
    }
    get generateComponentStyles() {
        return `:host label{color:var(--default-font-color, #9b9b9b)}:host div div.input{display:flex;flex-direction:row;margin:0 0 5px 0;border-bottom:1px solid var(--default-border-color, #9b9b9b)}:host div div.input.focus{border-color:var(--login-form-border-color, green)}:host div div.input input,:host div div.input textarea{flex:1 1;padding:5px;font-size:1em;background-color:var(--default-bg-color-light, transparent);border:none;margin:auto;outline:none;resize:none;color:var(--login-form-font-color, inherit)}:host div div.input input:focus,:host div div.input textarea:focus{border:none;outline-offset:0}:host div div.input input:focus+.clear-value,:host div div.input textarea:focus+.clear-value{opacity:0.5;cursor:pointer}:host div div.input ct-icon{flex:0 0 20px;text-align:center}:host div div.input ct-icon.show-password{opacity:0.5}:host div div.input ct-icon.show-password.show-password-enabled{opacity:1}:host div div.input ct-icon.clear-value{opacity:0}:host div div.input ct-icon+ct-icon{margin:0 0 0 5px}:host div div.input .validation{margin-bottom:1%;color:red}:host div.disabled div.input{border-bottom:none}:host([full-border]) div div.input{border:1px solid var(--default-border-color, #9b9b9b)}
        `;
    }
    generateComponentMarkup() {
        return (window.__CTRender("div", { class: this.disabled ? "disabled" : "" },
            renderUtils_1.renderIf(this.label !== undefined, window.__CTRender("label", { htmlFor: this.name }, this.label)),
            window.__CTRender("div", { class: "input" },
                renderUtils_1.renderIfElse(this.type === "textarea", window.__CTRender("textarea", { placeholder: this.placeholder, name: this.name, onFocus: e => this._toggleFocus(true), onBlur: e => this._toggleFocus(false), onInput: e => this._updateValue({ key: e.target.name, value: e.target.value }), onkeydown: this._returnKeypress, value: this.defaultValue, disabled: this.disabled, rows: 5 }), window.__CTRender("input", { type: this.type, placeholder: this.placeholder, name: this.name, onFocus: e => this._toggleFocus(true), onBlur: e => this._toggleFocus(false), onInput: e => this._updateValue({ key: e.target.name, value: e.target.value }), onkeydown: this._returnKeypress, value: this.defaultValue, disabled: this.disabled })),
                renderUtils_1.renderIf(this.showClearOptions && !this._isPasswordField, window.__CTRender(components_1.CTIcon, { class: "clear-value", width: "12", height: "12", icon: models_1.Icons.COMMON.ClearTextbox, onClick: e => this._clear() })),
                renderUtils_1.renderIf(this._isPasswordField, window.__CTRender(components_1.CTIcon, { class: `show-password ${this.type === "text" ? "show-password-enabled" : ""}`, width: "20", height: "20", icon: models_1.Icons.COMMON.ShowPassword, onClick: e => this._togglePasswordFieldType() }))),
            renderUtils_1.renderIf(!this.validated, window.__CTRender("div", { class: "validation" },
                window.__CTRender("span", null,
                    "This field has a max length of ",
                    this.max,
                    ".")))));
    }
    // === Private functions === //
    _updateValue(e) {
        this._value = e.value;
        this._isValidated();
        this.callback({
            key: e.key,
            value: e.value,
            validated: this.validated
        });
    }
    _clear() {
        let input;
        if (this.type !== "textarea") {
            input = this.shadowRoot.querySelector("input");
        }
        else {
            input = this.shadowRoot.querySelector("textarea");
        }
        input.value = "";
        input.focus();
        input.dispatchEvent(new Event("change"));
    }
    _toggleFocus(focused) {
        const container = this.shadowRoot.querySelector(".input");
        const input = (this.type === "textarea")
            ? container.querySelector("textarea")
            : container.querySelector("input");
        if (focused) {
            container.classList.add("focus");
            if ("scrollIntoViewIfNeeded" in input) {
                // tslint:disable-next-line no-any
                input.scrollIntoViewIfNeeded(); // non-standard, but better when it's available
            }
            else if ("scrollIntoView" in input) {
                input.scrollIntoView();
            }
        }
        else {
            container.classList.remove("focus");
        }
    }
    _isValidated() {
        this.validated = this._value.length <= this.max;
    }
    _togglePasswordFieldType() {
        if (!this._isPasswordField)
            return;
        if (this.type === "password") {
            this.type = "text";
        }
        else {
            this.type = "password";
        }
    }
    _watchPasswordField() {
        // tslint:disable-next-line no-any
        const watcher = (e) => {
            const container = this.shadowRoot.querySelector(".input");
            if (e.path) {
                const clickWithinContainer = e.path.includes(container);
                if (clickWithinContainer === false && this.type === "text") {
                    this.type = "password";
                }
            }
        };
        document.removeEventListener("click", watcher);
        document.addEventListener("click", watcher);
    }
}
__decorate([
    base_1.prop({ type: String, attribute: true })
], CTTextbox.prototype, "placeholder", void 0);
__decorate([
    base_1.prop({ type: String, attribute: true })
], CTTextbox.prototype, "type", void 0);
__decorate([
    base_1.prop({ type: String, attribute: true })
], CTTextbox.prototype, "label", void 0);
__decorate([
    base_1.prop({ type: String, attribute: true })
], CTTextbox.prototype, "name", void 0);
__decorate([
    base_1.prop({ type: Boolean, attribute: true, default: true })
], CTTextbox.prototype, "showClearOptions", void 0);
__decorate([
    base_1.prop({ type: String, attribute: true })
], CTTextbox.prototype, "defaultValue", void 0);
__decorate([
    base_1.prop({ type: Boolean, attribute: true, default: false })
], CTTextbox.prototype, "disabled", void 0);
__decorate([
    base_1.prop({ type: Boolean, attribute: true, default: false })
], CTTextbox.prototype, "fullBorder", void 0);
__decorate([
    base_1.prop({ type: Number, attribute: true, default: 4000 })
], CTTextbox.prototype, "max", void 0);
__decorate([
    base_1.prop({ type: Boolean, attribute: false, default: true })
], CTTextbox.prototype, "validated", void 0);
exports.CTTextbox = CTTextbox;
CTTextbox.register();


/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const base_1 = __webpack_require__(0);
const events_1 = __webpack_require__(5);
const models_1 = __webpack_require__(2);
const renderUtils_1 = __webpack_require__(4);
const components_1 = __webpack_require__(1);
class CTUserDisplay extends base_1.CTLayerComponent {
    static get is() {
        return "ct-user-display";
    }
    // === End properties === //
    initialize() {
        return __awaiter(this, void 0, void 0, function* () {
            this.username = this.layer.getCurrentXmppDisplayName();
        });
    }
    setupListeners() {
        this.addListener(events_1.BaseEvents.ConnectionStatusChange, (detail) => {
            this.username = this.layer.getCurrentXmppDisplayName();
        });
        this.addListener(events_1.BaseEvents.CurrentUserVCardUpdate, () => {
            this.username = this.layer.getCurrentXmppDisplayName();
        });
    }
    get generateComponentStyles() {
        return `:host{color:#333536;font-weight:400}:host h1,:host h2,:host h3,:host h4,:host h5,:host h6{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}:host,:host *{box-sizing:border-box}.user-html p{margin:0}.user-html p+p{margin:.8em 0 0 0}.user-html strong{font-weight:600}:host{display:inline-flex;font-size:inherit;font-weight:inherit;color:inherit}:host .user-display{display:flex;align-items:center}:host .user-display .icon{flex:none;margin:0 5px 0 0}:host .user-display .label{flex:1 1}
        `;
    }
    generateComponentMarkup() {
        return (window.__CTRender("div", { class: "user-display" },
            renderUtils_1.renderIf(this.showIcon, (window.__CTRender("div", { class: "icon" },
                window.__CTRender(components_1.CTIcon, { width: "16", height: "16", icon: models_1.Icons.COMMON.UserIconEmpty })))),
            window.__CTRender("div", { class: "label" }, this.username)));
    }
}
__decorate([
    base_1.prop({ type: base_1.Stroolean, attribute: true, default: true })
], CTUserDisplay.prototype, "showIcon", void 0);
__decorate([
    base_1.prop({ type: String, attribute: false })
], CTUserDisplay.prototype, "username", void 0);
exports.CTUserDisplay = CTUserDisplay;
CTUserDisplay.register();


/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// tslint:disable

Object.defineProperty(exports, "__esModule", { value: true });
class TouchTracker {
}
// This determines the movement speed of the element being dragged. Increase this number to make it faster or lower to make slower
TouchTracker.Accelerator = 2.5;
// Resets current state
TouchTracker.Reset = () => {
    delete TouchTracker.LastTouchStartX;
    delete TouchTracker.LastTouchStartY;
    delete TouchTracker.LastTouchStartTime;
    delete TouchTracker.LastTouchMoveX;
    delete TouchTracker.LastTouchMoveY;
};
TouchTracker.NumMatch = /-?\d+/;
TouchTracker.X = ["clientX"];
TouchTracker.Y = ["clientY"];
TouchTracker.GetNumberValue = (str) => {
    const res = str.match(TouchTracker.NumMatch);
    if (res) {
        return parseInt(res[0]);
    }
    else
        return null;
};
TouchTracker.CheckIfFirstTouch = (x, y) => {
    if (!TouchTracker.LastTouchStartX) {
        console.log("First X detected");
        TouchTracker.LastTouchStartX = x;
    }
    if (!TouchTracker.LastTouchStartY) {
        console.log("First Y detected");
        TouchTracker.LastTouchStartY = y;
    }
    TouchTracker.LastTouchStartTime = new Date().getTime();
};
exports.TouchTracker = TouchTracker;
function slideToReveal(e, offset, tracking = "x") {
    e.stopPropagation();
    e.stopImmediatePropagation();
    const maxOffset = 0 - (offset + 1);
    const target = e.currentTarget;
    const currPos = target.style.transform;
    let newPos = 0;
    if (currPos) {
        newPos = TouchTracker.GetNumberValue(currPos);
    }
    // if (newPos > maxOffset) {
    TouchTracker.CheckIfFirstTouch(e.changedTouches[0].clientX, e.changedTouches[0].clientY);
    const diffX = (TouchTracker.LastTouchMoveX || TouchTracker.LastTouchStartX) - e.changedTouches[0].clientX;
    const diffY = (TouchTracker.LastTouchMoveY || TouchTracker.LastTouchStartY) - e.changedTouches[0].clientY;
    TouchTracker.LastTouchMoveX = e.changedTouches[0].clientX;
    TouchTracker.LastTouchMoveY = e.changedTouches[0].clientY;
    if (tracking === "x") {
        // Moving left
        if (diffX > 0) {
            newPos--;
            if (newPos > maxOffset) {
                target.style.transform = `translateX(${newPos}vw)`;
            }
        }
        else {
            newPos++;
            if (newPos < 1) {
                target.style.transform = `translateX(${newPos}vw)`;
            }
        }
    }
    else if (tracking === "y") {
        // Moving down
        if (diffY > 1) {
            newPos = newPos - (1 * TouchTracker.Accelerator);
            //--newPos;
            target.style.transform = `translateY(${newPos}vh)`;
        }
        else if (diffY < -0.5) {
            newPos = newPos + (1 * TouchTracker.Accelerator);
            // ++newPos;
            if (newPos > 0.5)
                newPos = 0;
            target.style.transform = `translateY(${newPos}vh)`;
        }
    }
    // tslint:disable
    // console.log(`CurrPos: ${currPos}, DiffX: ${diffX}, DiffY: ${diffY}, New Pos: ${newPos}`);
    // }
}
exports.slideToReveal = slideToReveal;
function slideToRevealEnd(e, maxOffset, axis = "x") {
    e.stopPropagation();
    e.stopImmediatePropagation();
    const target = e.currentTarget;
    const currLeft = target.style.transform;
    let newLeft;
    if (currLeft) {
        newLeft = TouchTracker.GetNumberValue(target.style.transform);
    }
    if (axis === "x") {
        const velocity = calculateVelocityOfCurrentTouch();
        if (velocity > 1.2) {
            target.style.transform = `translateX(0vw)`;
        }
        else if (velocity < -1.2) {
            target.style.transform = `translateX(-${maxOffset}vw)`;
        }
        else {
            const halfWay = Math.round(maxOffset / 2);
            if (newLeft < -halfWay) {
                // Snap to reveal
                target.style.transform = `translateX(-${maxOffset}vw)`;
            }
            else {
                // Snap to reset
                target.style.transform = "translateX(0vw)";
            }
        }
    }
    TouchTracker.Reset();
}
exports.slideToRevealEnd = slideToRevealEnd;
function calculateVelocityOfCurrentTouch() {
    const finalPos = TouchTracker.LastTouchMoveX;
    const initialPos = TouchTracker.LastTouchStartX;
    const finalTime = new Date().getTime();
    const initialTime = TouchTracker.LastTouchStartTime;
    const pos = finalPos - initialPos;
    const time = finalTime - initialTime;
    return pos / time;
}


/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  for (var i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(
      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
    ))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}


/***/ }),
/* 96 */
/***/ (function(module, exports) {

exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),
/* 97 */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__(95)
var ieee754 = __webpack_require__(96)
var isArray = __webpack_require__(97)

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(30)))

/***/ }),
/* 99 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),
/* 100 */
/***/ (function(module, exports) {

/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {/* globals __webpack_amd_options__ */
module.exports = __webpack_amd_options__;

/* WEBPACK VAR INJECTION */}.call(exports, {}))

/***/ }),
/* 101 */
/***/ (function(module, exports) {

module.exports = moment;

/***/ }),
/* 102 */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(0);
__webpack_require__(1);
__webpack_require__(17);
__webpack_require__(19);
__webpack_require__(20);
__webpack_require__(31);
__webpack_require__(32);
__webpack_require__(33);
__webpack_require__(34);
module.exports = __webpack_require__(35);


/***/ })
/******/ ]);